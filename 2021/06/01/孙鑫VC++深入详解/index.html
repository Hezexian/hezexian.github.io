
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.27.0" theme-name="Stellar" theme-version="1.27.0">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>孙鑫VC++深入详解 - 何泽贤的图书室</title>

  
    <meta name="description" content="第一章 Windows程序内部运行机制1.1 API和SDK API:Windows操作系统提供给应用程序编程的接口。  SDK（软件开发包）:用于开发的所有资源的集合。  1.2 窗口和句柄 窗口  句柄：系统在创建资源时会为他们分配内存，并返回这些资源的标识号，即句柄。(类似于指针）窗口句柄(HWND)、图标(HICON)、光标(HCURSOR)、画刷(HBRUSH)  1.3 消息和队列消息">
<meta property="og:type" content="article">
<meta property="og:title" content="孙鑫VC++深入详解">
<meta property="og:url" content="https://hezexian.github.io/2021/06/01/%E5%AD%99%E9%91%ABVC++%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="何泽贤的图书室">
<meta property="og:description" content="第一章 Windows程序内部运行机制1.1 API和SDK API:Windows操作系统提供给应用程序编程的接口。  SDK（软件开发包）:用于开发的所有资源的集合。  1.2 窗口和句柄 窗口  句柄：系统在创建资源时会为他们分配内存，并返回这些资源的标识号，即句柄。(类似于指针）窗口句柄(HWND)、图标(HICON)、光标(HCURSOR)、画刷(HBRUSH)  1.3 消息和队列消息">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708742389376-8d3746b0-03cd-4018-abe6-7773bef5b530.jpeg#averageHue=%23f9f9f9&clientId=u36ddef60-4b23-4&from=paste&height=1305&id=u43747779&originHeight=1424&originWidth=3039&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=415874&status=done&style=none&taskId=ude1c62be-9fa7-401d-bf95-2ccea8ae71e&title=&width=2785.75">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708742415566-92333483-5371-45dc-bd72-771fa5be5b33.png#averageHue=%23eeeeee&clientId=u36ddef60-4b23-4&from=paste&height=211&id=u03b2526e&originHeight=230&originWidth=296&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=12042&status=done&style=none&taskId=u6dcd2671-8216-4537-b4de-ce5fe35207d&title=&width=271.33333333333337">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708742427838-701c9a37-07b4-4745-aed1-da1345bfb30f.jpeg#averageHue=%2309328c&clientId=u36ddef60-4b23-4&from=paste&height=1408&id=u502e6573&originHeight=1536&originWidth=2048&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=164854&status=done&style=none&taskId=u070cc178-4cc3-46f3-8ac1-f3fd3f01e34&title=&width=1877.3333333333335">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708742439266-c5b377aa-1c43-45b6-849d-b4075033d0a6.jpeg#averageHue=%23fcfcfc&clientId=u36ddef60-4b23-4&from=paste&height=1354&id=u85029cfc&originHeight=1477&originWidth=3557&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=315758&status=done&style=none&taskId=uf7498ddf-7578-450d-b406-d0c894c1451&title=&width=3260.5833333333335">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708742459674-ddc535d0-7134-4034-bcdb-8b0f50519dab.jpeg#averageHue=%23f5f5f4&clientId=u36ddef60-4b23-4&from=paste&height=2178&id=ufc444e15&originHeight=2376&originWidth=3489&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=1163196&status=done&style=none&taskId=ua1badef6-adaa-465f-bcc3-a18f715f92f&title=&width=3198.2500000000005">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708742476799-76e92417-5326-4278-b8a6-e365d0bfc278.png#averageHue=%2312100e&clientId=u36ddef60-4b23-4&from=paste&height=55&id=u257db54c&originHeight=60&originWidth=166&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=2019&status=done&style=none&taskId=u14eaddc1-0bb1-403a-b47f-18db63b8233&title=&width=152.16666666666669">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708745317287-3559a957-3a2e-46a4-9260-acce8d441597.png#averageHue=%23f0f3fa&clientId=u36ddef60-4b23-4&from=paste&height=244&id=u6da8e2a2&originHeight=266&originWidth=317&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=14898&status=done&style=none&taskId=u02c08995-b3c7-471b-9695-f85765db29c&title=&width=290.58333333333337">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708745329159-794985ec-0dc0-45ee-9a70-3a28ad394216.png#averageHue=%23f3f2f2&clientId=u36ddef60-4b23-4&from=paste&height=261&id=u85290e4d&originHeight=285&originWidth=637&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=48246&status=done&style=none&taskId=ud923bd32-08e5-4e4c-a797-3e09019c401&title=&width=583.9166666666667">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708745341365-2e5d3bc4-d1c1-4bcb-9ced-e225a099ccb7.jpeg#averageHue=%23f6f5f1&clientId=u36ddef60-4b23-4&from=paste&height=722&id=u866d3efa&originHeight=788&originWidth=1050&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=97959&status=done&style=none&taskId=u570fef31-d012-4839-9eaa-3695cbec5ff&title=&width=962.5000000000001">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708745349967-79931c34-9233-41fc-ba5e-050932aa1319.png#averageHue=%23faf7f1&clientId=u36ddef60-4b23-4&from=paste&height=477&id=ua24ef771&originHeight=520&originWidth=322&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=19727&status=done&style=none&taskId=u13b05d18-4f4d-44d0-8be9-87d6464991f&title=&width=295.1666666666667">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708745365962-cb74b989-7e48-4bf6-a2d8-648637033aea.jpeg#averageHue=%2393928e&clientId=u36ddef60-4b23-4&from=paste&height=1938&id=u7043a8f4&originHeight=2114&originWidth=3521&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=1817235&status=done&style=none&taskId=ue64837f9-9983-4081-a9f1-7fd32b838a4&title=&width=3227.5833333333335">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708745378767-bd154cd4-0ce9-412f-9727-f627a5a7ba16.png#averageHue=%23f8f8f8&clientId=u36ddef60-4b23-4&from=paste&height=359&id=u19b856da&originHeight=392&originWidth=473&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=11529&status=done&style=none&taskId=u37cbe054-bf17-449b-b5c2-7e27b0cd463&title=&width=433.58333333333337">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708745389524-b5a69e4b-93ce-491f-930c-66b1dd73768e.jpeg#averageHue=%23f9f9f8&clientId=u36ddef60-4b23-4&from=paste&height=342&id=ua360e299&originHeight=373&originWidth=478&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=21537&status=done&style=none&taskId=u37f2b81c-7387-496f-b8b5-b65cb635e91&title=&width=438.1666666666667">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708745400906-50533c80-aedc-4146-aec2-bbfbb55d0523.png#averageHue=%23f8f8f8&clientId=u36ddef60-4b23-4&from=paste&height=359&id=ud85f9d87&originHeight=392&originWidth=473&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=11529&status=done&style=none&taskId=u026d89e7-0cc3-4c9b-897d-8f389cd56f3&title=&width=433.58333333333337">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708745412623-e486145b-9b48-4a8b-ba6e-f207c4956bfd.jpeg#averageHue=%23f9f9f8&clientId=u36ddef60-4b23-4&from=paste&height=342&id=u66b53f0d&originHeight=373&originWidth=478&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=21537&status=done&style=none&taskId=ue47d26be-ba4d-42d3-836f-addde49943d&title=&width=438.1666666666667">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708745424131-528c1482-9393-43d1-b507-4772e7c31b8c.jpeg#averageHue=%23e6ecec&clientId=u36ddef60-4b23-4&from=paste&height=828&id=uf058e09c&originHeight=903&originWidth=332&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=106972&status=done&style=none&taskId=u4ea5f69f-e3b6-422b-9d3a-28dade09475&title=&width=304.33333333333337">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699693442-7e86c413-92a8-470b-a890-5b28d08cdf89.png#averageHue=%23fcfbfb&id=YgJFN&originHeight=739&originWidth=795&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=%E5%9B%BE4.1%20%E5%88%A9%E7%94%A8SDK%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%88%92%E7%BA%BF%E5%8A%9F%E8%83%BD">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699693561-d4db98aa-a5a0-4a80-a00b-5c6d2afdc349.png#averageHue=%23fbfafa&id=wcueU&originHeight=599&originWidth=715&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%9B%BE4.2%20%E7%BB%98%E5%88%B6%E5%BD%A9%E8%89%B2%E7%BA%BF%E6%9D%A1">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699693661-4f28b577-50a3-4725-89ab-c8820f6d5111.png#averageHue=%23fbc6c6&id=iUBHB&originHeight=560&originWidth=635&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%9B%BE4.3%20%E7%BA%A2%E8%89%B2%E7%AE%80%E5%8D%95%E7%94%BB%E5%88%B7">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699693762-0fb01846-4578-4426-b142-8da40dd2e4f8.png#averageHue=%23faf8f8&id=rr2t3&originHeight=536&originWidth=540&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%9B%BE4.3%20%E4%BD%8D%E5%9B%BE%E7%94%BB%E5%88%B7%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699693851-c49376bd-9887-41db-bba3-2b217dc2c643.png#averageHue=%2327323b&id=INXoX&originHeight=530&originWidth=331&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://hezexian.github.io/image/image%20(1)_4EcJoeM6pn.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699693954-5da557da-f305-4d56-a5a7-991b455a66e0.png#averageHue=%23f2f1f0&id=O9tW0&originHeight=391&originWidth=541&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%9B%BE4.5%20%E4%BD%8D%E5%9B%BE%E7%9A%84%E5%88%9B%E5%BB%BA">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699694042-c77a2d2d-6dc5-466f-808f-d8b111e18588.png#averageHue=%23242c33&id=BXuvi&originHeight=525&originWidth=330&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%9B%BE4.6%20%E6%9F%A5%E7%9C%8B%E8%B5%84%E6%BA%90ID">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699694153-87275896-fa7e-4ca9-b5ee-29627d1c10e5.png#averageHue=%23f9f8f8&id=aUomT&originHeight=576&originWidth=582&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%9B%BE4.7%20%E9%80%8F%E6%98%8E%E7%94%BB%E5%88%B7">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699694251-1d815638-0a60-4b88-8631-f5a14aa2f72d.png#averageHue=%23faf9f9&id=TvaSY&originHeight=520&originWidth=430&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%9B%BE4.8%20%E8%BF%9E%E7%BB%AD%E7%BB%98%E5%9B%BE%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699694365-6851228c-add6-4f4f-af6c-410469b8a33f.png#averageHue=%23bfbfbe&id=TH6yB&originHeight=577&originWidth=571&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%9B%BE4.9%20%E5%B8%A6%E8%BE%B9%E6%89%87%E5%BD%A2">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699694584-c0c2cce4-27da-4d50-bbb4-57010ae21186.png#averageHue=%23242b32&id=KIzAw&originHeight=515&originWidth=314&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699694920-662b5ee5-3d6e-432d-b91e-06e95eacbc2e.png#averageHue=%23272d32&id=qii1b&originHeight=653&originWidth=565&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699695015-c469fe2c-7750-4dd3-98ed-cdaeebd61f94.png#averageHue=%23f6f5f5&id=tWjX9&originHeight=384&originWidth=381&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpg/21452222/1708699500215-bec03e70-374a-43bb-92c2-029a19c87c6f.jpg#averageHue=%23e3e6e4&id=v01Cj&originHeight=1730&originWidth=4262&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpg/21452222/1708699500872-5f67e29b-8676-434b-a466-4f60c3ca8330.jpg#averageHue=%23c8cbc9&id=LhMv0&originHeight=2161&originWidth=3328&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpg/21452222/1708699501330-d837189f-b543-4873-949f-be1b606995c2.jpg#averageHue=%23adaea9&id=o2rhw&originHeight=1670&originWidth=2791&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpg/21452222/1708699501561-3f340dfe-030a-4ce0-9471-7406f1b09a3d.jpg#id=IBEb6&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699501922-1462270c-902c-4927-b2f5-081462113f6d.png#id=gUC7t&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://hezexian.github.io/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-08-01%20110502_J5FSHM4WxG.jpg">
<meta property="og:image" content="https://hezexian.github.io/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-08-01%20114550_mUnOKGHFru.jpg">
<meta property="og:image" content="https://hezexian.github.io/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-08-01%20114102_eotD0A4Rvf.jpg">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpg/21452222/1708699502034-14cd3b22-f8c9-45db-9bd8-8452e3a71eed.jpg#id=a13XF&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://hezexian.github.io/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-08-06%20102753_TUrnaTOgaJ.jpg">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpg/21452222/1708699502177-0fc3285d-547f-4612-98a7-b50c3b52a61e.jpg#id=BNRC1&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="article:published_time" content="2021-05-31T16:00:00.000Z">
<meta property="article:modified_time" content="2024-03-23T09:26:06.612Z">
<meta property="article:author" content="He Zexian">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="读书笔记">
<meta property="article:tag" content="mfc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708742389376-8d3746b0-03cd-4018-abe6-7773bef5b530.jpeg#averageHue=%23f9f9f9&clientId=u36ddef60-4b23-4&from=paste&height=1305&id=u43747779&originHeight=1424&originWidth=3039&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=415874&status=done&style=none&taskId=ude1c62be-9fa7-401d-bf95-2ccea8ae71e&title=&width=2785.75">
  
  
  
  <meta name="keywords" content="c++,读书笔记,mfc">

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="何泽贤的图书室" type="application/atom+xml">
  

  <link rel="stylesheet" href="/css/main.css?v=1.27.0">

  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="imgs/photo.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">何泽贤的图书室</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2023/12/26/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/"><span class="title">相机旋转矩阵相关</span></a><a class="item title" href="/2024/02/24/%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AEPlatformIO%E7%94%9F%E6%88%90HEX%E6%96%87%E4%BB%B6/"><span class="title">通过代码配置PlatformIO生成HEX文件</span></a><a class="item title" href="/2021/06/01/%E5%AD%99%E9%91%ABVC++%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3/"><span class="title">孙鑫VC++深入详解</span></a><a class="item title" href="/2024/02/19/vmware%E5%AE%89%E8%A3%85%E8%BF%87%E5%A2%9E%E5%BC%BA%E5%B7%A5%E5%85%B7%E8%BF%98%E6%98%AF%E6%97%A0%E6%B3%95%E6%8B%96%E6%94%BE/"><span class="title">vmware安装过增强工具还是无法拖放</span></a><a class="item title" href="/2024/02/19/Qt%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83%EF%BC%8C%E5%90%AB%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"><span class="title">qt程序打包发布，含三方库</span></a><a class="item title" href="/2024/02/27/protues%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/"><span class="title">protues配置相关</span></a><a class="item title" href="/2024/02/26/platformio%E9%85%8D%E7%BD%AE/"><span class="title">platformio配置问题</span></a><a class="item title" href="/2024/02/15/lsky+1panel+https+%E9%9B%A8%E4%BA%91%E9%85%8D%E7%BD%AE/"><span class="title">1panel+雨云服务器+https配置lsky-pro（兰空图床）</span></a><a class="item title" href="/2024/01/25/hexo%E4%BB%A3%E7%A0%81%E5%9D%97%E7%BC%A9%E8%BF%9B%E9%97%AE%E9%A2%98/"><span class="title">hexo在butterfly/next主题下代码块缩进问题</span></a><a class="item title" href="/2024/01/02/hexo+github%E5%BB%BA%E7%AB%99%E7%AC%94%E8%AE%B0/"><span class="title">hoxe+github建站笔记</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> <span class="sep"></span> <a class="cap breadcrumb-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AD%99%E9%91%ABVC-%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3/">孙鑫VC++深入详解</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2021-05-31T16:00:00.000Z">2021-06-01</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-03-23T09:26:06.612Z">2024-03-23</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>孙鑫VC++深入详解</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h1 id="第一章-Windows程序内部运行机制"><a href="#第一章-Windows程序内部运行机制" class="headerlink" title="第一章 Windows程序内部运行机制"></a>第一章 Windows程序内部运行机制</h1><h2 id="1-1-API和SDK"><a href="#1-1-API和SDK" class="headerlink" title="1.1 API和SDK"></a>1.1 API和SDK</h2><ul>
<li>API:Windows操作系统提供给应用程序编程的接口。 </li>
<li>SDK（软件开发包）:用于开发的所有资源的集合。</li>
</ul>
<h2 id="1-2-窗口和句柄"><a href="#1-2-窗口和句柄" class="headerlink" title="1.2 窗口和句柄"></a>1.2 窗口和句柄</h2><ul>
<li>窗口 </li>
<li>句柄：系统在创建资源时会为他们分配内存，并返回这些资源的标识号，即句柄。(类似于指针）<br>窗口句柄(HWND)、图标(HICON)、光标(HCURSOR)、画刷(HBRUSH)</li>
</ul>
<h2 id="1-3-消息和队列"><a href="#1-3-消息和队列" class="headerlink" title="1.3 消息和队列"></a>1.3 消息和队列</h2><p>消息（先进先出）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMSG</span> &#123;</span></span><br><span class="line">  HWND   hwnd;           <span class="comment">//HWND:窗口变量，hwnd:消息所属的窗口</span></span><br><span class="line">  UINT   message;        <span class="comment">//message消息标识符，数值定义为WM_XXX  (P4)</span></span><br><span class="line">  WPARAM wParam; </span><br><span class="line">  LPARAM lParam;         <span class="comment">//指定消息的附加信息，ASCII等</span></span><br><span class="line">  DWORD  time;           <span class="comment">//消息投递到消息队列中的时间</span></span><br><span class="line">  POINT  pt;             <span class="comment">//当前鼠标的位置</span></span><br><span class="line">&#125; MSG, *PMSG;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-WinMain"><a href="#1-4-WinMain" class="headerlink" title="1.4 WinMain"></a>1.4 WinMain</h2><ul>
<li>Win32实现的步骤 <ol>
<li>定义WinMain函数；</li>
<li>创建窗口；</li>
<li>消息循环；</li>
<li>窗口过程函数。</li>
</ol>
</li>
</ul>
<h3 id="1-4-1-WinMain函数的定义"><a href="#1-4-1-WinMain函数的定义" class="headerlink" title="1.4.1 WinMain函数的定义"></a>1.4.1 WinMain函数的定义</h3><p>winmain函数是程序入口函数，由系统调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> WINAPI <span class="title function_">WinMain</span><span class="params">(</span></span><br><span class="line"><span class="params">  HINSTANCE hInstance,      <span class="comment">// handle to current instance</span></span></span><br><span class="line"><span class="params">  HINSTANCE hPrevInstance,  <span class="comment">// handle to previous instance，always NULL in Win32</span></span></span><br><span class="line"><span class="params">  LPSTR lpCmdLine,          <span class="comment">// 空终止的字符串，指定传递给应用程序的命令行参数</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> nCmdShow              <span class="comment">// 指定窗口应该如何显示</span></span></span><br><span class="line"><span class="params">  )</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-2-窗口的创建"><a href="#1-4-2-窗口的创建" class="headerlink" title="1.4.2 窗口的创建"></a>1.4.2 窗口的创建</h3><ul>
<li>步骤 <ol>
<li>设计窗口类；</li>
<li>注册窗口；</li>
<li>创建窗口；</li>
<li>显示及更新窗口；</li>
</ol>
</li>
</ul>
<h4 id="1-4-2-1-设计窗口类"><a href="#1-4-2-1-设计窗口类" class="headerlink" title="1.4.2.1 设计窗口类"></a>1.4.2.1 设计窗口类</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WNDCLASS</span>                //窗口类</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    UINT       style;                      <span class="comment">/*（P7知识点方框）窗口样式；</span></span><br><span class="line"><span class="comment">                                             CS_XXX(都只有一位是1，且1位各不相同：位标志)；</span></span><br><span class="line"><span class="comment">                                             多种特点组合用（|）号；</span></span><br><span class="line"><span class="comment">                                             去掉style中的样式用（&amp;~）*/</span></span><br><span class="line">    WNDPROC    lpfnWndProc;             <span class="comment">//指向回调函数的指针；在特定的事件发生时，用于对该事件的响应</span></span><br><span class="line">    <span class="type">int</span>        cbClsExtra;               </span><br><span class="line">    <span class="type">int</span>        cbWndExtra;              <span class="comment">//cbClsExtra和cbWndExtra两个附加内存，一般都为0</span></span><br><span class="line">    HINSTANCE  hInstance;               <span class="comment">//实例句柄</span></span><br><span class="line">    HICON      hIcon;                  <span class="comment">//图标句柄；HICON LoadIcon(HINSTANCE hInstance, LPCTSTR lpIconName);</span></span><br><span class="line">    HCURSOR    hCursor;                  <span class="comment">//光标句柄；HCURSOR LoadCursor(HINSTANCE hInstance,LPCTSTR lpCursorName);</span></span><br><span class="line">    HBRUSH     hbrBackground;        <span class="comment">//画刷句柄，背景颜色；wndcls.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);</span></span><br><span class="line">    LPCTSTR    lpszMenuName;           <span class="comment">//菜单名字，NULL</span></span><br><span class="line">    LPCTSTR    lpszClassName;             <span class="comment">//类名，和创建窗口CreateWindow函数中的lpClassName一致</span></span><br><span class="line">&#125; WNDCLASS, *PWNDCLASS;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-2-2-注册窗口"><a href="#1-4-2-2-注册窗口" class="headerlink" title="1.4.2.2 注册窗口"></a>1.4.2.2 注册窗口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ATOM <span class="title function_">RegisterClass</span><span class="params">(  CONST WNDCLASS *lpWndClass )</span>; <span class="comment">// 注册窗口</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-2-3-创建窗口"><a href="#1-4-2-3-创建窗口" class="headerlink" title="1.4.2.3 创建窗口"></a>1.4.2.3 创建窗口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HWND <span class="title function_">CreateWindow</span><span class="params">(  </span></span><br><span class="line"><span class="params">  LPCTSTR lpClassName,  <span class="comment">// registered class name，与窗口类WNDCLASS中的lpszClassName一致</span></span></span><br><span class="line"><span class="params">  LPCTSTR lpWindowName, <span class="comment">// window name，</span></span></span><br><span class="line"><span class="params">  DWORD dwStyle,        <span class="comment">/*window style；和WNDCLASS中的style不同，style是指定具体窗口的样式，dwstyle是窗口都具有的样式</span></span></span><br><span class="line"><span class="comment"><span class="params">                        常用WS_OVERLAPPEDWINDOW*/</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> x,                <span class="comment">// horizontal position of window</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> y,                <span class="comment">// vertical position of window</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> nWidth,           <span class="comment">// window width</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> nHeight,          <span class="comment">// window height;</span></span></span><br><span class="line"><span class="params">                        <span class="comment">/*如果x设为CW_USEDEFAULT,系统为窗口选择左上角并忽略y;</span></span></span><br><span class="line"><span class="comment"><span class="params">                        nWidth设为CW_USEDEFAULT，系统为默认大小并忽略nHeight。</span></span></span><br><span class="line"><span class="comment"><span class="params">                        窗口之间的父子关系，子窗口必须有WS_CHILD*/</span></span></span><br><span class="line"><span class="params">  HWND hWndParent,      <span class="comment">// handle to parent or owner window（父窗口句柄）；NULL</span></span></span><br><span class="line"><span class="params">  HMENU hMenu,          <span class="comment">// menu handle or child identifier;NULL</span></span></span><br><span class="line"><span class="params">  HINSTANCE hInstance,  <span class="comment">// handle to application instance;hInstance</span></span></span><br><span class="line"><span class="params">  LPVOID lpParam        <span class="comment">// window-creation data;NULL</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>注意：创建窗口成功，函数返回系统为该窗口分配的句柄，否则返回NULL。创建窗口之前应先定义一个窗口句柄变量来接收创建窗口之后返回的句柄值。</p>
<h4 id="1-4-2-4-显示及更新窗口"><a href="#1-4-2-4-显示及更新窗口" class="headerlink" title="1.4.2.4 显示及更新窗口"></a>1.4.2.4 显示及更新窗口</h4><p>显示窗口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">ShowWindow</span><span class="params">(</span></span><br><span class="line"><span class="params">  HWND hWnd,     <span class="comment">// 哪一个窗口？</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> nCmdShow   <span class="comment">// 如何显示？；常用SW_SHOWNORMAL</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>更新窗口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">UpdateWindow</span><span class="params">(</span></span><br><span class="line"><span class="params">    HWND hWnd   <span class="comment">// handle to window</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-3-消息循环"><a href="#1-4-3-消息循环" class="headerlink" title="1.4.3 消息循环"></a>1.4.3 消息循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">GetMessage</span><span class="params">(</span></span><br><span class="line"><span class="params">  LPMSG lpMsg,         <span class="comment">// 指向一个消息结构体MSG，GetMessage取出的消息放入该结构体对象中</span></span></span><br><span class="line"><span class="params">  HWND hWnd,           <span class="comment">// handle to window，设为NULL接收所用窗口</span></span></span><br><span class="line"><span class="params">  UINT wMsgFilterMin,  <span class="comment">// first message</span></span></span><br><span class="line"><span class="params">  UINT wMsgFilterMax   <span class="comment">// last message；范围过滤，获得所有消息则设为0</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>注意：GetMessage函数除了接收到WM_QUIT（退出消息）外都返回非零值，出错返回-1。</p>
<p>通常编写的消息循环代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MSG msg;<span class="comment">//声明消息结构体变量</span></span><br><span class="line"><span class="keyword">while</span>(GetMessage(&amp;msg,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>))<span class="comment">//没接收到WM_QUIT时一致循环</span></span><br><span class="line">&#123;</span><br><span class="line">    TranslateMessage(&amp;msg);<span class="comment">//将WM_KEYDOWN和WM_KEYUP转化为WM_CHAR,不修改原消息</span></span><br><span class="line">    DispatchMessage(&amp;msg);<span class="comment">//将消息发送至操作系统，后者用窗口过程函数对消息响应； Dispatch：派遣</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708742389376-8d3746b0-03cd-4018-abe6-7773bef5b530.jpeg#averageHue=%23f9f9f9&clientId=u36ddef60-4b23-4&from=paste&height=1305&id=u43747779&originHeight=1424&originWidth=3039&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=415874&status=done&style=none&taskId=ude1c62be-9fa7-401d-bf95-2ccea8ae71e&title=&width=2785.75" alt="IMG_20210623_120844.jpg"></p>
<p>1.4.2窗口创建和1.4.3消息循环都包含在WinMain函数体内</p>
<h3 id="1-4-4-窗口过程函数"><a href="#1-4-4-窗口过程函数" class="headerlink" title="1.4.4 窗口过程函数"></a>1.4.4 窗口过程函数</h3><p>即回调函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">WindowProc</span><span class="params">(</span></span><br><span class="line"><span class="params">  HWND hwnd,      <span class="comment">// 窗口句柄</span></span></span><br><span class="line"><span class="params">  UINT uMsg,      <span class="comment">// 消息代码</span></span></span><br><span class="line"><span class="params">  WPARAM wParam,  <span class="comment">// first message parameter</span></span></span><br><span class="line"><span class="params">  LPARAM lParam   <span class="comment">// second message parameter</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>过程函数名WindowProc可以换，但要和声明保持一致。</li>
<li>使用switch&#x2F;case来对不同消息作出不同反应。</li>
</ol>
<p>如下方例子中的过程函数所示。</p>
<h2 id="课后程序"><a href="#课后程序" class="headerlink" title="课后程序"></a>课后程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_DEPRECATE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************函数声明****************************/</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WinSunProc</span><span class="params">(</span></span><br><span class="line"><span class="params">  HWND hwnd,      <span class="comment">// handle to window</span></span></span><br><span class="line"><span class="params">  UINT uMsg,      <span class="comment">// message identifier</span></span></span><br><span class="line"><span class="params">  WPARAM wParam,  <span class="comment">// first message parameter</span></span></span><br><span class="line"><span class="params">  LPARAM lParam   <span class="comment">// second message parameter</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************WinMain函数*************************/</span></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">WinMain</span><span class="params">(</span></span><br><span class="line"><span class="params">  HINSTANCE hInstance,      <span class="comment">// handle to current instance</span></span></span><br><span class="line"><span class="params">  HINSTANCE hPrevInstance,  <span class="comment">// handle to previous instance</span></span></span><br><span class="line"><span class="params">  LPSTR lpCmdLine,          <span class="comment">// command line</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> nCmdShow              <span class="comment">// show state</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*设计一个窗口类*/</span></span><br><span class="line">  WNDCLASS wndcls;</span><br><span class="line">  wndcls.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">  wndcls.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">  wndcls.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);</span><br><span class="line">  wndcls.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_CROSS);</span><br><span class="line">  wndcls.hIcon = LoadIcon(<span class="literal">NULL</span>, IDI_ERROR);</span><br><span class="line">  wndcls.hInstance = hInstance;</span><br><span class="line">  wndcls.lpfnWndProc = WinSunProc;</span><br><span class="line">  wndcls.lpszClassName=<span class="string">&quot;hezexian2021&quot;</span>;</span><br><span class="line">  wndcls.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">  wndcls.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">  RegisterClass(&amp;wndcls);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*创建窗口*/</span></span><br><span class="line">  HWND hwnd;</span><br><span class="line">  hwnd = CreateWindow(<span class="string">&quot;hezexian2021&quot;</span>, <span class="string">&quot;He Zexian&#x27;s home.&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="number">0</span>, <span class="number">0</span>, <span class="number">600</span>, <span class="number">400</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*显示及刷新窗口*/</span></span><br><span class="line">  ShowWindow(hwnd, SW_SHOWNORMAL);</span><br><span class="line">  UpdateWindow(hwnd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*消息循环*/</span></span><br><span class="line">  MSG msg;</span><br><span class="line">  <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    TranslateMessage(&amp;msg);<span class="comment">//将WM_KEYDOWN和WM_KEYUP转化为WM_CHAR,不修改原消息</span></span><br><span class="line">    DispatchMessage(&amp;msg);<span class="comment">//将消息发送至操作系统，后者用窗口过程函数对消息响应</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> msg.wParam;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************窗口过程函数*************************/</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WinSunProc</span><span class="params">(</span></span><br><span class="line"><span class="params">  HWND hwnd,      <span class="comment">// handle to window</span></span></span><br><span class="line"><span class="params">  UINT uMsg,      <span class="comment">// message identifier</span></span></span><br><span class="line"><span class="params">  WPARAM wParam,  <span class="comment">// first message parameter</span></span></span><br><span class="line"><span class="params">  LPARAM lParam   <span class="comment">// second message parameter</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (uMsg)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> WM_CHAR:</span><br><span class="line">    <span class="type">char</span> szChar[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(szChar, <span class="string">&quot;char code is %d&quot;</span>, wParam);</span><br><span class="line">    MessageBox(hwnd, szChar, <span class="string">&quot;char&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">    MessageBox(hwnd, <span class="string">&quot;mouse clicked&quot;</span>, <span class="string">&quot;message&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    HDC hdc;                    <span class="comment">//要在窗口中输出文字或显示图形，要用到设备描述表（DC）。DC是一个包含设备信息的结构体，所有的图形操作都是利用DC来完成。</span></span><br><span class="line">                                <span class="comment">//定义类型为HDC的变量hdc</span></span><br><span class="line">        hdc = GetDC(hwnd);          <span class="comment">//GetDC返回与特定窗口相关联的DC句柄</span></span><br><span class="line">    TextOut(hdc, <span class="number">0</span>, <span class="number">50</span>, <span class="string">&quot;何泽贤之家&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;何泽贤之家&quot;</span>));</span><br><span class="line">    ReleaseDC(hwnd, hdc);          <span class="comment">//在使用完GetDC后一定要注意释放</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> WM_PAINT:<span class="comment">//窗口重绘</span></span><br><span class="line">    HDC hDC;</span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    hDC = BeginPaint(hwnd, &amp;ps);</span><br><span class="line">    TextOut(hDC, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;http://www.hezexian.org&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;http://www.hezexian.org&quot;</span>));</span><br><span class="line">    EndPaint(hwnd, &amp;ps);<span class="comment">//WM_PAINT、BeginPaint、EndPaint一起用，而不能用GetDC</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> WM_CLOSE:<span class="comment">//关闭消息</span></span><br><span class="line">    <span class="keyword">if</span> (IDYES == MessageBox(hwnd, <span class="string">&quot;是否真的结束了？&quot;</span>, <span class="string">&quot;message&quot;</span>, MB_YESNO))</span><br><span class="line">    &#123;</span><br><span class="line">      DestroyWindow(hwnd);<span class="comment">//销毁窗口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line"><span class="comment">//此时窗口销毁，但程序还在后台运行</span></span><br><span class="line">            </span><br><span class="line">  <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">    PostQuitMessage(<span class="number">0</span>);<span class="comment">//在响应消息后,投递一个退出的消息使用程序安全退出</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, uMsg, wParam, lParam);<span class="comment">//调用缺省的消息处理过程函数，对没有处理的其他消息以默认处理</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充：<br>1、如遇到cannot convert from ‘const char [7]’ to ‘LPCWSTR’的错误，请对工程进行字符设置菜单栏-&lt;项目-&lt;xxx 属性-&lt;配置属性-&lt;高级-&lt;字符集,改成“not set”或改成“Use Multi-Byte Character Set”。<br>2、vs2019–Windows桌面应用程序</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] VC深入详解 孙鑫 第一章 Windows程序内部运行机制 - focusahaha - 博客园 (cnblogs.com).<a target="_blank" rel="noopener" href="https://_www.cnblogs.com_focusahaha_p_12601081/">https://www.cnblogs.com/focusahaha/p/12601081.html</a><br>[2]孙鑫.VC深度详解修订版[M]. 北京:电子工业出版社, 2012. 1-26.</p>
<hr>
<h1 id="第二章-掌握C"><a href="#第二章-掌握C" class="headerlink" title="第二章 掌握C++"></a>第二章 掌握C++</h1><h2 id="2-1-从结构到类"><a href="#2-1-从结构到类" class="headerlink" title="2.1 从结构到类"></a>2.1 从结构到类</h2><h3 id="2-1-1-结构体的定义"><a href="#2-1-1-结构体的定义" class="headerlink" title="2.1.1 结构体的定义"></a>2.1.1 结构体的定义</h3><ol>
<li>C++相比于C的特性：封装性、继承性、多态性；</li>
<li>对象具有状态和行为，状态保存在成员变量中，行为通过函数实现；</li>
<li>标准输入输出流对象：cin（&gt;&gt;）默认键盘   和    cout（&lt;&lt;）、cerr（&lt;&lt;）默认显示器；自动根据数据类型调整输入输出格式；</li>
<li>结构体中的函数称为成员函数。</li>
</ol>
<p><strong>程序2.1</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;   <span class="comment">//error C1083: 无法打开包括文件:“iostream.h”: No such file or directory</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> x, y;           <span class="comment">//状态</span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">output</span><span class="params">()</span>       <span class="comment">//行为</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x=&quot;</span>&lt;&lt; x &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;y=&quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//endl是换行符</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;pt;<span class="comment">//注意分号</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入x和y的值：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; pt.x;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; pt.y;</span><br><span class="line">  pt.output();    <span class="comment">//注意括号</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-结构体与类"><a href="#2-1-2-结构体与类" class="headerlink" title="2.1.2 结构体与类"></a>2.1.2 结构体与类</h3><p>在C++中，结构体（struct）和类（class）可以通用。<br>区别在于访问控制的差异：</p>
<ol>
<li>struct默认访问控制标识符public；public：可以在类的外部进行访问</li>
<li>class默认访问控制标识符private；private：只能在类的内部进行访问</li>
<li>protective。</li>
</ol>
<p><strong>程序2.2：将程序2.1中的struct point修改为class point</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span>   //类：抽象出一些事物共有的属性</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">  <span class="type">void</span> <span class="title function_">output</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x=&quot;</span>&lt;&lt; x &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;y=&quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;pt;   <span class="comment">//实例化了一个对象==类的实例化：具有具体的属性值</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-C-的特性"><a href="#2-2-C-的特性" class="headerlink" title="2.2 C++的特性"></a>2.2 C++的特性</h2><h3 id="2-2-1-类与对象"><a href="#2-2-1-类与对象" class="headerlink" title="2.2.1 类与对象"></a>2.2.1 类与对象</h3><p>类：抽象出一些事物共有的属性；<br>对象：有具体的属性值。</p>
<h3 id="2-2-2-构造函数"><a href="#2-2-2-构造函数" class="headerlink" title="2.2.2 构造函数"></a>2.2.2 构造函数</h3><p>作用：在定义对象的同时，对成员变量进行初始化；<br>创建对象本身（分配内存）<br>规定：构造函数的名字和类名相同（唯一性）；<br>没用返回值；<br>可以有参数。<br>注意：</p>
<ol>
<li>如果一个类没有定义任何构造函数，那么C会提供一个默认的不带参构造函数。而只要类中定义了一个构造函数，C便不再提供任何其他构造函数；</li>
<li>每个类必须有一个构造函数，没有构造函数不能创建任何对象。构造函数如代码2.3所示。</li>
</ol>
<h3 id="2-2-3-析构函数"><a href="#2-2-3-析构函数" class="headerlink" title="2.2.3 析构函数"></a>2.2.3 析构函数</h3><p><code>~类名(); //对象生命周期结束，释放其占用资源；是一个对象最后调用的成员函数</code><br>注意：析构函数不允许有返回值，更不允许有参数，并且一个类中只有一个构造函数。<br><strong>代码2.3：构造函数和析构函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span>       //类名：<span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">  <span class="type">int</span> x , y;</span><br><span class="line">    point()      <span class="comment">//构造函数  point()</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">0</span>;    <span class="comment">//在类中定义成员变量时，不能直接给其赋值(如int x=0;)，而是在构造函数中赋值(P37提示)</span></span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~point()    <span class="comment">//析构函数   ~point()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-4-函数的重载"><a href="#2-2-4-函数的重载" class="headerlink" title="2.2.4 函数的重载"></a>2.2.4 函数的重载</h3><p>条件：函数参数类型、个数不同才能构成重载。<br>注意：</p>
<ol>
<li>只有函数的返回值类型不同，不能重载；</li>
<li>重载时，注意函数带有默认参数的情况。(P38)</li>
<li>对比覆盖：重载是发生在同一个类当中；覆盖是发生在父类和子类之间</li>
</ol>
<p><strong>代码2.4 函数的重载</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">  <span class="type">int</span> x , y;</span><br><span class="line">    point()      <span class="comment">//函数1</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    point(<span class="type">int</span> a, <span class="type">int</span> b)    <span class="comment">//重载，函数2</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    point <span class="title function_">pt</span><span class="params">(<span class="number">5</span>,<span class="number">5</span>)</span>;   <span class="comment">//C++根据参数类型和个数，执行函数2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-5-this指针"><a href="#2-2-5-this指针" class="headerlink" title="2.2.5 this指针"></a>2.2.5 this指针</h3><ol>
<li>this指针是一个隐含的指针，指向对象本身，代表对象的地址。</li>
<li>用法：当形参的变量名和成员变量的变量名冲突时，可用this-&gt;来区别对哪一个变量进行赋值。(P40)</li>
</ol>
<p>this-&gt;x是对成员变量进行赋值；<br>x是对形参赋值。</p>
<h3 id="2-2-6-类的继承"><a href="#2-2-6-类的继承" class="headerlink" title="2.2.6 类的继承"></a>2.2.6 类的继承</h3><h4 id="2-2-6-1-继承"><a href="#2-2-6-1-继承" class="headerlink" title="2.2.6.1 继承"></a>2.2.6.1 继承</h4><p>例如：<code>class fish : public animal&#123;&#125;;</code></p>
<ol>
<li>animal是父类，fish是子类。子类fish以public（公有）的方式继承父类animal。</li>
<li>子类除了自己的成员变量和成员方法外，还可以继承父类的成员变量和成员方法。</li>
<li>构造函数和析构函数的调用次序：</li>
</ol>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708742415566-92333483-5371-45dc-bd72-771fa5be5b33.png#averageHue=%23eeeeee&clientId=u36ddef60-4b23-4&from=paste&height=211&id=u03b2526e&originHeight=230&originWidth=296&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=12042&status=done&style=none&taskId=u6dcd2671-8216-4537-b4de-ce5fe35207d&title=&width=271.33333333333337" alt="image.png"></p>
<h4 id="2-2-6-2-在子类中调用父类带参数的构造函数"><a href="#2-2-6-2-在子类中调用父类带参数的构造函数" class="headerlink" title="2.2.6.2 在子类中调用父类带参数的构造函数"></a>2.2.6.2 在子类中调用父类带参数的构造函数</h4><p>例如：父类构造函数： <code>animal(int h , int w)&#123;&#125;</code><br>则在构造子类时，应该显式地去调用父类的带参数构造函数： <code>fish():animal(400,300)&#123;&#125;</code></p>
<h4 id="2-2-6-3-类的继承及类中成员的访问特性"><a href="#2-2-6-3-类的继承及类中成员的访问特性" class="headerlink" title="2.2.6.3 类的继承及类中成员的访问特性"></a>2.2.6.3 类的继承及类中成员的访问特性</h4><p><strong>3种访问权限修饰符：</strong><br>public：定义的成员可以在任何地方被访问；<br>protected：定义的成员只能在该类及其子类中访问；<br>private：定义的成员只能在该类自身中访问。&#x3D;&#x3D;&gt;不能被子类继承</p>
<p><strong>3种继承方式：</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708742427838-701c9a37-07b4-4745-aed1-da1345bfb30f.jpeg#averageHue=%2309328c&clientId=u36ddef60-4b23-4&from=paste&height=1408&id=u502e6573&originHeight=1536&originWidth=2048&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=164854&status=done&style=none&taskId=u070cc178-4cc3-46f3-8ac1-f3fd3f01e34&title=&width=1877.3333333333335" alt="QQ图片20210627115117.jpg"></p>
<h4 id="2-2-6-4-多重继承"><a href="#2-2-6-4-多重继承" class="headerlink" title="2.2.6.4 多重继承"></a>2.2.6.4 多重继承</h4><p>定义形式：<code>class B: public C , public D</code><br>了解父类表顺序对调用构造函数和析构函数的影响。对于上面的例子，先构造C再构造D，先析构D再析构C。</p>
<h3 id="2-2-7-虚函数与多态性、纯虚函数"><a href="#2-2-7-虚函数与多态性、纯虚函数" class="headerlink" title="2.2.7 虚函数与多态性、纯虚函数"></a>2.2.7 虚函数与多态性、纯虚函数</h3><h4 id="2-2-7-1虚函数与多态性"><a href="#2-2-7-1虚函数与多态性" class="headerlink" title="2.2.7.1虚函数与多态性"></a>2.2.7.1虚函数与多态性</h4><p>**程序 2.5 **</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(P49)...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">void</span> <span class="title function_">breathe</span><span class="params">()</span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;animal breathe&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;   <span class="comment">/*注意此时不是虚函数*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fish</span> :</span> public animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  ...</span><br><span class="line">    <span class="type">void</span> <span class="title function_">breathe</span><span class="params">()</span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;fish bubble&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">breathetest</span><span class="params">(animal* pan)</span></span><br><span class="line">&#123;</span><br><span class="line">  pan-&gt;breathe();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  animal* pan;  <span class="comment">//指向animal类的指针pan</span></span><br><span class="line">  fish fi;</span><br><span class="line">  pan = &amp;fi;    <span class="comment">//将fish类的对象fi的地址直接赋给指向animal类的指针变量pan</span></span><br><span class="line">  breathetest(pan);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出animal breathe*/</span></span><br></pre></td></tr></table></figure>

<p>1、fish对象也是一个animal类，C++自动进行类型转换；反之，不能把animal对象看成fish对象。</p>
<p>2、当我们将fish转化为animal时，该对象就会被认为是原对象内存模型的上半部分。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708742439266-c5b377aa-1c43-45b6-849d-b4075033d0a6.jpeg#averageHue=%23fcfcfc&clientId=u36ddef60-4b23-4&from=paste&height=1354&id=u85029cfc&originHeight=1477&originWidth=3557&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=315758&status=done&style=none&taskId=uf7498ddf-7578-450d-b406-d0c894c1451&title=&width=3260.5833333333335" alt="IMG_20210627_153537.jpg"></p>
<p>3、将父类函数修改为虚函数，输出结果为fish bubble。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(P49)...</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">breathe</span><span class="params">()</span>    <span class="comment">//虚函数</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/*输出fish bubble*/</span></span><br></pre></td></tr></table></figure>

<p>虚函数：用virtual关键字申明的函数–&gt;多态性；<br>迟邦定：编译时并不确定具体调用的函数，而是在运行时依据对象的类型来确认调用的是哪一个函数。</p>
<p>概括(用法)：在父类的函数前加上virtual关键字，在子类重写该函数，运行时将会根据对象的实际类型来调用相应的函数。</p>
<h4 id="2-2-7-2-纯虚函数"><a href="#2-2-7-2-纯虚函数" class="headerlink" title="2.2.7.2 纯虚函数"></a>2.2.7.2 纯虚函数</h4><ol>
<li>纯虚函数不被具体实现，是抽象类，不能实例化对象。</li>
<li>纯虚函数可以让类先具有一个操作名称，而没有操作内容，在子类继承时再去具体定义。</li>
</ol>
<p>写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="type">void</span> <span class="title function_">breathe</span><span class="params">()</span> = <span class="number">0</span> ;    <span class="comment">//1、等于0；2、无函数体</span></span><br></pre></td></tr></table></figure>

<p>注意：子类如果有对父类虚函数的覆盖定义，无论该覆盖定义是否有virtual，都是虚函数。</p>
<h3 id="2-2-8函数的覆盖和隐藏"><a href="#2-2-8函数的覆盖和隐藏" class="headerlink" title="2.2.8函数的覆盖和隐藏"></a>2.2.8函数的覆盖和隐藏</h3><h4 id="2-2-8-1-覆盖"><a href="#2-2-8-1-覆盖" class="headerlink" title="2.2.8.1 覆盖"></a>2.2.8.1 覆盖</h4><p>1、覆盖(P52)：发生在父类和子类之间    的   函数完全一样（函数名、参数列表），编译器根据实际类型确定要调用的函数。<br>2、对比重载：重载是发生在同一个类当中；覆盖是发生在父类和子类之间</p>
<p><strong>程序2.6 函数的覆盖</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">breathe</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;animal breathe&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fish</span> :</span> public animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  <span class="type">void</span> <span class="title function_">breathe</span><span class="params">()</span>     <span class="comment">//覆盖</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;fish bubble&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    fish fi;</span><br><span class="line">    fi.breathe();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出fish bubble*/</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-8-2-隐藏"><a href="#2-2-8-2-隐藏" class="headerlink" title="2.2.8.2 隐藏"></a>2.2.8.2 隐藏</h4><p>两种父类函数隐藏的情况：</p>
<ol>
<li>子类和父类函数完全相同（函数名、参数列表），但父类函数没有virtual，则父类函数被隐藏。</li>
<li>子类和父类函数同名，但参数列表不同，则父类函数被隐藏。</li>
</ol>
<p>区别隐藏与覆盖：覆盖是发生在父类与子类之间，两个函数必须完全相同且都是虚函数。否则就是隐藏。</p>
<h3 id="2-2-9-引用"><a href="#2-2-9-引用" class="headerlink" title="2.2.9 引用"></a>2.2.9 引用</h3><p>定义形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> &amp;b = a;  <span class="comment">//引用必须在申明时就初始化，与a绑定;后面不会再与其他变量绑定</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>引用只是一个别名，不占用内存空间；此处要和指针区分开来。</li>
<li>引用多用于函数的形参定义。如程序2.4所示。</li>
</ol>
<p><strong>程序2.7  引用示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;                <span class="comment">//换成引用意思表达更清晰：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*以下为用指针交换数据*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span>;         <span class="comment">//void change(int&amp; a,int&amp; b);</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;y=&quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  change(&amp;x,&amp;y);                <span class="comment">//是对x和y的地址互换还是对x和y互换？     change(x,y);</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;y=&quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span>        <span class="comment">//void change(int a,int b)</span></span><br><span class="line">&#123;                                   <span class="comment">//&#123;</span></span><br><span class="line">  <span class="type">int</span> c;                            <span class="comment">// int c;</span></span><br><span class="line">  c = *a;                          <span class="comment">//  c = a;</span></span><br><span class="line">  *a = *b;                          <span class="comment">// a = b;</span></span><br><span class="line">  *b = c;                           <span class="comment">// b = c;</span></span><br><span class="line">&#125;                                   <span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-10-C-类设计习惯和头文件重复包含问题的解决"><a href="#2-2-10-C-类设计习惯和头文件重复包含问题的解决" class="headerlink" title="2.2.10 C++类设计习惯和头文件重复包含问题的解决"></a>2.2.10 C++类设计习惯和头文件重复包含问题的解决</h3><p>1、头文件存放类的定义及类成员函数的声明；<br>源文件存放类中成员函数的实现。</p>
<p>2、注意文件包含；<br><code>#include &quot;animal.h&quot;  //&quot;&quot;，从当前目录开始搜索，然后是系统目录和PATH环境变量所列出的目录</code><br><code>#include &lt;iostream&gt;   //&lt;&gt;，从系统目录开始搜索，然后是PATH环境变量所列出的目录。``不搜索当前目录</code><br>注意子类的头文件中也要包含父类的头文件，如fish.h中的#include “animal.h”。</p>
<p>3、::是作用域表示符，表明函数或数据成员属于哪个类；<br>前面如果不跟类名，表示全局函数（即非成员函数）或全局数据。</p>
<p>4、在头文件中声明函数时用了virtual，在源文件中就不用写virtual。</p>
<p>5、要解决类重复定义的问题，要使用条件预处理指令（如课后程序animal.h和fish.h所示）</p>
<p><strong>程序2.8 条件预处理指令解决类重复定义的问题</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ANIMAL_H_H     <span class="comment">//如果没有定义ANIMAL_H_H，就定义ANIMAL_H_H，接着申明animal类</span></span></span><br><span class="line">                       <span class="comment">//如果定义过了ANIMAL_H_H，直接跳至endif</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANIMAL_H_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-11-VC-程序编译连接的原理与过程"><a href="#2-2-11-VC-程序编译连接的原理与过程" class="headerlink" title="2.2.11 VC++程序编译连接的原理与过程"></a>2.2.11 VC++程序编译连接的原理与过程</h3><p>1、编译：头文件不参与编译<br>源文件单独编译<br>XXX.obj目标文件<br>2、链接</p>
<p>编译链接过程如下。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708742459674-ddc535d0-7134-4034-bcdb-8b0f50519dab.jpeg#averageHue=%23f5f5f4&clientId=u36ddef60-4b23-4&from=paste&height=2178&id=ufc444e15&originHeight=2376&originWidth=3489&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=1163196&status=done&style=none&taskId=ua1badef6-adaa-465f-bcc3-a18f715f92f&title=&width=3198.2500000000005" alt="IMG_20210627_171323.jpg"></p>
<h2 id="课后程序-1"><a href="#课后程序-1" class="headerlink" title="课后程序"></a>课后程序</h2><p><strong>animal.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*animal.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ANIMAL_H_H     <span class="comment">//如果没有定义ANIMAL_H_H，就定义ANIMAL_H_H，接着申明animal类</span></span></span><br><span class="line">                       <span class="comment">//如果定义过了ANIMAL_H_H，直接跳至endif</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANIMAL_H_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">  animal();</span><br><span class="line">  ~animal();</span><br><span class="line">  <span class="type">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">void</span> <span class="title function_">sleep</span><span class="params">()</span>;</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">breathe</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>animal.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*animal.cpp*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;animal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">animal::animal()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">animal::~animal()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">animal::eat</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">animal::sleep</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">animal::breathe</span><span class="params">()</span>      <span class="comment">//在头文件中有virtual,则在源文件中不用加virtual</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;animal breathe&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>fish.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*fish.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;animal.h&quot;</span>  <span class="comment">//fish类从animal类继承</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FISH_H_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FISH_H_H</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fish</span> :</span>public animal     <span class="comment">//结构体、类名后面没有括号()</span></span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  <span class="type">void</span> <span class="title function_">breathe</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>fish.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*fish.cpp*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fish.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fish::breathe</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fish bubble&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>main.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.cpp*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;animal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fish.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">breathetest</span><span class="params">(animal* pan)</span></span><br><span class="line">&#123;</span><br><span class="line">  pan-&gt;breathe();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  animal* pan;</span><br><span class="line">  fish fi;</span><br><span class="line">  animal an;</span><br><span class="line">  pan = &amp;fi;</span><br><span class="line">  breathetest(pan);</span><br><span class="line">  pan = &amp;an;</span><br><span class="line">  breathetest(pan);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708742476799-76e92417-5326-4278-b8a6-e365d0bfc278.png#averageHue=%2312100e&clientId=u36ddef60-4b23-4&from=paste&height=55&id=u257db54c&originHeight=60&originWidth=166&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=2019&status=done&style=none&taskId=u14eaddc1-0bb1-403a-b47f-18db63b8233&title=&width=152.16666666666669" alt="image(1).png"></p>
<h2 id="问题及反思"><a href="#问题及反思" class="headerlink" title="问题及反思"></a>问题及反思</h2><p>vs2019编程出现的问题：<br>1、建立C++空项目后，要在右侧工程的源文件的文件夹下创建XXX.cpp文件；</p>
<p>否则编译时无法启动程序XXX.exe，系统找不到指定文件。</p>
<p>2、头文件#include &lt;iostream.h&gt;后添加using namespace std；<br>否则报错：error C1083: 无法打开包括文件:“iostream.h”: No such file or directory<br>3、定义结构体或类时，别忘记最后的分号；结构体名或类名后面没有小括号；<br>4、引用成员函数别忘记括号：pt.output();<br>5、.sln为项目文件</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708745317287-3559a957-3a2e-46a4-9260-acce8d441597.png#averageHue=%23f0f3fa&clientId=u36ddef60-4b23-4&from=paste&height=244&id=u6da8e2a2&originHeight=266&originWidth=317&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=14898&status=done&style=none&taskId=u02c08995-b3c7-471b-9695-f85765db29c&title=&width=290.58333333333337" alt="image(2).png"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708745329159-794985ec-0dc0-45ee-9a70-3a28ad394216.png#averageHue=%23f3f2f2&clientId=u36ddef60-4b23-4&from=paste&height=261&id=u85290e4d&originHeight=285&originWidth=637&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=48246&status=done&style=none&taskId=ud923bd32-08e5-4e4c-a797-3e09019c401&title=&width=583.9166666666667" alt="image(3).png"></p>
<h2 id="参考文献-1"><a href="#参考文献-1" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]&lt;<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43751983/article/details/91147918">https://blog.csdn.net/weixin_43751983&#x2F;article&#x2F;details&#x2F;91147918</a> &gt;this指针<br>[2]孙鑫.VC++深度详解修订版[M]. 北京:电子工业出版社, 2012. 27-62.</p>
<hr>
<h1 id="第三章-MFC框架程序剖析"><a href="#第三章-MFC框架程序剖析" class="headerlink" title="第三章 MFC框架程序剖析"></a>第三章 MFC框架程序剖析</h1><h2 id="3-1创建MFC-AppWizard"><a href="#3-1创建MFC-AppWizard" class="headerlink" title="3.1创建MFC AppWizard"></a>3.1创建MFC AppWizard</h2><p>如何利用vs2019创建MFC应用见参考文献[1]<br>需要注意的地方有<br>[1]创建MFC单文档应用程序</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708745341365-2e5d3bc4-d1c1-4bcb-9ced-e225a099ccb7.jpeg#averageHue=%23f6f5f1&clientId=u36ddef60-4b23-4&from=paste&height=722&id=u866d3efa&originHeight=788&originWidth=1050&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=97959&status=done&style=none&taskId=u570fef31-d012-4839-9eaa-3695cbec5ff&title=&width=962.5000000000001" alt="屏幕截图 2021-06-28 101949.jpg"></p>
<p>[2]开启类视图窗口</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708745349967-79931c34-9233-41fc-ba5e-050932aa1319.png#averageHue=%23faf7f1&clientId=u36ddef60-4b23-4&from=paste&height=477&id=ua24ef771&originHeight=520&originWidth=322&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=19727&status=done&style=none&taskId=u13b05d18-4f4d-44d0-8be9-87d6464991f&title=&width=295.1666666666667" alt="image(4).png"></p>
<h2 id="3-2基于MFC的程序框架剖析"><a href="#3-2基于MFC的程序框架剖析" class="headerlink" title="3.2基于MFC的程序框架剖析"></a>3.2基于MFC的程序框架剖析</h2><p>在MFC中，类的命名都以C开头；对于单文档应用程序，如图3.2所示，都有：</p>
<ul>
<li>CAboutDlg帮助类，同于说明这个工程的开发信息；</li>
<li>CMainFrame主框架类；</li>
<li>C工程名App应用程序入口；</li>
<li>C工程名Doc文档类，用来管理、存放数据；</li>
<li>C工程名View用来将文档中的数据可视化。</li>
</ul>
<p>CMainFrame类和CTestView类都有一个共同的基类：Cwnd类，其封装了与窗口相关的操作。</p>
<h3 id="3-2-1-MFC中的WinMain函数"><a href="#3-2-1-MFC中的WinMain函数" class="headerlink" title="3.2.1 MFC中的WinMain函数"></a>3.2.1 MFC中的WinMain函数</h3><p>文件路径（在安装路径下直接搜索MFC,找到mfc）：D:\Program Files (x86)\visualstudio\VC\Tools\MSVC\14.29.30037\atlmfc\src，打开appmodul.cpp 查找WinMain</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> WINAPI</span><br><span class="line">_tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,     <span class="comment">//右键_tWinMain,单击转到定义：#define _tWinMain   WinMain</span></span><br><span class="line">  _In_ LPTSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(suppress: 4985)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// call shared/exported WinMain</span></span><br><span class="line">  <span class="keyword">return</span> AfxWinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1-1-theApp全局对象"><a href="#3-2-1-1-theApp全局对象" class="headerlink" title="3.2.1.1 theApp全局对象"></a>3.2.1.1 theApp全局对象</h4><p>以简单的C++源程序为例，在入口函数main()加载之前，就已经为全局变量（对象）分配了内存空间，并为其赋了初值。对于一个全局对象来说，此时就会调用该对象的构造函数构造该对象并进行初始化操作，然后才是进入main()函数。(P72例3-4已标出先后顺序)</p>
<p>对于MFC来说，通过产生一个应用程序类的对象来唯一标识应用程序的实例。每个MFC程序有且仅有一个从应用程序类（CWinApp）派生的类；每个MFC程序实例有且仅有一个该派生类的实例化对象，即theApp全局对象，theApp表示了该应用程序本身。theApp的定义如程序3.1所示，在test.cpp中查看。</p>
<p><strong>程序3.1 theApp全局对象</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*test.cpp*/</span></span><br><span class="line"><span class="comment">// 唯一的 CtestApp 对象</span></span><br><span class="line">CtestApp theApp;    <span class="comment">//theApp是CtestApp的一个对象，注意其是一个全局对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*test.h*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CtestApp</span> :</span> public CWinApp   <span class="comment">//CtestApp继承于CWinApp，后者表示应用程序类</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件路径（在安装路径下直接搜索MFC,找到mfc）：D:\Program Files (x86)\visualstudio\VC\Tools\MSVC\14.29.30037\atlmfc\src，打开appcore.cpp 查找CWinApp（184行）其中，<br><strong>程序3.2</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CWinApp::CWinApp(LPCTSTR lpszAppName)  <span class="comment">//注意此处有参数</span></span><br><span class="line">&#123; ...   </span><br><span class="line">pModuleState-&gt;m_pCurrentWinApp = this; <span class="comment">//此处this代表子类CTestApp的对象，即theApp</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>程序3.3</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CWinApp</span> :</span> public CWinThread</span><br><span class="line">&#123;...</span><br><span class="line">  explicit <span class="title function_">CWinApp</span><span class="params">(LPCTSTR lpszAppName = <span class="literal">NULL</span>)</span>;     <span class="comment">// app name defaults to EXE name;构造函数形参有默认值默认值</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>补充：如果某个函数的参数有默认值，那么在调用该函数时可以传参，也可以不传参直接使用默认值。</p>
<p>由程序3.3可见，来CWinApp类的定义时，CWinApp的构造函数的形参有默认值NULL。因此，在调用CWinApp类的构造函数时，不用显式地传参。</p>
<h4 id="3-2-1-2-AfxWinMain函数"><a href="#3-2-1-2-AfxWinMain函数" class="headerlink" title="3.2.1.2 AfxWinMain函数"></a>3.2.1.2 AfxWinMain函数</h4><p>WinMain函数实际上是通过调用AfxWinMain函数来完成它的功能的。<br>其中，Afx前缀的函数代表应用程序框架函数，辅助我们生成应用程序框架的应用模型。在MFC中，Afx为前缀的函数都是全局函数，可以在程序的任何位置调用。</p>
<p>在AfxWinMain函数的定义中，有<br><strong>程序3.4</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*pThread和pApp这两个指针是一致的，这两个指针都指向CTestApp类的对象，即theApp全局对象*/</span>  </span><br><span class="line">    CWinThread* pThread = AfxGetThread();</span><br><span class="line">  CWinApp* pApp = AfxGetApp();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*MFC内部管理所调用的函数*/</span></span><br><span class="line">  <span class="keyword">if</span> (pApp != <span class="literal">NULL</span> &amp;&amp; !pApp-&gt;InitApplication())</span><br><span class="line">    <span class="keyword">goto</span> InitFailure;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用的是子类InitInstance()：因为在父类CWinApp中的InitInstance()是虚函数*/</span></span><br><span class="line">  <span class="keyword">if</span> (!pThread-&gt;InitInstance())&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*消息循环*/</span></span><br><span class="line">  nReturnCode = pThread-&gt;Run();</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1-3-InitInstance函数"><a href="#3-2-1-3-InitInstance函数" class="headerlink" title="3.2.1.3  InitInstance函数"></a>3.2.1.3  InitInstance函数</h4><p>见程序3.4的第九行。</p>
<h3 id="3-2-2-MFC框架窗口"><a href="#3-2-2-MFC框架窗口" class="headerlink" title="3.2.2 MFC框架窗口"></a>3.2.2 MFC框架窗口</h3><h4 id="3-2-2-1-设计和注册窗口"><a href="#3-2-2-1-设计和注册窗口" class="headerlink" title="3.2.2.1 设计和注册窗口"></a>3.2.2.1 设计和注册窗口</h4><p>窗口类的注册是由位于wincore.cpp的AfxEndDeferRegisterClass函数完成的。AfxEndDeferRegisterClass函数预定义了几种缺省的窗口类，首先判断窗口类的类型，再赋予其相应的类名。部分代码如书本p79所示。</p>
<p>接着调用AfxRegisterClass函数注册从窗口类,该函数首先获得窗口类信息，窗口已经注册，返回真。否则注册该窗口类。</p>
<p>注意：AfxRegisterClass实际上就是AfxEndDeferRegisterClass（宏定义）；</p>
<h4 id="3-2-2-2-创建窗口"><a href="#3-2-2-2-创建窗口" class="headerlink" title="3.2.2.2 创建窗口"></a>3.2.2.2 创建窗口</h4><p>窗口的创建是由CWnd类中的CreateEx函数完成的。定义：afxwin.h,实现：wincore.cpp。（以Ex结尾的函数表示扩展函数。）</p>
<p>CreateEx函数不是虚函数，CFrameWnd类的Create函数内调用的实际上就是CWnd类的CreatEx函数。CreateEx函数内部调用的PreCreateWindow函数是一个虚函数，在产生窗口之前有机会修改窗口外观。</p>
<h4 id="3-2-2-3-显示和更新窗口"><a href="#3-2-2-3-显示和更新窗口" class="headerlink" title="3.2.2.3 显示和更新窗口"></a>3.2.2.3 显示和更新窗口</h4><p>CTestApp中名为m_pMainWnd的成员变量保存了应用程序框架窗口（CMainFrame）对象的指针，在InitInstance函数（初始化工作：注册、显示、更新）内部：<br><strong>程序3.5</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唯一的一个窗口已初始化，因此显示它并对其进行更新</span></span><br><span class="line">  m_pMainWnd-&gt;ShowWindow(SW_SHOW);<span class="comment">//显示</span></span><br><span class="line">  m_pMainWnd-&gt;UpdateWindow();<span class="comment">//更新</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-消息循环"><a href="#3-2-3-消息循环" class="headerlink" title="3.2.3 消息循环"></a>3.2.3 消息循环</h3><p>见程序3.4的第12行。在thrdcore.cpp中<code>/*消息循环*/	nReturnCode = pThread-&gt;Run();</code></p>
<p>书本p85例3-16，该函数主要结构是一个for循环，在收到WM_QUIT时退出。在循环中的PumpMessage()与第一章的SDK编程的消息处理代码一致。</p>
<h3 id="3-2-4-MFC运行过程梳理"><a href="#3-2-4-MFC运行过程梳理" class="headerlink" title="3.2.4 MFC运行过程梳理"></a>3.2.4 MFC运行过程梳理</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708745365962-cb74b989-7e48-4bf6-a2d8-648637033aea.jpeg#averageHue=%2393928e&clientId=u36ddef60-4b23-4&from=paste&height=1938&id=u7043a8f4&originHeight=2114&originWidth=3521&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=1817235&status=done&style=none&taskId=ue64837f9-9983-4081-a9f1-7fd32b838a4&title=&width=3227.5833333333335" alt="IMG_20210628_164535.jpg"></p>
<h2 id="3-3-窗口类、窗口对象与窗口"><a href="#3-3-窗口类、窗口对象与窗口" class="headerlink" title="3.3 窗口类、窗口对象与窗口"></a>3.3 窗口类、窗口对象与窗口</h2><h3 id="3-3-1-三者之间的关系"><a href="#3-3-1-三者之间的关系" class="headerlink" title="3.3.1 三者之间的关系"></a>3.3.1 三者之间的关系</h3><p>:: 前面没有东西，表示所使用的函数是一个全局函数。如果当前定义的成员函数与内部调用的API函数重名，后者必须加  :: ，否则报错。</p>
<p>C窗口类对象与窗口并不是一回事，他们之间唯一的关系是C窗口类对象内部定义了一个窗口句柄变量，保存了与这个C窗口类对象相关的那个窗口的句柄。窗口销毁时，与之对应的C窗口类对象销毁与否要看其生命周期是否结束。但C++窗口类对象销毁时，与之相关的窗口也将销毁。</p>
<p>上段话用自己的话说：在窗口销毁后，CWnd的成员变量m_hWnd设为NULL，并没有被销毁（也有可能被销毁：对象生命周期结束（函数运行到右大括号“}”））；而在C++窗口类对象析构时，窗口被销毁。</p>
<p>在系统文件afxwin.h中,CWnd已有一个用于保存句柄的成员变量m_hWnd,ShowWindow()和UpdateWindow()不需要再传递这个句柄，因为它已经是成员变量。<br><strong>程序3.6</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*afxwin.h*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CWnd</span> :</span> public CCmdTarget</span><br><span class="line">&#123;</span><br><span class="line">  DECLARE_DYNCREATE(CWnd)</span><br><span class="line">protected:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> MSG* PASCAL <span class="title function_">GetCurrentMessage</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attributes</span></span><br><span class="line">public:</span><br><span class="line">  HWND m_hWnd;            <span class="comment">// must be first data member</span></span><br><span class="line">    ......</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*lesson3:\\wainmain.cpp*/</span></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">WinMain</span><span class="params">(  HINSTANCE hInstance,      <span class="comment">// handle to current instance</span></span></span><br><span class="line"><span class="params">  HINSTANCE hPrevInstance,  <span class="comment">// handle to previous instance</span></span></span><br><span class="line"><span class="params">  LPSTR lpCmdLine,          <span class="comment">// command line</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> nCmdShow              <span class="comment">// show state</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设计窗口类</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//注册窗口类</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//创建窗口类</span></span><br><span class="line">    CWnd wnd;</span><br><span class="line">    wnd.CreateEx(...);</span><br><span class="line">    wnd.ShowWindow(SW_SHOWNORMAL);</span><br><span class="line">    wnd.UpdateWindow();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对比第一章：</span></span><br><span class="line"><span class="comment">    创建窗口</span></span><br><span class="line"><span class="comment">  HWND hwnd;</span></span><br><span class="line"><span class="comment">  hwnd = CreateWindowEx();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  显示及刷新窗口</span></span><br><span class="line"><span class="comment">  ::ShowWindow(hwnd, SW_SHOWNORMAL);</span></span><br><span class="line"><span class="comment">  ::UpdateWindow(hwnd);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    注意ShowWindow和UpdateWindow的参数，原因是：CWnd类定义过了一个HWND类型的成员变量m_hWnd用于保存这个窗口的句柄，</span></span><br><span class="line"><span class="comment">    在调用CWnd类中的ShowWindow显示窗口时，就不在需要传递这个句柄了，因为它已经是成员变量了，该函数可以直接使用它。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    在窗口销毁后，CWnd的成员变量m_hWnd设为NULL，并没有被销毁；而在C++窗口类对象析构时，窗口被销毁。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//消息循环</span></span><br><span class="line">     ...   </span><br><span class="line">         </span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-在窗口中显示按钮"><a href="#3-3-2-在窗口中显示按钮" class="headerlink" title="3.3.2 在窗口中显示按钮"></a>3.3.2 在窗口中显示按钮</h3><p>CButton的Create函数声明：<br><code>BOOL Create( LPCTSTR lpszCaption, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID );</code></p>
<ul>
<li>lpszCaption：按钮文本；</li>
<li>dwStyle：按钮风格+窗口风格；</li>
<li>rect：定义一个矩形区域；</li>
<li>pParentWnd：指定父窗口。MFC不再通过窗口句柄，而是通过一个与窗口相关的C++窗口类对象指针来传递窗口对象。</li>
<li>nID:按钮控件标识。可取整数随机值。在框架窗口产生之后，再创建该标识，否则没地方放置。</li>
</ul>
<p>窗口创建时都会产生WM_Create消息，OnCreate函数用于相应这条窗口创建消息。</p>
<p>如果将按钮创建在CMainFrame::OnCreate()函数内，按钮的父窗口是主框架窗口，此时按钮遮挡住了保存等按钮。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708745378767-bd154cd4-0ce9-412f-9727-f627a5a7ba16.png#averageHue=%23f8f8f8&clientId=u36ddef60-4b23-4&from=paste&height=359&id=u19b856da&originHeight=392&originWidth=473&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=11529&status=done&style=none&taskId=u37cbe054-bf17-449b-b5c2-7e27b0cd463&title=&width=433.58333333333337" alt="image(5).png"></p>
<p>改为在CTestView.cpp中创建button，首先在testView.cpp中创建OnCreate函数，步骤如问题及反思[3]所示。运行结果如下。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708745389524-b5a69e4b-93ce-491f-930c-66b1dd73768e.jpeg#averageHue=%23f9f9f8&clientId=u36ddef60-4b23-4&from=paste&height=342&id=ua360e299&originHeight=373&originWidth=478&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=21537&status=done&style=none&taskId=u37f2b81c-7387-496f-b8b5-b65cb635e91&title=&width=438.1666666666667" alt="屏幕截图 2021-06-29 103602.jpg"></p>
<p>而将m_btn.Create()中的this改为GetParent(),运行结果变为</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708745400906-50533c80-aedc-4146-aec2-bbfbb55d0523.png#averageHue=%23f8f8f8&clientId=u36ddef60-4b23-4&from=paste&height=359&id=ud85f9d87&originHeight=392&originWidth=473&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=11529&status=done&style=none&taskId=u026d89e7-0cc3-4c9b-897d-8f389cd56f3&title=&width=433.58333333333337" alt="image(6).png"></p>
<p>可见，按钮的位置与其父窗口有关，与创建它的代码所在的类无关。</p>
<p>将按钮窗口销毁，m_btn并没有销毁，因为m_btn是CTestView类的一个成员变量，其生命周期与CTestView对象一致。</p>
<h2 id="课后程序-2"><a href="#课后程序-2" class="headerlink" title="课后程序"></a>课后程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*testview.h*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CtestView</span> :</span> public CView</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">private:</span><br><span class="line">  CButton m_btn;  <span class="comment">//在定义类的成员变量时都以&quot;m_&quot;为前缀，表明这个变量是类的成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*testview.cpp*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CtestView::OnCreate</span><span class="params">(LPCREATESTRUCT lpCreateStruct)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (CView::OnCreate(lpCreateStruct) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*CButton的Create函数声明：BOOL Create( LPCTSTR lpszCaption, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID );*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  m_btn.Create(_T(&quot;button&quot;), WS_CHILD | BS_DEFPUSHBUTTON, CRect(0, 0, 100, 100), this, 123);</span></span><br><span class="line"><span class="comment">//  m_btn.ShowWindow(SW_SHOWNORMAL);//窗口显示</span></span><br><span class="line"></span><br><span class="line">  m_btn.Create(_T(<span class="string">&quot;button&quot;</span>), WS_CHILD | BS_DEFPUSHBUTTON |WS_VISIBLE , CRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>), this, <span class="number">123</span>);</span><br><span class="line"><span class="comment">//  m_btn.Create(_T(&quot;button&quot;), WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON, CRect(0, 0, 100, 100), GetParent(), 123);</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">  &quot;按钮&quot;：名称； CRect(0,0,100,100)：矩形区域； 123：ID号。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  WS_CHILD（窗口风格）:The window is a child window. A window with this style cannot have a menu bar.</span></span><br><span class="line"><span class="comment">  BS_DEFPUSHBUTTON（按钮风格）:下按按钮风格</span></span><br><span class="line"><span class="comment">  WS_VISIBLE:The window is initially visible.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  this指针（代表对象本身）</span></span><br><span class="line"><span class="comment">  GetParent():Call this function to get a pointer to a child window&#x27;s parent window</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  C2664  “BOOL CButton::Create(LPCTSTR,DWORD,const RECT &amp;,CWnd *,UINT)”: 无法将参数 1 从“const char [7]”转换为“LPCTSTR”  test  E:\VCProject\Lesson3\test\test\MainFrm.cpp  68</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  解决方法：</span></span><br><span class="line"><span class="comment">  方法1、&quot;button&quot;改为_T(&quot;button&quot;)[2]</span></span><br><span class="line"><span class="comment">  方法2、调试&gt;&gt;XXX调试属性&gt;&gt;配置属性&gt;&gt;高级&gt;&gt;高级属性&gt;&gt;字符集，改为：使用多字节字符集[3]</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708745412623-e486145b-9b48-4a8b-ba6e-f207c4956bfd.jpeg#averageHue=%23f9f9f8&clientId=u36ddef60-4b23-4&from=paste&height=342&id=u66b53f0d&originHeight=373&originWidth=478&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=21537&status=done&style=none&taskId=ue47d26be-ba4d-42d3-836f-addde49943d&title=&width=438.1666666666667" alt="屏幕截图 2021-06-29 103602(1).jpg"></p>
<h2 id="问题及反思-1"><a href="#问题及反思-1" class="headerlink" title="问题及反思"></a>问题及反思</h2><p>[1]如何利用vs2019创建MFC应用见参考文献[1]</p>
<p>[2]C2664	“BOOL CButton::Create(LPCTSTR,DWORD,const RECT &amp;,CWnd *,UINT)”: 无法将参数 1 从“const char [7]”转换为“LPCTSTR”<br>解决方法：<br>方法1、”button”改为_T(“button”)<br>方法2、调试&gt;&gt;XXX调试属性&gt;&gt;配置属性&gt;&gt;高级&gt;&gt;高级属性&gt;&gt;字符集，改为：使用多字节字符集</p>
<p>[3]vs2019为一个类添加某函数的方法如下所示。第四步单击最右侧向下小三角，选择Add  OnCreate。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708745424131-528c1482-9393-43d1-b507-4772e7c31b8c.jpeg#averageHue=%23e6ecec&clientId=u36ddef60-4b23-4&from=paste&height=828&id=uf058e09c&originHeight=903&originWidth=332&originalType=binary&ratio=1.0909090909090908&rotation=0&showTitle=false&size=106972&status=done&style=none&taskId=u4ea5f69f-e3b6-422b-9d3a-28dade09475&title=&width=304.33333333333337" alt="屏幕截图 2021-06-29 103208.jpg"></p>
<h2 id="参考文献-2"><a href="#参考文献-2" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] &lt;<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37062716/article/details/113827243?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">https://blog.csdn.net/m0_37062716&#x2F;article&#x2F;details&#x2F;113827243?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source&#x3D;distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control</a> &gt;.安装MFC,创建MFC工程文件</p>
<p>[2]&lt;<a target="_blank" rel="noopener" href="https://blog.csdn.net/huijie4728/article/details/50487315">https://blog.csdn.net/huijie4728/article/details/50487315</a>&gt; . 问题及反思[2]</p>
<p>[3]&lt;<a target="_blank" rel="noopener" href="https://blog.csdn.net/feilong911hao/article/details/39231533?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">https://blog.csdn.net/feilong911hao/article/details/39231533?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source&#x3D;distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control</a>&gt; . 问题及反思[2]</p>
<p>[4]孙鑫.VC++深度详解修订版[M]. 北京:电子工业出版社, 2012. 63-99.</p>
<hr>
<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="4-1-MFC消息映射机制"><a href="#4-1-MFC消息映射机制" class="headerlink" title="4.1 MFC消息映射机制"></a>4.1 MFC消息映射机制</h2><h3 id="4-1-1-classwizard"><a href="#4-1-1-classwizard" class="headerlink" title="4.1.1 classwizard"></a>4.1.1 classwizard</h3><p>所有操作，包括鼠标点击鼠标移动等操作都只能由视类窗口捕获。因为视类窗口在框架窗口之上，如果在框架窗口操作。就会被视类窗口覆盖而看不见了。</p>
<p>删除通过向导添加的消息响应函数时，应在向导中删除。</p>
<h3 id="4-1-2-消息映射机制"><a href="#4-1-2-消息映射机制" class="headerlink" title="4.1.2 消息映射机制"></a>4.1.2 消息映射机制</h3><p>一个MFC消息响应函数在程序中有3处相关信息：</p>
<p>1、消息响应函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*drawView.h*/</span></span><br><span class="line"><span class="comment">// 生成的消息映射函数</span></span><br><span class="line">protected:</span><br><span class="line">  DECLARE_MESSAGE_MAP()</span><br><span class="line">public:</span><br><span class="line">  afx_msg <span class="type">void</span> <span class="title function_">OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span>;</span><br></pre></td></tr></table></figure>

<p>2、消息映射宏</p>
<p>消息映射宏ON_WM_LBUTTONDOWN()的作用：把消息(WM_LBUTTONDOWN)与消息响应函数(OnLButtonDown)关联起来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN_MESSAGE_MAP(CdrawView, CView)</span><br><span class="line">  <span class="comment">// 标准打印命令</span></span><br><span class="line">  ON_COMMAND(ID_FILE_PRINT, &amp;CView::OnFilePrint)</span><br><span class="line">  ON_COMMAND(ID_FILE_PRINT_DIRECT, &amp;CView::OnFilePrint)</span><br><span class="line">  ON_COMMAND(ID_FILE_PRINT_PREVIEW, &amp;CView::OnFilePrintPreview)</span><br><span class="line">  ON_WM_LBUTTONDOWN()</span><br><span class="line">END_MESSAGE_MAP()</span><br></pre></td></tr></table></figure>

<p>3、消息响应函数的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*drawView.cpp*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">  MessageBox(<span class="string">&quot;click down&quot;</span>);</span><br><span class="line">  CView::OnLButtonDown(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MFC消息映射方式的具体实现：在每个能接受和处理消息的类中，定义一个消息和消息函数静态对照表，即消息映射表。<strong>在消息映射表中，消息和对应的消息处理函数指针成对出现。</strong>某个类能处理的所有信息及其对应的消息处理函数地址都列在这个类对应的静态表中。当有消息需要处理时，程序只能搜索该消息静态表，查看表中是否含有该消息，就知道该类能否处理此消息。如果能处理，则同样依照静态表能很容易找到并调用对应的消息处理函数。</p>
<h2 id="4-2-绘制线条"><a href="#4-2-绘制线条" class="headerlink" title="4.2 绘制线条"></a>4.2 绘制线条</h2><p>在基类中添加成员变量的原因：可以一直存在；而在子类中，程序运行到右}，变量的生命周期就结束了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CdrawView</span> :</span> public CView&#123;...</span><br><span class="line">private:</span><br><span class="line">  CPoint m_ptOrigin;</span><br><span class="line">  ...&#125;;</span><br></pre></td></tr></table></figure>

<p>在构造函数中将m_ptOrigin赋0以初始化后，在消息响应函数中将鼠标按下的信息保存到基类的成员变量m_ptOrigin中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;<span class="comment">//CPoint point接收按下鼠标左键的位置</span></span><br><span class="line">  m_ptOrigin = point;</span><br><span class="line">  <span class="comment">/*保存该位置到基类的成员变量；</span></span><br><span class="line"><span class="comment">  **当前的鼠标坐标也就是划线的起点坐标。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  CView::OnLButtonDown(nFlags, point);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最后添加WM_LButtonUp.</p>
<h3 id="4-2-1-利用SDK全局函数实现划线功能"><a href="#4-2-1-利用SDK全局函数实现划线功能" class="headerlink" title="4.2.1 利用SDK全局函数实现划线功能"></a>4.2.1 利用SDK全局函数实现划线功能</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体实现如下：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 获取设备描述表</span></span><br><span class="line">  HDC hdc;</span><br><span class="line">  hdc = ::GetDC(m_hWnd);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//移动到线条的起点</span></span><br><span class="line">  MoveToEx(hdc , m_ptOrigin.x , m_ptOrigin.y , <span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//划线</span></span><br><span class="line">  LineTo(hdc , point.x , point.y );</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//释放设备描述表</span></span><br><span class="line">  ::ReleaseDC(m_hWnd , hdc);</span><br><span class="line"></span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699693442-7e86c413-92a8-470b-a890-5b28d08cdf89.png#averageHue=%23fcfbfb&id=YgJFN&originHeight=739&originWidth=795&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=%E5%9B%BE4.1%20%E5%88%A9%E7%94%A8SDK%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%88%92%E7%BA%BF%E5%8A%9F%E8%83%BD"></p>
<p>1、获取设备描述表(平台SDK的GetDC)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字典</span></span><br><span class="line"><span class="comment">//平台SDK的GetDC</span></span><br><span class="line">HDC <span class="title function_">GetDC</span><span class="params">(</span></span><br><span class="line"><span class="params">  HWND hWnd</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//本例</span></span><br><span class="line">HDC hdc;<span class="comment">//HDC:A handle to a device context (DC).</span></span><br><span class="line"><span class="comment">/*device context (DC):There are four types of DCs: display, </span></span><br><span class="line"><span class="comment">printer, memory (or compatible), and information. </span></span><br><span class="line"><span class="comment">Each type serves a specific purpose*/</span></span><br><span class="line"></span><br><span class="line">hdc = ::GetDC(m_hWnd);</span><br><span class="line"><span class="comment">/*用自己的话说（暂时的理解是），HWND hWnd就是当前窗口，HDC hdc就是用来画画的，</span></span><br><span class="line"><span class="comment">GetDC()就是把当前窗口中用来画画的一部分（DC）取出来赋给hdc变量,</span></span><br><span class="line"><span class="comment">意思是接下来的画的东西都会保存在hdc上，也就是保存在了hWnd当前窗口的DC上</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//注意最后释放 </span></span><br><span class="line">::ReleaseDC(m_hWnd , hdc);<span class="comment">//将m_hWnd窗口的hdc释放</span></span><br></pre></td></tr></table></figure>

<p>2、鼠标移动到线条的起点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">MoveToEx</span><span class="params">(</span></span><br><span class="line"><span class="params">  HDC     hdc, <span class="comment">//设备描述表句柄</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span>     x,</span></span><br><span class="line"><span class="params">  <span class="type">int</span>     y, <span class="comment">//起点坐标</span></span></span><br><span class="line"><span class="params">  LPPOINT lppt <span class="comment">//指向point结构体的指针，保存移动操作前鼠标的位置坐标</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">MoveToEx(hdc , m_ptOrigin.x , m_ptOrigin.y , <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>3、划线</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">LineTo</span><span class="params">(</span></span><br><span class="line"><span class="params">  HDC hdc,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> x,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> y<span class="comment">//终点坐标</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">LineTo(hdc , point.x , point.y );</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-利用MFC的CDC类实现画图功能"><a href="#4-2-2-利用MFC的CDC类实现画图功能" class="headerlink" title="4.2.2 利用MFC的CDC类实现画图功能"></a>4.2.2 利用MFC的CDC类实现画图功能</h3><p>MFC为我们提供了一个设备描述表的封装类CDC，该类封装了所有绘图操作。该类中的数据成员m_hDC保存与CDC类相关的DC句柄，因此不需要DC句柄作为参数，其作用类似m_hWnd。而平台SDK提供的全局TextOut()则不然。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  CDC* pDC = GetDC(); <span class="comment">//此处的GetDC是CWnd()的而不是平台SDK的。</span></span><br><span class="line">  pDC-&gt;MoveTo(m_ptOrigin);<span class="comment">//从什么位置</span></span><br><span class="line">  <span class="comment">/*pDC是指向CDC类的指针，MoveTo()是CDC类的函数，所以用指向符-&gt;*/</span></span><br><span class="line">  <span class="comment">/*如果是CDC类的对象的话就用“.”号*/</span></span><br><span class="line">  pDC-&gt;LineTo(point);<span class="comment">//画线到什么位置</span></span><br><span class="line">  ReleaseDC(pDC);</span><br><span class="line"></span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的GetDC是CWnd()的而不是平台SDK的。对比4.2.1的GetDC</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字典</span></span><br><span class="line">CWnd::GetDC </span><br><span class="line">CDC* <span class="title function_">GetDC</span><span class="params">( )</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-3-利用MFC的CClientDC类实现画图功能"><a href="#4-2-3-利用MFC的CClientDC类实现画图功能" class="headerlink" title="4.2.3 利用MFC的CClientDC类实现画图功能"></a>4.2.3 利用MFC的CClientDC类实现画图功能</h3><p>CClientDC类派生于CDC类，并在构造函数时<strong>自动调用GetDC和ReleaseDC</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  CClientDC <span class="title function_">dc</span><span class="params">(this)</span>;</span><br><span class="line"><span class="comment">/*CClientDC dc(CWnd* pWnd);</span></span><br><span class="line"><span class="comment">**CWnd* pWnd是指向窗口的指针，此处需要指向视类窗口对象，即CdrawView。</span></span><br><span class="line"><span class="comment">**在CdrawView::OnLButtonUp(...)中使用this指向CdrawView自己。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*DetParent()返回父类窗口的指针*/</span></span><br><span class="line"></span><br><span class="line">  dc.MoveTo(m_ptOrigin);</span><br><span class="line">  dc.LineTo(point);</span><br><span class="line"><span class="comment">/*这里CClientDC类型的变量dc是一个对象，因此使用点操作符来调用该对象的函数；</span></span><br><span class="line"><span class="comment">**4.2.2中，pDC是指向CDC类的指针，MoveTo()是CDC类的函数，所以用指向符-&gt;  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  </span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-4-利用MFC的CWindowDC类实现画图功能"><a href="#4-2-4-利用MFC的CWindowDC类实现画图功能" class="headerlink" title="4.2.4 利用MFC的CWindowDC类实现画图功能"></a>4.2.4 利用MFC的CWindowDC类实现画图功能</h3><p>CWindowDC类派生于CDC类，并在构造函数时<strong>自动调用GetDC和ReleaseDC</strong>，调用方式与CClientDC一样。</p>
<p>不同于CClientDC的是，CWindowDC可以访问整个窗口区域，包括框架窗口的客户区（菜单栏以下）和非客户区（标题栏和菜单栏）；而CClientDC最多只能到客户区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  CWindowDC <span class="title function_">dc</span><span class="params">(GetDesktopWindow())</span>;<span class="comment">//整个桌面窗口</span></span><br><span class="line">  <span class="comment">//CWindowDC dc(GetParent());//框架窗口，包括客户区和非客户区</span></span><br><span class="line">  <span class="comment">//CWindowDC dc(this);//视类窗口</span></span><br><span class="line">  dc.MoveTo(m_ptOrigin);</span><br><span class="line">  dc.LineTo(point);</span><br><span class="line">  </span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-5-在桌面窗口划线"><a href="#4-2-5-在桌面窗口划线" class="headerlink" title="4.2.5 在桌面窗口划线"></a>4.2.5 在桌面窗口划线</h3><p>见4.2.4。</p>
<h3 id="4-2-6-绘制线条色彩"><a href="#4-2-6-绘制线条色彩" class="headerlink" title="4.2.6 绘制线条色彩"></a>4.2.6 绘制线条色彩</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  CPen <span class="title function_">pen</span><span class="params">(PS_SOLID, <span class="number">1</span>, RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span>;</span><br><span class="line">  CClientDC <span class="title function_">dc</span><span class="params">(this)</span>;</span><br><span class="line">  <span class="comment">//只创建CPen不会生效，还要将其选入设备描述表</span></span><br><span class="line">  CPen* pOldPen = dc.SelectObject(&amp;pen);</span><br><span class="line">  dc.MoveTo(m_ptOrigin);</span><br><span class="line">  dc.LineTo(point);</span><br><span class="line">  <span class="comment">//还原设备描述表</span></span><br><span class="line">  dc.SelectObject(pOldPen);</span><br><span class="line"></span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699693561-d4db98aa-a5a0-4a80-a00b-5c6d2afdc349.png#averageHue=%23fbfafa&id=wcueU&originHeight=599&originWidth=715&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%9B%BE4.2%20%E7%BB%98%E5%88%B6%E5%BD%A9%E8%89%B2%E7%BA%BF%E6%9D%A1" alt="图4.2 绘制彩色线条" title="图4.2 绘制彩色线条"></p>
<p>1、Cpen类创建画笔对象，该类封装了画笔的相关操作</p>
<p><code>CPen (int nPenStyle , int Width , COLORREF crColor);</code></p>
<p>三个参数分别代表线形、线宽和颜色。</p>
<p>颜色用RGB(r,g,b)表示，每个参数都是0~255之间。黑色全0，白色全255.</p>
<p>2、在程序中构造GDI对象后,该对象不会立即生效，必须**(作用1)选入设备描述表<strong>后，才会生效。<code>SelectObject()</code>函数除了实现以上操作，还会</strong>(作用2)返回指向先前被选中对象的指针**，以在完成绘画后，还原设备描述表。</p>
<p>小结：需要使用<code>SelectObject()</code>选入设备描述表：CPen类、Rectangle函数</p>
<h2 id="4-3-画刷"><a href="#4-3-画刷" class="headerlink" title="4.3 画刷"></a>4.3 画刷</h2><h3 id="4-3-1-简单画刷"><a href="#4-3-1-简单画刷" class="headerlink" title="4.3.1 简单画刷"></a>4.3.1 简单画刷</h3><p>利用CBrush类创建画刷对象，以填充一块区域。</p>
<p><code>CBrush(COLORREF crColor )</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  CBrush <span class="title function_">brush</span><span class="params">(RGB(<span class="number">255</span> , <span class="number">0</span>, <span class="number">0</span>))</span>;<span class="comment">//创建红色画刷</span></span><br><span class="line">  CClientDC <span class="title function_">dc</span><span class="params">(this)</span>;<span class="comment">//创建并获取设备描述表</span></span><br><span class="line">  <span class="comment">//利用红色画刷填充鼠标拖拽过程中产生的矩形区域</span></span><br><span class="line">  dc.FillRect(CRect(m_ptOrigin, point), &amp;brush);</span><br><span class="line">  </span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699693661-4f28b577-50a3-4725-89ab-c8820f6d5111.png#averageHue=%23fbc6c6&id=iUBHB&originHeight=560&originWidth=635&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%9B%BE4.3%20%E7%BA%A2%E8%89%B2%E7%AE%80%E5%8D%95%E7%94%BB%E5%88%B7" alt="图4.3 红色简单画刷" title="图4.3 红色简单画刷"></p>
<p>1、FillRect函数：利用画刷填充鼠标拖拽过程中产生的矩形区域，包括左边和上部边界，不填充右边和底部边界。</p>
<p><code>void FillRect( LPCRECT lpRect, CBrush* pBrush );</code></p>
<p>1、<code>lpRect</code>：指向一个RECT结构体或CRect对象指针。本例使用CRect()函数,即   <code>CRect( POINT topLeft, POINT bottomRight );</code>第一个参数是左上角点，第二个参数是右下角点，以确定一个矩形。</p>
<p>2、<code>pBrush</code>：指向用于填充矩形的画刷对象的指针。</p>
<h3 id="4-3-2-位图画刷"><a href="#4-3-2-位图画刷" class="headerlink" title="4.3.2 位图画刷"></a>4.3.2 位图画刷</h3><p>CBrush类中有如下构造函数：<code>CBrush (CBitmap* pBitMap);</code>其中，CBitmap类是位图类。创建CBitmap对象时，仅调用其构造函数，并不能得到有用的位图对象，还需要调用初始化函数来初始化该位图对象。本例中用加载位图的初始化函数：<code>LoadBitmap(UINT nIDResource);</code>。其中，<code>nIDResource</code>是资源ID号，在资源视图中查看，如图4.6所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  CBitmap bitmap;<span class="comment">//创建位图对象</span></span><br><span class="line">  bitmap.LoadBitmap(IDB_BITMAP1);<span class="comment">//初始化位图对象</span></span><br><span class="line">  CBrush <span class="title function_">brush</span><span class="params">(&amp;bitmap)</span>;<span class="comment">//将位图对象装进画刷</span></span><br><span class="line">  CClientDC <span class="title function_">dc</span><span class="params">(this)</span>;<span class="comment">//创建并获取设备描述表</span></span><br><span class="line">  <span class="comment">//用位图填充矩形区域</span></span><br><span class="line">  dc.FillRect(CRect(m_ptOrigin , point) , &amp;brush);</span><br><span class="line"></span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699693762-0fb01846-4578-4426-b142-8da40dd2e4f8.png#averageHue=%23faf8f8&id=rr2t3&originHeight=536&originWidth=540&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%9B%BE4.3%20%E4%BD%8D%E5%9B%BE%E7%94%BB%E5%88%B7%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C" alt="图4.3 位图画刷运行结果" title="图4.3 位图画刷运行结果"></p>
<p>1、位图的创建过程如下所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699693851-c49376bd-9887-41db-bba3-2b217dc2c643.png#averageHue=%2327323b&id=INXoX&originHeight=530&originWidth=331&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/image/image%20(1)_4EcJoeM6pn.png"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699693954-5da557da-f305-4d56-a5a7-991b455a66e0.png#averageHue=%23f2f1f0&id=O9tW0&originHeight=391&originWidth=541&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%9B%BE4.5%20%E4%BD%8D%E5%9B%BE%E7%9A%84%E5%88%9B%E5%BB%BA" alt="图4.5 位图的创建" title="图4.5 位图的创建"></p>
<p>2、资源ID在资源视图中查看</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699694042-c77a2d2d-6dc5-466f-808f-d8b111e18588.png#averageHue=%23242c33&id=BXuvi&originHeight=525&originWidth=330&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%9B%BE4.6%20%E6%9F%A5%E7%9C%8B%E8%B5%84%E6%BA%90ID" alt="图4.6 查看资源ID" title="图4.6 查看资源ID"></p>
<h3 id="4-3-3-透明画刷"><a href="#4-3-3-透明画刷" class="headerlink" title="4.3.3 透明画刷"></a>4.3.3 透明画刷</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  CClientDC <span class="title function_">dc</span><span class="params">(this)</span>;</span><br><span class="line">  <span class="comment">//创建空画刷</span></span><br><span class="line">  CBrush* pBrush = CBrush::FromHandle(</span><br><span class="line">          (HBRUSH) GetStockObject(NULL_BRUSH));</span><br><span class="line">  <span class="comment">//将画刷选入设备描述表</span></span><br><span class="line">  CBrush* pOldBrush = dc.SelectObject(pBrush);</span><br><span class="line">  dc.Rectangle(CRect(m_ptOrigin, point));</span><br><span class="line">  dc.SelectObject(pBrush);</span><br><span class="line"></span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699694153-87275896-fa7e-4ca9-b5ee-29627d1c10e5.png#averageHue=%23f9f8f8&id=aUomT&originHeight=576&originWidth=582&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%9B%BE4.7%20%E9%80%8F%E6%98%8E%E7%94%BB%E5%88%B7" alt="图4.7 透明画刷" title="图4.7 透明画刷"></p>
<p>1、GetStockObject()函数,获取一个黑点或白色的画刷句柄</p>
<p>GetStockObject(NULL_BRUSH);获取一个空画刷</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HGDIOBJ <span class="title function_">GetStockObject</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">int</span> fnObject   <span class="comment">// stock object type</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>再利用强制类型转换，将HGDIOBJ类型转换为HBRUSH类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(HBRUSH) GetStockObject(NULL_BRUSH);</span><br></pre></td></tr></table></figure>

<p>2、FromHandle()函数将画刷句柄转化为画刷对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> CBrush* PASCAL <span class="title function_">FromHandle</span><span class="params">( HBRUSH hBrush )</span>;</span><br><span class="line"><span class="comment">/*Parameters(参数)</span></span><br><span class="line"><span class="comment">hBrush </span></span><br><span class="line"><span class="comment">Specifies the HANDLE to a Windows CE GDI brush. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Return Value</span></span><br><span class="line"><span class="comment">A pointer to a CBrush object if successful; otherwise, it is NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="static静态成员函数"><a href="#static静态成员函数" class="headerlink" title="static静态成员函数"></a><strong>static静态成员函数</strong></h4><p><strong>P126</strong></p>
<p>(1)<strong>静态成员</strong>函数和静态成员变量<strong>属于类本身</strong>，而不属于某一个变量，<strong>在类加载的时候，既为他们分配了空间</strong>，所以可以通过<strong>类名::函数名</strong>或<strong>类名:变量名</strong>来访问。而非静态成员函数和非静态成员变量属于对象的方法和数据，即应先产生类的对象，再通过类的对象去引用。</p>
<p>(2)<strong>在静态成员函数中是不能调用非静态成员的</strong>，包括非静态成员函数和非静态成员变量；静态成员函数<strong>只能访问静态成员变量</strong>。而<strong>非静态成员函数中是可以调用静态成员函数的</strong>。</p>
<p>(1)和(2)小结：也就是说，无论采用什么样的操作，代码都是在内存中运行的。<strong>程序只有在内存中占有一席之地，才能够访问它。</strong></p>
<p>(3)对于静态成员变量，必须对其<strong>初始化</strong>，并且应<strong>在类的定义之外</strong>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>;<span class="comment">//静态成员函数</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;x = &quot;</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> x;<span class="comment">//静态成员变量</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Point::x = <span class="number">0</span>;<span class="comment">//知识点(3)：1初始化2在类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Point::init();<span class="comment">//知识点(1)：用类名::函数名来直接调用</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果输出x = 0*/</span></span><br></pre></td></tr></table></figure>

<h2 id="4-4-绘制连续线条"><a href="#4-4-绘制连续线条" class="headerlink" title="4.4 绘制连续线条"></a>4.4 绘制连续线条</h2><p>为捕获鼠标移动过程的每一个点，可以通过捕获鼠标移动消息(WM_MouseMove)来实现。只要鼠标在程序窗口中移动，都会进入这个消息响应函数中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*drawView.h*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CdrawView</span> :</span> public CView</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">private:</span><br><span class="line">  BOOL m_bdraw;<span class="comment">//判断鼠标左键是否按下去，按下为真，否则为假</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*drawView.cpp*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  m_ptOrigin = point;</span><br><span class="line">  m_bdraw = <span class="number">1</span>;</span><br><span class="line">  CView::OnLButtonDown(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  m_bdraw = <span class="number">0</span>;</span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnMouseMove</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  CClientDC <span class="title function_">dc</span><span class="params">(this)</span>;</span><br><span class="line">  CPen <span class="title function_">pen</span><span class="params">(PS_SOLID , <span class="number">1</span> , RGB(<span class="number">255</span> , <span class="number">0</span> , <span class="number">0</span>))</span>;</span><br><span class="line">  CPen* pOldPen = dc.SelectObject(&amp;pen);</span><br><span class="line">  <span class="keyword">if</span> (m_bdraw == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    dc.MoveTo(m_ptOrigin);<span class="comment">//第一次左键按下</span></span><br><span class="line">    dc.LineTo(point);<span class="comment">//将起点与终点连线</span></span><br><span class="line">    m_ptOrigin = point;</span><br><span class="line">    <span class="comment">/*绘制完当前线段后，立即将上一段的终点位置赋给下一段的起点*/</span></span><br><span class="line">    dc.SelectObject(pOldPen);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CView::OnMouseMove(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699694251-1d815638-0a60-4b88-8631-f5a14aa2f72d.png#averageHue=%23faf9f9&id=TvaSY&originHeight=520&originWidth=430&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%9B%BE4.8%20%E8%BF%9E%E7%BB%AD%E7%BB%98%E5%9B%BE%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C" alt="图4.8 连续绘图运行结果" title="图4.8 连续绘图运行结果"></p>
<h2 id="4-5-绘制扇形效果线条"><a href="#4-5-绘制扇形效果线条" class="headerlink" title="4.5 绘制扇形效果线条"></a>4.5 绘制扇形效果线条</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnMouseMove</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">    dc.LineTo(m_ptOld);<span class="comment">//表示鼠标移动过程中的连线中，每个极小的线段</span></span><br><span class="line">    <span class="comment">//m_ptOrigin = point;//修改起点信息</span></span><br><span class="line">    m_ptOld = point;<span class="comment">//m_ptOld用于保存鼠标上一个移动点</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699694365-6851228c-add6-4f4f-af6c-410469b8a33f.png#averageHue=%23bfbfbe&id=TH6yB&originHeight=577&originWidth=571&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=%E5%9B%BE4.9%20%E5%B8%A6%E8%BE%B9%E6%89%87%E5%BD%A2" alt="图4.9 带边扇形" title="图4.9 带边扇形"></p>
<h2 id="问题及反思-2"><a href="#问题及反思-2" class="headerlink" title="问题及反思"></a>问题及反思</h2><p>[1]位图创建过程见4.3.2</p>
<h2 id="参考文献-3"><a href="#参考文献-3" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]孙鑫.VC++深度详解修订版[M]. 北京:电子工业出版社, 2012. 100-134.</p>
<hr>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="5-1-插入符"><a href="#5-1-插入符" class="headerlink" title="5.1 插入符"></a>5.1 插入符</h2><h3 id="5-1-1-创建插入符"><a href="#5-1-1-创建插入符" class="headerlink" title="5.1.1 创建插入符"></a>5.1.1 创建插入符</h3><p>在窗口创建之后的WM_CREATE消息响应函数OnCreate中添加创建插入符代码：</p>
<p><code>void CreateSolidCaret(int nWidth , int nHeight);</code>若参数为0，则使用系统定义。</p>
<p>接着，使用<code>ShowCaret();</code>显示插入符。</p>
<p>对于CreateSolidCaret()的两个参数，可以根据<strong>字体度量信息</strong>自动调整插入符：</p>
<p><code>BOOL GetTextMetrics( LPTEXTMATRIC lpMetrics ) const;</code>其中，参数要求一个指向TEXTMETRIC结构体的指针，函数从DC中获取字体度量信息后填充进这个结构体。</p>
<p>经常用到的TEXTMETRIC结构体变量：</p>
<ul>
<li>int tmHeight;   &#x2F;&#x2F;tmAscent+tmDescent</li>
<li>int tmAscent;   &#x2F;&#x2F;升序高度</li>
<li>int tmDescent;   &#x2F;&#x2F;降序高度</li>
<li>int tmAveCharWidth;   &#x2F;&#x2F;平均宽度</li>
<li>int tmMaxCharWidth;   &#x2F;&#x2F;最大字符宽度</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CtextView::OnCreate</span><span class="params">(LPCREATESTRUCT lpCreateStruct)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (CView::OnCreate(lpCreateStruct) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>  在此添加您专用的创建代码</span></span><br><span class="line">  CClientDC <span class="title function_">dc</span><span class="params">(this)</span>;</span><br><span class="line">  TEXTMETRIC tm;</span><br><span class="line">  dc.GetTextMetrics(&amp;tm);</span><br><span class="line">  CreateSolidCaret(tm.tmAveCharWidth / <span class="number">8</span> , tm.tmHeight); <span class="comment">//除以8是经验值</span></span><br><span class="line">  ShowCaret();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//创建插入符</span></span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-创建图形插入符"><a href="#5-1-2-创建图形插入符" class="headerlink" title="5.1.2 创建图形插入符"></a>5.1.2 创建图形插入符</h3><p><code>void CreateCaret(CBitmap* pBitmap);</code>创建图形插入符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CtextView::OnCreate</span><span class="params">(LPCREATESTRUCT lpCreateStruct)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (CView::OnCreate(lpCreateStruct) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>  在此添加您专用的创建代码</span></span><br><span class="line"><span class="comment">//CBitmap对象在基类CView中创建</span></span><br><span class="line">  bitmap.LoadBitmap(IDB_BITMAP1);</span><br><span class="line">  CreateCaret(&amp;bitmap);</span><br><span class="line">  ShowCaret();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//位图插入符</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2-窗口重绘"><a href="#5-2-窗口重绘" class="headerlink" title="5.2 窗口重绘"></a>5.2 窗口重绘</h2><h3 id="5-2-1-OnDraw函数"><a href="#5-2-1-OnDraw函数" class="headerlink" title="5.2.1 OnDraw函数"></a>5.2.1 OnDraw函数</h3><p>窗口重绘时，已输入的文字或图形就会被擦除。如想要保留，则需要WM_PAINT的消息响应函数OnCreate将内容再次输出（重绘）。</p>
<p>字符串类CString,其对象可以当作普通变量赋值、相加。</p>
<p>CDC类封装的TetOut(x,y,str);在指定位置显示字符串。</p>
<h3 id="5-2-2-添加字符串资源"><a href="#5-2-2-添加字符串资源" class="headerlink" title="5.2.2 添加字符串资源"></a>5.2.2 添加字符串资源</h3><p><code>BOOL LoadString(UINT nID);</code></p>
<p>其中，nID为字符串资源标识，如下图所示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699694584-c0c2cce4-27da-4d50-bbb4-57010ae21186.png#averageHue=%23242b32&id=KIzAw&originHeight=515&originWidth=314&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699694920-662b5ee5-3d6e-432d-b91e-06e95eacbc2e.png#averageHue=%23272d32&id=qii1b&originHeight=653&originWidth=565&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CtextView::OnDraw</span><span class="params">(CDC* pDC)</span></span><br><span class="line">&#123;</span><br><span class="line">  CtextDoc* pDc = GetDocument();</span><br><span class="line">  ASSERT_VALID(pDoc);</span><br><span class="line">  <span class="keyword">if</span> (!pDoc)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此处为本机数据添加绘制代码</span></span><br><span class="line">  CString str;</span><br><span class="line">  str = <span class="string">&quot;VC++深入编程&quot;</span>;</span><br><span class="line">  pDC-&gt;TextOut(<span class="number">0</span>,<span class="number">0</span>,str);</span><br><span class="line"></span><br><span class="line">  str.LoadString(IDS_STRINGVC);</span><br><span class="line">  pDC-&gt;TextOut(<span class="number">0</span>,<span class="number">50</span>,str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699695015-c469fe2c-7750-4dd3-98ed-cdaeebd61f94.png#averageHue=%23f6f5f5&id=tWjX9&originHeight=384&originWidth=381&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="5-3-路径层"><a href="#5-3-路径层" class="headerlink" title="5.3 路径层"></a>5.3 路径层</h2><p>1、步骤：</p>
<ol>
<li>打开路径层：BeginPath</li>
<li>利用GDI提供的绘图函数绘图</li>
<li>关闭路径层：EndPath</li>
</ol>
<p>2、<code>CSize GetTextExtent(str)</code>：获取某个特定<strong>字符串的宽度和高度</strong>,返回CSize对象。和GetTextMetrics（字体度量）区分。</p>
<p>3、裁剪区域：可以理解为一个绘图区域，大小可以由我们来控制，以后的绘图操作仅限于这个矩形区域内。</p>
<p>CDC类提供了<code>BOOL SelectClipPath(int nMod);</code>用于把当前设置的路径层和DC中已有的剪裁区域按照一定指定的模式进行一个互操作。</p>
<p>nMod是用于指定互操作的模式，如：</p>
<p>RGN_DIFF：新的剪裁区域包含当前剪裁区域，但排除当前路径层区域。</p>
<p>RGN_AND：剪裁区域和路径层的交集</p>
<p>小结：如果希望整幅图形中的某一部分与其他部分有所区别，就可以把这个部分的图形放置在一个路径层中，然后利用SelectClipPath函数设置一种模式，让路径层和剪裁区域进行互操作以达到一种特殊的效果。</p>
<h2 id="5-4-字符输入"><a href="#5-4-字符输入" class="headerlink" title="5.4 字符输入"></a>5.4 字符输入</h2><p>利用CString类对象可以直接字符输入。</p>
<p>输入字符，就会有WM_CHAR消息，在OnChar消息处理函数中写代码，说明要如何处理该消息。</p>
<p>设置插入符位置函数：CWnd类中的<code>SetCaretPos(POINT point);</code>函数。将插入符移动到鼠标左键单击处。</p>
<p>清除字符可以直接用CString类中的<code>Empty()</code> 来实现。</p>
<p>1、回车处理（ASCII为0x0d）</p>
<p>插入符横坐标不变，纵坐标发生变化：当前插入点的纵坐标加上字体高度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">0x0d</span> == nChar)</span><br><span class="line">&#123;</span><br><span class="line">  m_strLine.Empty();<span class="comment">//清空当前字符串</span></span><br><span class="line">  m_ptOrigin.y += tm.tmHeight;<span class="comment">//移动插入点</span></span><br><span class="line">  dc.TextOut(m_ptOrigin.x , m_ptOrigin.y , m_strLine);<span class="comment">//在新的插入点输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、退格键（ASCII为0x08）</p>
<p>步骤：</p>
<ol>
<li>设置文本颜色为背景色：<code>virtual COLORREF SetTextColor( COLORREF crColor );</code>返回原来的颜色。CDC::<code>GetBkColor()</code>获取背景色。</li>
<li>输出</li>
<li>在字符串变量中删除要删除的文字<code>CString Left( int nCount ) const;</code>其中，nCount指字符串左边指定数目的字符。<code>int GetLength( ) const;</code>获取长度。</li>
<li>还原文字颜色</li>
<li>输出</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">0x08</span> == nChar)</span><br><span class="line">&#123;</span><br><span class="line">  COLORREF clr = dc.SetTextColor(dc.GetBkColor());<span class="comment">//设置文本颜色为背景色</span></span><br><span class="line">  dc.TextOut(m_ptOrigin.x , m_ptOrigin.y , str);<span class="comment">//输出</span></span><br><span class="line">  m_strLine = m_strLine.Left(m_strLine.GetLength() - <span class="number">1</span>);<span class="comment">//在字符串变量中删除要删除的文字</span></span><br><span class="line">  dc.SetTextColor(clr);<span class="comment">//还原文字颜色</span></span><br><span class="line">  dc.TextOut(m_ptOrigin.x , m_ptOrigin.y , m_strLine);<span class="comment">//输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、设置字体</p>
<p>1、创建字体对象；</p>
<p>2、CFont类设置字体</p>
<p><code>BOOL CreatePointFont( int nPointSize, LPCTSTR lpszFaceName, CDC* pDC = NULL );</code></p>
<p>(字体高度，字体名称，NULL)</p>
<p>3、将字体选入DC，SelectObject(CFont *font);</p>
<p>4、字幕变色功能</p>
<p>CDC::DrawText函数 在指定矩形范围内输出文字。</p>
<p><code>int DrawText(const CString&amp; str, LPRECT lpRect, UINT nFormat );</code></p>
<p>（要输出的字符串，文字显示范围的矩形，文本的输出格式）</p>
<p>CWnd::SetTimer函数 定时器函数<br><code>UINT SetTimer( UINT nIDEvent, UINT nElapse, void (CALLBACK EXPORT* lpfnTimer)( HWND, UINT, UINT, DWORD) );</code></p>
<ul>
<li>UINT nIDEvent：非零定时器标识，函数调用成功，则返回标识；</li>
<li>UINT nElapse：以<strong>毫秒</strong>为单位的时间间隔，即每隔多长时间发送一次定时器消息<strong>WM_TIMER</strong>。程序在OnTimer函数中编写。</li>
<li>CALLBACK EXPORT* lpfnTimer：如果设置了该回调函数，则系统调用该回调函数处理消息。如果NULL，则窗口对象CWnd来处理</li>
</ul>
<p>参考文献：<br>[1]孙鑫.VC++深度详解修订版[M]. 北京:电子工业出版社, 2012. 135-161.</p>
<h1 id="第六章-菜单"><a href="#第六章-菜单" class="headerlink" title="第六章 菜单"></a>第六章 菜单</h1><h2 id="一、创建菜单项"><a href="#一、创建菜单项" class="headerlink" title="一、创建菜单项"></a>一、创建菜单项</h2><p>资源管理器→menu项→双击IDR_MAINFRAME打开菜单编辑器</p>
<p>pop-up类型的菜单是弹出式菜单，不能进行命令响应。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/jpg/21452222/1708699500215-bec03e70-374a-43bb-92c2-029a19c87c6f.jpg#averageHue=%23e3e6e4&id=v01Cj&originHeight=1730&originWidth=4262&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>ID号的命名规则：</p>
<p>IDM菜单资源</p>
<p>IDC光标资源</p>
<p>IDI图标资源</p>
<h2 id="二、为菜单项添加响应函数"><a href="#二、为菜单项添加响应函数" class="headerlink" title="二、为菜单项添加响应函数"></a>二、为菜单项添加响应函数</h2><p>打开ClassWizard【类向导】，</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/jpg/21452222/1708699500872-5f67e29b-8676-434b-a466-4f60c3ca8330.jpg#averageHue=%23c8cbc9&id=LhMv0&originHeight=2161&originWidth=3328&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ol>
<li>区别Message中的COMMAND和UPDATE_COMMAND_UI<br>COMMAND处理该菜单对应的<strong>功能</strong>。<br>UPDATE_COMMAND_UI处理菜单应对的<strong>用户界面</strong>。 </li>
<li>菜单项响应顺序：view→doc→mainframe→App </li>
<li>Windows消息的分类<br>1、标准消息：除 WM_COMMAND 之外，<strong>所有以 WM_开头的消息</strong>都是标准消息。<br>CWnd类，都可以接收到这类消息。<br>2、命令消息：来自菜单、加速键或工具栏按钮的消息。这类消息都<strong>以 WM_COMMAND 形式呈现</strong>。<br>在 MFC 中，通过菜单项的标识（ID）来区分不同的命令消息；在 SDK 中，通过消息的wParam 参数识别。从 CCmdTarget 派生的类，都可以接收到这类消息。<br>3、通告消息：由控件产生的消息，例如按钮的单击、列表框的选择等。目的是为了向其父窗口（通常是对话框）通知事件的发生。这类消息也是<strong>以 WM_COMMAND 形式呈现</strong>。从CCmdTarget 派生的类，都可以接收到这类消息。<br>实际上，CWnd 类派生于 CCmdlTarget类。也就是说<strong>凡是从 CWnd 派生的类，它们既可以接收标准消息，也可以接收命令消息和通告消息。而对于那些从 CCmdTarget 派生的类，则只能接收命令消息和通告消息，不能接收标准消息。</strong> </li>
<li>菜单消息响应过程：mainframe类接收消息→view首先处理，若不行→doc→mainframe→App</li>
</ol>
<h2 id="三、基本菜单操作"><a href="#三、基本菜单操作" class="headerlink" title="三、基本菜单操作"></a>三、基本菜单操作</h2><h3 id="1、了解菜单结构"><a href="#1、了解菜单结构" class="headerlink" title="1、了解菜单结构"></a>1、了解菜单结构</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/jpg/21452222/1708699501330-d837189f-b543-4873-949f-be1b606995c2.jpg#averageHue=%23adaea9&id=o2rhw&originHeight=1670&originWidth=2791&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>程序的主菜单属于框架窗口，因此要在框架类的OnCreate中编程。</p>
<h3 id="2、标记菜单"><a href="#2、标记菜单" class="headerlink" title="2、标记菜单"></a>2、标记菜单</h3><p>获取程序菜单栏：CWnd类 <code>CMenu* GetMenu( ) const;</code> </p>
<p>获取子菜单：CMenu类<code>CMenu* GetSubMenu( int nPos ) const;</code>参数是子菜单的索引号,注意分隔栏也占据索引号。</p>
<p>添加或移除标记：CMenu类<code>UINT CheckMenuItem( UINT nIDCheckItem, UINT nCheck );</code></p>
<p> Parameters<br>_nIDCheckItem_：Specifies the menu item to be checked, as determined by <em>nCheck</em>.<br>_nCheck_Specifies ：how to check the menu item and how to determine the position of the item in the menu. The <em>nCheck</em> parameter can be a combination of MF_CHECKED or MF_UNCHECKED with MF_BYPOSITION or MF_BYCOMMAND flags.</p>
<ul>
<li>  MF_BYCOMMAND   指定第一个参数通过ID</li>
<li>  MF_BYPOSITION   指定第一个参数通过索引号</li>
<li>  MF_CHECKED   设置复选标记</li>
<li>  MF_UNCHECKED  移走复选标记</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetMenu()-&gt;GetSubMenu(<span class="number">0</span>)-&gt;CheckMenuItem(<span class="number">0</span>,MF_BYPOSITION | MF_CHECKED);</span><br></pre></td></tr></table></figure>

<h3 id="3、默认菜单项（粗体）"><a href="#3、默认菜单项（粗体）" class="headerlink" title="3、默认菜单项（粗体）"></a>3、默认菜单项（粗体）</h3><p>注意子菜单只能有一个默认菜单项。</p>
<p>CMenu类<code>BOOL SetDefaultItem( UINT uItem, BOOL fByPos = FALSE );</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetMenu()-&gt;GetSubMenu(<span class="number">0</span>)-&gt;SetDefaultItem(<span class="number">2</span>,MF_BYPOSITION);</span><br></pre></td></tr></table></figure>

<h3 id="4、图形标记菜单"><a href="#4、图形标记菜单" class="headerlink" title="4、图形标记菜单"></a>4、图形标记菜单</h3><p>CMenu类：<code>BOOL SetMenuItemBitmaps( UINT nPosition, UINT nFlags, const CBitmap* pBmpUnchecked, const CBitmap* pBmpChecked );</code></p>
<p>pBmpUnchecked是取消选中时的位图；pBmpchecked是选中状态时的位图。</p>
<p>获取系统的信息度量：<code>int GetSystemMetrics( int nIndex);</code>其中，参数用于指定希望获取哪部分的系统信息。SM_CXMENUCHECK和SM_CYMENUCHECK用于获取菜单项标记图形的默认尺寸。</p>
<p>CString类的Format函数类似C中的printf。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CBitmap m_bitmap;<span class="comment">//头文件全局变量</span></span><br><span class="line"></span><br><span class="line">m_bitmap.LoadBitmap(IDB_BITMAP1);</span><br><span class="line">GetMenu()-&gt;GetSubMenu(<span class="number">0</span>)-&gt;SetMenuItemBitmaps(<span class="number">0</span>, MF_BYPOSITION, &amp;m_bitmap, &amp;m_bitmap);</span><br><span class="line"></span><br><span class="line">Ctring str;</span><br><span class="line">str.Format(<span class="string">&quot;x = %d , y = %d&quot;</span>, GetSystemMetrics(SM_CXMENUCHECK), GetSystemMetrics(SM_CYMENUCHECK));</span><br><span class="line">MessageBox(str);</span><br></pre></td></tr></table></figure>

<h3 id="5、禁用菜单项"><a href="#5、禁用菜单项" class="headerlink" title="5、禁用菜单项"></a>5、禁用菜单项</h3><p>CMenu类：<code>UINT EnableMenuItem( UINT nIDEnableItem, UINT nEnable );</code></p>
<p>nEnable：</p>
<p><strong>MF_BYCOMMAND</strong>   Specifies that the parameter gives the command ID of the existing menu item. This is the default.</p>
<p><strong>MF_BYPOSITION</strong>   Specifies that the parameter gives the position of the existing menu item. The first item is at position 0.</p>
<p><strong>MF_DISABLED</strong>   Disables the menu item so that it cannot be selected but does not dim it.</p>
<p><strong>MF_ENABLED</strong>   Enables the menu item so that it can be selected and restores it from its dimmed state.</p>
<p><strong>MF_GRAYED</strong>   Disables the menu item so that it cannot be selected and dims it.</p>
<p>常把<strong>MF_GRAYED</strong>和<strong>MF_DISABLED</strong>放在一起使用。</p>
<p>发现不能正常禁用？</p>
<p>&#x2F;&#x2F; NOTE: m_bAutoMenuEnable is set to FALSE in the constructor of </p>
<p>&#x2F;&#x2F; CMainFrame so no ON_UPDATE_COMMAND_UI or ON_COMMAND handlers are </p>
<p>&#x2F;&#x2F; needed, and CMenu::EnableMenuItem() will work as expected.</p>
<p>即在CMainFrame构造函数中添加m_bAutoMenuEnable &#x3D; FALSE;</p>
<h3 id="6、移除和装载菜单"><a href="#6、移除和装载菜单" class="headerlink" title="6、移除和装载菜单"></a>6、移除和装载菜单</h3><p>CWnd类：<code>BOOL SetMenu( CMenu* pMenu );</code>CMenu* pMenu 指向一个新的菜单对象，若值为NULL，则移除当前菜单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*移除菜单*/</span></span><br><span class="line">SetMenu(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*装载菜单资源*/</span></span><br><span class="line">Cmenu menu;<span class="comment">//1、框架类成员变量2、若是局部变量，结尾一定要加Detach函数</span></span><br><span class="line"></span><br><span class="line">menu.LoadMenu(IDR_MAINFRAME);</span><br><span class="line">SetMenu(&amp;menu);</span><br><span class="line">menu.Detach();<span class="comment">//menu是局部变量的情况，将菜单句柄与菜单对象分离</span></span><br></pre></td></tr></table></figure>

<h2 id="四、MFC菜单命令更新机制"><a href="#四、MFC菜单命令更新机制" class="headerlink" title="四、MFC菜单命令更新机制"></a>四、MFC菜单命令更新机制</h2><p>菜单项状态的维护依赖于CN_UPDATE_COMMAND_UI消息，该消息智能用于菜单项，不能用于永久显示的顶级菜单（即弹出式菜单）。</p>
<p>在BEGIN_MESSAGE_MAP和END_MESSAGE_MAP之间添加宏以捕获消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)<span class="comment">//自动添加的</span></span><br><span class="line">  ON_WM_CREATE()</span><br><span class="line">  ON_UPDATE_COMMAND_UI(ID_FILE_NEW, &amp;CMainFrame::OnUpdateFileNew)</span><br><span class="line">END_MESSAGE_MAP()</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CMainFrame::OnUpdateEditCut</span><span class="params">(CCmdUI* pCmdUI)</span><span class="comment">//消息响应函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令更新用户界面处理程序代码</span></span><br><span class="line">  pCmdUI-&gt;Enable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*CCmdUI类决定一个菜单项是否可以使用(Enable)，是否有标记(SetCheck)，改变菜单项文本(SetText)*/</span></span><br><span class="line"><span class="comment">/*CCmdUI类有成员变量m_nID保存对象ID和m_nIndex保存对象索引*/</span></span><br></pre></td></tr></table></figure>

<p>如果只是利用禁用菜单项，菜单项变灰禁用，但工具栏按钮依然能够使用。而如果使用命令更新机制，则都不能使用。</p>
<h2 id="五、快捷菜单"><a href="#五、快捷菜单" class="headerlink" title="五、快捷菜单"></a>五、快捷菜单</h2><p>（上下文菜单、右键菜单）</p>
<p>为CView类添加一个WM_CONTEXTMENU消息处理函数，当鼠标右键单击窗口时，就会调用该函数。</p>
<p>显示快捷菜单函数：                                                                                                                          <code>BOOL TrackPopupMenu( UINT nFlags, int x, int y, CWnd* pWnd, LPCRECT lpRect = NULL );</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CmenuView::OnContextMenu</span><span class="params">(CWnd* pWnd, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此处添加消息处理程序代码</span></span><br><span class="line">  CMenu popmenu;</span><br><span class="line">  popmenu.LoadMenu(IDR_POPMENU1); <span class="comment">//读取资源</span></span><br><span class="line">  popmenu.GetSubMenu(<span class="number">0</span>)-&gt;TrackPopupMenu(</span><br><span class="line">  TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON, point.x, point.y, this);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TPM_LEFTALIGN定位弹出菜单，使其左侧与 x 指定的坐标对齐。*/</span></span><br></pre></td></tr></table></figure>

<h2 id="六、动态菜单操作"><a href="#六、动态菜单操作" class="headerlink" title="六、动态菜单操作"></a>六、动态菜单操作</h2><h3 id="1、针对子菜单的动态操作"><a href="#1、针对子菜单的动态操作" class="headerlink" title="1、针对子菜单的动态操作"></a>1、针对子菜单的动态操作</h3><p>1、把一个新的子菜单<strong>添加到</strong>菜单栏<strong>末尾</strong>。CMenu类：<code>BOOL AppendMenu ( UINT nFlags, UINT nIDNewItem = 0, LPCTSTR lpszNewItem = NULL);</code></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/jpg/21452222/1708699501561-3f340dfe-030a-4ce0-9471-7406f1b09a3d.jpg#id=IBEb6&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>CMenu类：CreateMenu()创建一个弹出菜单，并与CMenu对象关联</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CMenu m_menu;<span class="comment">//成员变量</span></span><br><span class="line"></span><br><span class="line">m_menu.CreateMenu();</span><br><span class="line">GetMenu()-&gt;AppendMenu(MF_POPUP, (UINT)m_menu.m_hMenu, <span class="string">&quot;TEST&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>2、两个子菜单中间<strong>插入</strong>子菜单。CMenu类：                                                                                     <code>BOOL InsertMenu( UINT nPosition, UINT nFlags, UINT nIDNewItem = 0, LPCTSTR lpszNewItem = NULL );</code></p>
<p>用法类似AppendMenu</p>
<p>3、<strong>删除</strong>子菜单或菜单项。CMenu类：<code>BOOL DeleteMenu( UINT nPosition, UINT nFlags );</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除子菜单</span></span><br><span class="line">  GetMenu()-&gt;DeleteMenu(<span class="number">0</span>,MF_BYPOSITION );</span><br><span class="line"><span class="comment">//删除菜单项</span></span><br><span class="line">GetMenu()-&gt;GetSubMenu(<span class="number">1</span>)-&gt;DeleteMenu(<span class="number">0</span>,MF_BYPOSITION );</span><br></pre></td></tr></table></figure>

<h3 id="2、针对菜单项的动态操作"><a href="#2、针对菜单项的动态操作" class="headerlink" title="2、针对菜单项的动态操作"></a>2、针对菜单项的动态操作</h3><p>1、插入菜单项同样使用AppendMenu和InsertMenu</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m_menu.AppendMenuA(MF_STRING, <span class="number">111</span>, <span class="string">&quot;hello&quot;</span>);<span class="comment">//往弹出菜单TEST中添加菜单项</span></span><br><span class="line">GetMenu()-&gt;GetSubMenu(<span class="number">0</span>)-&gt;AppendMenu(MF_STRING, <span class="number">113</span>, <span class="string">&quot;hello1&quot;</span>);<span class="comment">//往文件子菜单末尾添加菜单项</span></span><br><span class="line">GetMenu()-&gt;GetSubMenu(<span class="number">0</span>)-&gt;InsertMenu(<span class="number">1</span>, MF_BYPOSITION | MF_STRING , <span class="number">112</span> , <span class="string">&quot;VC编程&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3、为-动态添加的菜单项-添加响应函数"><a href="#3、为-动态添加的菜单项-添加响应函数" class="headerlink" title="3、为  动态添加的菜单项  添加响应函数"></a>3、为  动态添加的菜单项  添加响应函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在头文件resource.h中创建菜单资源ID</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IDM_HELLO   111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//源文件中</span></span><br><span class="line">m_menu.AppendMenuA(MF_STRING, IDM_HELLO, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遵循消息映射机制：增加3处代码实现消息响应</span></span><br><span class="line"><span class="comment">//1、在响应这个菜单命令的类中添加响应函数原型，位于声明消息映射宏之上，（第11行所示）</span></span><br><span class="line">protected:</span><br><span class="line">  afx_msg <span class="type">int</span> <span class="title function_">OnCreate</span><span class="params">(LPCREATESTRUCT lpCreateStruct)</span>;</span><br><span class="line">  afx_msg <span class="type">void</span> <span class="title function_">OnHello</span><span class="params">()</span>;</span><br><span class="line">  DECLARE_MESSAGE_MAP()</span><br><span class="line">  </span><br><span class="line"><span class="comment">//2、在源文件的消息映射表中添加消息映射，消息映射宏是ON_COMMAND宏，（第17行所示）</span></span><br><span class="line"><span class="comment">//注意：消息映射表中，代码结尾不加分号</span></span><br><span class="line">BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)</span><br><span class="line">  ON_WM_CREATE()</span><br><span class="line">  ON_COMMAND(IDM_HELLO,OnHello)</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、添加消息响应函数定义</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CMainFrame::OnHello</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  MessageBox(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第七章-对话框（一）"><a href="#第七章-对话框（一）" class="headerlink" title="第七章 对话框（一）"></a>第七章 对话框（一）</h1><h2 id="1、基本知识"><a href="#1、基本知识" class="headerlink" title="1、基本知识"></a>1、基本知识</h2><p>控件：通常作为对话框的子窗口创建</p>
<p>对话框的种类：</p>
<p>模态对话框：对话框显示时，程序暂停执行，直到关闭对话框。</p>
<p>非模态：显示对话框时，可以执行其他任务。</p>
<h2 id="2、创建和显示"><a href="#2、创建和显示" class="headerlink" title="2、创建和显示"></a>2、创建和显示</h2><p>CDialog对话框资源类</p>
<p>1.新建一个MFC类与该对话框关联：双击新建的对话框。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699501922-1462270c-902c-4927-b2f5-081462113f6d.png#id=gUC7t&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>新建对话框资源后有两个按钮，功能一样（关闭对话框），返回值不同。</p>
<p>OK    IDOK    OnOK</p>
<p>Cancel     IDCANCEL     OnCancel</p>
<p>2.<code>**DoDataExchange()**</code>：完成对话框数据的交换和校验。</p>
<p>3.在视类中</p>
<p>**<code>CDialog::DoModal</code>**创建并显示模态对话框</p>
<p>**<code>CDialog::EndDialog</code>**关闭模态对话框</p>
<h2 id="3、创建动态按钮"><a href="#3、创建动态按钮" class="headerlink" title="3、创建动态按钮"></a>3、创建动态按钮</h2><p>1.视类→工具箱→对话框编辑器     创建一个按钮。</p>
<p>2.为该按钮添加功能</p>
<p>类向导→选择该对象对应的BN_CLICKED（按钮被单击的消息）消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">在CTestDlg类添加</span><br><span class="line">private:</span><br><span class="line">  CButton m_btn;<span class="comment">//动态按钮对象</span></span><br><span class="line">  BOOL isbtncreate;<span class="comment">//判断动态按钮是否被创建，在构造函数中初始化为0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CTestDlg::OnClickedBtnAdd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//动态创建按钮</span></span><br><span class="line">  <span class="comment">//static BOOL isbtncreate = 0;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isbtncreate == <span class="number">0</span>)<span class="comment">//判断动态按钮是否被创建,</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//CButton::Create创建按钮</span></span><br><span class="line">    m_btn.Create(_T(<span class="string">&quot;new&quot;</span>), WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON, CRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>), this, <span class="number">123</span>);</span><br><span class="line">    isbtncreate = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_btn.DestroyWindow();<span class="comment">//销毁窗口</span></span><br><span class="line">    isbtncreate = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化变量的两种方法</p>
<p>1.创建成员变量，并在构造函数中初始化；</p>
<p>2.创建静态局部变量同时初始化。</p>
<h2 id="4、对话框控件"><a href="#4、对话框控件" class="headerlink" title="4、对话框控件"></a>4、对话框控件</h2><h3 id="1-静态文本控件"><a href="#1-静态文本控件" class="headerlink" title="1.静态文本控件"></a>1.静态文本控件</h3><p>IDC_STATIC不能响应消息，可通过修改ID来响应消息</p>
<p>**<code>CWnd::GetDlgItem</code>**获取对话框子控件的指针</p>
<p>**<code>CWnd::GetWindowText</code>**获取窗口文本</p>
<p>**<code>CWnd::SetWindowText</code>**设置窗口文本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CTestDlg::OnClickedNumber1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">  CString str;</span><br><span class="line">  <span class="keyword">if</span> (GetDlgItem(IDC_NUMBER1)-&gt;GetWindowText(str),str == <span class="string">&quot;数值1&quot;</span>)</span><br><span class="line">  <span class="comment">//逗号表达式，返回最后一个表达式的值</span></span><br><span class="line">  &#123;</span><br><span class="line">    GetDlgItem(IDC_NUMBER1)-&gt;SetWindowText(<span class="string">&quot;Number1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    GetDlgItem(IDC_NUMBER1)-&gt;SetWindowText(<span class="string">&quot;数值1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在属性中选中通知（Notify）选项，否则不能向其父窗口发送鼠标事件。</p>
<h3 id="2-编辑框控件"><a href="#2-编辑框控件" class="headerlink" title="2.编辑框控件"></a>2.编辑框控件</h3><p>🌟GetDlgItem()获取编辑框框窗口对象的指针</p>
<p>1.法一：<code>**GetDlgItem→Get(Set)WindowText**</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CTestDlg::OnClickedBtnAdd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//编辑框控件法一：  CWnd::GetDlgItem()-&gt;Get(Set)WindowText();获取(设置)指定窗口文本</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> num1, num2, num3;</span><br><span class="line">  <span class="type">char</span> ch1[<span class="number">10</span>], ch2[<span class="number">10</span>], ch3[<span class="number">10</span>];</span><br><span class="line">  </span><br><span class="line">  GetDlgItem(IDC_EDIT1)-&gt;GetWindowText(ch1, <span class="number">10</span>);<span class="comment">//(指向存放字符串内存的指针，最大字符数目)</span></span><br><span class="line">  GetDlgItem(IDC_EDIT2)-&gt;GetWindowText(ch2, <span class="number">10</span>);</span><br><span class="line">  num1 = atoi(ch1);<span class="comment">//atoi字符串-&gt;数值</span></span><br><span class="line">  num2 = atoi(ch2);</span><br><span class="line">  num3 = num1 + num2;</span><br><span class="line">  _itoa_s(num3, ch3, <span class="number">10</span>);<span class="comment">//itoa数值-&gt;字符串，这里的10代表10进制</span></span><br><span class="line">  GetDlgItem(IDC_EDIT3)-&gt;SetWindowText(ch3);<span class="comment">//将ch3中的字符串显示在编辑框中</span></span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>2.法二：<code>**Get(Set)DlgItemText**</code></p>
<p>&#x3D;GetDlgItem+Get(Set)WindowText</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CTestDlg::OnClickedBtnAdd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//编辑框控件法二：CWnd::Get(Set)DlgItemText()获取指定控件上的文本</span></span><br><span class="line">  <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, num3 = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> ch1[<span class="number">10</span>], ch2[<span class="number">10</span>], ch3[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">  GetDlgItemText(IDC_EDIT1, ch1,<span class="number">10</span>);</span><br><span class="line">  GetDlgItemText(IDC_EDIT2, ch2,<span class="number">10</span>);<span class="comment">//=GetDlgItem + GetWindowText</span></span><br><span class="line">  </span><br><span class="line">  num1 = atoi(ch1);</span><br><span class="line">  num2 = atoi(ch2);</span><br><span class="line">  num3 = num1 + num2;</span><br><span class="line">  _itoa_s(num3, ch3, <span class="number">10</span>);</span><br><span class="line">  </span><br><span class="line">  SetDlgItemText(IDC_EDIT3, ch3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CTestDlg::OnClickedBtnAdd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//编辑框控件法二：CWnd::Get(Set)DlgItemText()获取指定控件上的文本</span></span><br><span class="line">  <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, num3 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//  char ch1[10], ch2[10], ch3[10];</span></span><br><span class="line">  CString str1, str2, str3;</span><br><span class="line">  GetDlgItemText(IDC_EDIT1, str1);</span><br><span class="line">  GetDlgItemText(IDC_EDIT2, str2);</span><br><span class="line">  num1 = atoi(str1);</span><br><span class="line">  num2 = atoi(str2);</span><br><span class="line">  num3 = num1 + num2;</span><br><span class="line"><span class="comment">//  str3 = (CString)num3;</span></span><br><span class="line"><span class="comment">//错误  C2440  “类型强制转换” : 无法从“int”转换为“CString”</span></span><br><span class="line"><span class="comment">//Format是CString类的一个成员函数，它通过格式操作使任意类型的数据转换成一个字符串。</span></span><br><span class="line">  str3.Format(<span class="string">&quot;%d&quot;</span>,num3);</span><br><span class="line">  SetDlgItemText(IDC_EDIT3, str3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.**<code>CWnd::Get(Set)DlgItemInt</code>**返回指定控件的文本并将其转换为一个整数值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CTestDlg::OnClickedBtnAdd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, num3 = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  num1 = GetDlgItemInt(IDC_EDIT1);</span><br><span class="line">  num2 = GetDlgItemInt(IDC_EDIT2);</span><br><span class="line">  num3 = num1 + num2;</span><br><span class="line">  </span><br><span class="line">  SetDlgItemInt(IDC_EDIT3, num3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.控件与整型变量相关联（注意DoDataExchange和UpdateData一起用）</p>
<p>步骤：项目→类向导→成员变量→IDC_EDIT1→添加变量→类别（值）→变量名称→变量类型→其他（最大值、最小值等）</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-08-01%20110502_J5FSHM4WxG.jpg"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-08-01%20114550_mUnOKGHFru.jpg"></p>
<p>系统为我们创建的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*1、头文件定义*/</span></span><br><span class="line">  <span class="comment">// 编辑框与数值变量相关联</span></span><br><span class="line">  <span class="type">int</span> m_num1;</span><br><span class="line">  <span class="type">int</span> m_num2;</span><br><span class="line">  <span class="type">int</span> m_num3;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*2、构造函数初始化*/</span></span><br><span class="line">CTestDlg::CTestDlg(CWnd* pParent <span class="comment">/*=nullptr*/</span>)</span><br><span class="line">  : CDialog(IDD_DIALOG1, pParent)</span><br><span class="line">  <span class="comment">//数值变量初始化</span></span><br><span class="line">  , m_num1(<span class="number">0</span>)</span><br><span class="line">  , m_num2(<span class="number">0</span>)</span><br><span class="line">  , m_num3(<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*3、DoDataExchange将对话框控件与类成员变量相关联，要配合UpDateDate使用*/</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">CTestDlg::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span><br><span class="line">&#123;</span><br><span class="line">  CDialog::DoDataExchange(pDX);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//控件与数值变量关联</span></span><br><span class="line">  DDX_Text(pDX, IDC_EDIT1, m_num1);<span class="comment">//DDX_前缀用于数据交换</span></span><br><span class="line">  DDV_MinMaxInt(pDX, IDC_EDIT1, <span class="number">0</span>, <span class="number">100</span>);<span class="comment">//设定数值范围，DDV_数据校验</span></span><br><span class="line">  DDX_Text(pDX, IDC_EDIT2, m_num2);</span><br><span class="line">  DDX_Text(pDX, IDC_EDIT3, m_num3); </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>自己编写的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">void</span> <span class="title function_">CTestDlg::OnClickedBtnAdd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//法四：控件与数值变量相关联</span></span><br><span class="line"></span><br><span class="line">  UpdateData();<span class="comment">//和DoDataExchange配合使用，参数为TRUE(缺省)：函数获取对话框数据</span></span><br><span class="line">  m_num3 = m_num1 + m_num2;</span><br><span class="line">  UpdateData(FALSE);<span class="comment">//参数为FALSE：以变量的值来初始化对话框控件</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动消息提示框：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-08-01%20114102_eotD0A4Rvf.jpg"></p>
<p>5.控件与控件变量相关联</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">系统自动添加</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*1、头文件定义*/</span></span><br><span class="line">  <span class="comment">//编辑框与控件变量相关联</span></span><br><span class="line">  CEdit m_edit1;</span><br><span class="line">  CEdit m_edit2;</span><br><span class="line">  CEdit m_edit3;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*2、DoDataExchange将对话框控件与类成员变量相关联，要配合UpDateDate使用*/</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">CTestDlg::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span><br><span class="line">&#123;</span><br><span class="line">  CDialog::DoDataExchange(pDX);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//控件与控件变量关联</span></span><br><span class="line">  DDX_Control(pDX, IDC_EDIT1, m_edit1);</span><br><span class="line">  DDX_Control(pDX, IDC_EDIT2, m_edit2);</span><br><span class="line">  DDX_Control(pDX, IDC_EDIT3, m_edit3);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">手动添加</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//法五：控件与控件变量相关联</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, num3 = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> ch1[<span class="number">10</span>], ch2[<span class="number">10</span>], ch3[<span class="number">10</span>];</span><br><span class="line">  </span><br><span class="line">  m_edit1.GetWindowText(ch1, <span class="number">10</span>);</span><br><span class="line">  m_edit2.GetWindowText(ch2, <span class="number">10</span>);</span><br><span class="line">  </span><br><span class="line">  num1 = atoi(ch1);</span><br><span class="line">  num2 = atoi(ch2);</span><br><span class="line">  num3 = num1 + num2;</span><br><span class="line">  _itoa_s(num3, ch3, <span class="number">10</span>);</span><br><span class="line">  </span><br><span class="line">  m_edit3.SetWindowText(ch3);</span><br></pre></td></tr></table></figure>

<p>6.**<code>SendMessage()</code>**发送消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, num3 = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> ch1[<span class="number">10</span>], ch2[<span class="number">10</span>], ch3[<span class="number">10</span>];</span><br><span class="line">  ::SendMessage(GetDlgItem(IDC_EDIT1)-&gt;m_hWnd, WM_GETTEXT, <span class="number">10</span>, (LPARAM)ch1);<span class="comment">//获取编辑框窗口对象的指针</span></span><br><span class="line">  ::SendMessage(m_edit2.m_hWnd, WM_GETTEXT, <span class="number">10</span>, (LPARAM)ch2);<span class="comment">//第一个参数直接利用控件变量获取句柄</span></span><br><span class="line"><span class="comment">//Windows系统中，获取文本的消息是WM_GETTEXT，将系统指定窗口的文本复制到调用者提供的一个缓存中</span></span><br><span class="line"><span class="comment">//wParam指定复制的字符数，lParam保存窗口文本的缓存地址</span></span><br><span class="line"></span><br><span class="line">  num1 = atoi(ch1);</span><br><span class="line">  num2 = atoi(ch2);</span><br><span class="line">  num3 = num1 + num2;</span><br><span class="line">  _itoa_s(num3, ch3, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  m_edit3.SendMessage(WM_SETTEXT, <span class="number">0</span>, (LPARAM)ch3);</span><br><span class="line"><span class="comment">//WM_SETTEXT设置窗口文本的消息，lParam指定设置窗口文本的字符串地址</span></span><br></pre></td></tr></table></figure>

<p>7.**<code>SendDlgItemMessage()</code>**直接给对话框的子控件发送消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法七：</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, num3 = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ch1[<span class="number">10</span>], ch2[<span class="number">10</span>], ch3[<span class="number">10</span>];</span><br><span class="line">SendDlgItemMessage(IDC_EDIT1, WM_GETTEXT, <span class="number">10</span>, (LPARAM)ch1);</span><br><span class="line">SendDlgItemMessage(IDC_EDIT2, WM_GETTEXT, <span class="number">10</span>, (LPARAM)ch2);</span><br><span class="line"></span><br><span class="line">num1 = atoi(ch1);</span><br><span class="line">num2 = atoi(ch2);</span><br><span class="line">num3 = num1 + num2;</span><br><span class="line">_itoa_s(num3, ch3, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">SendDlgItemMessage(IDC_EDIT3, WM_SETTEXT, <span class="number">0</span>, (LPARAM)ch3);</span><br></pre></td></tr></table></figure>

<p>补充：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//设置复选内容</span></span><br><span class="line"> SendDlgItemMessage(IDC_EDIT3, EM_SETSEL, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// EM_GETSEL获得编辑框中的复选内容</span></span><br><span class="line"><span class="comment">//EM_SETSEL设置……，EM表示Edit Control Message</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//wParam接收复选内容开始位置，lParam ……结束位置.</span></span><br><span class="line"><span class="comment">//wParam=0，lParam=-1,表示所有文本</span></span><br><span class="line"> m_edit3.SetFocus();<span class="comment">//设置光标</span></span><br></pre></td></tr></table></figure>

<h2 id="5、对话框的伸缩"><a href="#5、对话框的伸缩" class="headerlink" title="5、对话框的伸缩"></a>5、对话框的伸缩</h2><h1 id="CWnd-SetWindowPos"><a href="#CWnd-SetWindowPos" class="headerlink" title="CWnd::SetWindowPos"></a>CWnd::SetWindowPos</h1><p><strong>BOOL SetWindowPos (const CWnd</strong>* <em>pWndInsertAfter</em>,  <strong>int</strong> <em>x</em>,  <strong>int</strong> <em>y</em>,  <strong>int</strong> <em>cx</em>,  <strong>int</strong> <em>cy</em>,  <strong>UINT</strong> <em>nFlags)&#x2F;&#x2F;</em> 设置窗口位置、大小、z次序等</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/jpg/21452222/1708699502034-14cd3b22-f8c9-45db-9bd8-8452e3a71eed.jpg#id=a13XF&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h1 id="CWnd-GetDlgItem"><a href="#CWnd-GetDlgItem" class="headerlink" title="CWnd::GetDlgItem"></a>CWnd::GetDlgItem</h1><p>This method retrieves a pointer to the specified control or child window in a dialog box or other window. The pointer returned is usually cast to the type of control identified by <em>nID</em>.<br><em>CWnd</em>   GetDlgItem (int* <em>nID</em> <strong>)const;</strong></p>
<h1 id="CWnd-SetDlgItemText"><a href="#CWnd-SetDlgItemText" class="headerlink" title="CWnd::SetDlgItemText"></a>CWnd::SetDlgItemText</h1><p><strong>void SetDlgItemText(int</strong> <em>nID</em><strong>,  LPCTSTR</strong> <em>lpszString);&#x2F;&#x2F;</em> 将nID中的文本设置为_lpszString_ </p>
<h1 id="CWnd-GetWindowRect"><a href="#CWnd-GetWindowRect" class="headerlink" title="CWnd::GetWindowRect"></a>CWnd::GetWindowRect</h1><p><strong>void GetWindowRect(LPRECT</strong> <em>lpRect)const;&#x2F;&#x2F;</em> 获得窗口尺寸</p>
<p>CRect::IsRectNull</p>
<p>CRect::IsRectEmpty</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CTestDlg::OnBnClickedButton1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">  CString str;</span><br><span class="line">  <span class="keyword">if</span> (GetDlgItemText(IDC_BUTTON1,str),str == <span class="string">&quot;收缩&lt;&lt;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    SetDlgItemText(IDC_BUTTON1, <span class="string">&quot;括展&gt;&gt;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    SetDlgItemText(IDC_BUTTON1, <span class="string">&quot;收缩&lt;&lt;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> CRect rectlarge;<span class="comment">//原对话框尺寸</span></span><br><span class="line">  <span class="type">static</span> CRect rectsmall;<span class="comment">//切割后的尺寸</span></span><br><span class="line">  <span class="keyword">if</span> (rectlarge.IsRectNull())<span class="comment">//判断矩形区域是否为空</span></span><br><span class="line">  &#123;</span><br><span class="line">    CRect rectseparator;<span class="comment">//分割线的尺寸</span></span><br><span class="line">    GetDlgItem(IDC_SEPARATOR)-&gt;GetWindowRect(rectseparator);<span class="comment">//获得分割线的尺寸</span></span><br><span class="line">    GetWindowRect(rectlarge);<span class="comment">//获得原对话框的尺寸</span></span><br><span class="line">    rectsmall.top = rectlarge.top;</span><br><span class="line">    rectsmall.left = rectlarge.left;</span><br><span class="line">    rectsmall.right = rectlarge.right;</span><br><span class="line">    rectsmall.bottom = rectseparator.bottom;<span class="comment">//将对话框底部的尺寸更改</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (str == <span class="string">&quot;收缩&lt;&lt;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    SetWindowPos(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, rectsmall.Width(), rectsmall.Height(), SWP_NOMOVE | SWP_NOZORDER);<span class="comment">//设置窗口的位置和大小</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    SetWindowPos(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, rectlarge.Width(), rectlarge.Height(), SWP_NOMOVE | SWP_NOZORDER);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、输入焦点的传递"><a href="#6、输入焦点的传递" class="headerlink" title="6、输入焦点的传递"></a>6、输入焦点的传递</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CTestDlg::OnBnClickedOk</span><span class="params">()</span><span class="comment">//注释掉默认的OnOK</span></span><br><span class="line">&#123;</span><br><span class="line">  GetNextDlgTabItem(GetFocus())-&gt;SetFocus();<span class="comment">//按照TAB顺序循环查找【格式】-&gt;【TAB顺序】</span></span><br><span class="line"><span class="comment">//  CDialog::OnOK();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WNDPROC prevproc;<span class="comment">//窗口过程类型，接收先前的窗口过程。窗口过程函数是全局函数，里面的函数不能再用CWnd的成员函数，只能用API函数</span></span><br><span class="line">LRESULT CALLBACK WinEnterProc<span class="comment">//windowproc函数</span></span><br><span class="line">(</span><br><span class="line">  HWND hwnd,      <span class="comment">// handle to window</span></span><br><span class="line">  UINT uMsg,      <span class="comment">// message identifier</span></span><br><span class="line">  WPARAM wParam,  <span class="comment">// first message parameter</span></span><br><span class="line">  LPARAM lParam   <span class="comment">// second message parameter</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (uMsg == WM_CHAR &amp;&amp; wParam == <span class="number">0x0d</span>)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="comment">//    ::SetFocus(::GetNextWindow(hwnd, GW_HWNDNEXT));</span></span><br><span class="line"><span class="comment">//    ::SetFocus(::GetWindow(hwnd, GW_HWNDNEXT));</span></span><br><span class="line">    ::SetFocus(::GetNextDlgTabItem(::GetParent(hwnd), hwnd, <span class="number">0</span>));<span class="comment">//SetFocus设置焦点，GetFocus得到焦点</span></span><br><span class="line">                                  <span class="comment">//GetNextWindow、GetWindow获得下一个窗口的句柄</span></span><br><span class="line">                                  <span class="comment">//GetNextDlgTabItem按照TAB顺序转移焦点</span></span><br><span class="line"><span class="comment">//    return 1;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//按下的按键不是回车，让先前的窗口过程来处理</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> prevproc(hwnd,uMsg,wParam,lParam);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">CTestDlg::OnInitDialog</span><span class="params">()</span><span class="comment">//对话框及其子控件创建完成将要显示之前调用。虚函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">CDialog::OnInitDialog</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line">  <span class="comment">//SetWindowLong修改指定窗口的属性，本例修改已指定的过程函数</span></span><br><span class="line">  prevproc = (WNDPROC)SetWindowLong(GetDlgItem(IDC_EDIT1)-&gt;m_hWnd, GWL_WNDPROC<span class="comment">/*设置新的窗口过程地址*/</span>, (LONG)WinEnterProc<span class="comment">/*新的窗口过程地址*/</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> TRUE;  <span class="comment">// return TRUE unless you set the focus to a control</span></span><br><span class="line">          <span class="comment">// 异常: OCX 属性页应返回 FALSE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、默认按钮的说明"><a href="#7、默认按钮的说明" class="headerlink" title="7、默认按钮的说明"></a>7、默认按钮的说明</h2><p>收缩按钮设置为默认按钮，即在其属性对话框中选择default button选项，就不会再由CTestDlg类的OnOK函数来响应。<br>当用户按下回车键时，windows将查看对话框中是否存在默认按钮, 如果没有默认按钮，就会调用虚拟的OnOK函数, 即没有默认ok按钮。这个默认OnOK函数的ID是IDOK。而不是IDC_OK.</p>
<h1 id="第八章-对话框2"><a href="#第八章-对话框2" class="headerlink" title="第八章 对话框2"></a>第八章 对话框2</h1><h2 id="1、逃跑按钮"><a href="#1、逃跑按钮" class="headerlink" title="1、逃跑按钮"></a>1、逃跑按钮</h2><p>&#x2F;*逃跑按钮创建过程<br>1、创建新类（专注于逃跑功能）<br>*存储地址的变量<br>*OnMouseMove()<br>2、CTestDlg.h控件与控件变量关联，即创建了新类的对象<br>3、CTestDlg.cpp的OnInitDialog()中两个对象存储对方首地址<br>4、鼠标移动OnMouseMove()接收WM_MOUSEMOVE消息，执行程序<br>*&#x2F;</p>
<h2 id="2、属性表单的创建"><a href="#2、属性表单的创建" class="headerlink" title="2、属性表单的创建"></a>2、属性表单的创建</h2><p>一个属性表单是由一个或多个属性页组成，属性页对应MFC中的CPropertyPage类，一个属性页的标题就是选项卡的名称。</p>
<p>步骤：</p>
<p>1、创建属性页</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-08-06%20102753_TUrnaTOgaJ.jpg"></p>
<p>2、添加控件</p>
<p>组框Group Box</p>
<p>单选按钮Radio Button</p>
<p>复选框Check Box</p>
<p>列表框控件List Box</p>
<p>静态文本控件Static Box</p>
<p>组合框Combo Box</p>
<p>simple，能输入，总是显示列表框</p>
<p>dropdown，能输入只有单击下拉列表后，列表框才弹出</p>
<p>droplist,只读，只能从下来列表选择内容</p>
<p>3、为对话框资源创建新类</p>
<p>1.创建新类步骤：<a target="_blank" rel="noopener" href="https://blog.csdn.net/KJ_Study/article/details/109057281">参考1</a>，在“添加MFC类”中添加类名与ID号一致，基类中选择相应的类型</p>
<p>属性页CPropertyPage</p>
<p>属性表单CPropertySheet</p>
<p>2.在属性表单（CPropSheet）中，创建三个属性页对象，并在构造函数中初始化。用AddPage将属性页添加进属性表单，构造函数指明了2中实例化对象的方法（ID&#x2F;字符串）</p>
<p>CPropSheet::AddPage将属性页添加到属性表单中</p>
<p>OnPropertysheet::DoModal()创建模态属性表单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*定义*/</span></span><br><span class="line">  <span class="comment">//自定义成员变量</span></span><br><span class="line">  PROP1 m_prop1;</span><br><span class="line">  PROP2 m_prop2;</span><br><span class="line">  PROP3 m_prop3;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*初始化*/</span></span><br><span class="line"> CPropSheet::CPropSheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)</span><br><span class="line">  :CPropertySheet(nIDCaption, pParentWnd, iSelectPage)<span class="comment">//用ID号来构造属性表单</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化属性页</span></span><br><span class="line">  AddPage(&amp;m_prop1);<span class="comment">//CPropSheet::AddPage将属性页添加到属性表单中</span></span><br><span class="line">  AddPage(&amp;m_prop2);</span><br><span class="line">  AddPage(&amp;m_prop3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CPropSheet::CPropSheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)</span><br><span class="line">  :CPropertySheet(pszCaption, pParentWnd, iSelectPage)<span class="comment">//用字符串来构造属性表单</span></span><br><span class="line">&#123;</span><br><span class="line">  AddPage(&amp;m_prop1);</span><br><span class="line">  AddPage(&amp;m_prop2);</span><br><span class="line">  AddPage(&amp;m_prop3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.在视类中创建菜单命令响应函数，用字符串实例化属性表单对象，并用DoModal创建模态属性表单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CpropView::OnPropertysheet</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">  CPropSheet <span class="title function_">propsheet</span><span class="params">(<span class="string">&quot;属性表单&quot;</span>)</span>;<span class="comment">//使用字符串构造属性表单对象</span></span><br><span class="line"><span class="comment">//  propsheet.SetWizardMode();//创建向导样式时添加</span></span><br><span class="line">  propsheet.DoModal();<span class="comment">//创建模态属性表单</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、向导的创建"><a href="#3、向导的创建" class="headerlink" title="3、向导的创建"></a>3、向导的创建</h2><p>1、更改向导底部按钮CPropertySheet::SetWizardButtons</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">PROP1::OnSetActive</span><span class="params">()</span><span class="comment">//右键PROP1类-&gt;类向导-&gt;虚函数-&gt;OnSetActive-&gt;编辑代码</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line">  CPropertySheet* psheet = (CPropertySheet*)GetParent();<span class="comment">//属性页的父窗口属性表单，并将CWnd*转换为CPropertySheet*</span></span><br><span class="line">  psheet-&gt;SetWizardButtons(PSWIZB_NEXT);<span class="comment">//CPropertySheet::SetWizardButtons设置对话框上的按钮</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> CPropertyPage::OnSetActive();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROP2,PROP3过程类似，SetWizardButtons参数不同。</span><br></pre></td></tr></table></figure>

<p>1、设置第一个属性页</p>
<p>将第一个单选按钮设置为Group属性以添加成员变量。第一个单选按钮设置为Group后，之后的按钮和这个按钮属于同一组，直到遇到下一个Group。同一组内的控件关联的成员变量的值依次为1、2、3…</p>
<p>单击【下一步】，调用OnWizardNext()虚函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*PROP1.h*/</span></span><br><span class="line">  <span class="type">int</span> m_occupation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*PROP1.cpp*/</span> </span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">PROP1::PROP1()</span><br><span class="line">  : CPropertyPage(IDD_PROP1)</span><br><span class="line">  , m_occupation(<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据交换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PROP1::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span><br><span class="line">&#123;</span><br><span class="line">  CPropertyPage::DoDataExchange(pDX);</span><br><span class="line">  DDX_Radio(pDX, IDC_RADIO1, m_occupation);<span class="comment">//单选按钮和成员变量之间的数据交换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断</span></span><br><span class="line">LRESULT <span class="title function_">PROP1::OnWizardNext</span><span class="params">()</span><span class="comment">//单击【下一步】，调用OnWizardNext()虚函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line">  UpdateData();<span class="comment">//系统通过调用UpdateData()来调用DoDataExchange以完成控件与变量的数据交换</span></span><br><span class="line">               <span class="comment">//TRUE从控件得到成员变量的值。 FAUSE用成员变量的值初始化控件</span></span><br><span class="line">  <span class="keyword">if</span> (m_occupation == <span class="number">-1</span>)<span class="comment">//用户没有选择职业</span></span><br><span class="line">  &#123;</span><br><span class="line">    MessageBox(<span class="string">&quot;请选择职业！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//OnWizardNext()返回0，进入下一个属性</span></span><br><span class="line">              <span class="comment">//返回-1，禁止属性页变更</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (m_workaddress == <span class="string">&quot;&quot;</span> )<span class="comment">//工作地点为空</span></span><br><span class="line">  &#123;</span><br><span class="line">    MessageBox(<span class="string">&quot;请选择工作地点！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> CPropertyPage::OnWizardNext();<span class="comment">//进入下一个页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">PROP1::OnInitDialog</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  CPropertyPage::OnInitDialog();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line">  CListBox* listbox = (CListBox*)GetDlgItem(IDC_LIST1);</span><br><span class="line">  listbox-&gt;AddString(<span class="string">&quot;北京&quot;</span>);<span class="comment">//CListBox::AddString添加字符串到列表框</span></span><br><span class="line">  listbox-&gt;AddString(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line">  listbox-&gt;AddString(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> TRUE;  <span class="comment">// return TRUE unless you set the focus to a control</span></span><br><span class="line">          <span class="comment">// 异常: OCX 属性页应返回 FALSE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、设置第二个属性页</p>
<p>操作类似第一个属性页</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LRESULT <span class="title function_">PROP2::OnWizardNext</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line">  UpdateData();</span><br><span class="line">  <span class="keyword">if</span> (m_football || m_basketball || m_volleyball || m_swim)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> CPropertyPage::OnWizardNext();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    MessageBox(<span class="string">&quot;请选择那你的兴趣爱好！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//返回-1，禁止属性页变更</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、设置第三个属性页</p>
<p>CComboBox::AddString向组合框的列表框中添加字符串选项</p>
<p>CComboBox::SetCurSel选择列表框中的一个字符串，并将其显示在该组合框的编辑框中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">PROP3::OnInitDialog</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  CPropertyPage::OnInitDialog();</span><br><span class="line">  <span class="comment">//组合框控件由一个编辑框和一个列表框组成</span></span><br><span class="line">  <span class="comment">//CComboBox::AddString向组合框的列表框中添加字符串选项</span></span><br><span class="line">  <span class="comment">//CComboBox::SetCurSel(set current selection)选择列表框中的一个字符串，并将其显示在该组合框的编辑框中</span></span><br><span class="line">  CComboBox* combobox = (CComboBox*)GetDlgItem(IDC_COMBO1);</span><br><span class="line">  combobox-&gt;AddString(<span class="string">&quot;1000元以下&quot;</span>);</span><br><span class="line">  combobox-&gt;AddString(<span class="string">&quot;1000元-2000元&quot;</span>);</span><br><span class="line">  combobox-&gt;AddString(<span class="string">&quot;2000元-3000元&quot;</span>);</span><br><span class="line">  combobox-&gt;AddString(<span class="string">&quot;3000元以上&quot;</span>);<span class="comment">//取消属性框中的排序功能以关闭自动排序</span></span><br><span class="line">  combobox-&gt;SetCurSel(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> TRUE;  <span class="comment">// return TRUE unless you set the focus to a control</span></span><br><span class="line">          <span class="comment">// 异常: OCX 属性页应返回 FALSE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CComboBox::GetCurSel得到当前选项的索引值</p>
<p>CComboBox::GetLBText得到对应索引值的文本并存储在字符串中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*提取用户的薪资选项，并存储在m_strsalary中*/</span></span><br><span class="line">BOOL <span class="title function_">PROP3::OnWizardFinish</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line">  <span class="type">int</span> index;</span><br><span class="line">  CComboBox* combobox = (CComboBox*)GetDlgItem(IDC_COMBO1);</span><br><span class="line">  index = combobox -&gt;GetCurSel();<span class="comment">//得到当前选项的索引值</span></span><br><span class="line">  combobox-&gt;GetLBText(index, m_strsalary);<span class="comment">//得到对应索引值的文本并存储在字符串m_strsalary中</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> CPropertyPage::OnWizardFinish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、将结果在视类显示</p>
<p>memset初始化数组</p>
<p>Invalidate();&#x2F;&#x2F;让视类窗口无效，从而引起重绘，然后在OnDraw中完成信息的输</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*propView.h*/</span></span><br><span class="line">  <span class="comment">//自定义成员变量</span></span><br><span class="line">  <span class="type">int</span> m_ioccupation;  <span class="comment">//职业</span></span><br><span class="line">  CString m_strworkaddress;<span class="comment">//工作地点</span></span><br><span class="line">  BOOL m_blike[<span class="number">4</span>];<span class="comment">//爱好</span></span><br><span class="line">  CString m_strsalary;<span class="comment">//薪资水平</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*propView.cpp*/</span></span><br><span class="line">  <span class="comment">//构造函数中初始化</span></span><br><span class="line">CpropView::CpropView() noexcept</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此处添加构造代码</span></span><br><span class="line">  m_ioccupation = <span class="number">-1</span>;  <span class="comment">//职业,对于一个组，未选为-1</span></span><br><span class="line">  m_strworkaddress = <span class="string">&quot;&quot;</span>;<span class="comment">//工作地点</span></span><br><span class="line">  <span class="built_in">memset</span>(m_blike , <span class="number">0</span> , <span class="keyword">sizeof</span>(m_blike));<span class="comment">//爱好,将m_blike内存的sizeof(m_blike)个字节设为0</span></span><br><span class="line">  m_strsalary = <span class="string">&quot;&quot;</span>;<span class="comment">//薪资水平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*一般情况下，CPropertySheet 类的 DoModal 函数的返回值是 IDOK 或 IDCANCEL。</span></span><br><span class="line"><span class="comment">但是如果属性表单已经被创建为向导了,那么该函数的返回值将是 ID_WIZFINISH 或 IDCANCEL.</span></span><br><span class="line"><span class="comment">因此,在程序中应该对属性表单对象的 DoModal 函数的返回值进行判断，</span></span><br><span class="line"><span class="comment">如果返回的是【完成】按钮的 ID:ID_WIZFINISH，那么才进行输出处理。*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CpropView::OnPropertysheet</span><span class="params">()</span><span class="comment">//菜单项响应函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">  CPropSheet <span class="title function_">propsheet</span><span class="params">(<span class="string">&quot;属性表单&quot;</span>)</span>;<span class="comment">//使用字符串构造属性表单对象</span></span><br><span class="line">  propsheet.SetWizardMode();<span class="comment">//设置向导样式</span></span><br><span class="line"><span class="comment">//  propsheet.DoModal();//创建模态属性表单</span></span><br><span class="line">  <span class="keyword">if</span> (ID_WIZFINISH == propsheet.DoModal())<span class="comment">//属性表单被创建向导，DoModal()返回ID_WIZFINISH</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_ioccupation = propsheet.m_prop1.m_occupation;<span class="comment">//向导.属性页.属性页成员</span></span><br><span class="line">    m_strworkaddress = propsheet.m_prop1.m_workaddress;</span><br><span class="line">    m_blike[<span class="number">0</span>] = propsheet.m_prop2.m_football;</span><br><span class="line">    m_blike[<span class="number">1</span>] = propsheet.m_prop2.m_basketball;</span><br><span class="line">    m_blike[<span class="number">2</span>] = propsheet.m_prop2.m_volleyball;</span><br><span class="line">    m_blike[<span class="number">3</span>] = propsheet.m_prop2.m_swim;</span><br><span class="line">    m_strsalary = propsheet.m_prop3.m_strsalary;</span><br><span class="line">    Invalidate();<span class="comment">//让视类窗口无效，从而引起重绘，然后在OnDraw中完成信息的输出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口重绘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CpropView::OnDraw</span><span class="params">(CDC* pDC)</span></span><br><span class="line">&#123;</span><br><span class="line">  CpropDoc* pDoc = GetDocument();</span><br><span class="line">  ASSERT_VALID(pDoc);</span><br><span class="line">  <span class="keyword">if</span> (!pDoc)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此处为本机数据添加绘制代码</span></span><br><span class="line">  CFont font;</span><br><span class="line">  font.CreatePointFont(<span class="number">100</span>, <span class="string">&quot;宋体&quot;</span>,pDC);<span class="comment">//创建字体</span></span><br><span class="line">  CFont* pfont;</span><br><span class="line">  pfont = pDC-&gt;SelectObject(&amp;font);<span class="comment">//将字体选入设备描述表，并保存旧字体</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//职位</span></span><br><span class="line">  CString position;</span><br><span class="line">  position = <span class="string">&quot;你的职业:&quot;</span>;</span><br><span class="line">  <span class="keyword">switch</span> (m_ioccupation)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    position += <span class="string">&quot;程序员&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    position += <span class="string">&quot;系统工程师&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    position += <span class="string">&quot;项目经理&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pDC-&gt;TextOut(<span class="number">0</span>, <span class="number">0</span>, position);<span class="comment">//将文本展示在视类窗口</span></span><br><span class="line"></span><br><span class="line">  TEXTMETRIC tm;</span><br><span class="line">  pDC-&gt;GetTextMetrics(&amp;tm);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//工作地点</span></span><br><span class="line">  CString workplace;</span><br><span class="line">  workplace = <span class="string">&quot;你的工作地点:&quot;</span>;</span><br><span class="line">  workplace += m_strworkaddress;</span><br><span class="line">  pDC-&gt;TextOut(<span class="number">0</span>, tm.tmHeight, workplace);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//兴趣爱好</span></span><br><span class="line">  CString hobby;</span><br><span class="line">  hobby = <span class="string">&quot;你的爱好:&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (m_blike[<span class="number">0</span>])</span><br><span class="line">    hobby += <span class="string">&quot;足球 &quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (m_blike[<span class="number">1</span>])</span><br><span class="line">    hobby += <span class="string">&quot;篮球 &quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (m_blike[<span class="number">2</span>])</span><br><span class="line">    hobby += <span class="string">&quot;排球 &quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (m_blike[<span class="number">3</span>])</span><br><span class="line">    hobby += <span class="string">&quot;游泳 &quot;</span>;</span><br><span class="line">  pDC-&gt;TextOut(<span class="number">0</span>, tm.tmHeight*<span class="number">2</span>, hobby);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//薪资</span></span><br><span class="line">  CString salary;</span><br><span class="line">  salary = <span class="string">&quot;你的薪资水平:&quot;</span>;</span><br><span class="line">  salary += m_strsalary;</span><br><span class="line">  pDC-&gt;TextOut(<span class="number">0</span>, tm.tmHeight*<span class="number">3</span>, salary);</span><br><span class="line"></span><br><span class="line">  pDC-&gt;SelectObject(pfont);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第九章-定制应用程序外观"><a href="#第九章-定制应用程序外观" class="headerlink" title="第九章 定制应用程序外观"></a>第九章 定制应用程序外观</h1><h2 id="4、工具栏编程ToolBar"><a href="#4、工具栏编程ToolBar" class="headerlink" title="4、工具栏编程ToolBar"></a>4、工具栏编程ToolBar</h2><p>1.在工具栏上添加、删除按钮</p>
<p>创建按钮：按钮和菜单项用一样的ID</p>
<p>按钮之间的分隔符：用鼠标把按钮向右拖动一段距离</p>
<p>删除按钮：将按钮脱出工具栏</p>
<p>2.创建工具栏</p>
<p>分析系统创建的工具栏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cmainframe头文件中</span><br><span class="line">CToolBar          m_wndToolBar;</span><br><span class="line"></span><br><span class="line">cmainframe.cpp中</span><br><span class="line"><span class="type">int</span> <span class="title function_">CMainFrame::OnCreate</span><span class="params">(LPCREATESTRUCT lpCreateStruct)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||</span><br><span class="line">    !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))</span><br><span class="line">  &#123;</span><br><span class="line">    TRACE0(<span class="string">&quot;未能创建工具栏\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// 未能创建</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> ....</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 如果不需要可停靠工具栏，则删除这三行</span></span><br><span class="line">  m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);<span class="comment">//工具栏对象的成员函数EnableDocking，表示工具栏对象可以停靠</span></span><br><span class="line">  <span class="comment">//CBRS_ALIGN_ANY允许停靠在任意位置</span></span><br><span class="line">  EnableDocking(CBRS_ALIGN_ANY);<span class="comment">//CFrameWnd对象的EnableDocking成员函数，表示主框架窗口可以被停靠</span></span><br><span class="line">  DockControlBar(&amp;m_wndToolBar);<span class="comment">//工具栏停靠在主框架窗口上</span></span><br></pre></td></tr></table></figure>

<p>创建自定义工具栏(参照系统工具栏)</p>
<p>1.新建ToolBar资源</p>
<p>2.构造ToolBar对象</p>
<p>3.调用Create函数创建工具栏，并将其与ToolBar对象关联</p>
<p>4.LoadToolBar加载工具栏</p>
<p>5.设置停靠位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">头文件  </span><br><span class="line">CToolBar    m_newtoolbar;<span class="comment">//2.构造ToolBar对象</span></span><br><span class="line">  </span><br><span class="line">源文件</span><br><span class="line">  <span class="keyword">if</span> (!m_newtoolbar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_RIGHT | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||</span><br><span class="line">    !m_newtoolbar.LoadToolBar(IDR_TOOLBAR1))</span><br><span class="line"><span class="comment">//3.调用Create函数创建工具栏，并将其与ToolBar对象关联</span></span><br><span class="line"><span class="comment">//4.LoadToolBar加载工具栏</span></span><br><span class="line">  &#123;</span><br><span class="line">    TRACE0(<span class="string">&quot;未能创建工具栏\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// 未能创建</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//5.设置停靠位置</span></span><br><span class="line">  m_newtoolbar.EnableDocking(CBRS_ALIGN_ANY);</span><br><span class="line">  DockControlBar(&amp;m_newtoolbar);</span><br></pre></td></tr></table></figure>

<p>改进方法**<code>CFrameWnd::ShowControlBar</code>**隐藏或显示指定的控制条</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CMainFrame::OnViewNewtoolbar</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">/*   </span></span><br><span class="line"><span class="comment">if (!m_newtoolbar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_RIGHT | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||</span></span><br><span class="line"><span class="comment">    !m_newtoolbar.LoadToolBar(IDR_TOOLBAR1))</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    TRACE0(&quot;未能创建工具栏\n&quot;);</span></span><br><span class="line"><span class="comment">    return -1;      // 未能创建</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  m_newtoolbar.EnableDocking(CBRS_ALIGN_ANY);</span></span><br><span class="line"><span class="comment">  DockControlBar(&amp;m_newtoolbar);   </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">          </span><br><span class="line">  ShowControlBar(&amp;m_newtoolbar, !m_newtoolbar.IsWindowVisible(), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CMainFrame::OnUpdateViewNewtoolbar</span><span class="params">(CCmdUI* pCmdUI)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 在菜单项前添加标记,见第六章</span></span><br><span class="line">  pCmdUI-&gt;SetCheck(m_newtoolbar.IsWindowVisible());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、状态栏StatusBar"><a href="#5、状态栏StatusBar" class="headerlink" title="5、状态栏StatusBar"></a>5、状态栏StatusBar</h2><p>步骤：</p>
<p>1.在资源视图String Table中添加响应的ID</p>
<p>2.在源文件中将响应的ID添加进indicator（状态行指示器）中</p>
<p>系统创建的状态栏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  CStatusBar        m_wndStatusBar;<span class="comment">//定义默认状态栏对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> UINT indicators[] =</span><br><span class="line">&#123;</span><br><span class="line">  ID_SEPARATOR,           <span class="comment">// 状态行指示器</span></span><br><span class="line">  ID_INDICATOR_CAPS,</span><br><span class="line">  ID_INDICATOR_NUM,</span><br><span class="line">  ID_INDICATOR_SCRL,</span><br><span class="line"><span class="comment">//  IDS_TIMER,</span></span><br><span class="line"><span class="comment">//  IDS_PROGRESS,</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//OnCreate()中</span></span><br><span class="line"> <span class="keyword">if</span> (!m_wndStatusBar.Create(this))<span class="comment">//创建状态栏对象</span></span><br><span class="line">  &#123;</span><br><span class="line">    TRACE0(<span class="string">&quot;未能创建状态栏\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// 未能创建</span></span><br><span class="line">  &#125;</span><br><span class="line">  m_wndStatusBar.SetIndicators(indicators, <span class="keyword">sizeof</span>(indicators)/<span class="keyword">sizeof</span>(UINT));<span class="comment">//设置状态指示器(数组设置状态栏内容，数组元素个数)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在OnTimer()中添加</span><br><span class="line"><span class="comment">//在状态栏显示动态变化的系统时间</span></span><br><span class="line">  CTime time;<span class="comment">//接收系统时间</span></span><br><span class="line">  CString str;<span class="comment">//系统时间文本</span></span><br><span class="line">  CClientDC <span class="title function_">dc</span><span class="params">(this)</span>;<span class="comment">//调用GetTextExtent()</span></span><br><span class="line">  CSize sz;<span class="comment">//接收时间字符串大小</span></span><br><span class="line">  <span class="type">int</span> indicatorindex =  <span class="number">0</span>;<span class="comment">//indicator索引</span></span><br><span class="line"></span><br><span class="line">  time = CTime::GetCurrentTime();<span class="comment">//获取系统时间保存进time中</span></span><br><span class="line">  str = time.Format(<span class="string">&quot;%H:%M:%S&quot;</span>);<span class="comment">//将time中的时间格式化</span></span><br><span class="line">  indicatorindex = m_wndStatusBar.CommandToIndex(IDS_TIMER);<span class="comment">//获取ID在indicator中的索引</span></span><br><span class="line">  sz = dc.GetTextExtent(str);<span class="comment">//获取文本显示宽度 </span></span><br><span class="line">  </span><br><span class="line">  m_wndStatusBar.SetPaneInfo(indicatorindex, IDS_TIMER, SBPS_NORMAL, sz.cx);<span class="comment">//设置状态栏右侧小窗口属性</span></span><br><span class="line">  m_wndStatusBar.SetPaneText(indicatorindex, str);<span class="comment">//将str显示到indicator数组对应的小窗口</span></span><br></pre></td></tr></table></figure>

<h2 id="6、进度栏"><a href="#6、进度栏" class="headerlink" title="6、进度栏"></a>6、进度栏</h2><h1 id="CProgressCtrl-Create-进度栏类CProgressCtrl"><a href="#CProgressCtrl-Create-进度栏类CProgressCtrl" class="headerlink" title="CProgressCtrl::Create&#x2F;&#x2F;进度栏类CProgressCtrl"></a>CProgressCtrl::Create&#x2F;&#x2F;进度栏类CProgressCtrl</h1><p><strong>BOOL</strong> <strong>Create(</strong> <strong>DWORD</strong> <em>dwStyle</em><strong>,</strong> <strong>const</strong> <strong>RECT&amp;</strong> <em>rect</em><strong>,</strong> <strong>CWnd</strong>* <em>pParentWnd</em><strong>,</strong> <strong>UINT</strong> <em>nID);&#x2F;&#x2F;</em> 创建进度栏</p>
<h1 id="CProgressCtrl-SetPos"><a href="#CProgressCtrl-SetPos" class="headerlink" title="CProgressCtrl::SetPos"></a>CProgressCtrl::SetPos</h1><p><strong>int</strong> <strong>SetPos(</strong> <strong>int</strong> <em>nPos);&#x2F;&#x2F;</em> 设置进度栏当前进度</p>
<h1 id="CStatusBar-GetItemRect"><a href="#CStatusBar-GetItemRect" class="headerlink" title="CStatusBar::GetItemRect"></a>CStatusBar::GetItemRect</h1><p><strong>void GetItemRect(int</strong> <em>nIndex</em><strong>,LPRECT</strong> <em>lpRect)const;&#x2F;&#x2F;</em> 得到状态栏小窗格大小</p>
<p>🌟补充消息响应过程</p>
<p>1.头文件声明（定义）函数afx_msg LRESULT  OnProgress(WPARAM, LPARAM);</p>
<p>2.消息与函数关联ON_MESSAGE(UM_PROGRESS, &amp;OnProgress)</p>
<p>3.实现函数LRESULT CMainFrame::OnProgress(WPARAM wParam, LPARAM lParam) </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CMainFrame::OnPaint</span><span class="params">()</span><span class="comment">//窗口大小发生变化-&gt;窗口重绘-&gt;重新获得rect</span></span><br><span class="line">&#123;</span><br><span class="line">  CPaintDC <span class="title function_">dc</span><span class="params">(this)</span>; <span class="comment">// device context for painting</span></span><br><span class="line">                     <span class="comment">// <span class="doctag">TODO:</span> 在此处添加消息处理程序代码</span></span><br><span class="line">                     <span class="comment">// 不为绘图消息调用 CFrameWnd::OnPaint()</span></span><br><span class="line">             </span><br><span class="line">  CRect rect;</span><br><span class="line">  m_wndStatusBar.GetItemRect(<span class="number">5</span>, &amp;rect);<span class="comment">//获得窗格大小并储存在rect中</span></span><br><span class="line">  <span class="keyword">if</span> (!m_progress.m_hWnd)<span class="comment">//如果句柄没有值，说明对象没有创建</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_progress.Create(WS_VISIBLE | WS_CHILD | PBS_SMOOTH, rect, &amp;m_wndStatusBar, <span class="number">123</span>);<span class="comment">//创建进度栏，WS_CHILD:The window is a child window. </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_progress.MoveWindow(rect);<span class="comment">//移动窗格，The CRect object or RECT structure that specifies the new size and position. </span></span><br><span class="line">  &#125;</span><br><span class="line">  m_progress.SetPos(<span class="number">50</span>);<span class="comment">//设置进度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、在状态栏上显示鼠标当前位置"><a href="#7、在状态栏上显示鼠标当前位置" class="headerlink" title="7、在状态栏上显示鼠标当前位置"></a>7、在状态栏上显示鼠标当前位置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CstyleView::OnMouseMove</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line"><span class="comment">//视类中捕获鼠标移动的消息WM_MOUSEMOVE</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">  CString str;</span><br><span class="line">  str.Format(<span class="string">&quot;x = %d  y = %d&quot;</span>,point.x, point.y);<span class="comment">//格式化鼠标位置</span></span><br><span class="line">  ((CMainFrame*)GetParent())-&gt;m_wndStatusBar.SetWindowText(str);</span><br><span class="line">  <span class="comment">/*上述代码中，首先格式化鼠标当前位置的信息。然后为了把该信息显示在</span></span><br><span class="line"><span class="comment">状态栏的第一个窗格上，需要获取状态栏对象。而状态栏对象是在框架类窗口中定义的，同时，</span></span><br><span class="line"><span class="comment">框架类窗口是视类窗口的父窗口，因此在视类对象中通过调用 GetParent 函数就可以得到</span></span><br><span class="line"><span class="comment">视类的父窗口，即框架窗口。因为该函数返回的是一个CWnd 类型的指针，而这里需要的</span></span><br><span class="line"><span class="comment">是 CMainFrame 类型的指针，所以需要进行一个转换。然后利用框架窗口对象去调用该对</span></span><br><span class="line"><span class="comment">象内部的状态栏成员变量：m_wndStatusBar，以得到状态栏对象，*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*因为上述代码用到了框架类的类型，所以要在头文件中包含框架类头文件*/</span></span><br><span class="line">  </span><br><span class="line">  CView::OnMouseMove(nFlags, point);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="十、绘图控制"><a href="#十、绘图控制" class="headerlink" title="十、绘图控制"></a>十、绘图控制</h1><h3 id="1、简单绘图"><a href="#1、简单绘图" class="headerlink" title="1、简单绘图"></a>1、简单绘图</h3><p>CPen pen</p>
<p>SelectObject</p>
<p>GetStockObject</p>
<p>FromHandle</p>
<p>SetPixel</p>
<p>Rectangle</p>
<p>Ellipse</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*头文件*/</span></span><br><span class="line"><span class="comment">//自定义成员变量</span></span><br><span class="line">private:</span><br><span class="line">  UINT m_nDrawType;<span class="comment">//标记用户选择那种图形</span></span><br><span class="line">  CPoint m_ptOrigin;<span class="comment">//保存鼠标左键按下的点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*构造函数*/</span></span><br><span class="line">CGraphicView::CGraphicView() noexcept</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此处添加构造代码</span></span><br><span class="line">  m_nDrawType = <span class="number">0</span>;<span class="comment">//初始化绘图图形类型</span></span><br><span class="line">  m_ptOrigin = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*视类消息处理程序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CGraphicView::OnDot</span><span class="params">()</span><span class="comment">//点</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">  m_nDrawType = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CGraphicView::OnLine</span><span class="params">()</span><span class="comment">//直线</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">  m_nDrawType = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CGraphicView::OnRectangle</span><span class="params">()</span><span class="comment">//矩形</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">  m_nDrawType = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CGraphicView::OnEllipse</span><span class="params">()</span><span class="comment">//椭圆</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">  m_nDrawType = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CGraphicView::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">  m_ptOrigin = point;<span class="comment">//保存鼠标左键按下的位置</span></span><br><span class="line">  </span><br><span class="line">  CView::OnLButtonDown(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CGraphicView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span><span class="comment">//鼠标左键抬起，实现绘图功能</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">  CClientDC <span class="title function_">dc</span><span class="params">(this)</span>;<span class="comment">//绘图操作首先要有DC对象</span></span><br><span class="line">  CPen <span class="title function_">pen</span><span class="params">(PS_SOLID, <span class="number">10</span>, RGB(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>))</span>;<span class="comment">//线条的颜色由DC中的画笔颜色确定，构造CPen对象并指定其颜色</span></span><br><span class="line">  dc.SelectObject(&amp;pen);<span class="comment">//将画笔选入设备描述表</span></span><br><span class="line">                        <span class="comment">//加载资源用LoadBitmap等，CDC对象用SelectObject(&amp;xxx)  </span></span><br><span class="line">  CBrush* pBrush = CBrush::FromHandle((HBRUSH)GetStockObject(NULL_BRUSH));<span class="comment">//GetStockObject调用NULL_BRUSH创建透明画刷</span></span><br><span class="line">                                                                          <span class="comment">//CBrush的静态成员变量FromHandle将画刷句柄转化为指向画刷对象的指针</span></span><br><span class="line">                                                                          <span class="comment">//FromHandle的参数是HBRUSH类型，强制类型转化</span></span><br><span class="line">  dc.SelectObject(pBrush);<span class="comment">//将画刷选入设备描述表</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (m_nDrawType)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    dc.SetPixel(point, RGB(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>));<span class="comment">//在指定的点设置一个像素</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    dc.MoveTo(m_ptOrigin);</span><br><span class="line">    dc.LineTo(point);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    dc.Rectangle(CRect(m_ptOrigin,point));<span class="comment">//利用CRect对象绘制矩形</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    dc.Ellipse(CRect(m_ptOrigin, point));<span class="comment">//绘制椭圆</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意将CDC对象加入设备miaoshub；</p>
<p>注意静态成员函数的调用方式：要声明是哪个类的。</p>
<h2 id="2、线宽线型（设置对话框）"><a href="#2、线宽线型（设置对话框）" class="headerlink" title="2、线宽线型（设置对话框）"></a>2、线宽线型（设置对话框）</h2><p>1、将设置对话框创建一个新的对话框类</p>
<p>2、在主菜单添加设置菜单项并设置消息响应函数</p>
<p>3、控件关联无符号整型变量，View类创建同类型变量以保存其值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CGraphicView::OnSetting</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">  CSettingDlg dlg;<span class="comment">//实例化设置对话框对象</span></span><br><span class="line">  dlg.m_nLineWidth = m_nLineWidth;<span class="comment">//保持之前设置过的线宽</span></span><br><span class="line">  dlg.m_nLineStyle = m_nLineStyle;<span class="comment">//保持之前设置过的线型</span></span><br><span class="line">  <span class="keyword">if</span> (IDOK == dlg.DoModal())</span><br><span class="line">  &#123;</span><br><span class="line">    m_nLineWidth = dlg.m_nLineWidth;<span class="comment">//保存新设置的值</span></span><br><span class="line">    m_nLineStyle = dlg.m_nLineStyle;<span class="comment">//保存设置的线型，WINGDI.h定义了一些符号常量，包括线型</span></span><br><span class="line">                                    <span class="comment">//本例设置的对话框的线型排序正好按照WINGDI.h的顺序定义</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、颜色对话框"><a href="#3、颜色对话框" class="headerlink" title="3、颜色对话框"></a>3、颜色对话框</h2><p>CColorDialog默认颜色对话框类了解（m_cc、CHOOSECOLOR、rgbResult、Flags (CC_RGBINIT)）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CGraphicView::OnColor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">  CColorDialog colordlg;<span class="comment">//CColorDialog颜色对话框类</span></span><br><span class="line">  colordlg.m_cc.Flags |= CC_RGBINIT;<span class="comment">//设置颜色对话框初始选择的颜色，需要设置该对话框的CC_RGBINIT标记</span></span><br><span class="line">  <span class="comment">/*实际上，当在创建 CColorDialog 对象 dlg 时，它的数据成员 m_cc 中的 Flags 成员已经具有了一些初始的默认标记。</span></span><br><span class="line"><span class="comment">  当我们将 CC_RGBINTT 标记直接赋给 Flags 成员时，就相当于将 Flags 成员初始默认的标记都去掉了。</span></span><br><span class="line"><span class="comment">  这里不能给 Flags 标记直接赋值，应利用或操作（|）将CC_RGBINIT 标记与 Flags 先前的标记组合起来。*/</span></span><br><span class="line">  colordlg.m_cc.rgbResult = m_ctr;<span class="comment">//保持之前设置过的颜色</span></span><br><span class="line">  <span class="keyword">if</span> (IDOK == colordlg.DoModal())<span class="comment">//创建颜色对话框</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_ctr = colordlg.m_cc.rgbResult;<span class="comment">//CColorDialog类有一个结构体类型的变量m_cc</span></span><br><span class="line">                                    <span class="comment">//CHOOSECOLOR结构体的rgbResult变量保存了用户选择的颜色</span></span><br><span class="line">                                    <span class="comment">//将用户选择的颜色保存在m_ctr中</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、字体对话框"><a href="#4、字体对话框" class="headerlink" title="4、字体对话框"></a>4、字体对话框</h2><p>DeleteObject释放这个字体资源</p>
<p>CFont::CreateFontIndirect利用lpLogFont指向的LOGFONT结构体中的一些特征初始化CFont对象</p>
<p>Invalidate()引起窗口重绘</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">头文件</span><br><span class="line">CFont m_font;<span class="comment">//字体对象</span></span><br><span class="line">CString m_strFontName;<span class="comment">//保存所选字体的名称</span></span><br><span class="line"></span><br><span class="line">源文件</span><br><span class="line"><span class="type">void</span> <span class="title function_">CGraphicView::OnFont</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">  CFontDialog fontdlg;<span class="comment">//字体对话框对象</span></span><br><span class="line">  <span class="keyword">if</span> (IDOK == fontdlg.DoModal())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_font.m_hObject)</span><br><span class="line">    <span class="comment">/*利用CGdiobject 对象的数据成员 m_hObject 来判断 m_font 对象是否已经与某个字体资源相关联了，</span></span><br><span class="line"><span class="comment">    该变量保存了与CGdiObject对象相关联的Windows GDI 的资源句柄。</span></span><br><span class="line"><span class="comment">    如果已经有关联了，则调用 DeleteObject 释放这个字体资源*/</span></span><br><span class="line">    &#123;</span><br><span class="line">      m_font.DeleteObject();</span><br><span class="line">    &#125;</span><br><span class="line">    m_font.CreateFontIndirect(fontdlg.m_cf.lpLogFont);<span class="comment">//CFont::CreateFontIndirect利用lpLogFont指向的LOGFONT结构体中的一些特征初始化CFont对象</span></span><br><span class="line">    m_strFontName = fontdlg.m_cf.lpLogFont-&gt;lfFaceName;<span class="comment">//lfFaceName保存了字体名字</span></span><br><span class="line">    Invalidate();</span><br><span class="line">    <span class="comment">/*窗口的客户区无效意味着需要重绘，例如，如果一个被其它窗口遮住的窗口变成了前台窗口，</span></span><br><span class="line"><span class="comment">    那么原来被遮住的部分就是无效的，需要重绘。这时Windows会在应用程序的消息队列中放置WM_PAINT消息。</span></span><br><span class="line"><span class="comment">    MFC为窗口类提供了WM_PAINT的消息处理函数OnPaint，OnPaint负责重绘窗口。</span></span><br><span class="line"><span class="comment">    视图类有一些例外，在视图类的OnPaint函数中调用了OnDraw函数，实际的重绘工作由OnDraw来完成。*/</span></span><br><span class="line">    <span class="comment">/*系统会在多个不同的时机发送WM_PAINT消息：</span></span><br><span class="line"><span class="comment">    当第一次创建一个窗口时，当改变窗口的大小时，当把窗口从另一个窗口背后移出时，当最大化或最小化窗口时，等等，</span></span><br><span class="line"><span class="comment">    这些动作都是由系统管理的，应用只是被动地接收该消息，在消息处理函数中进行绘制操作；</span></span><br><span class="line"><span class="comment">    大多数的时候应用也需要能够主动引发窗口中的绘制操作，比如当窗口显示的数据改变的时候，</span></span><br><span class="line"><span class="comment">    这一般是通过InvalidateRect和 InvalidateRgn函数来完成的。*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.nlark.com/yuque/0/2024/jpg/21452222/1708699502177-0fc3285d-547f-4612-98a7-b50c3b52a61e.jpg#id=BNRC1&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="5、示例对话框"><a href="#5、示例对话框" class="headerlink" title="5、示例对话框"></a>5、示例对话框</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CSettingDlg::OnChangeLineWidth</span><span class="params">()</span></span><br><span class="line"><span class="comment">//对编辑框控件中的文本改变时，会向父窗口发送EN_CHANGE消息</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  Invalidate();<span class="comment">//让窗口重绘以在OnPaint中完成示例线条的绘制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CSettingDlg::OnClickedRadio1</span><span class="params">()</span></span><br><span class="line"><span class="comment">//单击Radio Button时，按钮会向对话框发送BN_CLICKED消息</span></span><br><span class="line">&#123;</span><br><span class="line">  Invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CSettingDlg::OnClickedRadio2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">  Invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CSettingDlg::OnClickedRadio3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">  Invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CSettingDlg::OnPaint</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  CPaintDC <span class="title function_">dc</span><span class="params">(this)</span>; <span class="comment">// device context for painting</span></span><br><span class="line">             <span class="comment">// <span class="doctag">TODO:</span> 在此处添加消息处理程序代码</span></span><br><span class="line">             <span class="comment">// 不为绘图消息调用 CDialog::OnPaint()</span></span><br><span class="line">  UpdateData();<span class="comment">//当控件与一个成员变量相关联时，如果想让控件上的值反应到成员变量上，必须调用UpdateData()</span></span><br><span class="line">  CPen <span class="title function_">pen</span><span class="params">(m_nLineStyle, m_nLineWidth, m_clr)</span>;</span><br><span class="line">  dc.SelectObject(&amp;pen);</span><br><span class="line"></span><br><span class="line">  CRect rect;</span><br><span class="line">  GetDlgItem(IDC_SAMPLE)-&gt;GetWindowRect(&amp;rect);</span><br><span class="line">  <span class="comment">/*要想在组框中绘图，那么首先要得到组框的矩形区域范围。</span></span><br><span class="line"><span class="comment">  这可以通过调用GetDlgltem 函数来得到指向组框窗口对象的指针，</span></span><br><span class="line"><span class="comment">  然后利用 GetWindowRect 函数获得组框窗口矩形区域的大小,参数是指向CRect或RECT结构体的变量，接收屏幕坐标</span></span><br><span class="line"><span class="comment">  需要提醒读者注意的是，这里不能直接调用 GetWindowRect 函数，否则得到的将是对话框的矩形区域大小。*/</span></span><br><span class="line">  ScreenToClient(&amp;rect);<span class="comment">//得到矩形区域的大小后，将其原点从屏幕坐标转化为客户坐标（即将应用程序坐标转化为设置对话框坐标）</span></span><br><span class="line"></span><br><span class="line">  dc.MoveTo(rect.left+<span class="number">20</span>,rect.top+rect.Height()/<span class="number">2</span>);<span class="comment">//组框左上角的y值+矩形区域高度的一半，即将线条移动到示例窗口中间</span></span><br><span class="line">  dc.LineTo(rect.right - <span class="number">20</span>, rect.top + rect.Height() / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、改变对话框及其控件的背景和文本WM-CTLCOLOR"><a href="#6、改变对话框及其控件的背景和文本WM-CTLCOLOR" class="headerlink" title="6、改变对话框及其控件的背景和文本WM_CTLCOLOR"></a>6、改变对话框及其控件的背景和文本WM_CTLCOLOR</h2><p>1、改变对话框及其控件的背景</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件声明</span></span><br><span class="line">  CBrush m_brush;<span class="comment">//画刷</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数初始化</span></span><br><span class="line">  m_clr = RGB(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  m_brush.CreateSolidBrush(RGB(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>));<span class="comment">//利用CreateSolidBrush函数将m_brush初始化画刷颜色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//消息响应函数</span></span><br><span class="line">HBRUSH <span class="title function_">CSettingDlg::OnCtlColor</span><span class="params">(CDC* pDC, CWnd* pWnd, UINT nCtlColor)</span><span class="comment">//每一个控件（对话框和子控件）在绘制时都发送WM_CTLCOLOR消息</span></span><br><span class="line">&#123;</span><br><span class="line">  HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>  在此更改 DC 的任何特性</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>  如果默认的不是所需画笔，则返回另一个画笔</span></span><br><span class="line">  <span class="keyword">if</span> (IDC_LINE_STYLE == pWnd-&gt;GetDlgCtrlID())<span class="comment">//判断是否为线型组框</span></span><br><span class="line">  &#123;</span><br><span class="line">    pDC-&gt;SetTextColor(RGB(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>));<span class="comment">//设置文本颜色为红色</span></span><br><span class="line">    pDC-&gt;SetBkMode(TRANSPARENT);<span class="comment">//将控件上的文字背景设置为透明</span></span><br><span class="line">    <span class="keyword">return</span> m_brush;<span class="comment">//如果想要改变背景颜色，只需要自定义一个画刷，然后让OnColor函数返回这个画刷句柄即可</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (IDC_LINE_WIDTH == pWnd-&gt;GetDlgCtrlID())</span><br><span class="line">  &#123;</span><br><span class="line">    pDC-&gt;SetTextColor(RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//    pDC-&gt;SetBkMode(TRANSPARENT);</span></span><br><span class="line">    pDC-&gt;SetBkColor(RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));<span class="comment">//设置窗口背景色</span></span><br><span class="line">    <span class="keyword">return</span> m_brush;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hbr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、改变控件的文本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件声明</span></span><br><span class="line">private:</span><br><span class="line">  CFont m_font;<span class="comment">//改变控件上的文本字体</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//构造函数初始化</span></span><br><span class="line">  m_font.CreatePointFont(<span class="number">200</span>,<span class="string">&quot;华文行楷&quot;</span>);<span class="comment">//初始化字体</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//消息响应函数</span></span><br><span class="line">  HBRUSH <span class="title function_">CSettingDlg::OnCtlColor</span><span class="params">(CDC* pDC, CWnd* pWnd, UINT nCtlColor)</span><span class="comment">//每一个控件（对话框和子控件）在绘制时都发送WM_CTLCOLOR消息</span></span><br><span class="line">&#123;</span><br><span class="line">  HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>  在此更改 DC 的任何特性</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>  如果默认的不是所需画笔，则返回另一个画笔</span></span><br><span class="line">  <span class="keyword">if</span> (IDC_TEXT == pWnd-&gt;GetDlgCtrlID())</span><br><span class="line">  &#123;</span><br><span class="line">    pDC-&gt;SelectObject(&amp;m_font);<span class="comment">//将字体选入设备描述表-&gt;改变字体</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hbr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、改变按钮的背景色及文本</p>
<h2 id="7、位图的显示"><a href="#7、位图的显示" class="headerlink" title="7、位图的显示"></a>7、位图的显示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CGraphicView::OnEraseBkgnd</span><span class="params">(CDC* pDC)</span><span class="comment">//擦除背景时，系统发送WM_ERASEBKGND消息</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">  CBitmap bitmap;</span><br><span class="line">  bitmap.LoadBitmap(IDB_BITMAP1);</span><br><span class="line">  BITMAP bmp;<span class="comment">//定义BITMAP结构体变量</span></span><br><span class="line">  bitmap.GetBitmap(&amp;bmp);<span class="comment">//CBitmap::GetBitmap用位图信息填充BITMAP结构体</span></span><br><span class="line"></span><br><span class="line">  CDC dcCompatible;<span class="comment">//创建兼容DC</span></span><br><span class="line">  dcCompatible.CreateCompatibleDC(pDC);<span class="comment">//兼容DC(源DC)和当前DC兼容</span></span><br><span class="line"></span><br><span class="line">  dcCompatible.SelectObject(&amp;bitmap);<span class="comment">//将位图选入兼容DC，从而确定兼容DC显示表面的大小</span></span><br><span class="line"></span><br><span class="line">  CRect rect;</span><br><span class="line">  GetClientRect(&amp;rect);<span class="comment">//获得目的DC客户区大小</span></span><br><span class="line"><span class="comment">//  pDC-&gt;BitBlt(0, 0, rect.Width(), rect.Height(), &amp;dcCompatible, 0, 0, SRCCOPY);//BitBlt()将源DC的位图1:1复制到目的DC</span></span><br><span class="line">  pDC-&gt;StretchBlt(<span class="number">0</span>, <span class="number">0</span>, rect.Width(), rect.Height(), &amp;dcCompatible, <span class="number">0</span>, <span class="number">0</span>,bmp.bmWidth,bmp.bmHeight, SRCCOPY);</span><br><span class="line">  <span class="comment">//StretchBlt复制位图并实现拉伸或压缩；bmp.bmWidth,bmp.bmHeight存储源矩形的宽度和高度</span></span><br><span class="line">  <span class="keyword">return</span> TRUE;<span class="comment">//已经擦除过窗口背景了，返回非零值</span></span><br><span class="line"><span class="comment">//  return CView::OnEraseBkgnd(pDC);//将窗口背景擦除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;构造函数初始化</p>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2022/06/09/cmake+mingw32+win11+clion%E7%BC%96%E8%AF%91OpenCV4.5+contrib/">cmake+mingw32+win11+clion编译OpenCV4.5+contrib</a></div><div class="item" id="next"></div></section></div>




  <div class="related-wrap md-text" id="comments">
    <section class='header cmt-title cap theme'>
      <p>快来参与讨论吧~</p>

    </section>
    <section class='body cmt-body twikoo'>
      

<div id="twikoo_container"><svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg></div>
    </section>
  </div>



<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">He Zexian</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.27.0">Stellar 1.27.0</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="4" onerror="localStorage.setItem('modelId','4')" style="display:none;"><script src="https://www.hekeke.top/live2d-widget-master/autoload.js"></script></p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-Windows%E7%A8%8B%E5%BA%8F%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">第一章 Windows程序内部运行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-API%E5%92%8CSDK"><span class="toc-text">1.1 API和SDK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%AA%97%E5%8F%A3%E5%92%8C%E5%8F%A5%E6%9F%84"><span class="toc-text">1.2 窗口和句柄</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%B6%88%E6%81%AF%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-text">1.3 消息和队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-WinMain"><span class="toc-text">1.4 WinMain</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-WinMain%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1.4.1 WinMain函数的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E7%AA%97%E5%8F%A3%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">1.4.2 窗口的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-1-%E8%AE%BE%E8%AE%A1%E7%AA%97%E5%8F%A3%E7%B1%BB"><span class="toc-text">1.4.2.1 设计窗口类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-2-%E6%B3%A8%E5%86%8C%E7%AA%97%E5%8F%A3"><span class="toc-text">1.4.2.2 注册窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-3-%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3"><span class="toc-text">1.4.2.3 创建窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-4-%E6%98%BE%E7%A4%BA%E5%8F%8A%E6%9B%B4%E6%96%B0%E7%AA%97%E5%8F%A3"><span class="toc-text">1.4.2.4 显示及更新窗口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF"><span class="toc-text">1.4.3 消息循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-4-%E7%AA%97%E5%8F%A3%E8%BF%87%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="toc-text">1.4.4 窗口过程函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E7%A8%8B%E5%BA%8F"><span class="toc-text">课后程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-text">参考文献</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8E%8C%E6%8F%A1C"><span class="toc-text">第二章 掌握C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BB%8E%E7%BB%93%E6%9E%84%E5%88%B0%E7%B1%BB"><span class="toc-text">2.1 从结构到类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">2.1.1 结构体的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB"><span class="toc-text">2.1.2 结构体与类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-C-%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">2.2 C++的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.2.1 类与对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">2.2.2 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">2.2.3 析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-text">2.2.4 函数的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-this%E6%8C%87%E9%92%88"><span class="toc-text">2.2.5 this指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-6-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">2.2.6 类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-6-1-%E7%BB%A7%E6%89%BF"><span class="toc-text">2.2.6.1 继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-6-2-%E5%9C%A8%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">2.2.6.2 在子类中调用父类带参数的构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-6-3-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%8F%8A%E7%B1%BB%E4%B8%AD%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E6%80%A7"><span class="toc-text">2.2.6.3 类的继承及类中成员的访问特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-6-4-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">2.2.6.4 多重继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-7-%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E6%80%81%E6%80%A7%E3%80%81%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">2.2.7 虚函数与多态性、纯虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-7-1%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-text">2.2.7.1虚函数与多态性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-7-2-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">2.2.7.2 纯虚函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-8%E5%87%BD%E6%95%B0%E7%9A%84%E8%A6%86%E7%9B%96%E5%92%8C%E9%9A%90%E8%97%8F"><span class="toc-text">2.2.8函数的覆盖和隐藏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-8-1-%E8%A6%86%E7%9B%96"><span class="toc-text">2.2.8.1 覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-8-2-%E9%9A%90%E8%97%8F"><span class="toc-text">2.2.8.2 隐藏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-9-%E5%BC%95%E7%94%A8"><span class="toc-text">2.2.9 引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-10-C-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E4%B9%A0%E6%83%AF%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-text">2.2.10 C++类设计习惯和头文件重复包含问题的解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-11-VC-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%87%E7%A8%8B"><span class="toc-text">2.2.11 VC++程序编译连接的原理与过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E7%A8%8B%E5%BA%8F-1"><span class="toc-text">课后程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%8A%E5%8F%8D%E6%80%9D"><span class="toc-text">问题及反思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-1"><span class="toc-text">参考文献</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-MFC%E6%A1%86%E6%9E%B6%E7%A8%8B%E5%BA%8F%E5%89%96%E6%9E%90"><span class="toc-text">第三章 MFC框架程序剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E5%88%9B%E5%BB%BAMFC-AppWizard"><span class="toc-text">3.1创建MFC AppWizard</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E5%9F%BA%E4%BA%8EMFC%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E5%89%96%E6%9E%90"><span class="toc-text">3.2基于MFC的程序框架剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-MFC%E4%B8%AD%E7%9A%84WinMain%E5%87%BD%E6%95%B0"><span class="toc-text">3.2.1 MFC中的WinMain函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-1-theApp%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.2.1.1 theApp全局对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-2-AfxWinMain%E5%87%BD%E6%95%B0"><span class="toc-text">3.2.1.2 AfxWinMain函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-3-InitInstance%E5%87%BD%E6%95%B0"><span class="toc-text">3.2.1.3  InitInstance函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-MFC%E6%A1%86%E6%9E%B6%E7%AA%97%E5%8F%A3"><span class="toc-text">3.2.2 MFC框架窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-1-%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%B3%A8%E5%86%8C%E7%AA%97%E5%8F%A3"><span class="toc-text">3.2.2.1 设计和注册窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-2-%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3"><span class="toc-text">3.2.2.2 创建窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-3-%E6%98%BE%E7%A4%BA%E5%92%8C%E6%9B%B4%E6%96%B0%E7%AA%97%E5%8F%A3"><span class="toc-text">3.2.2.3 显示和更新窗口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF"><span class="toc-text">3.2.3 消息循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-MFC%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%A2%B3%E7%90%86"><span class="toc-text">3.2.4 MFC运行过程梳理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%AA%97%E5%8F%A3%E7%B1%BB%E3%80%81%E7%AA%97%E5%8F%A3%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%AA%97%E5%8F%A3"><span class="toc-text">3.3 窗口类、窗口对象与窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">3.3.1 三者之间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E5%9C%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E6%98%BE%E7%A4%BA%E6%8C%89%E9%92%AE"><span class="toc-text">3.3.2 在窗口中显示按钮</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E7%A8%8B%E5%BA%8F-2"><span class="toc-text">课后程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%8A%E5%8F%8D%E6%80%9D-1"><span class="toc-text">问题及反思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-2"><span class="toc-text">参考文献</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0"><span class="toc-text">第四章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-MFC%E6%B6%88%E6%81%AF%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-text">4.1 MFC消息映射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-classwizard"><span class="toc-text">4.1.1 classwizard</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E6%B6%88%E6%81%AF%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-text">4.1.2 消息映射机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E7%BB%98%E5%88%B6%E7%BA%BF%E6%9D%A1"><span class="toc-text">4.2 绘制线条</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E5%88%A9%E7%94%A8SDK%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%88%92%E7%BA%BF%E5%8A%9F%E8%83%BD"><span class="toc-text">4.2.1 利用SDK全局函数实现划线功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E5%88%A9%E7%94%A8MFC%E7%9A%84CDC%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%94%BB%E5%9B%BE%E5%8A%9F%E8%83%BD"><span class="toc-text">4.2.2 利用MFC的CDC类实现画图功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E5%88%A9%E7%94%A8MFC%E7%9A%84CClientDC%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%94%BB%E5%9B%BE%E5%8A%9F%E8%83%BD"><span class="toc-text">4.2.3 利用MFC的CClientDC类实现画图功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E5%88%A9%E7%94%A8MFC%E7%9A%84CWindowDC%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%94%BB%E5%9B%BE%E5%8A%9F%E8%83%BD"><span class="toc-text">4.2.4 利用MFC的CWindowDC类实现画图功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-5-%E5%9C%A8%E6%A1%8C%E9%9D%A2%E7%AA%97%E5%8F%A3%E5%88%92%E7%BA%BF"><span class="toc-text">4.2.5 在桌面窗口划线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-6-%E7%BB%98%E5%88%B6%E7%BA%BF%E6%9D%A1%E8%89%B2%E5%BD%A9"><span class="toc-text">4.2.6 绘制线条色彩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E7%94%BB%E5%88%B7"><span class="toc-text">4.3 画刷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E7%AE%80%E5%8D%95%E7%94%BB%E5%88%B7"><span class="toc-text">4.3.1 简单画刷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E4%BD%8D%E5%9B%BE%E7%94%BB%E5%88%B7"><span class="toc-text">4.3.2 位图画刷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-%E9%80%8F%E6%98%8E%E7%94%BB%E5%88%B7"><span class="toc-text">4.3.3 透明画刷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#static%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">static静态成员函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E7%BB%98%E5%88%B6%E8%BF%9E%E7%BB%AD%E7%BA%BF%E6%9D%A1"><span class="toc-text">4.4 绘制连续线条</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E7%BB%98%E5%88%B6%E6%89%87%E5%BD%A2%E6%95%88%E6%9E%9C%E7%BA%BF%E6%9D%A1"><span class="toc-text">4.5 绘制扇形效果线条</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%8A%E5%8F%8D%E6%80%9D-2"><span class="toc-text">问题及反思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-3"><span class="toc-text">参考文献</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0"><span class="toc-text">第五章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%8F%92%E5%85%A5%E7%AC%A6"><span class="toc-text">5.1 插入符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E5%88%9B%E5%BB%BA%E6%8F%92%E5%85%A5%E7%AC%A6"><span class="toc-text">5.1.1 创建插入符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%BD%A2%E6%8F%92%E5%85%A5%E7%AC%A6"><span class="toc-text">5.1.2 创建图形插入符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%AA%97%E5%8F%A3%E9%87%8D%E7%BB%98"><span class="toc-text">5.2 窗口重绘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-OnDraw%E5%87%BD%E6%95%B0"><span class="toc-text">5.2.1 OnDraw函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E6%B7%BB%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B5%84%E6%BA%90"><span class="toc-text">5.2.2 添加字符串资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E8%B7%AF%E5%BE%84%E5%B1%82"><span class="toc-text">5.3 路径层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5"><span class="toc-text">5.4 字符输入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%8F%9C%E5%8D%95"><span class="toc-text">第六章 菜单</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%9B%E5%BB%BA%E8%8F%9C%E5%8D%95%E9%A1%B9"><span class="toc-text">一、创建菜单项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%BA%E8%8F%9C%E5%8D%95%E9%A1%B9%E6%B7%BB%E5%8A%A0%E5%93%8D%E5%BA%94%E5%87%BD%E6%95%B0"><span class="toc-text">二、为菜单项添加响应函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9F%BA%E6%9C%AC%E8%8F%9C%E5%8D%95%E6%93%8D%E4%BD%9C"><span class="toc-text">三、基本菜单操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BA%86%E8%A7%A3%E8%8F%9C%E5%8D%95%E7%BB%93%E6%9E%84"><span class="toc-text">1、了解菜单结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%A0%87%E8%AE%B0%E8%8F%9C%E5%8D%95"><span class="toc-text">2、标记菜单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E9%BB%98%E8%AE%A4%E8%8F%9C%E5%8D%95%E9%A1%B9%EF%BC%88%E7%B2%97%E4%BD%93%EF%BC%89"><span class="toc-text">3、默认菜单项（粗体）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%9B%BE%E5%BD%A2%E6%A0%87%E8%AE%B0%E8%8F%9C%E5%8D%95"><span class="toc-text">4、图形标记菜单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E7%A6%81%E7%94%A8%E8%8F%9C%E5%8D%95%E9%A1%B9"><span class="toc-text">5、禁用菜单项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E7%A7%BB%E9%99%A4%E5%92%8C%E8%A3%85%E8%BD%BD%E8%8F%9C%E5%8D%95"><span class="toc-text">6、移除和装载菜单</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81MFC%E8%8F%9C%E5%8D%95%E5%91%BD%E4%BB%A4%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">四、MFC菜单命令更新机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%BF%AB%E6%8D%B7%E8%8F%9C%E5%8D%95"><span class="toc-text">五、快捷菜单</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%8A%A8%E6%80%81%E8%8F%9C%E5%8D%95%E6%93%8D%E4%BD%9C"><span class="toc-text">六、动态菜单操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%92%88%E5%AF%B9%E5%AD%90%E8%8F%9C%E5%8D%95%E7%9A%84%E5%8A%A8%E6%80%81%E6%93%8D%E4%BD%9C"><span class="toc-text">1、针对子菜单的动态操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%92%88%E5%AF%B9%E8%8F%9C%E5%8D%95%E9%A1%B9%E7%9A%84%E5%8A%A8%E6%80%81%E6%93%8D%E4%BD%9C"><span class="toc-text">2、针对菜单项的动态操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%BA-%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E7%9A%84%E8%8F%9C%E5%8D%95%E9%A1%B9-%E6%B7%BB%E5%8A%A0%E5%93%8D%E5%BA%94%E5%87%BD%E6%95%B0"><span class="toc-text">3、为  动态添加的菜单项  添加响应函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%AF%B9%E8%AF%9D%E6%A1%86%EF%BC%88%E4%B8%80%EF%BC%89"><span class="toc-text">第七章 对话框（一）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-text">1、基本知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E6%98%BE%E7%A4%BA"><span class="toc-text">2、创建和显示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E6%8C%89%E9%92%AE"><span class="toc-text">3、创建动态按钮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%8E%A7%E4%BB%B6"><span class="toc-text">4、对话框控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E6%96%87%E6%9C%AC%E6%8E%A7%E4%BB%B6"><span class="toc-text">1.静态文本控件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BC%96%E8%BE%91%E6%A1%86%E6%8E%A7%E4%BB%B6"><span class="toc-text">2.编辑框控件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%9A%84%E4%BC%B8%E7%BC%A9"><span class="toc-text">5、对话框的伸缩</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CWnd-SetWindowPos"><span class="toc-text">CWnd::SetWindowPos</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CWnd-GetDlgItem"><span class="toc-text">CWnd::GetDlgItem</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CWnd-SetDlgItemText"><span class="toc-text">CWnd::SetDlgItemText</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CWnd-GetWindowRect"><span class="toc-text">CWnd::GetWindowRect</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E8%BE%93%E5%85%A5%E7%84%A6%E7%82%B9%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-text">6、输入焦点的传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E9%BB%98%E8%AE%A4%E6%8C%89%E9%92%AE%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-text">7、默认按钮的说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%AF%9D%E6%A1%862"><span class="toc-text">第八章 对话框2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%80%83%E8%B7%91%E6%8C%89%E9%92%AE"><span class="toc-text">1、逃跑按钮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%B1%9E%E6%80%A7%E8%A1%A8%E5%8D%95%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">2、属性表单的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%90%91%E5%AF%BC%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">3、向导的创建</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AE%9A%E5%88%B6%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%A4%96%E8%A7%82"><span class="toc-text">第九章 定制应用程序外观</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%B7%A5%E5%85%B7%E6%A0%8F%E7%BC%96%E7%A8%8BToolBar"><span class="toc-text">4、工具栏编程ToolBar</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%8A%B6%E6%80%81%E6%A0%8FStatusBar"><span class="toc-text">5、状态栏StatusBar</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E8%BF%9B%E5%BA%A6%E6%A0%8F"><span class="toc-text">6、进度栏</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CProgressCtrl-Create-%E8%BF%9B%E5%BA%A6%E6%A0%8F%E7%B1%BBCProgressCtrl"><span class="toc-text">CProgressCtrl::Create&#x2F;&#x2F;进度栏类CProgressCtrl</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CProgressCtrl-SetPos"><span class="toc-text">CProgressCtrl::SetPos</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CStatusBar-GetItemRect"><span class="toc-text">CStatusBar::GetItemRect</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%9C%A8%E7%8A%B6%E6%80%81%E6%A0%8F%E4%B8%8A%E6%98%BE%E7%A4%BA%E9%BC%A0%E6%A0%87%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE"><span class="toc-text">7、在状态栏上显示鼠标当前位置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E7%BB%98%E5%9B%BE%E6%8E%A7%E5%88%B6"><span class="toc-text">十、绘图控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E5%8D%95%E7%BB%98%E5%9B%BE"><span class="toc-text">1、简单绘图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E5%AE%BD%E7%BA%BF%E5%9E%8B%EF%BC%88%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%AF%9D%E6%A1%86%EF%BC%89"><span class="toc-text">2、线宽线型（设置对话框）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E9%A2%9C%E8%89%B2%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-text">3、颜色对话框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%AD%97%E4%BD%93%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-text">4、字体对话框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%A4%BA%E4%BE%8B%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-text">5、示例对话框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%94%B9%E5%8F%98%E5%AF%B9%E8%AF%9D%E6%A1%86%E5%8F%8A%E5%85%B6%E6%8E%A7%E4%BB%B6%E7%9A%84%E8%83%8C%E6%99%AF%E5%92%8C%E6%96%87%E6%9C%ACWM-CTLCOLOR"><span class="toc-text">6、改变对话框及其控件的背景和文本WM_CTLCOLOR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E4%BD%8D%E5%9B%BE%E7%9A%84%E6%98%BE%E7%A4%BA"><span class="toc-text">7、位图的显示</span></a></li></ol></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js`,
    marked: `https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.27.0" async></script>

<!-- optional -->

  <script>
    function load_twikoo() {
        if (!document.querySelectorAll("#twikoo_container")[0]) return;
        utils.js('https://gcore.jsdelivr.net/npm/twikoo@1.6.8/dist/twikoo.all.min.js', {defer: true}).then(function () {
            const el = document.getElementById("twikoo_container");
            var path = el.getAttribute('comment_id');
            if (!path) {
                path = decodeURI(window.location.pathname);
            }
            twikoo.init(Object.assign({"js":"https://gcore.jsdelivr.net/npm/twikoo@1.6.8/dist/twikoo.all.min.js","envId":"https://hezexian-blogcommentsystem.hf.space"}, {
                el: '#twikoo_container',
                path: path,
            }));
        });
    }

    window.addEventListener('DOMContentLoaded', (event) => {
        load_twikoo();
    });
</script>



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"></script><script defer src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css`,
    js: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || null
        }
      });
    })
  }
</script><script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          loop: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
<script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
<script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"onload="renderMathInElement(document.body);"></script>
<script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/mermaid@v9/dist/mermaid.min.js"></script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    var mermaid_config = {
      startOnLoad: true,
      theme:
        "" == "auto" &&
          window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "neutral",
      logLevel: 3,
      themeVariables: {
        darkMode: true
      },
      flowchart: {
        useMaxWidth: false,
        htmlLabels: true,
        curve: "linear"
      },
      gantt: {
        axisFormat: "%Y/%m/%d"
      },
      sequence: {
        actorMargin: 50
      }
    }
    mermaid.initialize(mermaid_config);
  });
</script><script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
