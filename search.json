[{"title":"protues配置相关","path":"/2024/02/27/protues配置相关/","content":"问题遇到多种问题： Proteus仿真报错：未找到“LEDA.MDF” 第一次仿真成功，停止后，重新仿真终止，报一堆错。包括：[SPICE] TRAN: Timestep too small; initial timepoint: trouble with instance Q1等 解决以管理员身份运行protues： 在Windows操作系统中，你可以通过以下步骤将软件设置为默认以管理员身份运行： 找到应用程序的可执行文件：首先，找到你想要设置为默认以管理员身份运行的应用程序的可执行文件。通常，这些文件的扩展名为.exe。 右键单击可执行文件：在文件资源管理器中，找到应用程序的可执行文件，然后右键单击它以显示上下文菜单。 选择“属性”：在上下文菜单中，选择“属性”选项。这将打开应用程序的属性对话框。 切换到“兼容性”选项卡：在属性对话框中，切换到“兼容性”选项卡。 勾选“以管理员身份运行此程序”：在“兼容性”选项卡下方，你会看到一个复选框，标有“以管理员身份运行此程序”。勾选这个复选框以激活管理员权限。 保存更改：点击“应用”或“确定”按钮，然后关闭属性对话框。现在，每次运行这个应用程序时，Windows都会提示你是否要以管理员身份运行它。如果你选择是，程序将以管理员权限运行。","tags":["嵌入式","protues"],"categories":["随笔","嵌入式"]},{"title":"platformio配置问题","path":"/2024/02/26/platformio配置/","content":"P1_0,__sfr等报错：未定义参考链接 c_cpp_properties.json中defines添加： 1234&quot;__interrupt(IntelliSense_Hack)=&quot;,&quot;__sfr=unsigned char&quot;,&quot;__sbit=int&quot;,&quot;__at(a)= &quot; 生成.hex文件 项目根目录添加extra_script.py 123456789Import(&quot;env&quot;)env.AddPostAction( &quot;$BUILD_DIR/$&#123;PROGNAME&#125;.elf&quot;, env.VerboseAction(&quot; &quot;.join([ &quot;$OBJCOPY&quot;, &quot;-O&quot;, &quot;ihex&quot;, &quot;-R&quot;, &quot;.eeprom&quot;, &quot;$BUILD_DIR/$&#123;PROGNAME&#125;.elf&quot;, &quot;$BUILD_DIR/$&#123;PROGNAME&#125;.hex&quot; ]), &quot;Building $BUILD_DIR/$&#123;PROGNAME&#125;.hex&quot;)) platformio.ini追加 1extra_scripts = extra_script.py 重新编译即可","tags":["环境配置","嵌入式","platformio"],"categories":["随笔","嵌入式"]},{"title":"通过代码配置PlatformIO生成HEX文件","path":"/2024/02/24/通过代码配置PlatformIO生成HEX文件/","content":"**原文链接 ** 如果要通过串口给51或者32等单片机烧写程序，很多时候需要HEX文件。Keil软件中就有输出HEX文件的设置，勾选一下就行，但是，PlatformIO好像还没这么方便的操作，下面我以STM32工程为例，介绍一下如何通过代码配置PlatformIO生成HEX文件。 首先，在工程目录下新建extra_script.py文件（和platformio.ini在同一目录下），代码如下： 123456789Import(&quot;env&quot;)env.AddPostAction( &quot;$BUILD_DIR/$&#123;PROGNAME&#125;.elf&quot;, env.VerboseAction(&quot; &quot;.join([ &quot;$OBJCOPY&quot;, &quot;-O&quot;, &quot;ihex&quot;, &quot;-R&quot;, &quot;.eeprom&quot;, &quot;$BUILD_DIR/$&#123;PROGNAME&#125;.elf&quot;, &quot;$BUILD_DIR/$&#123;PROGNAME&#125;.hex&quot; ]), &quot;Building $BUILD_DIR/$&#123;PROGNAME&#125;.hex&quot;)) 然后，在VS Code左侧项目列表打开platformio.ini文件，在最后一行增加如下代码： 1extra_scripts = extra_script.py 我的platformio.ini完整如下： 123456[env:genericSTM32F103C8]platform = ststm32board = genericSTM32F103C8framework = arduinoextra_scripts = extra_script.py OK，配置完成，可以点击VS Code底部的“对勾”按钮进行编译了，编译成功就会生成HEX文件，生成路径如下：","tags":["环境配置","嵌入式","platformio"],"categories":["随笔","嵌入式"]},{"title":"qt程序打包发布，含三方库","path":"/2024/02/19/Qt程序打包发布，含第三方库/","content":"原文链接 1、在Qt里选择release构建。 2、点击run运行，保证程序能够成功运行出来。 3、成功能运行后，去构建成功的build release文件夹下找到刚刚编译后的.exe文件。 4、单独复制出来到一个新文件夹model，复制进去。 5、在qt程序找到如下，构建的时候选择64位，现在打包编译也是需要64位，一一对应，不能混32位。 6、点击，命令执行进入到刚刚创建的文件夹下。 7、执行windeployqt jie_mian1.exe，也就是windeployqt+你自己刚刚编译后的程序名称.exe。 8、此时已经在model文件下qt依赖库已经安装好了，直接点击就可以运行。但是如果含有第三库.dll，点击会提示找不到，所以这时候把.dll拷贝到model文件夹下，即可。 9、把缺少的第三方库拷贝到model文件夹下和qt依赖库放一起，即可打开，因为原来在qt上debug的时候，第三方库也是放在build debug文件夹下的，所以debug模式编译时候能找到。 10、打开打包软件。用 Enigma Virtual Box软件。没有的同学，自己要去网上下载一个。 11、点击浏览，选择要打包的.exe文件。 12、点击文件选项，勾选压缩文件。 13、点击左下角添加，选择按文件递归。 14、选择刚刚的model文件夹，点击确定。 15、选择默认，确定即可。 16、最后看到下图，最后点击打包即可。 17、打包成功之后在刚刚设置的输出目标目录会出现打包好的XXXXX_boxed.exe应用程序，这个程序就是可以直接完全打包好的，点击即用。","tags":["qt"],"categories":["随笔","Qt"]},{"title":"vmware安装过增强工具还是无法拖放","path":"/2024/02/19/vmware安装过增强工具还是无法拖放/","content":"vmware安装过增强工具还是无法拖放 还需安装： 1sudo apt install open-vm-tools-desktop","tags":["环境配置","虚拟机","vmware"],"categories":["随笔","虚拟机"]},{"title":"1panel+雨云服务器+https配置lsky-pro（兰空图床）","path":"/2024/02/15/lsky+1panel+https+雨云配置/","content":"前言：摸了两天终于在自己的服务器配置了图床，根据回忆记录一下，大致是这样。 1 在1panel下载lsky 2 登录lsky2.1 创建一个数据库 2.2 浏览器新建标签页 在浏览器地址栏输入服务器地址:lsky服务端口 等待环境检测 -&gt; 下一步 配置数据库 ip修改为服务器的公网ip 数据库连接端口不用改 后面根据下图修改 安装完成后，使用管理员账户登录 此后就可以使用http://服务器地址:lsky服务端口登录图床了 上传一张图片，默认是：http://服务器地址:lsky服务端口/i/图片名查看图片 3 配置图床 更改保存文件格式 图床空间大小等 图像设置为公开 参考： 配置lsky 4 https4.1 创建雨云二级域名 参考，假设创建的域名为kekepiclsky.skyman.cloud 添加cname解析，以腾讯云为例： 设主机记录栏填写（假设lsky）， 记录类型栏须cname；记录值须为雨云二级域名，此处为kekepiclsky.skyman.cloud 4.2 添加ssl 在雨云ssl证书中心-&gt;自己的域名.xxx.xxx（例：lsky.hekeke.top，我的主域名为hekeke.top）-&gt;立即创建-&gt;复制主机名和记录值 参考雨云ssl证书，以在4.1节图中第一行所示，主机记录值填_acme-challenge.自己的域名（例：_acme-challenge.lsky），记录值复制进去，点击确认 等2分钟，点击我已完成解析 4.3 反向代理 在域名管理中，找到申请ssl的域名，复制查看&amp;下载中的文本 进入网站配置，点击https，选择手动导入，将上一步复制的文本导入（要对应），保存 4.4 修改访问网址浏览器地址栏输入服务器地址:lsky端口进入控制面板 点击存储策略，修改访问网址 将原来的http://服务器地址:lsky端口/i改为https//example.com/i（例：https://lsky.hekeke.top/i） 4.5 图像https可访问从 http:&#x2F;&#x2F;服务器ip:lsky端口&#x2F;i&#x2F;picture&#x2F;202402151108204.png 变为 https://lsky.hekeke.top/i/picture/20240215118204.png 5 picgo点击此链接获取配置lsky-picgo的方法；token的获取方法如下面的连接所示 注意token的获取方式，不是从‘接口-验证方式’直接复制，参考readme 123curl --location --request POST &#x27;https://your.domain/api/v1/tokens&#x27; \\--form &#x27;email=&quot;your_email@address&quot;&#x27; \\--form &#x27;password=&quot;your_passwd&quot;&#x27; 参考文献[1] 配置lsky [2] 参考雨云ssl证书 [3] picgo 兰空图床插件","tags":["环境配置","hexo","博客"],"categories":["随笔","hexo"]},{"title":"emit和connect的顺序问题","path":"/2024/01/31/emit和connect的顺序/","content":"问题下述代码，无论如何都进不到槽函数MonoCalibrate::calibrate里面 1234567QThread *caliThread = new QThread(this);MonoCalibrate *monocali = new MonoCalibrate(m_res_ckbd);monocali-&gt;moveToThread(caliThread);caliThread-&gt;start();emit monocali-&gt;startCalibration();connect(monocali,&amp;MonoCalibrate::startCalibration,monocali,&amp;MonoCalibrate::calibrate); 解决需要先连接（connect）再发射信号（emit）： 在连接信号和槽函数之前就发出了信号，将导致信号连接无效，因为在连接之前，没有接收槽函数的对象。 为了解决这个问题，可以将信号发出的代码移到连接之后。这样，当信号被发出时，槽函数已经连接并准备好执行 1234567891011qDebug() &lt;&lt; QThread::currentThread();QThread *caliThread = new QThread(this);MonoCalibrate *monocali = new MonoCalibrate(m_res_ckbd);monocali-&gt;moveToThread(caliThread);caliThread-&gt;start();connect(monocali, &amp;MonoCalibrate::startCalibration, monocali, &amp;MonoCalibrate::calibrate);// 在连接之后发出信号emit monocali-&gt;startCalibration();","tags":["qt"],"categories":["随笔","Qt"]},{"title":"hexo在butterfly/next主题下代码块缩进问题","path":"/2024/01/25/hexo代码块缩进问题/","content":"问题遇到了一个问题：hexo的butterfly、next主题下，代码块缩进特别大。 对比发现，当缩进为一个tab时才会出现问题。当缩进为4个空格时，则表现正常。 原因hexo的next主题(v 8.5)编译之后代码块缩进特别大，怎么调整？ - Mr.J的回答 - 知乎 文中说， 可能原因，你缩进使用了tab，在HTML下，默认等于8个空格，建议修改为空格缩进，或者修改tab-size属性 把vscode的缩进改成空格就好了。 可是，我的文章已经写了上万字，逐个修改显然不可能实现。 解决办法hexo根目录/_config.yml第50行(若没改过的话)，tab_replace改为四个空格，如下： 123456highlight: line_number: true auto_detect: false tab_replace: &#x27; &#x27; wrap: true hljs: false 问题解决。","tags":["环境配置","hexo","博客"],"categories":["随笔","hexo"]},{"title":"C++ Primer","path":"/2024/01/08/C++Primer/","content":"前言 固然，轻薄短小的书籍乍见之下让所有读者心情轻松，但如果舍弃太多应该深入的地方不谈，也难免令人行止失据，进退两难。 …… 作为一个好的学习者，背景不是重点，重要的是，你是否具备正确的学习态度。起步固然可从轻松小品开始，但如果碰上大部头巨著就退避三舍、逃之夭夭，面对任何技术只求快餐速成，学语言却从来不写程序，那就绝对没有成为高手乃至专家的一天。 有些人的学习，自练就一身钢筋铁骨，可以在热带丛林中披荆斩棘，在莽莽草原中追奔逐北。有些人的学习，既未习惯大部头书，也未习惯严谨格调，更未习惯自修勤学，是温室里的一朵花，没有自立自强的本钱。 ——《Essential C++》前言，侯捷 参考资料[1] C++ 标准库参考 (STL)—Microsoft [2] cplusplus.com [3] stl—wiki ------C++ 基础------ 二 变量和基本类型2.1 基本内置类型2.1.1 变量类型的大小下图列出了各类型的最小尺寸。 2.1.2 符号 整型 int：正数、负数和0 usigned int: 大于0 字符型 char :在有些机器上是signed，有些机器是unsigned signed char unsigned char 如何选择？ 明知数值不可能为负，用无符号 整数运算用int、long long 浮点用double 2.1.3类型转化 :question:有个不明白的地方，不明白怎么算的:(P33)赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。 当一个算术表达式中既有无符号又有int，int就会转换成无符号，有可能引发错误。 &lt;-混用引发错误 2.2 字面值常量 整型和浮点型 自动选择能匹配的空间最小的一个作为其数据类型 十进制不会是负数。符号不在字面值之内，负号的作用是对字面值取负 科学计数法指数部分用E或e标识 字符和字符串字面值 123456&#x27;a&#x27; // 字符, &#x27;a&#x27;&quot;a&quot; // 字符串，&#x27;a&#x27;+&#x27;\\0&#x27;// 当两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则实际上是一个整体std::cout&lt;&lt; &quot;a really, really long string literal &quot; &lt;&lt;&quot;that spans two lines&quot; &lt;&lt;std::endl; 转义常用转义字符 布尔和指针 bool ：true ，false 指针：nullptr 如何指定字面值类型？ 通过添加下表的前缀和后缀，改变整型、浮点型和字符型字面值的默认类型 2.3 变量2.3.1 了解变量 定义 初始化 初始化不是赋值： 初始化是创建变量时赋予其一个初始值； 赋值是把对象的当前值擦除，而以一个新值替代。 四种初始化方式 12345678// 可能有信息丢失的风险long double b = 3.1415929int a = b; // a = 3, 信息丢失int a(b); // a = 3// 使用列表初始化，存在上述风险将报错int a = &#123;b&#125;;int a&#123;b&#125;; 默认初始化 内置类型默认初始化的值由定义的位置决定 定义与任何函数体之外 ，初始化为0 …内，不被默认初始化，变量值未定义 建议初始化每一个内置类型的变量 声明和定义的关系 声明使得名字为程序所知；定义负责创建与名字关联的实体，并申请存储空间。 只能被定义一次，可以被声明多次。 如果想声明一个变量而非定义，使用extern，并且不要显示地初始化： 12extern int i; //仅声明int i ; //声明并定义 在函数体内部，初始化一个又extern标记的变量，将引发错误。 1extern int i = 3.14; //错误 如果要在多个文件中使用同一个变量，必须将声明和定义分离。变量的定义必须出现且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。例， 1234567891011121314151617181920212223242526//main.cpp#include &lt;iostream&gt;#include &quot;Class2.h&quot;using namespace std;int main()&#123; Class2::print_i(); // 重点输出：Class2: 5 return 0;&#125;//Class2.hpp#pragma once#include &lt;iostream&gt;using namespace std;extern int i; // &lt;- 注意这里，如果不写就会报：i未声明标识符class Class2&#123;public: static void print_i() &#123; cout &lt;&lt; &quot;Class2: &quot;&lt;&lt;i &lt;&lt; endl; &#125;&#125;;//Class2.cpp#include &quot;Class2.h&quot;int i = 5; 标识符 用户自定义标识符中不能连续出现两个下划线；不能下划线紧邻大写字母；定义在函数体外的标识符不能以下划线开头。 变量名一般小写字母；类名以大写字母开头 2.3.2 作用域对于嵌套作用域： 作用域中一旦声明了某个名字，它所嵌套着的所有作用域都能访问这个名字。 同时，允许在内层作用域中重新定义外层作用域中已有的名字。 ::访问全局变量。 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int a = 42;int main()&#123; int b = 0; cout &lt;&lt; a &lt;&lt; &quot;,&quot; &lt;&lt; b &lt;&lt; endl; //42,0 int a = 0; cout &lt;&lt; a &lt;&lt; &quot;,&quot; &lt;&lt; b &lt;&lt; endl; //0,0 cout &lt;&lt; ::a &lt;&lt; &quot;,&quot; &lt;&lt; b &lt;&lt; endl;\t//42,0 return 0;&#125; 2.4 复合类型 声明语句：一条语句声明由一个基本数据类型和紧随其后的声明符列表组成。 指针和引用，前后的类型都要严格匹配 2.4.1 引用 引用必须被初始化，且只能绑定到对象上，不能与字面值或某个表达式的计算结果绑定； 无法令引用重新绑定到另一个对象； 引用本身不是对象，所以不能定义引用的引用 2.4.2 指针 指针本身是一个对象； 无须在定义时赋初值； 引用不是对象，没有实际地址，不能定义指向引用的指针；但指针是对象，存在对指针的引用，例： 12int *p;int *&amp;r = p; // r是对指针p的引用 注：上面的代码如何阅读？从又向左阅读r的定义，离变量名最近的符号（此处为&amp;）对变量的类型有直接的影响，因此上文中r是一个引用。 void *可用于存放任意对象的地址，我们不清楚其到底指向的是什么类型的对象，也无法访问其指向的内存空间中的对象。 123double a = 3.14;void *ptr = &amp;a;cout&lt;&lt;*ptr&lt;&lt;endl; //报错 定义多个变量时，类型修饰符（如 *）只修饰一个变量，对该声明语句中的其他变量，不产生任何作用。例， 12345// 这样写容易产生误导int* p1,p2; // p1是指向int的指针，p2是int// 建议写成int *p1, p2; 2.5 const const的宗旨：任何试图改变const修饰的变量都将引发错误 const对象一旦创建就不能改变，因此必须初始化，初始值可以是任意复杂表达式 默认状态下，const对象仅在文件内生效。如果想要在多个文件中共享，最好的办法是不管是声明还是定义都加上extern关键字。 2.5.1 常量引用 即对const的引用 初始化常量引用允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。例： 1234double a = 3.14;//const int temp = a; // &lt;-编译器内部自己做的操作,生成一个临时变量//const int &amp;r = temp; //&lt;-编译器内部自己做的操作，将引用绑定到一个临时变量上const int &amp;r = a; //正确 const的左值引用可以绑定到右值右值引用 123int i = 42;int &amp;r = i*42; // 错误，左值引用不可绑定到右值const int &amp;r = i*42; // 正确，const的左值引用可以绑定到右值 2.5.2 指针和const 指针常量 – 指向常量的指针 想要存放常量对象的地址，只能使用指向常量的指针； 12const double pi = 3.14;const double *cptr = &amp;pi; 允许一个指向常量的指针指向非常量对象。 常量指针 – 指针本身是一个常量 把*放在const之后，用以说明指针是一个常量 12int a = 0;int *const ptr = &amp;a; 2.5.3 顶层const和底层const 顶层const表示指针本身是一个常量。推广：任意的对象是常量，如算术类型、类、指针… 底层const表示指针所指的对象是常量。推广：指针和引用等复合类型的基本类型部分有关。 当执行拷贝时， 顶层const不受影响； 底层const对象必须具有相同的const资格，或者两个对象的数据类型必须能够转换。 2.5.4 常量表达式和constexpr 常量表达式 常量表达式是指：值不会改变 且 在编译过程就能得到计算结果 的表达式 一个对象是不是常量表达式有其数据类型和初始值共同决定 12345678910111213141516/*********** 例1 **************/const int mf = 20;const int limit = mf +1;/*********** 例2 **************/#include &lt;iostream&gt;using namespace std;int get_size() &#123; return 1; &#125;int main()&#123; const int sz = get_size(); // 通过 cout &lt;&lt; sz &lt;&lt; endl; // 输出1 return 0;&#125; constexpr – 由编译器来验证变量是否是一个常量表达式。声明为constexpr的变量: 一定是一个常量 必须用常量表达式初始化 12345678910111213141516171819/*********** 例1 **************/constexpr int mf = 20;constexpr int limit = mf +1;/*********** 例2 **************/#include &lt;iostream&gt;using namespace std;//int get_size() &#123; return 1; &#125; //C++表达式必须含有常量值,无法调用非constexpr函数 //const int get_size() &#123; return 1; &#125; //同上constexpr int get_size() &#123; return 1; &#125;int main()&#123; constexpr int sz = get_size(); cout &lt;&lt; sz &lt;&lt; endl; // 输出1 return 0;&#125; 字面值类型 算术类型、引用和指针都属于，可被定义为constexpr； 注意： 引用和指针初始值受限：必须是0或者nullptr，或者存储于某个固定地址中的对象。函数提内的对象一般不在固定地址，不能用constexpr；允许函数定义的一类超出函数体本身的变量，其存在于固定地址，constexpr引用（指针）也能（绑定）指向该变量。 constexpr定义了一个指针，constexpr仅对指针本身有效，对指针所指的对象无关 &lt;-顶层const。 123456789constexpr int *q = nullptr;// 类似int *const q = nullptr;//----------------------------------//可得constexpr const int *p = nullptr;// 类似const int *const p = nullptr; io、string等不属于字面值类型 constexpr函数（笔记6.5.3） constexpr类（笔记7.4.2） 2.6 处理类型2.6.1 类型别名 typedef 12typedef double wages;typedef wages base, *p; //base = double, p = double * using 1using wages = double; 需要注意的是，类型别名不能直接往代码中替换，要将类型别名看成一个整体： 12345typedef char *pstring; //pstring = char *const pstring cstr = 0; // 指针本身是一个常量，char *const cstr = 0//直接替换是错误的：const char *cstr = 0; //指向常量的指针 2.6.2 auto auto定义的变量必须有初始值 编译器以引用对象的类型作为auto的类型（auto会忽略引用） 12int i = 0, &amp; r = i;auto a = r; // auto = int auto一般会忽略掉顶层const，保留底层const。想要保留顶层const，则需要手动指出 12345678int i = 0;const int ci = i, &amp; cr = ci;auto b = ci; //int (顶层const)auto c = cr; //int （顶层const）auto d = &amp;i; //int * （顶层const）auto e = &amp;ci; //const int * （底层const）const auto f = ci; //const int (为保留顶层const而手动指出) auto和引用 1234auto &amp;g = ci; //g 的类型为const int &amp;//auto &amp;h = 42; //错误，不能为非常量引用绑定字面值const auto &amp;h = 42; //const int &amp; 利用auto在一条语句中声明多个变量时，这多个变量的初始值必须是同一类型。 2.6.3 decltype 选择并返回操作数的数据类型 – 编译器分析表达式并得到其类型，却不计算其值 1decltype(func()) sun = x; 如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用）&lt;-区别于auto 123const int ci = 0, &amp;cj = ci;decltype(ci) x= 0; // const intdecltype(cj) y = x; //const int &amp; decltype和引用 123456789int i = 42, *p = &amp;i, &amp;r = i;decltype(r+0) b;//decltype(*p) c; //出错，“引用变量c需要初始值设定项”decltype(*p) c = i; //c的类型是int &amp;decltype(i) d; // intdecltype((i)) e = i; //int &amp; decltype(r)的结果是引用，如果想让结果类型是r所指的类型，只需把r作为表达式的一部分，如decltype(r+0) decltype表达式的类型是解引用操作，将得到引用类型，因此必须初始化，如decltype(*p) c = i; decltype((variable)) （注意是双层括号）的结果永远是引用类型 三 字符串、向量和数组3.1 using 每个名字都需要独立的using声明 1using std::cout; using std::endl; 注意：头文件中不应包含using &lt;-否则，每个使用该头文件的代码都会包含该声明，从而引起命名的冲突。 3.2 string[笔记9.6 - string专题](# 9.6 string专题) 3.2.1 初始化 拷贝初始化。string s = &quot;a&quot;; 直接初始化。string s(&quot;a&quot;); 笔记9.6.2 其他初始化string的方法 3.2.2 string对象的操作 读写 读取操作时，string对象会自动忽略开头的空白，并从真正的第一个字符开始读起，直到遇到下一个空白。 1234567891011//输入&quot; hello world&quot;;string s;cin&gt;&gt;s;cout&lt;&lt;s&lt;&lt;endl; //hellostring s1,s2;cin&gt;&gt;s1&gt;&gt;s2;cout &lt;&lt; s1&lt;&lt;s2&lt;&lt;endl; //helloworld//endl 结束当前行，刷新缓冲区 读取未知数量的string对象 123string s;while(cin&gt;&gt;s)&#123; //遇到文件结束标记或非法输入，循环结束&#125; 读取一整行 12string line;while(getline(cin,line))&#123;&#125; getline从给定的输入流中读取内容，直到遇到换行符为止（换行符也被读取进来了），将内容存入string对象中（不存换行符）。 如果一开始就是换行符，则得到空的string对象。 和cin一样返回流参数，因此可作为循环的判断条件 size size()返回一个string::size_type类型的值，是一个无符号类型的值，因此要避免与有符号数混用所带来的问题。 相加当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符两侧的运算对象至少有一个是string. 14.1最后一点，operator+在string类中为非成员 123456789101112string s = &quot;hello&quot;;string s1 = s+&quot;,&quot;; //正确string s2 = &quot;hello&quot;+&quot;,&quot;; // 错误string s3 = s+&quot;,&quot;+&quot;hello&quot;; //正确//等价于string s3 = (s+&quot;,&quot;)+&quot;hello&quot;;//等价于string tmp = s1+&quot;,&quot;;string s3 = tmp+&quot;hello&quot;;string s4 = &quot;hello&quot;+&quot;,&quot;+s; //错误 3.2.3 处理string对象中的字符 处理函数 范围for 注意declaration是引用时，是直接对experssion中原来的元素进行操作 123for(declaration : experssion)&#123; statement&#125; 下标运算符（[ ]）接收的输入是string::size_type类型的值，返回值是该位置上字符的引用。 str[str.size()-1]是最后一个字符 在访问指定字符之前，需要检查字符串是否为空：if(!str.isempty())&#123; /*访问指定字符*/&#125;，并注意下标的合法范围[0 , str.size())。 3.3 vector3.3.1 初始化vector对象 使用拷贝初始化（&#x3D;）只能提供一个初始值； 类内初始值只能使用拷贝初始化或使用花括号形式的初始值； 列表初始化使用{}，而不是() 值得注意的是 12vector&lt;string&gt; v1&#123;10&#125;; // 10个默认初始化的元素vector&lt;string&gt; v2&#123;10,&quot;hi&quot;&#125;; // 10个值为hi的元素 以上两者都不是列表初始化，花括号的值必须与元素类型相同，显然不能用int初始化string对象，因此上面两者的花括号中都不能作为元素的初始值。在无法执行列表初始化后，编译器会尝试用默认值初始化vector对象。 3.3.2 vector操作 添加元素 – push_back() 在定义vector对象的时候设定其大小就没什么必要了，事实上如果这么做性能可能更差 vector其他操作罗列 注意size()同样返回vector&lt;xxx&gt;::size_type类型 要使用size_type类型，需要首先指定它是由哪些类型定义的 只有当元素的值可比时，vector对象才能被比较：元素个数相等，对应位置的元素也相等 3.3.3 迭代器 用法 在for循环中使用!=，原因是c++程序员更愿意使用迭代器而非下标。并非所有的容器的迭代器都定义了&lt;等，但都定义了==和!= 迭代器的类型 – iterator和const_iterator（只读） 如果迭代器对象是一个常量，则只能用const_iterator 不是常量，则都能用 begin和end、cbegin和cend 它们返回的具体类型由对象是否是常量决定，如是常量返回const_iterator，否则返回iterator 如果只需读取，而不写入，可使用cbegin和cend，返回const_iterator 123456vector&lt;int&gt; v;const vector&lt;int&gt; cv;auto it1 = v.begin(); // vector&lt;int&gt;::iteratorauto it2 = cv.begin(); // vector&lt;int&gt;::const_iteratorauto it3 = v.cbegin(); // vector&lt;int&gt;::const_iterator 使vector迭代器失效的操作： 在范围for循环中向vector对象添加元素 任何一种可能改变vector对象的操作，如push_back 运算 迭代器相减的结果的类型：difference_type的带符号整型数 3.4 数组3.4.1 定义和初始化数组 定义 编译的时候维度必须是已知的，维度必须是一个常量表达式（constexpr） 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值 不许用auto指定数组； 不存在引用的数组 初始化 显式地初始化数组 列表初始化时，可不写维度，编译器会自动推测 指明维度后，初始值数量不应超过维度大小 字符数组的特殊性 – 注意字符串结尾的空字符也会被拷贝到数组中 123char a3[] = &quot;c++&quot;; // 维度为4// 相当于char a3[] = &#123;&#x27;c&#x27;,&#x27;+&#x27;,&#x27;+&#x27;,&#x27;\\0&#x27;&#125;; 数组不允许拷贝和赋值 123int a[] = &#123;0,1,2&#125;;int a2[] = a; // 错误a2 = a; // 错误 复杂的数组声明 1int (*parray)[10] = &amp;arr; 从数组名开始，由内向外，由右向左 –&gt;parray是一个指针，指向大小为10的数组，数组中包含int对象 在使用数组下标时，通常将其定义为size_t类型，它是一种无符号整型，定义于cstddef中 两个特殊性质 不允许拷贝数组 使用数组时通常会将其转化成指针 3.4.2 指针和数组 数组名是指向数组首元素的指针 auto推断得到的类型是指针 12int ia[] = &#123;0,1,2&#125;;auto ia2(ia); // auto == int * 使用decltype时，返回的类型是数组 &lt;– 与auto区分 12decltype(ia) ia3 = &#123;0,1,2,3&#125;;ia3[1] = 5; “迭代器” 获取数组的“尾后迭代器” &lt;–不能对尾后指针进行解引用或者递增 1int *e = &amp;arr[/*元素个数*/]; 然而这种方法极易出错，c++11在iterator头文件中定义了两个函数begin和end，它们分别返回头指针和尾指针，用法如下 1234#include &lt;iterator&gt;int ia[] = &#123;0,1,2,3&#125;;int *begin = begin(ia); // 正确的使用形式是将数组作为它们的参数int *end = end(ia); 两个指向同一数组不同元素的指针相减得到它们之间的距离，类型为ptrdiff_t，定义于cstddef,为带符号类型。[（对比3.3.3节-运算-两个迭代器相减的结果类型）](#3.3.3 迭代器) 与vector与string等标准库下标运算仅支持无符号数不同，数组的下标运算（内置下标运算）支持负数 1234int a[] = &#123;0,1,2,3&#125;;int *p = &amp;a[2];int j = *(p+1); // j = a[3]int k = p[-2]; //k = a[0] 3.4.3 多维数组 严格来说，c++没有多维数组，所说多维数组其实是数组的数组。谨记这一点，对今后理解和使用多维数组大有裨益。 int arr[3][4]: 大小为3的数组，每个元素是含有4个整数的数组 初始化 1234567891011int ia[3][4] = &#123;&#123;0,1,2,3&#125;, &#123;4,5,6,7&#125;, &#123;8,9,10,11&#125;&#125;;//等价int ia[3][4] = &#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;;//----------------------------------------//初始化每行首元素int ia[3][4] = &#123;&#123;0&#125;,&#123;4&#125;,&#123;8&#125;&#125;;//不等于int ia[3][4] = &#123;0,4,8&#125;; 下标和多维数组 略 范围for处理多维数组 12345for(const auto &amp; row :ia)&#123; &lt;--注意此处一定为 引用，原因如下所述 for(auto col :row)&#123; cout&lt;&lt;col&lt;&lt;endl; &#125;&#125; auto会将数组自动转成指针 （3.4.2节-auto推断得到…），row的类型就成了int *，怎么可能再进行内层循环呢？ 指针和多维数组 多维数组名 ：指向第一个内层数组的指针 12345for(auto p = begin(ia); p!=end(ia); p++)&#123; for(auto q = begin(*p); q != end(*p); q++)&#123; /*...*/ &#125;&#125; 参考资料 数组大小可省略的定义 – 努力学习游泳的鱼 3.4.4 与旧代码接口 C风格字符串 c++程序中最好不要使用 传入上述函数的指针必须指向以空字符串作为结束的数组 string和c风格字符串 任何出现字符串字面值的地方都可以用 以空字符结束的字符数组 替代 允许用…来初始化string对象或为string对象赋值 允许作为加法运算中的一员（P111） 但是，不能反过来用string对象直接初始化指向字符数组的指针， string.c_str()返回一个指向以空字符结束的字符数组的指针（char *），数组存放的数据恰好与string对象一样； 但如果后续操作改变string，之前返回的字符数组将会失效 使用数组初始化vector 允许使用数组来初始化vector对象，只需指明首元素地址和尾后地址 123int arr[] = &#123;0,1,2,3,4,5&#125;;vector&lt;int&gt; ivec1(begin(arr),end(arr)); //&#123;0,1,2,3,4,5&#125;vector&lt;int&gt; ivec2(arr+1,arr+3); //&#123;1,2&#125; &lt;--不包含rr[3] 四 表达式4.1 基础 小整数类型（bool、char、short等）通常会被提升成较大的整数类型，主要是int 运算符重载时，运算对象的个数、运算符的优先级和结合律都是无法改变的 左值和右值 &lt;– 有些迷惑（P121，2024&#x2F;1&#x2F;13）:question: 左值表示一个占据内存中可识别位置的一个对象，更进一步地，可以对左值取地址 判断右值的一个简单方法就是能不能对变量或者表达式取地址，如果不能，他就是右值 参考文献 左值与右值 – 不摆烂的zzz 求值顺序 对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。 求值顺序与优先级和结合律无关（P123底部） &lt;–拿不准的时候用括号来强制符合要求 12如，int i = f()+g()*h()+j()这些函数的调用顺序没有明确的规定，如果它们互不相关，则无妨。如果其中某几个函数影响同一个对象，则将会产生未定义行为 这4种运算符明确规定了运算对象的求值顺序：&amp;&amp;, ||, ?:, , 例外情况：当 改变运算对象的子表达式本身 就是 另一个子表达式的运算对象 ，则没有什么影响：如*++iter，递增运算先发生（改变运算对象的子表达式）,解引用后发生。 4.2 运算符本节运算符表都是按照优先级顺序将其分组，同优先级按照从左到右的顺序。 4.2.1 算术运算符 算术对象和求值结果都是右值 小整数的对象被提升成较大整数 一元正号、加法、减法运算符都能作用于指针 一元正（负）号，（负数将运算对象值取负后）返回对象值的一个（提升后的）副本 c++11规定商一律向0取整 %返回两个整数相除所得的余数 如果m%n!=0,结果符号与m相同 4.2.2 逻辑和关系运算符 关系运算符作用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型。 返回值都是布尔类型，运算结果和求值对象都是右值 因为关系运算法的求值结果是布尔类型，所以将几个关系运算符连写在一起会产生意想不到的效果 4.2.3 赋值运算符 赋值运算符的左侧运算对象必须是一个可修改的左值 右侧运算对象将转换成左侧运算对象的类型 4.2.4 递增、递减运算符 ++、--运算符必须作用于左值运算对象，前置版本将对象本身作为左值返回，后置版本将对象原始值的副本作为右值返回 除非必须，否则不用递增递减运算符的后置版本 &lt;– 额外增加开销（P132） 如果一个子表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话，运算对象的求值顺序就很关键了 12//P133*beg = toupper(*beg++); // 未定义行为 4.2.5 成员访问运算符12ptr-&gt;mem;(*ptr).men; 解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上()：(*ptr).men 箭头运算符作用于一个指针类型的对象，结果是一个左值。点运算符分成两种情况：如果成员所属的对象是左值，那么结果是左值；反之，如果成员所属的对象是右值，那么结果是右值。 4.2.6 条件运算符1condition ? expr1 : expr2; 当条件运算符的两个表达式都是左值或者能转换成同一类左值类型时，运算结果是左值，否者，运算结果是右值。 可嵌套，最好别超过2到3层，如 1cond1?expr1:cond2?expr2:expr3; 满足右结合律，右边的条件运算构成了靠左边条件运算的分支。上述代码实际为例。 1cond1 ? expr1 : (cond2?expr2:expr3) // &lt;--从右边开始结合，括号中的是分支 条件运算符的优先级非常低，当一条长表达式中嵌套了条件运算子表达式时，通常需要在其两端加上括号 4.2.7 位运算符 位运算符整数类型的运算对象，并且把运算对象看成二进制位的集和 如果运算对象是“小整型”，则它的值将会被自动提升为较大的整数类型。 —— 先提升，再对提升后的整体进行位运算 不同机器对于符号位的处理各不相同，因此建议位运算符仅用于处理无符号类型 移位运算符 &lt;&lt;、&gt;&gt;的右侧的运算符一定不能为负，并且值严格小于结果的位数 满足左结合律 123cout &lt;&lt; &quot;hi&quot;&lt;&lt;&quot;three&quot;&lt;&lt;endl;//等价于( (cout&lt;&lt;&quot;hi&quot;) &lt;&lt; &quot;three&quot; ) &lt;&lt;endl; 示例 位求反运算符 略 位与、位或、位异或 异或 ：不同出1，相同处0 4.2.8 sizeof运算符 sizeof返回一条表达式或一个类型名字所占的字节数，满足右结合律，得到size_t类型的常量表达式 12sizeof (type); // sizeof (类型名)sizeof expr; // sizeof 表达式 &lt;-- 不实际计算表达式的值，意味着即使是无效指针依然安全 c++11新标准允许使用作用域运算符来获取类成员大小 1sizeof Sale_data::revenue; 常见的sizeof运算结果 char或类型为char的表达式，结果为1 引用类型，结果为被引用对象所占空间的大小 指针，指针本身所占空间的大小 解引用指针，指针指向的对象所占空间的大小，指针不需要有效 数组，整个数组所占的大小；等价于对数组中所有元素各执行一次sizeof并求和 123int ia[] = &#123;...&#125; // 一个很多元素的数组constexpr size_t sz = sizeof(ia) / sizeof(*ia); // 返回ia数组的元素的数量int arr2[sz]; // sizeof返回一个常量表达式，所有可以用于声明数组的维度 string和vector，只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。&lt;– 什么意思？没看懂 123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; cout&lt;&lt;sizeof(int)&lt;&lt;endl; // 4 vector&lt;int&gt; a(10, 5); // 10个5，10个int大小按理来说应该是40个字节 for (auto&amp; ia : a) &#123; cout &lt;&lt; ia ; &#125; cout &lt;&lt; endl; cout &lt;&lt; sizeof(a) &lt;&lt; endl; // 却是32？ &lt;-- 不懂 return 0;&#125; 4.2.9 逗号运算符 首先对左侧的表达式求值，然后将结果丢弃。真正的运算结果是右侧表达式的值，如果右侧运算对象是左值，那么最终的求值结果也是左值 一般用于for循环，例 1234vector&lt;int&gt;::size_type cnt = ivec.size();for(vector&lt;int&gt;::size_type ix = 0; ix != ivec.size(); ++ix, --cnt)&#123; ivec[ix] = cnt;&#125; 4.3 类型转换如果两种类型可相互转换，则它们是关联的。 4.3.1 隐式转换 算术转换运算符的运算对象将转换至最宽的类型 整型提升 小整数类型提升成较大的整数类型：bool、char、signed char、unsigned char、short、unsigned short 所有可能的值都能存在int里，则提升为int，否则为unsigned int 较大的char（wchar_t, char16_t, char32_t）提升成int、unsigned int、long、unsigned long、long long和 unsigned long long 中最小的一种类型 无符号类型的运算对象 注意有符号和无符号的混用带来的意外后果 数组转换成指针 在大多数情况下，数组名自动转化成数组首元素的指针 当数组名被用作decltype关键字、取地址符、sizeof、typeid、用一个引用来初始化数组时，上述转化不会发生 指针的转换 0、nullptr能转化成任意指针类型 任意非常量指针能转换成void * 任意对象指针能转化成const void * 有继承关系的类型间 转换成bool 0:false 否则true 转换成常量 允许将指向非常量类型的指针（引用）转化成指向相应的常量类型的指针（引用） 不能反过来，因为这样试图删掉底层const 123int i;const int *p = &amp;i;const int &amp;r = i; 类类型定义的转换 （P144） 类类型能定义由编译器自动执行的转换 每次只能执行一种类类型的转换 4.3.2 显式转换1cast-name&lt;type&gt;(expression) type：要转换的类型，expression：要转换的值；如果type是引用类型，则结果是左值 cast-name包括：static_cast、dynamic_cast、const_cast和reinterpret_cast static_cast &lt;– 最常用 任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast 当需要把一个较大的算术类型赋给较小的类型时，利用static_cast可关闭“精度损失”的警告信息 利用static_cast找回void *指针。 12void *p = &amp;d;double * dp = static_cast&lt;double *&gt;(p); //确保等号两边类型一样，否则产生未定义行为 const_cast 只能改变对象的底层const，仅用于进行去除 const 属性，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。 要注意可能发生的未定义后果 [常用于有重载函数的上下文](#6.4 重载) &lt;– 比如？ 用法举例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*例1*/ //（P145,改）const int a = 0;const int* pc = &amp;a; // 底层constcout &lt;&lt; *pc &lt;&lt; endl; //0int* p = const_cast&lt;int*&gt;(pc); *p = 5;cout &lt;&lt; *p &lt;&lt; endl; //5/*例2*/ // 参考文献[1]//const_cast只针对指针、引用、this指针 （只能改变对象的底层const）int main() &#123; const int n = 5; int* k = const_cast&lt;int*&gt;(&amp;n);//指针 *k = 123; cout &lt;&lt; *k &lt;&lt; endl; //123 int&amp; kRef = const_cast&lt;int&amp;&gt;(n);//引用 kRef = 456; cout &lt;&lt; kRef &lt;&lt; endl; //456&#125;/*例3*/ // 参考文献[1]class CTest&#123;public: CTest() : m_nTest(2) &#123;&#125; //常成员函数，不能修改成员变量的值 void foo(int nTest) const &#123; //void* p = this; //m_nTest = nTest; //m_nTest = nTest; 错误 //&lt;CTest* const&gt;指针地址不可改变，(this)代表常成员函数的this指针 //const_cast去除CTest*前面的const const_cast&lt;CTest* const&gt;(this)-&gt;m_nTest = nTest; &#125;public: int m_nTest;&#125;;int main() &#123; CTest t; t.foo(1);&#125; 参考 [1] C++新特性06_强制转换运算符_const_cast - 十月旧城 reinterpret_cast 通常为运算对象的位模式提供较低层次上的重新解释 非常有风险 本质上依赖于机器，想要安全地使用必须对涉及的类型和编译器实现转换的过程都非常了解 dynamic_cast （19章介绍） 4.4 运算符优先级表 五 语句5.1 简单语句 空语句 – 没有什么用，但是需要注意对循环的影响 12; //&lt;--空语句，真么用也没有int i = 0;; // &lt;-- 不会报错，就是多了一条空语句 :) 5.2 作用域略 5.3 条件语句5.3.1 if…else 注意花括号 悬垂else 我们怎么知道给定的else和那个if相匹配？ 这个问题被称为悬垂else c++规定，与离它最近的尚未匹配的if匹配，从而消除程序的二义性 5.3.2 switch…case case标签必须是整型常量表达式 switch的默认动作是从某个匹配成功的case开始，顺序执行其下的所有case，直到遇到break。最好在每个case中都添加break，以避免不必要的问题。虽然在某些情况下，我们确实希望多个case共享同一组操作而不写break，此种情况最好加一段注释以说明。 最好添加default，声明我们已经考虑了默认情况，即使现在什么都没有做。 标签不应该孤零零地出现，它后面必须跟上一条语句或者另外一个 case标签。如果switch 结构以一个空的 default 标签作为结束则该default 标签后面必须跟上一条空语句或一个空块。 &lt;– （P163，没怎么懂在说什么） switch内部的变量定义 在C++11的标准下，【变量定义】操作在编译阶段就会执行分配内存，而涉及【变量初始化】操作的语句则必须等到程序运行时才会调用执行。 因此对于switch语句的使用，如果确实有需要在内部定义变量的场景，最好的方法就是在编程的时候，将整个switch语句中都用到的变量在switch外定义好，到了switch内部，则可以针对某个case需要单独使用某些变量的情况，用&#123;&#125;作用域符号来明确此case语句的作用域 参考文献 [1] switch case内部的变量定义问题 - John Chen1223 5.4 迭代语句5.4.1 while略 5.4.2 for1for(init-statemen; condition; expression)&#123; statement; &#125; 只要condition为真，就执行一次statement，如果为false，一次也不执行 init-statemen可以定义多个变量，但只能有一条声明语句，因此意味着所有变量的基础类型必须相同 init-statemen 、condition、 expression都可以省略（P167） 5.4.3 do…while123do&#123; statement;&#125;while(condition); //&lt;--最后还有个分号 condition不能为空 condition使用的变量不能定义在循环体之外 不允许在condition部分定义变量 5.5 跳转语句 break 终止最近的while，do...while，for，switch，并从这些语句之后的第一条语句开始执行; continue while，do...while，for可用 终止最近的循环中的当前迭代 并立即开始下一次迭代 goto 5.6 异常处理 5.6.1 异常类c++标准库定义了一组类，分别在4个头文件中： exception 定义exception，只报告异常的发生，不提供任何额外信息 stdexcept 定义了几种常用的异常，下图列出 new bad_alloc（12章） type_info bad_cast（19章） 其中，exception、bad_alloc、bad_cast只能默认初始化，不允许提供初值。反之，其余的异常类必须提供string或c风格字符串以初始化。 异常类只有一个名为what()的成员函数，没有任何参数，返回初始化异常类时用到string（c风格）字符串。对于默认初始化的异常类，返回内容由编译器决定。 5.6.2 抛出异常用throw关键字抛出一个异常后，会直接跳转到对应的catch块，节选5.6.4中示例如下： 1234if (this-&gt;m_isbn != item.m_isbn)&#123; throw runtime_error(&quot;data must refer to same isbn.&quot;);&#125;return this-&gt;m_sales_volume + item.m_sales_volume; 5.6.3 处理异常try...catch接住throw抛出的异常并处理，语法如下 12345678910try &#123; //正常逻辑 //抛出异常&#125;catch (/*（可能未命名的）异常声明1*/) &#123; //异常处理1&#125;catch (/*（可能未命名的）异常声明2*/) &#123; //异常处理2&#125; catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。 函数在寻找 异常处理代码 的过程中 退出（P175） 在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个 try语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能调用了包含又一个 try 语句块的新函数，以此类推。 寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的 catch 子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的 catch 子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路逐层回退，直到找到适当类型的 catch 子句为止。 如果最终还是没能找到任何匹配的 catch 子句，程序转到名为terminate 的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。对于那些没有任何 try语句块定义的异常，也按照类似的方式处理：毕竟，没有 try语句块也就意味着没有匹配的catch 子句。如果一段程序没有 try 语句块且发生了异常系统会调用terminate函数并终止当前程序的执行。 5.6.4 示例1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stdexcept&gt;using namespace std;class Sales_item &#123;public: Sales_item(string isbn, int sales_volume) :m_isbn&#123; isbn &#125;, m_sales_volume&#123; sales_volume &#125; &#123;&#125; string isbn() const &#123; return m_isbn; &#125; int saleVolume() const &#123; return m_sales_volume; &#125; int operator+(Sales_item item) &#123; // 使用异常处理将相加的代码和与用户交互的代码分离 try &#123; if (this-&gt;m_isbn != item.m_isbn) throw runtime_error(&quot;data must refer to same isbn.&quot;); //跳转到catch (runtime_error err) &#123;行 return this-&gt;m_sales_volume + item.m_sales_volume; &#125; catch (runtime_error err) &#123; cout &lt;&lt; err.what() &lt;&lt; endl; &#125; return -1; &#125;private: string m_isbn; int m_sales_volume; //销售额&#125;;int main() &#123; Sales_item item1(&quot;1-2-3&quot;, 10); Sales_item item2(&quot;1-2-3&quot;, 11); Sales_item item3(&quot;4-5-6&quot;, 12); int res1 = item1 + item2; cout &lt;&lt; res1 &lt;&lt; endl;//21 int res2 = item1 + item3; cout &lt;&lt; res2 &lt;&lt; endl;//失败并输出-1&#125; 六 函数6.1 基础 函数最外层的作用于中的局部变量也不能使用和函数形参一样的名字。（P184顶部，不理解） 函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针 函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，函数声明也被称为函数原型 局部静态对象：在局部变量前加static，第一次经过该对象定义语句的时候初始化，并且直到程序终止才销毁，在此期间即使对象所在的函数结束也不会对它有影响。 6.2 参数传递6.2.1 参数传递的方式 值传递 指针传递 其实是一种形式的值传递 在c++中，建议用引用类型的形参代替指针 引用传递 当函数无须修改引用形参的值时最好使用常量引用 使用引用形参返回额外的信息 6.2.2 const形参和实参 顶层const被忽略 当形参有顶层const时，形参的顶层const被忽略，传给他常量对象或非常量对象都是可以的 因为顶层const被忽略掉了，所以下述的两个func是一样的，不能[重载](#6.4 重载) 12int func(const int i) &#123; return i; &#125;int func(int i) &#123; return i; &#125; // 函数“int func(const int)”已有主体 指针或引用参与const 遵循“任何可能引发修改const值的操作都是非法的” P191，略 尽量使用常量引用 把函数不会改变的形参定义成普通的引用是一种比较常见的错误， 会给函数调用者“函数可以修改它们实参值的误导” 极大限制函数所能接收的实参类型（我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参） 123456789101112131415/*例1*/string func(const string&amp;i)&#123; return i; &#125;int main() &#123; cout &lt;&lt; func(&quot;a&quot;) &lt;&lt; endl; // a return 0;&#125;/*例2*/string func( string&amp;i)&#123; return i; &#125;int main() &#123; //无法用 &quot;const char [2]&quot; 类型的值初始化 &quot;std::string &amp;&quot; 类型的引用(非常量限定) cout &lt;&lt; func(&quot;a&quot;) &lt;&lt; endl; return 0;&#125; 参考文献 函数原型、函数签名、函数定义、函数参数传递方式 – 凶猛的瘦子 6.2.3 数组形参 因为不能拷贝数组，我们无法以值传递的方式使用数组参数；又因数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。 三种等价的数组传参方式，数组大小对函数调用无影响 1234//等价void func(const int *);void func(const int[]);void func(const int[10]); // 10表示我们期望，实际上不一定 数组以指针传参，函数不知道大小，有三种常用管理方式管理指针形参： 使用 结束标记 指定数组长度 使用 类似c风格字符串数组的结束标记 标记数组结束的位置 使用标准库规范 使用begin和end函数，传递首元素和尾后元素的指针 12345678void func(const int*beg, const int*end)&#123; while(beg != end) cout&lt;&lt;*beg++&lt;&lt;endl;&#125;/////调用int j[] = &#123;0,1,2&#125;;func(begin(j),end(j)); 显式传递一个表示数组大小的形参 – 旧式风格 1234567void func(const int *ia, size_t size)&#123; &#125;/////调用int j[] = &#123;0,1,2&#125;;func(j, end(j) - begin(j) ); 数组引用形参 形参是数组的引用，维度是类型的一部分 下例中，(&amp;arr)括号必不可少，否则 int &amp;arr[10] 是将arr声明成了引用的数组 下例中，[10]不可少，因为数组的大小是构成数组的一部分，只能将函数作用于大小为10的数组 1void func(int (&amp;arr)[10])&#123;&#125; 传递多维数组 多维数组是数组的数组，又因为将数组传递进函数的时候，传入的是指向第一个元素的指针。所以将多维数组传入函数，传入的是指向第一个数组（即多维数组的第一个元素）的指针。函数声明可以写为 12345//形参matrix看起来是一个二维数组，实际上是指向含有10个整数的数组的指针void func(int matrix[][10],int rowSize)&#123;&#125;//matrix是一个指针，指向10个整数的数组void func(int (*matrix)[10], int rowSize)&#123;&#125; //int (*matrix)[10] 小括号不可少，否则是10个指针构成的数组 main处理命令行 12int main(int argc, char **argv)&#123;&#125;int main(int argc, char *argv[])&#123;&#125; 6.2.4 可变形参可变形参用于编写可处理不同数量实参的函数，主要有三种方法： initializer_list 要求所有实参类型相同 其中的对象永远是常量，无法改变其中的元素值 如果向其中传递的是一个序列，则必须放在花括号中 示例 123456789/*声明*/void error(ErrorCode e, initializer_list&lt;string&gt; il)&#123; cout&lt;&lt;e.msg()&lt;&lt;endl; for(auto &amp;msg : il) cout&lt;&lt;msg&lt;&lt;endl;&#125;/*调用*/error_msg(ErrorCode(0), &#123;&quot;functionX&quot;,&quot;okay&quot;&#125; ); 可变参数模板 （16章） 实参类型不同 省略符 varargsc标准库功能 省略符只能出现在形参列表的最后一个位置 仅用于c和c++通用的类型，大多数类类型的对象在传递给省略符形参时都无法正确拷贝 示例 12void foo(parm_list, ...);void foo(...); 6.3 返回类型和return6.3.1 有返回值的函数 在含有return语句的循环后面也有一条return语句 不要返回 对局部对象的引用 或 指向局部变量的指针，局部变量在函数完成后已经被释放 123456789101112131415161718/** 在vs2022上测试，该程序能正常编译和运行，* 但是运行结果不对，* 显然意味着这种错误不容易被发现*/const string&amp; test() &#123; string a; a = &quot;a&quot;; if (!a.empty()) return a; else return &quot;empty&quot;;&#125;int main() &#123; cout &lt;&lt; test() &lt;&lt; endl; // 期望输出a，实际上输出空 return 0;&#125; 引用返回左值 调用一个返回引用的函数得到左值，其他返回类型得到右值 我们能为返回类型是非常量引用的函数的结果赋值 12345678910char&amp; get_val(string &amp;str, string::size_type ix) &#123; return str[ix]; // 返回对 str[ix]的引用&#125;int main() &#123; string s = &quot;a test&quot;; get_val(s, 0) = &#x27;A&#x27;; cout &lt;&lt; s &lt;&lt; endl; return 0;&#125; 可返回列表初始化，return &#123;&quot;funcX&quot;,&quot;okay&quot;&#125; main函数的返回值 cstdlib中定义了两个预处理变量，表示成功或者失败 12return EXIT_FALLURE;return EXIT_SUCCESS; 递归 在递归函数中，一定有某条路径是不包含递归调用的，否则将一直递归循环，直至内存耗尽 6.3.2 数组指针数组不能被拷贝，所以函数不能返回数组，不过函数可以返回数组的指针或引用。定义一个返回数组的指针或引用的函数有如下几种方法： 使用类型别名 1234567/*两个等价的定义类型别名的方法*///arrT是一个类型别名，它表示的类型是含有10个整数的数组typedef int arrT[10];using arrT = int[10];/*使用*/arrT *func(int i); 普通方法 1int (*func(int i))[10]; 尾置返回类型 c++11新标准可使用 ，将返回类型放在-&gt;后，并在原来写返回值类型的地方放个auto 1auto func(int i) -&gt; int(*)[10]; // 返回一个指针，指向放10个int数据的数组 decltype 123456int odd[] = &#123;1,3,5,7,9&#125;;int even[] = &#123;2,4,6,8&#125;;decltype(odd) *arrPtr(int i)&#123; return (i%2) ? &amp;odd : &amp;even;&#125; decltype 并不负责把数组类型转换成对应的指针，所以decltype 的结果（即int[]）是个数组，要想表示 arrPtr 返回指针还必须在函数声明时加一个*符号。 6.4 重载 如果同一作用域内的几个函数名字相同但形参列表不同，称之为函数重载（overloaded） 重载和const形参 [顶层const不影响传入的对象，有无顶层const不能构成重载](#6.2.2 const形参和实参) 底层const会实现重载： 指向const的指针（引用）传递给const形参 对于非常量，编译器会优先选择非常量版本的函数 （6.6-最佳匹配-实参类型的转换） 重载和const_cast const_cast在重载函数的情境中最有用 – 保障了安全性 重载与作用域 不要把函数声明置于局部作用域内 6.5 特殊用途语言特性6.5.1 默认实参 一旦某个形参被赋予了默认值，其后所有形参都必须有默认值 默认实参负责填补函数调用缺少的尾部实参 合理设置形参顺序，将经常使用默认值的形参放在后面 函数后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值 123string screen(sz,sz,char=&#x27; &#x27;);string screen(sz,sz,char= &#x27;*&#x27;); //错误，重复声明string screen(sz = 24, sz = 80, char);// 正确，添加默认形参 默认实参初始值 局部变量不能作为默认实参，用作默认实参初始值的 表达式的值 必须声明在函数之外 只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参 1234567891011121314sz wd = 80;char def = &#x27; &#x27;;sz ht();string screen(sz = ht(), sz = wd, char = def)void f2()&#123; string window = screen(); //screen(ht(), 80, &#x27; &#x27; ); def = &#x27;*&#x27;; // 将传递这个更新过的 全局变量的 值 sz wd = 100; //局部变量与默认实参没有任何关系 window = screen(); //screen(ht(), 80, &#x27;*&#x27;);&#125; 6.5.2 内联函数 inline 对编译器的建议， 加速程序 6.5.3 constexpr函数 能用于常量表达式的函数 函数的返回类型及所有形参的类型都得是字面值类型，函数体中必须有且只有一条return语句 1constexpr int new_sz() &#123;return 42;&#125; 初始化任务时，编译器会把constexpr函数的调用替换成其结果值，函数被隐式地指定为内联函数 1int arr[new_sz()]; constexpr函数中也可以包含其他语句，只要这些语句在运行时不执行任何操作（空语句、typedef、using） &lt;– 唯一可执行的语句就是return 允许返回非常量：当实参是是一个常量表达式时，返回常量表达式，反之则不然： &lt;– constexpr函数不一定返回常量表达式 123456constexpr int scale(size_t cnt) &#123;return new_sz() * cnt ;&#125;int arr[scale(2)]; // 正确int i = 2;int arr[scale(i)]; //错误，返回的不是常量表达式，无法初始化数组 6.5.4 调试帮助 assert(expr) – #include &lt;cassert&gt; expr为假，输出信息并终止，为真，什么也不做。即expr为不可能情况 NDEBUG预处理变量 针对assert()：定义NDEBUG能避免检查各种条件所需的运行时开销，当然此时根本就不会执行运行时检查。因此，assert 应该仅用于验证那些确实不可能发生的事情。我们可以把assert当成调试程序的一种辅助手段，但是不能用它替代真正的运行时逻辑检查，也不能替代程序本身应该包含的错误检查。 12345678910111213141516171819202122232425/*例1*/#include &lt;cassert&gt;int main() &#123; int i = 5; assert(i &gt; 6); // Assertion failed: i &gt; 6, file ... line 4 return 0;&#125;/*例2 NDEBUG要写在整个程序的开头，否则没有用*/#define NDEBUG#include &lt;cassert&gt;int main() &#123; int i = 5; assert(i &gt; 6); // 失效 return 0;&#125;/*例3 NDEBUG要写在整个程序的开头，否则没有用*/#include &lt;cassert&gt;#define NDEBUGint main() &#123; int i = 5; assert(i &gt; 6); // Assertion failed: i &gt; 6,file ... return 0;&#125; 针对#ifndef ...#endif 如果定义了NDEBUG，#ifndef ...#endif之间的代码将被忽略 12345//#define NDEBUG#ifndef NDEBUG...#endif 补充，预处理器定义的几个 用于调试程序的 变量 变量名 功能 __func__ const char 的一个静态数组，存放函数的名字 __FILE__ 存放文件名的字符串字面值 __LINE__ 存放当前行号的整型字面值 __TIME__ 存放文件编译时间的字符串字面值 __DATE__ 存放文件编译日期的字符串字面值 示例 1234//示例std::cout&lt;&lt;__func__ &lt;&lt;&quot;in file: &quot;&lt;&lt;__FILE__ &lt;&lt;&quot;line &quot;&lt;&lt;__LINE__; ​ 6.6 函数匹配 候选函数 与被调用的函数同名 其声明在调用的可见 可行函数 – 从候选函数中选出能被这组实参调用的函数 实参数量相等，类型相同 最佳匹配 单个参数：实参类型与形参类型越接近，它们匹配得越好 多个参数：如果有且只有一个函数满足下列条件，则匹配成功。如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用的信息。 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。 至少有一个实参的匹配优于其他可行函数提供的匹配。 实参类型的转换 （P219） 编译器将实参类型到形参类型的转换划分成几个等级： 在设计良好的系统中函数很少会含有与下列例子相似的形参：（P219底部-220） 假设有两个函数，一个接受 int、另一个接受short，则只有当调用提供的是 short 类型的值时才会选择 short 版本的函数。有时候，即使实参是一个很小的整数值，也会直接将它提升成int 类型。 所有算术类型转换的级别都一样。例如，从int 向unsigned int 的转换并不比从int向 double的转换级别高。当存在两种可能的算数类型转换时，调用具有二义性。 重载忽略顶层const，因此顶层const不能用于重载；而底层const可重载：如果重载函数的区别在于它们的引用类型的形参是否引用了 const（或者指针类型的形参是否指向const），则当调用发生时编译器通过实参是否是常量来决定选择哪个函数: 1234567int lookup(string&amp;);int lookup(const string &amp;);int a;const int b;lookup(a); // 调用 lookup( string &amp;);lookup(b); // 调用 lookup(const string &amp;); 6.7 函数指针6.7.1 函数指针是什么？ 函数指针指向的是函数而非对象 函数指针指向某种特定类型。函数的类型由它的返回类型和形参列表共同决定，与函数名无关 12345678910// 函数bool lengthCompare(const string &amp;, const string &amp;);// 类型bool(const string &amp;, const string &amp;);//指向函数的指针bool (*ptr)(const string &amp;, const string &amp;)/*ptr是一个指针，指向参数是（const string &amp;, const string &amp;）的函数，返回bool类型*//*（*ptr）的括号不可少，否则ptr变成了一个返回 bool* 类型的函数*/ 6.7.2 如何使用 当我们把函数名作为一个值使用时，该函数自动转换成指针 还能指向函数的指针调用该函数，而无须提前解引用指针 不同类型的函数指针间不存在转换 可用nullptr或0初始化指针 1234567891011121314151617181920212223/* 函数 */bool lengthCompare(const string &amp;, const string &amp;);/* 指向函数的指针 */bool (*ptr)(const string &amp;, const string &amp;);/*声明的同时定义*/bool (*ptr)(const string &amp;, const string &amp;) = lengthCompare;/* 初始化 */ptr = nullptr;/* 赋值 */ptr = lengthCompare; // 等价于 ptr = &amp;lengthCompare;/* 调用 */bool b = ptr(&quot;hello&quot;, &quot;goodbye&quot;);//等价bool b = (*ptr)(&quot;hello&quot;, &quot;goodbye&quot;);//等价bool b = lengthCompare(&quot;hello&quot;, &quot;goodbye&quot;) 6.7.3 重载函数的指针 编译器通过指针类型决定选用哪个函数 指针类型必须与重载函数中的某一个精确匹配 12345678//重载的func函数void func(int *);void func(unsigned int);//指向func函数的指针void (*ptr)(unsigned int) = func; // 正确void (*ptr)(int) = func; // 错误，没有一个重载的func与该形参列表匹配double (*ptr)(unsigned int) = func; // 错误，没有一个重载的func与该返回类型匹配 6.7.4 函数指针作形参 和数组类型（6.2.3节），形参可以是指向函数的指针。 123456//形参看起来是函数类型，实际上确实当成指针使用void useBigger(const string &amp;s1, const string &amp;s2, bool pf(const string &amp;, const string &amp;));//等价void useBigger(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;, const string &amp;)); 可以直接把函数作为实参使用，他会被自动转换为指针 1useBigger(s1,s2,lengthCompare); // 函数名即指向函数的指针 如上，直接使用函数指针类型显得冗长，使用类型别名和decltype简化 12345678910111213141516171819202122/*函数类型*/typedef bool Func(const string &amp;, const string &amp;);//等价using Func = bool(const string &amp;, const string &amp;);//等价typedef decltype(lengthCompare) Func;/*指向函数的指针*/typedef bool (*FuncPtr)(const string &amp;, const string &amp;);//等价using FuncPtr = bool(*)(const string &amp;, const string &amp;);//等价typedef decltype(lengthCompare) *FuncPtr;/*用简化的函数类型声明useBigger*/void useBigger(const string &amp;s1, const string &amp;s2, Func); // 编译器自动地将Func表示的函数类型转换成指针//等价void useBigger(const string &amp;s1, const string &amp;s2, FuncPtr); 6.7.5 返回指向函数的指针 与形参不同，编译器不会自动地将函数返回类型当成对应的指针类型处理，因此我们必须显式地将返回类型指定为指针 123456//四个等价FuncPtr useBigger(const string &amp;s1, const string &amp;s2, FuncPtr);Func *useBigger(const string &amp;s1, const string &amp;s2, FuncPtr);auto useBigger(const string &amp;s1, const string &amp;s2, FuncPtr) -&gt; bool(*)(const string &amp;, const string &amp;);//尾置返回类型 bool (* useBigger(const string &amp;s1, const string &amp;s2, FuncPtr) ) (const string &amp;, const string &amp;);/*解释：先看括号里的，useBigger有形参列表，是一个函数；其前面有*，是一个指针；指向一个bool(const string &amp;, const string &amp;)的函数类型*/ 将auto和decltype用于函数指针类型 牢记将decltype作用于某个函数，它返回函数类型而非指针类型 1234string::size_type sumlength(const string&amp;, const string &amp;);string::size_type largerlength(const string &amp;, const string &amp;);decltype(sumlength) *getFunc(const string &amp;); 七 类7.1 定义抽象数据类型7.1.1 关于类的基础知识（P228~P235）主要讲述了“类”的基础知识。 一、 首先说明了类是什么： 类的基本思想是数据抽象 (data abstraction)和封装(encapsulation)。数据抽象是一种依赖于接口(interface)和**实现 **(implementation)分离的编程(以及设计)技术。 类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。 封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。 二、 通过设计Sales_data类，讲述了数据成员及成员函数。并提出了如下建议： 在一些简单的应用程序中，类的用户和类的设计者常常是同一个人。尽管如此，还是最好把角色区分开来。当我们设计类的接口时，应该考虑如何才能使得类易于使用；而当我们使用类时，不应该顾及类的实现机理。 三、 接着通过成员函数引入this指针，该指针是类的成员函数额外的隐式参数，指向调用它的那个对象。有如下代码， 123//Sale_data定义于P230中间Sales_data total;total.isbn(); // total调用了成员函数isbn() 实际上，编译器将该调用重写成如下形式 1Sales_data::isbn(&amp;total); 任何对类成员的直接访问都被看做this的隐式引用； 任何自定义名为this的参数或变量的行为都是非法的； this是一个常量指针，不允许修改this中保存的地址。 成员函数在紧随参数列表之后，可以有const，用以修改隐式this指针的类型。示例如下： 1string isbn() const &#123;return bookNo; &#125; 默认的情况下，this是指向非常量版本的常量指针，所以不能把this绑定到常量对象上，这使得我们不能在一个常量对象上调用普通的成员函数。C++允许在成员函数紧随参数列表后，添加const关键字，使得this变成一个指向常量的常量指针。如此，该成员函数被称为常量成员函数，常量成员函数不能改变调用它的对象的内容。 常量对象，及常量对象的引用或指针都只能调用常量成员函数。 四、 关于成员变量声明于成员函数之后，成员函数却能读取到成员变量，书中作出如下解释： 编译器分两步处理类： 首先编译成员的声明 然后才轮到成员函数体(如果有的话)。 因此，成员函数可以随意使用类中的其他成员而无须在意这些成员出现的次序。 五、 之后， P232提及如何在类外部定义成员函数； P233介绍了如何定义一个返回this对象的函数，通过*this以获得执行该函数的对象。 P234在“定义类相关的非成员函数”一节中，提到了如下几个关键点： 一些辅助函数，尽管定义的操作从概念上来说属于类的接口的组成部分，但它们实际上并不属于类本身。这些函数也应与类声明(而非定义)在同一个头文件内。这样，用户使用接口的任何部分都只需要引入一个文件。 istream、ostream等io类属于不能被拷贝的类型，因此，我们只能通过引用来传递它们。又因为读写操作会改变流的内容，所以两个函数接受的都是普通引用，而非对常量的引用。 12345678910istream &amp;read(istream &amp;is, Sales_data &amp;item)&#123; ...; is&gt;&gt;a&gt;&gt;b&gt;&gt;c; return is;&#125;ostream &amp;write(ostream &amp;os, Sales_data &amp;item)&#123; ...; os&lt;&lt;item.isbn(); //注意没有endl()等控制格式 return os;&#125; 执行输出任务的函数应该尽量减少对格式的控制，将格式控制交给用户 默认情况下，拷贝类的对象其实拷贝的是对象的数据成员（没有拷贝成员函数，不同的类对象共用成员函数，并用this控制（侯捷高级面向对象课程）） 7.1.2 构造函数一、构造函数不能被声明成const。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才真正取得“常量”属性–&gt;因此，构造函数在const对象的构造过程中可以向其写值 二、（编译器）合成的默认构造函数将按如下规则初始化类的数据成员： 如果存在类内初始值。则用它来初始化成员 否则，默认初始化 （P262 默认构造函数的作用） 类必须包含一个默认构造函数以便在下述情况下使用。 在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。 当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况下发生: 当我们在块作用域内不使用任何初始值定义一个非静态变量(参见2.2.1节，第39页)或者数组时(参见3.5.1节，第101页)。 当一个类本身含有类类型的成员且使用合成的默认构造函数时(参见7.1.4 节，第235页)。 当类类型的成员没有在构造函数初始值列表中显式地初始化时(参见7.1.4 节，第237页)。 值初始化在以下情况下发生: 在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时 (参见3.5.1节，第 101页)。 当我们不使用初始值定义一个局部静态变量时(参见6.1.1节，第185页)。 当我们通过书写形如 T()的表达式显式地请求值初始化时，其中T是类型名(vector 的一个构造函数只接受一个实参用于说明 vector 大小(参见3.3.1节第88页)，它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化). 三、某些类不能依赖于默认构造函数： 类内已经显式声明了构造函数 类中包含内置类型（int等）或复合类型（如数组、指针），如执行默认构造，则他们的值将是未定义的。只有当这些值被赋予了初始值（7.3.4），才可使用默认构造 类中包含一个其他类型的成员，其这个成员的类型没有默认构造，则编译器也无法对当前类执行默认构造 四、构造函数的几种方式 =default 在c++11新标准中，可以在参数列表后面写=default来要求编译器生成默认构造函数。注意要为内置类型或复合类型数据成员提供初始值。 1Sales_data() = default; 构造函数列表初始化当某个数据成员被构造函数初始值化列表忽略时，它将以与合成的默认构造函数相同的方式隐式初始化（此时要求有类内初始值）， 1Sales_data(const string &amp;s,double p) : bookNo(s),revenue(p) &#123;&#125; 在类外部定义构造函数 五、拷贝、赋值和析构 尽管编译器能替我们合成拷贝、赋值和销毁的操作，但是必须要清楚的一点是，对于某些类来说合成的版本无法正常工作。特别是，当类需要分配类对象之外的资源时，合成的版本常常会失效。管理动态内存的类通常不能依赖于上述操作的合成版本。 7.1.3 构造函数再探 本节应是 书本P257页开始7.5 的内容，为了笔记结构的简洁，放到 笔记7.1.2构造函数 之后。 一、关于列表初始 使用列表初始化和在构造函数体内通过拷贝赋值的方式初始化，看似一样，但有时必须使用列表初始化且必不可少：如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过列表初始化为这些成员变量提供初始值。 1234567891011121314151617class ConstRef&#123;public:/*正确*/ConstRef(int ii):i(ii),ci(ii),ri(i)&#123;&#125;/*引发错误*/ ConstRef(int ii)&#123; i = ii; ci = ii; //错误，不能给const赋值 ri = i; //错误，引用未被初始化 &#125;private: int i; const int ci; int &amp;ri;&#125;; 列表初始化的初始化顺序问题 – 成员列表初始化的顺序与它们在类定义中的出现顺序一致： 构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。成员列表初始化的顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。一般来说，初始化的顺序没什么特别要求。不过一个成员用另一个成员来初始化，那么这两个成员的初始化顺序就很关键了。最好令构造函数初始值的顺序与成员声明的顺序保存一致，如果可能的话，尽量避免使用某些成员初始化其他成员。 123456789101112131415161718192021222324252627/*例1*/class ConstRef &#123;public: /*正确*/ ConstRef(int ii) :j(ii),i(j) &#123; cout &lt;&lt;&quot;i = &quot;&lt;&lt; i &lt;&lt; &quot;, j = &quot; &lt;&lt; j &lt;&lt; endl; // 终端输出：i = -858993460, j = 1 // 出错，因为根据声明的顺序，先初始化i，而此时j还是未定义状态 &#125;private: int i; int j;&#125;;/*例2*/class ConstRef &#123;public: /*正确*/ ConstRef(int ii) :j(ii),i(j) &#123; cout &lt;&lt;&quot;i = &quot;&lt;&lt; i &lt;&lt; &quot;, j = &quot; &lt;&lt; j &lt;&lt; endl; // 终端输出：i = 1, j = 1 &#125;private: // 声明顺序与列表初始化顺序匹配 int j; int i;&#125;; 如果为一个构造函数的所有参数都提供了默认实参，则其实际上也成为了默认构造函数。 二、委托构造 概念：一个委托构造函数 使用它所属类的其他构造函数 执行自身初始化过程。（将自身的（一些或全部）职责委托给了其他构造函数） 当一个构造函数委托给另一个构造函数时，受委托的构造函数的列表初始化和函数体被依次执行，然后才轮到委托者的函数体。 示例 12345678910111213141516171819class Sales_data &#123;public: using unint = unsigned int; //非委托构造使用对应的实参初始化成员 Sales_data(string s, unint cnt, double price) :bookNo(s), sold(cnt), rev(cnt* price) &#123;&#125; // 委托构造 Sales_data() :Sales_data(&quot;&quot;, 0, 0) &#123;&#125; Sales_data(string s) :Sales_data(s, 0, 0) &#123;&#125; Sales_data(istream&amp; is) :Sales_data() &#123; read(is, *this); &#125; void read(istream&amp; is, Sales_data) &#123;/*...*/ &#125;private: string bookNo; unint sold; double rev;&#125;; 三、隐式类型转换 如果一个类的构造函数只接受一个参数，则有从 该参数类型 到 该类类型 的隐式转换 123456789101112131415161718192021222324252627282930313233343536#include &lt;cassert&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;class Sales_data &#123;public: using uint = unsigned int; Sales_data() = default; Sales_data(string s, uint cnt, double p) :m_isbn(s), m_cnt(cnt), m_price(p) &#123;&#125; Sales_data(string s) :m_isbn(s) &#123; &#125; // 1.string 可隐式转换为 Sales_data Sales_data&amp; combine(Sales_data sd) &#123; // 3. &lt;-- string转换为Sales_data后带入 if (sd.m_isbn != this-&gt;m_isbn) cerr &lt;&lt; &quot;isbn is not same.&quot; &lt;&lt; endl; this-&gt;m_cnt += sd.m_cnt; return *this; &#125;private: string m_isbn = &quot;&quot;; uint m_cnt = 0; double m_price = 0;&#125;;int main() &#123; Sales_data item(&quot;978-7-121-15535-2&quot;); // 直接初始化 //也可拷贝初始化 //Sales_data item = string(&quot;978-7-121-15535-2&quot;); string isbn = &quot;978-7-121-15535-2&quot;; item.combine(isbn); // 2.正确，string 隐式转换为 Sales_data类型 return 0;&#125; 但是，这种类型转换只允许一步完成，下面这种分开是不允许的： 123456789101112131415int main() &#123; Sales_data item(&quot;978-7-121-15535-2&quot;, 2, 3); /*错误*/ item.combine(&quot;978-7-121-15535-2&quot;); //编译器先向字符串常量转化为string；再将该string临时变量转换成Sales_data //两步转换导致隐式转换失败 //编译器报错: 不存在从 &quot;const char [18]&quot; 转换到 &quot;Sales_data&quot; 的适当构造函数 /*正确*/ item.combine(string(&quot;978-7-121-15535-2&quot;)); //或 item.combine(Sales_data(&quot;978-7-121-15535-2&quot;)); return 0;&#125; 利用explicit关键字抑制单参数构造函数的隐式类型转换 关键字 explicit 只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为 explicit 的。 只能在类内声明构造函数时使用explicit 关键字，在类外部定义时不应重复 使用了explicit关键字的构造函数只能以直接初始化的形式使用，不再支持拷贝形式的初始化 123456789class Sales_data&#123;public: explicit Sales_data(string s) :m_isbn(s) &#123; &#125; // 禁止隐式转换&#125;;string isbn = &quot;978-7-121-15535-2&quot;;Sales_data item1(isbn); // 正确Sales_data item2 = isbn; // 错误item1.combine(isbn); // 错误，隐式转化为explicit禁止了 可是我们非要类型转换怎么办？可以显式类型转换 123item1.combine(Sales_data(isbn)); // 错误，隐式转化为explicit禁止了//或item1.combine(static_cast&lt;Sales_data&gt;(isbn)); 标准库中含有显式构造（explicit）的类 接受一个单参数的const char*的string构造函数(参见3.21节，第76页)不是explicit的。 接受一个容量参数的 vector 构造函数(参见3.3.1节，第87页)是explicit 的。 7.2 控制访问和封装7.2.1 访问说明符 public private protected 7.2.2 class与struct class默认private struct默认public 7.3.3 友元一、友元函数 当类的数据成员被设为private，非成员函数（所谓辅助函数）就无法访问到它们了。为解决这个问题，可将这些非成员函数设为友元friend; 友元生命只能定义在类的内部，但是在类内出现的具体位置不限。友元不是类的成员，也不受它所在区域访问控制级别的约束。不过，一般来说，最好在类开始或结束的位置集中声明友元。 友元的声明仅仅指定了访问权限，而非通常意义上的函数声明，所以必须在友元声明之外再专门对函数进行一次声明。 123456789101112131415class Sales data&#123; //为Salesdata的非成员函数所做的友元声明 friend Sales_data add(const Sales_data&amp;，const Sales_data&amp;); //其他成员及访问说明符与之前一致 public: Sales_data() = default; ......private: std::string bookNo; ......&#125;//Salesdata接口的非成员组成部分的声明Sales_data add(const Sales data&amp;，const Sales datas); //类的非成员函数声明 二、友元类书本P250~P252对友元进行了补充，介绍了类与类之间的友元关系。 1.类作友元 友元类的成员函数可以访问此类的所有成员 123class Screen&#123;friend class Window_mgr; // Window_mgr的成员函数可以访问Screen的所有成员&#125;; 友元关系不具有传递性。Window_mgr的友元与Screen没有关系。 2.类的成员函数作友元 当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类 123class Screen&#123;friend void Window_mgr::clear(ScreenIdx); // Window_mgr的成员函数可以访问Screen的所有成员&#125;; 想要某个成员函数作为友元，必须仔细组织程序结构，以满足声明和定义的彼此依赖关系： 尽管重载函数名字相同，但它们是不同的函数，友元声明要分别声明。 3.友元声明和作用域 要理解：友元声明的作用是设定访问权限，其本身并不是普通意义上的声明。（必须在别处书写真正的声明。） 1234567void f(); // 声明struct X&#123; friend void f() &#123; cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl; &#125; // 即使在此处定义，也要在类的外部提供声明 X() &#123; f(); &#125;&#125;;// void f(); //在此处定义，本例类的构造函数会报“f找不到标识符” 7.3 类的其他特性7.3.1 在类中定义类型成员 类还可以自定义某种类型在类中的别名，该别名同样存在访问权限。 与不同成员不用关注定义的顺序不同，定义类型的成员必须先定义后使用。因此类型成员通常出现在类开始的地方； 123456789101112131415class Screen&#123;public: /* 在类中定义类型成员 */ typedef string::size_type pos; //等价 //using pos = string::size_type; private: pos cursor = 0; pos height = 0, width = 0; // 默认初始值 &#125;/* 如何在类外使用？*/Screen::pos myPos; 7.3.2 令成员做inline函数 最好在类外部定义的地方说明inline，以使类更容易理解 12345678class Screen&#123;public: Screen &amp;move(pos r, pos c);&#125;inlineScreen &amp;Screen::move(pos r, pos c)&#123;&#125; inline成员函数也应与相应的类定义在同一个头文件中 7.3.3 可变数据成员 – mutable 可以通过向类的某个变量声明中加入mutable关键字，达到即使是在一个const成员函数内也能修改该成员变量的目的。 可变数据成员永远不会是const，任何时候都能被修改 123456class Screen&#123;public: void some_member() const &#123; ++access_ctr; &#125; //access_ctr用于记录成员函数被调用了多少次private: mutable size_t access_ctr;&#125; 7.3.4 类数据成员的初始值 希望自己设计的类一开始就被一个默认初始化，最好的方式就是将默认值声明成类内初始值 当我们提供一个类内初始值时，必须以等号或者花括号表示 1234class Window_mgr&#123; private: vector&lt;Screen&gt; screens&#123;Screen(24,80,&#x27; &#x27;)&#125;;&#125; 7.3.5 :star:成员函数利用引用返回*this一、可将一系列操作连接成一条表达式123456789typedef string::size_type pos;inline Screen &amp;Screen::move(pos r, pos c)&#123; // &lt;-- 返回*this的引用 ...; return *this;&#125;inline Screen &amp;Screen::set(char ch)&#123; ...; return *this;&#125; 上述代码中，返回引用的函数是左值的，意味着上述函数返回的是对象本身而非副本。将this对象作为左值返回，可以把一系列操作连接成一条表达式： 123456Screen myScreen;myScreen.move(4,0).set(&#x27;#&#x27;); // 一系列操作连接成一条表达式//等价myScreen.move(4,0);myScreen.set(&#x27;#&#x27;); 反之，如果返回的非引用（Screen &amp;）而是值传递（Screen），则调用set()只是改变副本，而不能改变myScreen的值，连续调用将会失败。 12Scream tmp = myScreen.move(4,0);tmp.set(&#x27;#&#x27;); 对比实验如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cassert&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;class Screen &#123;public: typedef string::size_type pos; Screen() = default; // 返回值为引用的版本 &lt;-- 正确的版本 Screen&amp; move(pos r, pos c); Screen&amp; set(char ch); // 重载返回值非引用的版本，noRefer是用于重载的参数，无实际意义 Screen move(pos r, pos c, string noRefer); Screen set(char ch, string noRefer); void print() &#123; cout &lt;&lt; m_r &lt;&lt; &quot;, &quot; &lt;&lt; m_c &lt;&lt; &quot;, &quot; &lt;&lt; m_ch &lt;&lt; endl; &#125;private: pos m_r = 0, m_c = 0; char m_ch = &#x27; &#x27;;&#125;;// 返回值为引用的版本inline Screen&amp; Screen::move(pos r, pos c) &#123; m_r = r; m_c = c; return *this;&#125;inline Screen&amp; Screen::set(char ch) &#123; m_ch = ch; return *this;&#125;// 重载返回值非引用的版本，noRefer是用于重载的参数，无实际意义inline Screen Screen::move(pos r, pos c, string noRef) &#123; m_r = r; m_c = c; return *this;&#125;inline Screen Screen::set(char ch, string noRef) &#123; m_ch = ch; return *this;&#125;//mainint main() &#123; Screen myScreen1,myScreen2; myScreen1.print(); //0,0, myScreen1.move(4, 0).set(&#x27;#&#x27;); myScreen1.print(); //4,0,# myScreen2.move(4, 0, &quot;noRef&quot;).set(&#x27;#&#x27;, &quot;noRef&quot;); // set失败，作用于了myScreen的副本 myScreen2.print(); //4,0, return 0;&#125; 二、const成员函数的重载和*this指针的返回 重载多个const成员函数如何选择？下图1 从const成员函数返回*this：一个const成员函数如果以引用形式返回this，返回类型将是常量引用，下图2。 this指针的隐式传递，下图3 7.3.6 类类型 只声明而未定义的类被称作前向声明； 在类定义之后，声明之前被称为不完全类型； 不完全类型用于有限的场景： 可以定义指向这种类型的指针或引用 可以声明（但不可定义）以不完全类型作为参数或者返回类型的函数 我们创建类的对象之前，该类必须被定义过 一种例外情况：（此处没有读懂，但是知道该用法） 7.4 类的其他形式7.4.1 聚合类 用户可以直接访问其成员，且具有特殊初始化语法 满足如下条件： 所有成员都是 public的。 没有定义任何构造函数。 没有类内初始值 没有基类，也没有 virtual函数 示例 1234struct data&#123; int ival; string s;&#125;; 初始化 – 顺序必须与生命顺序一致 1data val&#123;0,&quot;anna&quot;&#125;; 7.4.2 constexpr类 对于聚合类，如果数据成员都是字面值类型，则为字面值常量类 对于普通的类，满足： 数据成员都必须是字面值类型 类必须至少含有一个 constexpr 构造函数。 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式(笔记2.5.4）；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。 类必须使用析构函数的默认定义，该成员负责销毁类的对象(书7.1.5节，第239页)。 关于constexpr构造函数 尽管构造函数不能是 const 的，但是字面值常量类的构造函数可以是 constexpr函数。 事实上，一个字面值常量类必须至少提供一个constexpr 构造函数。 constexpr构造函数的形式： 法一：=default 法二：既符合构造函数的要求（无返回语句），又符合constexpr函数的要求。 &lt;– constexpr构造函数体一般是空的。 constexpr构造函数必须初始化所有数据成员。初始值 或者使用constexpr 构造函数 ，或者是一条常量表达式。 constexpr 构造函数用于生成constexpr 对象以及 constexpr 函数的参数或返回类型。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cassert&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;class Debug &#123;public: constexpr Debug(bool b = true) : hw(b),io(b),other(b) &#123;&#125; constexpr Debug(bool h,bool i, bool o) : hw(h),io(i),other(o) &#123;&#125; /*constexpr */bool any() const &#123; return hw || io || other; &#125; //在vs2022上须指定为const成员函数，否则： //“bool Debug::any(void)”: 不能将“this”指针从“const Debug”转换为“Debug &amp;” void set_io(bool b) &#123; io = b; &#125; void set_hw(bool b) &#123; hw = b; &#125; void set_other(bool b) &#123; hw = b; &#125;private: bool hw; bool io; bool other;&#125;;int main() &#123; /*调用*/ constexpr Debug io_sub(false, true, false); if (io_sub.any()) // if(true) cerr &lt;&lt; &quot;print appropriate error messages&quot; &lt;&lt; endl; constexpr Debug prod(false); if (prod.any()) // if(false) cerr &lt;&lt; &quot;print anerror message&quot; &lt;&lt; endl; return 0;&#125; 7.5 类的作用域7.5.1 类名::的作用范围本节从书本P253开始，首先简述了如何通过类访问其中的成员变量、成员函数和typedef的类型别名。 接着，讲述了类名::的作用范围，即其后的所有东西，包括函数名、参数列表和函数体。而其之前的返回值类型不包含在其中，如果返回值类名在此类中定义，也要用类名::额外声明 123456789101112131415161718class Screen&#123;public: /* 在类中定义类型成员 */ typedef string::size_type pos; //等价 //using pos = string::size_type; pos clear(int i); private: pos cursor = 0; pos height = 0, width = 0; // 默认初始值 &#125;/*调用*/// Screen::clear中的 `Screen::`不作用于pos，pos需要额外声明其所属类Screen::pos Screen::clear(int i)&#123;&#125; 7.5.2 名字查找 类成员声明的名字查找，考虑下述代码 12345678910typedef double Money;string bal;class Account&#123;public: Money balance() &#123;return bal;&#125; //1. private: //typedef double Money; //2.错误，Money不可重复定义 Money bal;&#125;; 编译器处理完类中的全部声明后，才会处理成员函数的定义。 在注释1处，编译器没有找到 在Account中 使用Money前 出现的声明，接着到Account外层作用域寻找，找到了Money。 另一方面，成员函数balance()的函数体在整个类全部可见（声明）后才被处理（函数定义），因此返回成员变量bal，而非外层的string的bal。 在注释2处， 一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。 建议将类型名的定义放在类开始处，这样保证所有使用该类的成员都出现在类名定义之后。 成员函数中使用的名字的查找方式： 成员变量名和成员函数参数名重名，降低了代码的阅读性。 建议不要将成员名字作为参数或其他局部变量使用，如下述代码例3所示。 123456789101112131415161718192021222324252627282930313233343536373839int height;class Screen&#123;public: typedef string::size_type pos; /*********** 例1 *************/ void func(pos height)&#123; cursor = width * height; // height是参数声明 &#125; /*****************************/private: pos cursor = 0; pos height = 0,width = 0;&#125;;/*将例1替换成例2*//*********** 例2 *************/void func(pos height)&#123; cursor = width * this-&gt;height; //类成员height //等价 cursor = width * Screen::height; //类成员height&#125;/*****************************//*将例1替换成例3*//*********** 例3 建议的写法*************/void func(pos ht)&#123; cursor = width * height; // 类成员height&#125;/*****************************//*将例1替换成例4*//*********** 例4 *************/void func(pos height)&#123; cursor = width * ::height; // 全局的那个int height;&#125;/*****************************/ 在文件中名字的出现处进行解析 123456789101112131415int height;class Screen&#123;public: typedef string::size_type pos; void func(pos);private: pos cursor = 0; pos height = 0,width = 0;&#125;;Screen::pos verify(Screen::pos);void func(pos var)&#123; height = verify(var);&#125; 虽然函数verify()在类Screen定义之后，但出现在了成员函数func()定义之前的全局作用域，所以可被正常使用。（参见：成员函数中使用的名字的查找方式第3点：如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。） 7.6 类的静态成员7.6.1 基础 在成员声明前加上static关键字声明静态成员。静态成员直接与类关联，而不是与类的对象关联。 静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。只会存在一个静态数据，被所有对象共享。 静态成员函数不与任何对象绑定，不包含this指针，不能声明为const成员函数。 7.6.2 定义静态成员 因为静态成员不属于类的任何一个对象，因此不能用类的构造函数初始化。 一般来说，不能再类内初始化静态成员，必须在类外部定义和初始化每个静态成员。除了笔记7.6.3的情况。 一旦定义，将存在于整个程序的生命周期。 12345678910class Account&#123;public: Account(); ~Account() = default;private: static int i; /*= 0;//错误,带有类内初始值设定项的成员必须为常量*/&#125;;int Account::i = 0; // 类外定义和初始化 7.6.3 静态成员的类内初始化笔记7.6.2说：“不能再类内初始化静态成员，必须在类外部定义和初始化每个静态成员。”但是，有一种例外。 我们可以为静态成员提供const 整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr(参见 7.5.6 节，第267 页)。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适合于常量表达式的地方。例如，我们可以用一个初始化了的静态数据成员指定数组成员的维度: 12345678class Account&#123;private: static constexpr int period = 30; double daily_tbl[period];&#125;;// 不带初始值的定义constexpr int Account::period; 书中提到了两种情况，说明static constexpr是否需要重复定义： 仅用静态常量表达式替换它的值，如定义数组维度，则不用重复定义（也可以多此一举地定义） 当需要将其传递为一个接收该类型的函数时，则需要重复定义。 为省去麻烦，干脆不论上述何种情况，都在类外重新不带初始值地定义一下该成员。如上述代码最后一行所示。 7.6.4 能使用静态成员，而不能使用普通成员变量的场景一、静态数据成员可以是不完全类型有关不完全类型见书P250–类的声明和笔记7.3.6 类类型 特别的，静态数据成员的类型可以就是它所属的类型，而非静态成员变量只能声明它所属的类的指针或引用 123456class Bar&#123;private: static Bar mem1; //正确，静态成员可以是不完全类型 Bar *men2; //正确，指针成员可以是不完全类型 Bar mem3; // 错误，数据成员必须是完整类型&#125;; 二、可以使用静态成员作默认实参，而普通成员不行123456789101112131415161718192021class Screen &#123;public: //静态成员作默认实参 Screen&amp; clear(char = bg) ;private: static char bg;&#125;;char Screen::bg = &#x27;a&#x27;; // 类外定义static数据成员Screen&amp; Screen::clear(char s) &#123; cout &lt;&lt; s &lt;&lt; endl; return *this;&#125;int main() &#123; Screen a; a.clear(); // 使用默认实参bg，终端输出 a return 0;&#125; ------标准库------ 八 标准库的IO操作8.1 IO类8.1.1 IO库类型和头文件 标准库给出的IO类型如下图所示；其中，以“w”开头的版本是为了支持宽字符语言，标准库定义了一组类型和对象来操纵wchar_t类型的数据。 8.1.2 IO对象无拷贝或赋值 IO对象不能拷贝或者赋值 不能拷贝io对象，因此我们不能将形参或返回值类型设置为流类型，而常以引用方式传递 读写一个io对象会改变其状态，因此传递和返回的引用不能是const 1234ofstream out1,out2;out1 = out2; //错误，不能对流对象赋值ofstream print(ofstream); //错误，不能初始化ofstream参数out1 = print(out2); //错误，不能拷贝流对象（不能将形参设置为流对象） 8.1.3 IO状态 条件状态表 判断一个流是否处于良好状态的最简单的方法 123while(cin&gt;&gt;word)&#123; //读取成功的操作&#125; IO 库定义了一个与机器无关的 iostate 类型，该类型应作为一个位集合来使用。有4个iostate类型的constexpr值（badbit,failbit,eofbit,goodbit），表示特定的位模式，这些值可以与位运算符一起使用来一次性检测或设置多个标志位： badbit 表示系统级错误，如不可恢复的读写错误。通常情况下，一旦 badbit 被置位，流就无法再使用了。 failbit 被置位于发生可恢复错误后，如期望读取数值却读取一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。 如果到达文件结束位置，eofbit 和 failbit 都会被置位。 goodbit 的值为0，表示流未发生错误。如果badbit、failbit 和eofbit 任一个被置位，则检测流状态的条件会失败。 为检测流的状态，IO库提供了一组函数。其中，good()和fail()是确定流的总体状态的方法。下面列出两种使用方法： 状态管理：保存流的状态并恢复 1234auto old_state = cin.rdstate();cin.clear();proess_func(cin);cin.setstate(old_state); 将failbit和badbit复位，但保持eofbit不变： 1cin.clear(cin.rdstate() &amp; ~cin.failbit &amp; ~cin.badbit); 过程如下图所示 8.1.4 缓冲区 导致缓冲区刷新的原因 程序正常结束，作为main函数return操作的一部分，缓冲刷新被执行。 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。 我们可以使用操纵符如endl(参见1.2节，第6页)来显式刷新缓冲区。 在每个输出操作之后，我们可以用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr 是设置unitbuf的，因此写到cerr的内容都是立即刷新的。 一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和 cerr 都关联到 cout。因此，读cin或写cerr都会导致cout的缓冲区被刷新。 刷新缓冲区的几种方式 12345678cout&lt;&lt;&quot;hi&quot;&lt;&lt;endl; //附加一个换行符，然后刷新缓冲区cout&lt;&lt;&quot;hi&quot;&lt;&lt;flush; //不附加任何字符，刷新缓冲区cout&lt;&lt;&quot;hi&quot;&lt;&lt;end; //附加一个空字符，然后刷新缓冲区cout&lt;&lt;unitbuf;//任何输出都立即刷新，无缓冲......;// 一些操作cout&lt;&lt;nounitbuf; // 回到正常的缓冲模式 书中提到的一个注意事项： 警告：如果程序崩溃，输出缓冲区不会被刷新 如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩溃后，它所输出的数据很可能停留在输出缓冲区中等待打印。 当调试一个已经崩溃的程序时，需要确认那些你认为已经输出的数据确实已经刷新了。否则，可能将大量时间浪费在追踪代码为什么没有执行上，而实际上代码已经执行了，只是程序崩溃后缓冲区没有被刷新，输出数据被挂起没有打印而已。 程序员常常在调试添加打印语句。这类语句应该保证一直刷新流。否则，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。 8.1.5 关联输入流和输出流 当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将cin和cout关联，因此cin &gt;&gt;ival将会导致cout的缓冲区被刷新。 利用iostream::tie()函数，既可以将一个istream对象关联到另一个ostream上，也可以将一个ostream关联到另一个ostream上 12345678cin.tie(&amp;cout); // 标准库中，cin与cout关联//old_tie指向旧的关联ostream *old_tie = cin.tie(nullptr);//cin不再与任何流关联（即解除关联）cin.tie(&amp;cerr); // 将cin与cerr关联，读取cin会导致cerr的刷新cin.tie(old_tie); // 恢复之前的关联 8.2 iostream书本第5页（略） 8.3 fstream（文件流）8.3.1 fstream的特有操作 fstream继承与iostream，除了可以使用iostream的操作外，还有其特有的操作，如下所示： - **在要求使用基类类型对象的地方，我们可以用继承类型的对象来替代。**因为fstream（和sstream）继承于iostream，所以接受iostream的引用（或指针）参数的函数，可以用对用的fstream（或sstream）类型来调用。 - 通过构造函数打开文件的，会自动调用`open()`和`close()` （自动构造和析构）。通过`open()`打开文件，则必须在结束是手动书写`close()`。 - 对一个已经打开的文件流调用`open()`会失败，并导致`failbit`被置位。必须先关闭（`close()`）已经关联的文件，再打开新文件。 8.3.2 文件模式 默认模式 ifstream：in模式 ofstream：out模式 fstream：in+out模式 一些注意事项 以out模式打开文件会将文件清空，除非同时显式指定app或in。 只有当out也被设定时才可设定trunc 每次调用open()都要（显式或隐式地）重新设置文件模式。 只可以对ofstream或fstream设置out 只可以对ifstream或fstream设置in 只要 trunc没被设定，就可以设定app 模式。在 app模式下，即使没有显式指定out 模式，文件也总是以输出方式被打开。 ate和binary模式可用于任何类型的文件流对象，且可以与其他任何文件模式组合使用。 8.4 sstream（string流） 和fstream同样继承与ostream，既可以使用iostream的操作，也有其特有操作： strm.str(s)会清空strm中原有的数据，示例： 12345678910111213141516171819#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; ostringstream nums; vector&lt;string&gt; nums_vec&#123;&quot;123&quot;,&quot;456&quot;,&quot;789&quot;,&quot;101112&quot;&#125;; for ( auto num : nums_vec) &#123; nums &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; nums.str() &lt;&lt; endl; //123 456 789 101112 nums.str(string(&quot;888&quot;)); // 清空了string流中原有的数据 cout &lt;&lt; nums.str() &lt;&lt; endl; //888 return 0;&#125; 8.4.1 istringstream 何时使用？ 当我们对整行文本进行处理，并同时需要处理行内的单个单词时。 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;vector&gt;using namespace std;struct PersonInfo &#123; string name; vector&lt;string&gt; phones;&#125;;int main() &#123; string line, phone; vector&lt;PersonInfo&gt; people; // 将文件中的所有数据存入people:vector&lt;PersonInfo&gt;中 while (getline(cin, line)) &#123; PersonInfo info; istringstream record(line); record &gt;&gt; info.name; while (record &gt;&gt; phone) &#123; info.phones.push_back(phone); &#125; people.push_back(info); &#125; // 逐人验证号码是否有效 for(const auto &amp;entry : people) &#123; ostringstream formated, badNums; for (const auto &amp;phone :entry.phones) &#123; if (!valid(phone)) &#123; // 省略判断电话是否有效的代码 badNums &lt;&lt; phone &lt;&lt; &quot; &quot;; &#125; else&#123; formated &lt;&lt; format(phone) &lt;&lt; &quot; &quot;; //省略格式化电话号码的代码 &#125; &#125; if (badNums.str().empty()) cout &lt;&lt; entry.name &lt;&lt; &quot; &quot; &lt;&lt; formated.str() &lt;&lt; endl; else cerr &lt;&lt; &quot;input error: &quot; &lt;&lt; entry.name &lt;&lt; &quot; invalid numbers(s) &quot;&lt;&lt; badNums.str() &lt;&lt; endl; &#125; return 0;&#125; 8.4.2 ostringstream 何时使用？我们想逐步构造输出的内容，希望放在最后一起打印。（此构造非构造函数的构造，不要过分解读）） 接着8.4.1节的代码，示例如下： 12345678910111213141516171819202122232425// 逐人验证号码是否有效for(const auto &amp;entry : people)&#123; ostringstream formated, badNums; for (const auto &amp;phone :entry.phones) &#123; if (!valid(phone)) &#123; // 省略判断电话是否有效的代码 badNums &lt;&lt; phone &lt;&lt; &quot; &quot;; &#125; else&#123; formated &lt;&lt; format(phone) &lt;&lt; &quot; &quot;; //省略格式化电话号码的代码 /*注意此处 ↑。 使用标准的输出运算符`&lt;&lt;`向这些对象写入数据， 但这些“写入”操作实际上转换为 `string`操作， 分别向` formatted`和`badNums`中的`string `对象添加字符。*/ &#125; &#125; if (badNums.str().empty()) cout &lt;&lt; entry.name &lt;&lt; &quot; &quot; &lt;&lt; formated.str() &lt;&lt; endl; else cerr &lt;&lt; &quot;input error: &quot; &lt;&lt; entry.name &lt;&lt; &quot; invalid numbers(s) &quot;&lt;&lt; badNums.str() &lt;&lt; endl; 程序最有趣的部分是对字符串流 formatted和badNums 的使用。我们使用标准的输出运算符&lt;&lt;向这些对象写入数据，但这些“写入”操作实际上转换为 string操作，分别向 formatted和badNums中的string 对象添加字符。 8.4.3 本节完整的示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* 文件中的数据 *///morgan 2015552368 8625550123//drew 9735550130l//ee 6095550132 2015550175 8005550000#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;vector&gt;using namespace std;struct PersonInfo &#123; string name; vector&lt;string&gt; phones;&#125;;int main() &#123; string line, phone; vector&lt;PersonInfo&gt; people; // 将文件中的所有数据存入people:vector&lt;PersonInfo&gt;中 while (getline(cin, line)) &#123; PersonInfo info; istringstream record(line); record &gt;&gt; info.name; while (record &gt;&gt; phone) &#123; info.phones.push_back(phone); &#125; people.push_back(info); &#125; // 逐人验证号码是否有效 for(const auto &amp;entry : people) &#123; ostringstream formated, badNums; for (const auto &amp;phone :entry.phones) &#123; if (!valid(phone)) &#123; // 省略判断电话是否有效的代码 badNums &lt;&lt; phone &lt;&lt; &quot; &quot;; &#125; else&#123; formated &lt;&lt; format(phone) &lt;&lt; &quot; &quot;; //省略格式化电话号码的代码 &#125; &#125; if (badNums.str().empty()) cout &lt;&lt; entry.name &lt;&lt; &quot; &quot; &lt;&lt; formated.str() &lt;&lt; endl; else cerr &lt;&lt; &quot;input error: &quot; &lt;&lt; entry.name &lt;&lt; &quot; invalid numbers(s) &quot;&lt;&lt; badNums.str() &lt;&lt; endl; &#125; return 0;&#125; 九 顺序容器9.1 概述 forward_list没有size操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其他容器而言，size保证的是一个快速的常量时间的操作。 9.1.1 选用顺序容器的原则 首选vector 很多小元素，且空间开销重要 –&gt; 不要使用list或forward_list 要求随机访问 –&gt; vector或deque 中间插入和删除 –&gt; list或forward_list 头尾插入和删除，但不在中间插入和删除 –&gt; deque 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则 首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向 vector 追加数据，然后再调用标准库的sort函数，来重排容器中的元素，从而避免在中间位置添加元素。 如果必须在中间位置插入元素，考虑在输入阶段使用 list，一旦输入完成，将list中的内容拷贝到一个 vector 中。 如果程序既需要随机访问元素，又需要在容器中间位置插入元素，则取决于在list 或forward_list 中访问元素与 vector 或deque中插入&#x2F;删除元素的相对性能，一般来说，应用中占主导地位的操作(执行的访问操作更多还是插入&#x2F;删除更多)决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了）。 如果你不确定应该使用哪种容器，那么可以在程序中只使用 vector 和list公共的操作：迭代器，而不是使用下标，以避免随机访问。这样，在必要时选择使用vector或list 都很方便。 9.2 容器库概览 对于容器类型的操作，有些适用于所有容器；有些仅针对顺序或关联或无序；有些适用于个别容器。 本节介绍适用于所用容器的操作。 本章剩余部分则聚焦顺序容器的操作。 虽然我们可以在容器中保存几乎任何类型，但某些容器操作对元素类型有其自己的特殊要求。我们可以为不支持特定操作需求的类型定义容器，但这种情况下就只能使用那些没有特殊要求的容器操作了。有如下示例。 顺序容器的 接受容器大小的 构造函数版本，要求其中元素的类型必须能够被默认初始化。 123//NoDefault：a Type With No Default Constructorvector&lt;NoDefault&gt; v1(10,init); // 正确，提供了元素初始化器vector&lt;NoDefault&gt; v1(10); // 错误，需要元素初始化 9.2.1 迭代器在书P296~P299，介绍了容器的迭代器。书中首先说，与容器一样，迭代器有着公共的接口，不同容器的迭代器都执行着类似的操作。 并特别指出，forward_list的迭代器不支持-- 。 接着介绍了迭代器的左闭右开区间：[ begin , end )，以及利用该特性对容器中元素进行访问的操作。特别提到需要保证在合法的范围内解引用begin。 然后提到了类型成员，特别提到了反向迭代器，与正向迭代器相比，各种操作的含义都发生了颠倒。比如，++会得到上一个元素；rbegin和rend会获得尾元素和首元素之前位置的迭代器。笔记10.4.3介绍 提到容器相关的类型别名在书16章介绍。 P298，书9.2.3节begin和end成员 中提到： 迭代器中（begin，cbegin，rbegin，crbegin，end，cend，rend，crend），不以c开头的版本都是重载过的。 可以将一个普通版本的iterator转化为对应的const_iterator，反之则不然。 当auto与begin或end结合使用时，获得的选代器类型依赖于容器类型，与我们想要如何使用迭代器毫不相干。但以c 开头的版本还是可以获得 const_iterator 的而不管容器的类型是什么。示例如下 12auto it7 = a.begin(); // 仅当a是const时，it7是const_iteratorauto it8 = a.cbegin(); // it8是const_iterator 当不需要写访问时，应使用 cbegin 和cend。 笔记10.4 再探迭代器将对迭代器的内容进行拓展。 9.2.2 容器定义和初始化 一、拷贝初始化将一个新容器创建为另一个容器的拷贝的方法有两种： 直接拷贝整个容器 要求两个容器的类型及其元素类型必须匹配 示例 1234567list&lt;string&gt; authors = &#123;&quot;Milton&quot;,&quot;Shakespeare&quot;,&quot;Austen&quot;&#125;; // 列表初始化list&lt;string&gt; list2(authors);//等价list&lt;string&gt; list2 = authors;vector&lt;string&gt; list3(authors); //错误，容器的类型不匹配list&lt;char *&gt; list4(authors); //错误，元素的类型不匹配 拷贝由 迭代器对 指定的元素范围 不要求容器的类型相同，也不要求元素的类型相同。只要能将要拷贝的元素转换为要初始化的容器的元素类型即可。 12list&lt;const char *&gt; authors = &#123;&quot;Milton&quot;,&quot;Shakespeare&quot;,&quot;Austen&quot;&#125;;forward_list&lt;string&gt; words(authors.begin(), authors.end()); array不适用 二、列表初始化略 三、顺序容器独有：指定容器大小来初始化 只有顺序容器的构造函数才接受大小参数，关联容器并不支持。 如果元素类型是内置类型或者是具有默认构造函数的类类型，可以只为构造函数提供一个容器大小参数。如果元素类型没有默认构造函数，除了大小参数外，还必须指定一个显式的元素初始值。举个例子，创建一个Test类，并将其默认构造函数删除，编译器报错如下。 12345678910111213141516class Test &#123;public: Test() = delete; /*删除了默认构造函数，成员变量a无法执行默认初始化。 * 当创建10个Test类型的vector的时候，找不到默认构造函数，编译器报错如下： * 错误 C2280 “Test::Test(void)”: 尝试引用已删除的函数 */private: int a;&#125;;int main() &#123; vector&lt;Test&gt; t(10); return 0;&#125; 不指定大小的容器中，元素可以没有构造函数。如上面提到的拷贝初始化、列表初始化等。 四、array的固定大小 大小也是类型的一部分，必须同时指定元素类型和大小。 和其他容器不同，默认构造的array是非空的。其包含了指定数量的被默认初始化后的元素（因此元素类型一定要有默认初始化）。 值得注意的是，虽然不能对内置数组类型进行拷贝或者对象赋值，但array没有该限制。array&lt;&gt;在拷贝赋值的时候，注意元素类型和数量要一样。内置数组拷贝赋值和array容器拷贝赋值对比如下： 9.2.3 赋值和swap 上表中列出的，与赋值有关的运算符可用于所有容器： 12c1=c2;c1=&#123;a,b&#125;; 由于右边运算对象的大小可能与左边运算对象的大小不同，因此array类型不支持assign，也不允许用花括号值列表进行赋值。 12345array&lt;int,10&gt; a1 = &#123;0,1,2,3,4,5,6,7,8,9&#125;;array&lt;int,10&gt; a2 = &#123;0&#125;; // 10个0a2 = a1; //正确a2 = &#123;0&#125;; //错误，不能用花括号值列表给array赋值 assign() 仅顺序容器 允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。 123456789101112131415#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;int main() &#123; list&lt;string&gt; names; vector&lt;const char*&gt; old_style; names = old_style; // 错误,容器类型不匹配 names.assign(old_style.begin(), old_style.end()); // 自动进行了类型转换 return 0;&#125; 由于其旧元素被替代，因此传递给assign的迭代器不能指向调用assign的容器。以下是ChatGPT给出的例子，人为制造一个错误。 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;int main() &#123; std::list&lt;int&gt; originalList = &#123;1, 2, 3, 4, 5&#125;; // 试图在循环中使用迭代器来调用 assign for (auto it = originalList.begin(); it != originalList.end(); ++it) &#123; // 尝试在循环中调用 assign，传递迭代器指向原始列表 originalList.assign(it, it); // 这里迭代器已经失效，因为 assign 改变了容器的大小 // 这可能导致未定义的行为或程序崩溃 std::cout &lt;&lt; *it &lt;&lt; std::endl; // 试图访问失效的迭代器 &#125; return 0;&#125; swap() 交换两个相同类型的容器内容。 除array外，swap不对任何元素进行拷贝、删除或插入操作，只交换两个容器的内部数据结构，因此速度非常快。而对array则会真正交换它们的元素。 除string外，指向容器的迭代器、引用和指针，在swap操作后都不会失效，仍指向swap操作前所指向的那些元素。但是这些元素已经属于不同的容器了。 统一使用非成员版本的swap()是个好习惯。 9.2.4 容器大小 size()：返回元素数目。**forward_list不支持size()** empty()：容器是否为空 max_size()：返回一个大于或等于该类型容器所能容纳的最大元素数的值。 9.2.5 关系运算 每个容器类型都支持相等运算符（&#x3D;&#x3D;和!&#x3D;） 除无序关联容器外都支持关系运算符（&gt; 、&gt;&#x3D;、 &lt; 、&lt;&#x3D;） 比较的对象必须有相同的容器类型和相同的元素类型。 用于比较的元素类型必须重载了（定义了）关系运算符 比较规则类似string，如下： 9.3 顺序容器的特有操作9.3.1 插入元素 一、push_back 除array和forward_list外，每个顺序容器（包括string）都支持push_back。 push_back是将对象拷贝， 关键概念:容器元素是拷贝当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。 二、push_front list、forward_list、deque还支持push_front 三、insert vector、deque、list、string都支持insert。（注：forward_list为特殊版本，于forward_list专题介绍） 每个insert都接受一个迭代器作为其第一参数，表示将某个（些）额外的元素添加到这个迭代器所指向的元素之前。 &lt;–注意，是之前插入 虽然某些容器（如vector）不支持push_front 操作，但它们对于 insert 操作并无类似的限制（插入开始位置）。因此我们可以将元素插入到容器的开始位置，而不必担心容器是否支持push_front : 123456789101112131415#include &lt;iostream&gt;using namespace std;#include &lt;vector&gt;#include &lt;string&gt;int main() &#123; vector&lt;string&gt; vec_str = &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;; // vector不支持push_front,但是可以通过insert插入新的首元素，但是可能很耗时 vec_str.insert(vec_str.begin(), &quot;hello&quot;); for(const auto &amp;word : vec_str) cout&lt;&lt;word&lt;&lt;&quot; &quot;; // hello a b c return 0;&#125; 一、插入特定元素 1c.insert(p,t); //对容器c，向p位置之前插入元素t 二、插入范围内元素 c.insert(p,n,t) ：对容器c，向p位置之前插入n个元素t c.insert(p,b,e)：对容器c，向p位置之前插入一对迭代器，特别说明，这对迭代器不能指向 调用insert的容器对象（此处为c） 的元素 c.insert(p,il)：对容器c，向p位置之前插入初始化列表il 本节的三种插入方式，返回指向第一个新加入元素的迭代器。如果插入为空，则将insert的第一个参数返回。 通过使用该返回值，可以在容器中一个特定的位置反复插入元素。示例如下： 1234567891011121314#include &lt;iostream&gt;using namespace std;#include &lt;string&gt;#include &lt;list&gt;int main() &#123; list&lt;string&gt; lst; string word; auto iter = lst.begin(); while(cin&gt;&gt;word) //等价于调用push_front iter = lst.insert(iter,word); return 0;&#125; 三、 emplace_front、emplace、emplace_back与push_front、insert、push_back对应。 push_xxx和insert，将元素类型的对象拷贝到容器中； emplace_xxx则是将参数传递给元素类型的构造函数，以在容器管理的内存空间中直接构造元素。传递给emplace函数的参数必须元素类型的构造函数相匹配。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;#include &lt;utility&gt;#include &lt;vector&gt;class Sales_data&#123; friend ostream &amp; operator&lt;&lt;(ostream&amp; os, Sales_data sd);public: using uint = unsigned ; Sales_data() = default; Sales_data(string isbn, uint cnt, double price) :m_isbn(isbn),m_cnt(cnt),m_price(price)&#123;&#125;private: string m_isbn; uint m_cnt = 0; double m_price = 0;&#125;;ostream &amp; operator&lt;&lt;(ostream&amp; os, Sales_data sd)&#123; os&lt;&lt;sd.m_isbn&lt;&lt;&quot; &quot;&lt;&lt;sd.m_cnt&lt;&lt;&quot; &quot;&lt;&lt;sd.m_price; return os;&#125;int main() &#123; vector&lt;Sales_data&gt; vec; vec.emplace_back(&quot;123&quot;,25,15.99);//直接在容器的内存空间中创建对象 vec.push_back(Sales_data(&quot;456&quot;,15,36.2)); // 创建元素的临时对象，并将其拷贝到容器 for(const auto &amp; sales_data : vec) cout&lt;&lt;sales_data&lt;&lt;endl; /* 终端输出： 123 25 15.99 456 15 36.2 */&#125; 9.3.2 访问元素 at和下标运算符只使用于string、vector、deque、array back不适用forward_list back() 、front()、 at 和下标运算符返回的都是引用。 at相较于下标运算符较安全，越界抛出out_of_range的异常。 因为返回的是引用，可通过访问元素的函数修改容器内容： 123456789101112131415161718192021#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; vector&lt;int&gt; vec&#123;0,1,2,3,4,5,6,7,8,9&#125;; vec.front() = 42; auto &amp;v1 = vec.back(); v1 = 1024; //理解auto的规则（笔记2.6.2）： // auto以引用对象的类型作为auto的类型 auto v2 = vec.back(); //不是引用，是一个拷贝 v2 = 0; //未能改变vec中的元素 for(const auto &amp; num : vec) cout&lt;&lt;num&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; return 0;&#125; 9.3.3 删除元素 pop_front()和pop_back()返回void，如果还需要弹出的元素值，要在弹出前保存。 erase(p)返回p的下一个元素的迭代器 erase(b,e)e指向要删除的最后一个元素的下一个位置，结束后b&#x3D;&#x3D;e 1234vector&lt;int&gt; vec&#123;0,1,2,3&#125;;vec.clear();//等价vec.erase(vec.begin(),vec.end()); 补充：forward_list没有pop_back()，如何删除尾元素？ 在C++中，std::forward_list是单向链表，由于单向链表的特性，删除最后一个元素需要一些额外的考虑，因为它没有直接提供像pop_back这样的成员函数，而是需要从头开始遍历链表找到倒数第二个元素，然后将其next指针置为空。 1234567891011121314151617181920212223242526272829303132/*** forward_list删除尾元素*/#include &lt;iostream&gt;#include &lt;forward_list&gt;int main() &#123; std::forward_list&lt;int&gt; myList = &#123;1, 2, 3, 4, 5&#125;; // 如果列表为空，无需进行任何操作 if (!myList.empty()) &#123; auto current = myList.before_begin(); // 迭代器指向头之前的位置 auto last = myList.begin(); // 迭代器指向头 // 遍历找到倒数第二个元素 while (std::next(last) != myList.end()) &#123; ++current; ++last; &#125; // 删除最后一个元素 myList.erase_after(current); &#125; // 输出删除后的列表 for (const auto&amp; value : myList) &#123; std::cout &lt;&lt; value &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; std::next是C++标准库中的一个函数模板，用于返回给定迭代器的下一个迭代器。该函数的定义位于头文件 &lt;iterator&gt; 中。下面是它的基本语法： 12template&lt; class InputIt &gt;InputIt next( InputIt it, typename std::iterator_traits&lt;InputIt&gt;::difference_type n = 1 ); it：要获取下一个迭代器的起始迭代器。 n：要移动的步数，默认为1。std::next在迭代器上执行递增操作，允许你在容器中向前移动指定数量的位置。这对于在算法中进行迭代器操作时非常有用。以下是一个简单的示例，演示如何使用std::next： 1234567891011121314#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;vector&gt;int main() &#123; std::vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;; auto it = numbers.begin(); // 使用 std::next 将迭代器向前移动两个位置 auto advancedIt = std::next(it, 2); // 输出结果 std::cout &lt;&lt; &quot;Original iterator value: &quot; &lt;&lt; *it &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Advanced iterator value: &quot; &lt;&lt; *advancedIt &lt;&lt; std::endl; return 0;&#125; 在这个示例中，std::next被用来将迭代器 it 向前移动两个位置，产生一个新的迭代器 advancedIt。这样，你可以在容器中灵活地移动迭代器，而不必手动进行逐步增加。如果有其他问题或需要更详细的解释，请随时提出。 9.3.4 改变容器大小 如果当前大小大于所要求的大小，容器后部的元素会被删除:如果当前大小小于新大小，会将新元素添加到容器后部: 1234list&lt;int&gt; ilist(10,42); //10个int:每个的值都是42ilist.resize(15); //将5个值为0的元素添加到 ilist 的末尾ilist.resize(25,-1); //将10个值为-1的元素添加到 ilist的末尾ilist.resize(5); //从ilist末尾删除20个元素 resize 操作接受一个可选的元素值参数，用来初始化添加到容器中的元素。如果调用者未提供此参数，新元素进行值初始化。 如果容器保存的是类类型元素，且 resize 向容器添加新元素，则我们必须提供初始值，或者元素类型必须提供一个默认构造函数。 9.3.5 容器操作可能使迭代器失效一、添加元素 二、删除元素 三、因此，我们需要管理迭代器 当你使用迭代器（或指向容器元素的引用或指针）时，最小化要求迭代器必须保持有效的程序片段是一个好的方法。 由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确地重新定位迭代器。这个建议对 vector、string和 deque尤为重要。 有两个要求： 添加&#x2F;删除vector、string 或deque 元素的循环程序必须考虑迭代器、引用和指针可能失效的问题： 每次循环都更新迭代器、引用或指针。 1234567891011121314151617181920212223242526272829303132/** * 添加/删除vector、string 或deque 元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。 * 程序必须保证每个循环步中都更新迭代器、引用或指针。 * 如果循环中调用的是insert()或erase()，那么更新迭代器很容易，因为这些操作都返回迭代器，我们可以用来更新: */#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; vector&lt;int&gt; vec&#123;0,1,2,3,4,5,6,7,8,9&#125;; auto it = vec.begin(); while(it!=vec.end())&#123; //注意等号左侧，每步循环都更新了迭代器 if(*it % 2)&#123; //奇数 it = vec.insert(it, *it); it += 2; // 向前移动迭代器，跳过当前元素及插入到它之前的元素 // insert()在it的前面插入新元素，并返回指向新插入元素的迭代器，所以+2 &#125; else&#123; //偶数 it = vec.erase(it); // 不必向前移动迭代器，erase()使it指向删除元素的下一个位置 &#125; &#125; for(const auto &amp;num:vec) cout&lt;&lt;num&lt;&lt;&quot; &quot;; // 1 1 3 3 5 5 7 7 9 9 cout&lt;&lt;endl; return 0;&#125; 不要保存end返回的迭代器 当添加&#x2F;删除vector、string的元素，或在deque中首元素之外的任何位置添加&#x2F;删除元素，原来的end返回的迭代器总是失效。 因此，如果在一个循环中插入&#x2F;删除deque、string、vector中的元素，不要缓存end返回的迭代器。 12345678910111213141516171819202122/** * 想要往每两个数中间插入42 */#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; vector&lt;int&gt; vec&#123;0,1,2,3,4,5,6,7,8,9&#125;; auto be = vec.begin();// auto en = vec.end(); /*insert后，end迭代器失效会引发死循环*/// while(be != en)&#123; /*循环中，不要缓存尾后迭代器*/ while(be != vec.end())&#123; /*应该在每次插入操作后重新调用end()*/ ++be; be = vec.insert(be,42); ++be; &#125; for(const auto &amp;num:vec) cout&lt;&lt;num&lt;&lt;&quot; &quot;; // 0 42 1 42 2 42 3 42 4 42 5 42 6 42 7 42 8 42 9 42 cout&lt;&lt;endl; return 0;&#125; 9.4 vector对象是如何增长的？ resize和reserve resize改变容器中元素的数目，而不是容器的容量，如不能减少预留的内存空间。 reserve仅影响vector&#x2F;string预先分配多大的内存，并不改变容器中元素的数目 capacity和size size已经保存的元素数目 capacity表示在不分配新的内存的前提下，容器最多保存多少元素。 示例 123456789101112131415161718192021222324252627282930313233#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; vector&lt;int&gt; ivec; cout&lt;&lt;&quot;size = &quot;&lt;&lt;ivec.size()&lt;&lt;&quot; | &quot;&lt;&lt;&quot;capacity = &quot;&lt;&lt;ivec.capacity()&lt;&lt;endl; // size = 0 | capacity = 0 for(int i = 0; i &lt; 24; ++i) ivec.push_back(i); cout&lt;&lt;&quot;size = &quot;&lt;&lt;ivec.size()&lt;&lt;&quot; | &quot;&lt;&lt;&quot;capacity = &quot;&lt;&lt;ivec.capacity()&lt;&lt;endl; // size = 24 | capacity = 32 // 存了24个元素，分配了可保存32个元素内存 ivec.reserve(50); cout&lt;&lt;&quot;size = &quot;&lt;&lt;ivec.size()&lt;&lt;&quot; | &quot;&lt;&lt;&quot;capacity = &quot;&lt;&lt;ivec.capacity()&lt;&lt;endl; // size = 24 | capacity = 50、 // reserve()将内存括展到了50，ivec内元素个数没变 while(ivec.size()!=ivec.capacity()) ivec.push_back(0); //写满预分配的内存 ivec.push_back(1); // 在添加1位 cout&lt;&lt;&quot;size = &quot;&lt;&lt;ivec.size()&lt;&lt;&quot; | &quot;&lt;&lt;&quot;capacity = &quot;&lt;&lt;ivec.capacity()&lt;&lt;endl; // size = 51 | capacity = 100 // 超出预分配的内存，ivec的内存两倍括展 ivec.shrink_to_fit(); cout&lt;&lt;&quot;size = &quot;&lt;&lt;ivec.size()&lt;&lt;&quot; | &quot;&lt;&lt;&quot;capacity = &quot;&lt;&lt;ivec.capacity()&lt;&lt;endl; // size = 51 | capacity = 51 // 请求退还没有用过的内存（不一定采纳） return 0;&#125; 9.5 forward_list专题原文《特殊的forward_list》操作 当添加或删除一个元素时，删除或添加的元素之前的那个元素的后继会发生改变。为了添加或删除一个元素，我们需要访问其前驱，以便改变前驱的链接。但是，forward_list 是单向链表。在一个单向链表中，没有简单的方法来获取一个元素的前驱。 出于这个原因，在一个 forward list 中添加或删除元素的操作是通过改变给定元素之后的元素来完成的。这样，我们总是可以访问到被添加或删除操作所影响的元素。由于这些操作与其他容器上的操作的实现方式不同，forward_list 并未定义insert、emplace和erase，而是定义了名为insert_after、emplace_after和erase_after 的操作(参见表 9.8)。 例如，在我们的例子中，为了删除 elem3，应该用指向elem2的迭代器调用 erase_after。为了支持这些操作，forward_list还定义了before_begin，它返回一个首前迭代器。这个选代器允许我们在链表首元素之前并不存在的元素“之后”添加或删除元素(亦即在链表首元素之前添加删除元素)。 示例： 当向forward_list中添加或删除元素时，我们必须关注两个选代器：一个指向我们要处理的元素，另一个指向其前驱。 12345678910111213141516171819202122232425262728293031/** * 知识点： * 当向forward_list中添加或删除元素时，我们必须关注两个选代器： * 一个指向我们要处理的元素，另一个指向其前驱。 * * 示例：删除forward_list中的奇数 */#include &lt;forward_list&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; forward_list&lt;int&gt; flist = &#123;0,1,2,3,4,5,6,7,8,9&#125;; auto prev = flist.before_begin();//首前迭代器 auto curr = flist.begin(); while(curr != flist.end())&#123; if(*curr%2)&#123; //奇数 curr = flist.erase_after(prev);//返回删除的元素的下一个位置的迭代器，并用其更新curr &#125; else&#123; prev = curr; ++curr; &#125; &#125; for(const auto &amp;num:flist) cout&lt;&lt;num&lt;&lt;&quot; &quot;; //0 2 4 6 8 cout&lt;&lt;endl; return 0;&#125; 9.6 string专题书P320《9.5 额外的string操作》 除了顺序容器的共同操作外，string还提供了一些额外的操作，如所述。 9.6.1 string操作函数汇总 9.6.2 构造string的子序列除了在[笔记3.2.1](#3.2.1 初始化)已经介绍过的构造函数方法，以及与其他顺序容器相同的构造函数外，string还支持另外3个构造函数。 当我们从一个const char*创建string时 通常，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止。 如果我们还传递给构造函数一个计数值，数组就不必以空字符结尾。 如果我们未传递计数值且数组也未以空字符结尾，或者给定计数值大于数组大小，则构造函数的行为是未定义的。 因此，const char *数组最好以空字符结尾。 当从string拷贝： 开始位置要小于或等于size 计数值再大，最多拷贝到string结束的位置 子字符串操作： str.substr(pos = 0, n = str.size() -pos); 9.6.2 改变string的其他方法联想：[3.4.4 与旧代码接口—c风格字符串](#3.4.4 与旧代码接口) string类型支持顺序容器的赋值运算符以及assign、insert 和erase操作(表9.4；表9.7)外，还定义了额外的insert和erase版本。 insert、erase、assign示例 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;void printStr(string &amp;str)&#123; cout&lt;&lt;str&lt;&lt;&quot; | size = &quot;&lt;&lt;str.size()&lt;&lt;endl;&#125;int main()&#123; string s = &quot;abcdefghij&quot;; printStr(s); // abcdefghij | size = 10 string s1 = s; s1.insert(s1.size(), 5, &#x27;!&#x27;); //末尾插入5个感叹号 printStr(s1); // abcdefghij!!!!! | size = 15 string s2 = s; s2.erase(s.size()-5/*, 5*/); // 从s的倒数5个位置开始，删除最后5个字符 printStr(s2); // abcde | size = 5 string s3 = s; const char *cp = &quot;stately, plump buck&quot;; s3.assign(cp,2); // 用cp的前2个字符覆盖整个s printStr(s3); // st | size = 2 string s4 = s; s4.insert(s.size(), cp+7); // 从cp向后移动7位所指向的元素开始，到cp结束之间的所有字符，插入到s的末尾(s.size()) printStr(s4); // abcdefghij, plump buck | size = 22 string s5 = s; string s5_ = &quot;,xyz&quot;; s5.insert(0,s5_); //在s5的位置0处插入s5_ printStr(s5); // ,xyzabcdefghij | size = 14 string s6 = s; s6.insert(0,s5_,0,s5_.size()); // 在s6[0]之前插入s5_中s5_[0]开始的s5_.size()个字符 printStr(s6); //,xyzabcdefghij | size = 14&#125; append、replace示例 append(str)：末尾追加str replace(开始位置pos，删除几个元素n，在当前位置添加字符串str) &#x3D; erase+insert；删除的字符数n可以不等于添加的字符数量str 1234567891011121314151617181920#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;void printStr(string &amp;str)&#123; cout&lt;&lt;str&lt;&lt;&quot; | size = &quot;&lt;&lt;str.size()&lt;&lt;endl;&#125;int main()&#123; string s&#123;&quot;c++ primer&quot;&#125;; s.append(&quot; 4th Ed.&quot;); printStr(s); // c++ primer 4th Ed. | size = 18 s.replace(11,3,&quot;5th&quot;); printStr(s); //c++ primer 5th Ed. | size = 18 //replace时，删除的字符数和添加的字符数可以不相等 s.replace(11,3,&quot;Fifth&quot;);// 删除3个字符，但增加5个字符 printStr(s); // c++ primer Fifth Ed. | size = 20&#125; 9.6.3 string搜索操作 string类提供了6个搜索函数，每个函数都有4个重载版本。 搜索操作返回string::size_type值，表示匹配发生位置的下标。若搜索失败，返回string::npos的static成员。标准库将npos定义为const string::size_type类型，并初始化为-1。又由于npos是unsigned类型，此初始值意味着npos等于任何string最大的可能大小。 搜索操作大小写敏感 str.find_first_of(args)：返回str中第一个出现在args中的元素的下标 12345string str&#123;&quot;pi=3.14&quot;&#125;;string nums&#123;&quot;+-.0123456789&quot;&#125;;auto pos = str.find_first_of(nums);//str中第一个出现在nums的元素的下标（即“pi=3.14”的‘3’的下标）cout&lt;&lt;pos&lt;&lt;endl; // 3 find_last_of、find_first_not_of、find_last_not_of 逆向搜索：有从左向右搜索，也有从右向左搜索的函数 一个常见的设计模式：通过指定 从哪里搜索的可选参数 在字符串中循环地搜索 子字符串出现的所有位置 12345678910111213string::size_type pos=0;string name&#123;&quot;bananabananabanana&quot;&#125;;string nums&#123;&quot;hb&quot;&#125;;while((pos=name.find_first_of(nums,pos))!=string::npos)&#123; cout&lt;&lt;&quot;found number at idx: &quot;&lt;&lt;pos &lt;&lt;&quot;element is &quot;&lt;&lt; name[pos]&lt;&lt;endl; ++pos; //&lt;-- 必须，否则死循环&#125;/*found number at idx: 0element is bfound number at idx: 6element is bfound number at idx: 12element is b*/ 9.6.4 compare见笔记9.6.1汇总 表9.15 9.6.5 数值转换书P327~P328 要转换为数值的string中，第一个空白字符必须是数值可能出现的字符： 123string str&#123;&quot;pi = 3.14&quot;&#125;;double val = stod(str.substr(str.find_first_of(&quot;+-.0123456789&quot;)));cout&lt;&lt;val&lt;&lt;endl; // 3.14 如果string不能转换为数值，表9.6中函数抛出invalid_argument异常 如果转换得到的数值无法用任何类型表示，抛出out_of_range 查找原则 string 参数中第一个非空白符必须是符号(+ 或 -)或数字。它可以以0x 或0X开头来表示十六进制数。 对那些将字符串转换为浮点值的函数，string 参数也可以以小数点 (.)开头，并可以包含 e 或 E 来表示指数部分。 对于那些将字符串转换为整型值的函数，根据基数不同，string 参数可以包含字母字符，对应大于数字9的数。 9.7 适配器（adaptor） 9.7.1 什么是适配器9.7.2 定义一个适配器一、每个适配器都定义两个构造函数 A a;默认构造函数创建一个空对象 A a(c)接受一个容器c的构造函数 ，拷贝容器c的元素来初始化适配器 12345678int main()&#123; deque&lt;int&gt; deq; stack&lt;int&gt; stk(deq); // 拷贝deq的元素到stk，以初始化stk // 其实隐藏了默认容器类型，等价于 stack&lt;int,deque&lt;int&gt;&gt; stk(deq); return 0;&#125; 二、重载默认容器类型默认容器类型： stack和queue基于deque实现 priority_queue基于vector实现 我们可以在创建一个适配器时，将一个命名的顺序容器作为第二个 类型 参数，来重载默认容器类型。 123456789101112using namespace std;int main()&#123; vector&lt;int&gt; vec; // 在vector的基础上实现空栈 stack&lt;int,vector&lt;int&gt;&gt; stk1; // 在vector的基础上实现，初始化时保存vec的拷贝 stack&lt;int,vector&lt;int&gt;&gt; stk2(vec); return 0;&#125; 三、重载默认容器类型的限制stack：可用于除了array和forward_list之外的任何容器类型（deque、list、vector） queue：只能用于list和deque之上，不能用于vector priority_queue只能用于vector和deque，不能用于list 9.7.3 栈适配器参考资料 stack类 —— Microsoft stack定义在stack头文件中 用法示例（书P330）： 12345678910111213#include &lt;stack&gt;using namespace std;int main()&#123; stack&lt;int&gt; stk; for(size_t i = 0; i &lt; 10; ++i) stk.push(static_cast&lt;int&gt;(i)); while (!stk.empty()) &#123; int val = stk.top(); stk.pop(); &#125; return 0;&#125; 虽然每个适配器都是基于底层容器的操作定义自己的操作，但我们只可以使用适配器的操作，而不可使用底层容器的操作。如，虽然stack基于deque实现，stack.push()基于deque.push_back()，但我们不能在一个stack上调用push_back() 9.7.4 队列适配器参考资料 queue类 —— Microsoft priority_queue类 —— Microsoft queue和priority_queue定义在queue头文件中 queue（FIFO） priority_queue: priority_queue 允许我们为队列中的元素建立优先级。新加入的元素会排在所有优先级比它低的已有元素之前。 饭店按照客人预定时间而不是到来时间的早晚来为他们安排座位，就是一个优先队列的例子。 默认情况下，标准库在元素类型上使用&lt;运算符来确定相对优先级。 对于表9.19有个疑问：表中第二行说，queue也可以用list或vector实现，是不是有有误？在《笔记9.6.2三、重载默认容器类型的限制（书P329最下面的一大段话）》中提到：queue：只能用于list和deque之上，不能用于vector。两者是不是冲突了？ 不知道两句换描述的事物是不是不一样，但照我理解，两句话在说一个东西。 实际测试： 1.正确执行 1234567891011121314#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; deque&lt;int&gt; deq&#123;1,2,3,4&#125;; queue&lt;int,deque&lt;int&gt;&gt; que1(deq); while(!que1.empty()) &#123; cout&lt;&lt;que1.front()&lt;&lt;endl; que1.pop(); &#125;&#125; 2.正常编译： 1234567#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; vec&#123;1,2,3,4&#125;; queue&lt;int,vector&lt;int&gt;&gt; que1(vec);&#125; 3.编译器报错： In template: no member named ‘pop_front’ in ‘std::vector‘ 1234567891011121314#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; vector&lt;int&gt; vec&#123;1,2,3,4&#125;; queue&lt;int,vector&lt;int&gt;&gt; que1(vec); while(!que1.empty()) &#123; cout&lt;&lt;que1.front()&lt;&lt;endl; que1.pop(); // &lt;--在此处报错 &#125;&#125; 我认为，确实queue能用vector构造，但是当碰到处理（增删）首元素的情况，就会出错。所以不要用vector构造queue。 9.8 特例汇总9.8.1 forward_list&lt;&gt; 没有size操作 不支持反向迭代器 不支持-- 不支持适配器（因为所有适配器都要求容器有添加、删除和访问尾元素的能力） 单向链表对尾元素的处理很耗时，所以一般不支持xxx_back()操作，而是xxx_after()： 不支持push_back和emplace_back，有自己专有的insert和emplace 不支持back()获取尾元素的引用。 不支持pop_back() forward_list 并未定义insert、emplace和erase，而是定义了名为insert_after、emplace_after和erase_after 的操作（见forward_list专题） 9.8.2 string 不支持C c(n)构造 swap会导致string的迭代器、指针和引用失效。而其他容器不会。 9.8.3 array&lt;&gt;一、构造 C c默认构造的时候，c中的元素也会通过默认构造初始化。如果c是其他容器时，则为空。 不支持通过C c(n,t)、C c(n)构造容器。（n个值为t的元素） 二、拷贝和赋值 不支持c = &#123;a,b,c,...&#125; 不支持C c(b,e)：b和e为迭代器的范围拷贝构造（见笔记9.2.2 一、拷贝初始化） C c1=c2两者必须是相同大小 三、其他 不支持添加&#x2F;插入&#x2F;删除元素的函数 不支持笔记9.3.1中表9.5（如push_back） 不支持笔记9.3.3的所有操作 swap会真正交换array的元素值，而其他容器不会。 不支持resize() 不支持适配器（因为所有适配器都要求容器有添加和删除元素的能力） 十 泛型算法10.1 概述 关键概念：算法永远不会执行容器的操作（算法只所用于迭代器） 泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。 如我们将在书本10.4.1节(第358页)所看到的，标准库定义了一类特殊的**迭代器，称为插入器(inserter)**。与普通迭代器只能遍历所绑定的容器相比，插入器能做更多的事情。当给这类迭代器赋值时，它们会在底层的容器上执行插入操作。因此，当一个算法操作一个这样的迭代器时，迭代器可以完成向容器添加元素的效果，但算法自身永远不会做这样的操作。 大多数算法定义在algorithm中，numeric也定义了一组数值泛型算法。 一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。 迭代器令算法不依赖于容器，但是算法依赖于容器的元素类型。（因为算法要对元素进行比较等操作） 10.2 初识泛型算法10.2.1 只读算法 find_&lt;algorithm&gt;fund(开始迭代器（指针）,结束迭代器（指针）,val) 作用：在指定范围内[开始迭代器，结束迭代器)查找val值，找到了就返回 第一个 等于val的 元素的 迭代器，否则返回结束迭代器。 count_&lt;algorithm&gt; 作用：返回给定值在次序中出现的次数 accumulate_&lt;numeric&gt; sum = accumulate(vec.cbegin(),vec.cend(),0) 作用：将范围内所有元素加到第三个参数上，返回最终的加法之和。 要求第三个参数重载过+。 第三个参数决定了函数中使用哪个类型重载的加法运算符，以及返回值类型。 12string sum = accumulate(str.cbegin(),str.cend(),string(&quot;&quot;)); //正确string sum = accumulate(str.cbegin(),str.cend(),&quot;&quot;); //错误，const char*没有重载过‘+’运算符 equal_&lt;algorithm&gt;equal(roster1.cbegin(),roster1.cend(),roster2.cbegin()); 作用：用于确定两个序列是否保存相同的值。第三个参数是第二个序列的首元素的迭代器 基于假设：它假定第二序列至少与第一序列一样长 由于equal利用迭代器完成操作，因此，我们可以通过调用equal来比较两个不同类型的容器中的元素，而且，元素类型也不必一样，只要我们能用==来比较两个元素类型即可。 10.2.2 写容器元素算法 fillfill(vec.begin(),vec.end(),val); 作用：将范围内的每个元素重置为第三个参数 fill_nfill_n(起始位置迭代器,n,val) 作用：从其实位置的迭代器开始，将n和元素替换为val 注意：不应在一个空容器上调用fill_n，或类似写元素的算法。示例如下： 1234//灾难错误示例vector&lt;int&gt; vec; //空vector//修改了10个不存在的向量，引发未定义的结果fill_n(vec.begin(), 10, 0); back_inserter_&lt;iterator&gt;：“插入” 迭代器 作用：接受一个指向容器的引用，返回一个与该容器绑定插入迭代器。 我们用此迭代器赋值时，赋值运算符会调用push_back。 常常使用back_inserter创建一个插入迭代器，作为算法的目的位置使用 示例： 1234567891011121314151617181920212223242526272829303132333435#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;using namespace std;/** 有bug * 重载&lt;&lt;，流式输出容器中的元素 * @tparam T * @param os * @param ctor * @return */template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream &amp;os,T &amp;ctor)&#123; for(const auto &amp;ele:ctor)&#123; os&lt;&lt;ele; &#125; return os;&#125;int main()&#123; /*例1*/ vector&lt;int&gt; vec; //空容器 auto iter = back_inserter(vec); // 插入迭代器 *iter = 24; //赋值运算符调用push_back cout&lt;&lt;vec&lt;&lt;endl; /*例2*/ vec.clear(); //清空容器 //常常使用back_inserter创建一个插入迭代器，作为算法的目的位置使用 fill_n(back_inserter(vec),10,1); cout&lt;&lt;vec&lt;&lt;endl; return 0;&#125; copycopy(源起始迭代器，源终止迭代器，目的序列的起始位置) 传递给copy的目的序列至少要包含与输入序列一样多的元素 返回目的位置迭代器增值后的值。下例中为a2尾后位置： 1234567891011121314151617181920212223242526272829#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;using namespace std;/** 有bug * 流式输出容器 * @tparam T * @param os * @param ctor * @return */template&lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream &amp;os,T &amp;ctor)&#123; for(const auto &amp;ele:ctor)&#123; os&lt;&lt;ele; &#125; return os;&#125;int main()&#123; int a1[] = &#123;1,2,3,4,5,6,7,8,9&#125;; int a2[sizeof(a1)/sizeof(*a1)]; auto re = copy(begin(a1), end(a1),a2); // re指向尾后 cout&lt;&lt;a2&lt;&lt;endl; // 123456789 cout&lt;&lt;*(re-1)&lt;&lt;endl; // 9 return 0;&#125; replace_copyreplace_copy(ilst.cbegin(), ilst.end(), back_inserter(ivec), 0, 42);将ilst（值不会改变）中的所有元素拷贝到ivec（可以是空列表）之后，并将ivec中的0替换为24 对比replace是将原来的序列范围内的值替换 10.2.3 重排容器元素算法 sort：sort(序列开始位置迭代器，结束位置迭代器) unique：返回不重复区域之后一个位置的迭代器 &#x3D; unique(序列开始位置迭代器，结束位置迭代器) 书中的例子：排序一个由单词组成的vector，并删除重复的单词 123456789101112131415161718192021222324252627282930313233#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;template&lt;typename T&gt;void printCtor(T &amp;ctor)&#123; for(const auto &amp;ele:ctor)&#123; cout&lt;&lt;ele&lt;&lt;&quot; &quot;; &#125;&#125;int main()&#123; vector&lt;string&gt; vec&#123;&quot;the&quot;,&quot;quick&quot;,&quot;red&quot;,&quot;fox&quot;,&quot;jumps&quot;,&quot;over&quot;,&quot;the&quot;,&quot;slow&quot;,&quot;red&quot;,&quot;turtle&quot;&#125;; printCtor(vec);cout&lt;&lt;endl; // 输出：the quick red fox jumps over the slow red turtle /*sort*/ sort(vec.begin(), vec.end()); printCtor(vec);cout&lt;&lt;endl; // 输出：fox jumps over quick red red slow the the turtle /*unique 将重复项移动到末尾*/ // iter指向不重复区域的下一个位置 auto iter = unique(vec.begin(), vec.end()); vec.erase(iter,vec.end()); printCtor(vec);cout&lt;&lt;endl; // 输出：fox jumps over quick red slow the turtle return 0;&#125; 10.3 定制操作10.3.1 谓词一、通过“谓词”改变算法的默认行为“谓词”是一种可调用的表达式，其返回结果是一个能用作条件的值。 一元谓词，只接受一个单一参数的谓词 二元谓词，接受两个参数的谓词 接受谓词参数的算法对输入序列中的元素调用谓词，元素类型必须能转化为谓词的参数类型。 根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或两个参数。 二、举例接受一个二元谓词参数的sort()，用谓词替换&lt;来比较元素 1234567bool isShorter(const string s1, const string s2)&#123; return s1.size()&lt;s2.size();&#125;sort(words.begin(), words.end(), isShorter);stable_sort(words.begin(), words.end(), isShorter);//可保持等长元素间的字典顺序 三、补充find_if()算法接受一对迭代器，表示一个范围。与find()不同的是，find_if()的第三个参数是一个谓词，find_if算法对输入序列中的每个元素调用给定的这个谓词，返回第一个使谓词返回非0值的元素，如果不存在这样的元素，则返回尾迭代器。 12size_t sz = 5;auto wc = find_if(word.begin(), word.end(), [sz](const string &amp;s)&#123;return s.size() &gt;= sz ;&#125;); for_each()接受一个可调用的对象，并对输入序列中的每个元素调用此对象。 1for_each(word.begin(), word.end(), [](const string &amp;s)&#123;cout&lt;&lt;s&lt;&lt;&quot; &quot;;&#125;); 10.3.2 lambda（很重要，放在二级标题） 一、书写格式1[capture list](parameter list) -&gt; return type &#123; function body &#125; 我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体 12auto f = []&#123; return 42; &#125;; // 相当于空参数列表；自动推导返回类型。cout&lt;&lt;f()&lt;&lt;endl; 二、参数lambda不能有默认参数 —&gt; 一个lambda调用的实参数目永远与形参数目相等。 三、捕获列表一、谁需要被捕获？捕获列表只适用于局部非static变量，可以直接使用局部static变量和在它所在函数之外声明的名字。 12345678910int a = 1;int main() &#123; int b = 2; // 只有局部非static变量需要捕获 static int c = 3; auto f = [b]() &#123;cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c; &#125;; // f的类型 main::__l2::&lt;lambda_1&gt; f(); // 1 2 3 return 0;&#125; 二、几种捕获方式1.值捕获 采用值捕获的前提是变量可以拷贝 被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝。（与函数参数不同） 又由于 “ 被捕获的变量的值是在lambda创建时拷贝”，因此，随后对其修改不会影响到lambda内对应的值 123456void func1()&#123; size_t v1 = 42; auto f = [v1]&#123;return v1;&#125;;// &lt;--值捕获 v1=0; auto j = f();// j = 42;&#125; 2.引用捕获 下例为引用捕获示例与上述值捕获示例的对比 123456void func1()&#123; size_t v1 = 42; auto f = [&amp;v1]&#123;return v1;&#125;; // &lt;--引用捕获 v1=0; auto j = f();// j = 0;&#125; lambda捕获的都是函数的局部变量，函数结束后，捕获的引用指向的局部变量已经消失。 必须确保被引用的对象在lambda执行的时候是存在的。 函数不能返回一个包含引用捕获的lambda（因为局部变量已消失，和函数不能返回局部变量的引用&#x2F;指针是一个道理） 3.隐式捕获 当我们混合使用隐式捕获和显式捕获时， 必须以隐式捕获开头（原文：捕获列表的第一个元素必须是一个&amp;或=，以指定默认捕获方式）。 显式捕获的变量必须使用与隐式捕获不同的方式。 三、捕获列表的书写方式汇总 四、可变lambda（mutable） 默认情况下，对于一个值被拷贝的变量，lambda 不会改变其值。但是，如果我们希望能改变个被捕获的变量的值，就必须在参数列表首加上关键字 mutable。 一个引用捕获的变量是否可以修改，依赖于此引用指向的是一个const还是一个非const 对于局部static变量和在它所在函数之外声明，不用mutable也可以在lambda中修改 123456789101112131415161718/*如果我们希望能改变个被捕获的变量的值，就必须在参数列表首加上关键字 mutable。*/int v1 = 42;auto f = [v1]() mutable &#123;return ++v1; &#125;;// auto f = [v1]() &#123; return ++v1; &#125;; //v1报错：表达式必须是可修改的左值（v1只读）cout &lt;&lt; v1 &lt;&lt; &quot; &quot; &lt;&lt; f() &lt;&lt; endl; // 42 43/*一个引用捕获的变量是否可以修改，依赖于此引用指向的是一个const还是一个非const*/auto f1 = [&amp;v1]() &#123;return ++v1; &#125;;cout &lt;&lt; v1 &lt;&lt; &quot; &quot; &lt;&lt; f1() &lt;&lt; endl; //43 43const int v2 = 1;//auto f2 = [&amp;v2] &#123;return ++v2; &#125;; //v2报错：表达式必须是可修改的左值/*对于局部static变量和在它所在函数之外声明，不用mutable也可以在lambda中修改*/static int v3 = 1;auto f3 = [] &#123;return ++v3; &#125;;cout &lt;&lt; v3 &lt;&lt; &quot; &quot; &lt;&lt; f3(); // 2 2 四、指定lambda的返回类型 默认情况下，如果一个lambda体 除了单一return外 还包含了其他语句，则编译器假定lambda返回void。如果与本意不符，需要显式指明返回类型。 示例 123456789101112131415161718//lambda体内只有一条return语句，编译器自动推导返回类型transform(vi.begin(), vi.end(), vi,begin(), [](int i)&#123; return i &lt; 0 ? -i : i; &#125;);//编译错误：//除了单一return外 还包含了其他语句，编译器推断为void，实际却返回inttransform(vi.begin(), vi.end(), vi,begin(),[](int i)&#123; if(i &lt; 0) return -i; else return i; &#125;);//正确写法：显式指定返回类型transform(vi.begin(), vi.end(), vi,begin(),[](int i)-&gt;int&#123; // 尾置返回类型 if(i &lt; 0) return -i; else return i; &#125;); 补充：transform()使用标准库 transform 算法和一个 lambda来将一个序列中的每个负数替换为其绝对值: 12transform(vi.begin()， vi.end()， vi.begin()， [](int i) &#123; return i &lt; 0 ?-i :i; &#125;); 函数transform接受三个迭代器和一个可调用对象。前两个迭代器表示输入序列，第三个迭代器表示目的位置。算法对输入序列中每个元素调用可调用对象，并将结果写到目的位置。 五、参数绑定一、引入 之前我们写过的代码 12size_t sz = 5;auto wc = find_if(word.begin(), word.end(), [sz](const string &amp;s)&#123;return s.size() &gt;= sz ;&#125;); 如果好多地方使用同样的操作，或者操作需要很多语句才能完成，使用lambda不方便，需要使用函数。但是如何用接受两个参数的函数替换一元谓词？如 12345bool check_sz(const string &amp;s, string::size_type sz)&#123; return s.size() &gt; sz ;&#125;auto wc = find_if(word.begin(), word.end(), /*check_sz*/); // 如何用接受两个参数的函数替换一元谓词? 二、bind 使用在库functional中的bind()。可以将其看做函数适配器（类比容器适配器），接受一个可调用对象，生成一个新的可调用对象来“适应”原本对象的参数列表。一般形式为： 1auto newCallable = bind(callable, arg_list); 当调用newCallable时，newCallable会调用函数callable，并向callable传递arg_list中的参数。 其中，arg_list中可能会有std::placeholders::_n，为占位符。表示调用newCallable时，传入的参数应该填入callable形参列表的第n位。 举例，对于一中的例子，利用bind改写： 1234567bool check_sz(const string &amp;s, string::size_type sz)&#123; return s.size() &gt; sz ;&#125;auto check6 = bind(check_sz, std::placeholders::_1, 6);auto wc = find_if(word.begin(), word.end(), check6); 举例2： 12345678910using namesapce std::placeholders;bool check_sz(const string &amp;s, string::size_type sz)&#123; return s.size() &gt; sz ;&#125;auto check6 = bind(check_sz, _1, 6);string s = &quot;hello&quot;;bool b1 = check6(s); // 相当于 check_sz(s,6); 三、bind的参数 bind对参数的作用： 绑定给定可调用对象中的参数（上文所述） 重新安排参数的顺序。示例如下： 123auto g = bind(func, a, b, _2, c, _1);g(X,Y);//func(a,b,Y,c,X); 四、绑定引用参数 我们希望传递一个引用给bind，而不是拷贝，用ref()或cref() 12#include &lt;functional&gt;for_each(words.begin(), words.end(), bind(print, ref(os), _1, &#x27; &#x27;)); 10.4 再探迭代器笔记9.2.1迭代器基础 补充额外的迭代器： 插入迭代器（insert iterator）：迭代器被绑定到一个容器上，可以用来向容器插入元素 流迭代器（stream iterator）：迭代器被绑定到输入&#x2F;输出流上，用来遍历所关联的io 反向迭代器（reverse iterator）：迭代器向反方向移动（++&#x2F;–方向相反）。除了forward_list外标准库容器都有反向迭代器 移动迭代器（move iterator）：这些迭代器不是拷贝其中的元素，而是移动它们。 10.4.1 插入迭代器 1234567891011121314151617vector&lt;int&gt; nums&#123; 0,1,2,3,4,5,6,7,8,9 &#125;;auto it = inserter(nums,++nums.begin()); // inserter(容器，迭代器)；插入迭代器之前的位置it = 12; //等价*it或++it或it++ = 12，因为这三个存在但什么都不做，只返回itfor (const auto&amp; num : nums) &#123; cout &lt;&lt; num &lt;&lt; &quot; &quot;;//0 12 1 2 3 4 5 6 7 8 9&#125;//等价vector&lt;int&gt; nums&#123; 0,1,2,3,4,5,6,7,8,9 &#125;;int ins_num = 12;auto iter = nums.insert(++nums.begin(), ins_num);++iter; // &lt;--特别注意这里，iter又指回了原来的地方for (const auto&amp; num : nums) &#123; cout &lt;&lt; num &lt;&lt; &quot; &quot;;//0 12 1 2 3 4 5 6 7 8 9&#125; 一个值得注意的地方： 12345list&lt;int&gt; lst&#123;1,2,3,4&#125;;list&lt;int&gt; lst2, lst3;copy(lst.begin(), lst.end(), front_inserter(lst2));//lst2=4 3 2 1copy(lst.begin(), lst.end(), inserter(lst3,lst3.begin()));//lst2=1 2 3 4 原理如图所示： 10.4.2 流迭代器原文：iostream迭代器 虽然iostream类型不是容器，但标准库定义了可以用于这些IO类型对象的选代器(参见8.1 节，第278页)。 istream_iterator (参见表10.3)读取输入流，ostream_iterator(参见表10.4节，第361页)向一个输出流写数据。 这些选代器将它们对应的流当作一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。 一、istream_iterator 用法示例：用一个istream_iterator从标准输入读取数据，存入一个vector的例子 1234567891011/* 写法1 */vector&lt;int&gt; vec;istream_iterator&lt;int&gt; in_iter(cin) /* 从cin读取int类型的数据 */, eof/*istream尾后迭代器*/;while (in_iter != eof)&#123; vec.push_back(*in_iter++);&#125;/*写法2，等价于写法1*/istream_iterator&lt;int&gt; in_iter(cin), eof;vector&lt;int&gt; vec(in_iter, eof); // 从迭代器范围构造vec（用一对表示元素范围的迭代器构造vec） 要求： 必须指定迭代器将要读写的对象类型 该对象类型定义了&gt;&gt;来读取流 默认初始化迭代器，即创建了istream流的尾后迭代器 特点：允许使用懒惰求值。 &lt;– 没怎么看懂 当我们将一个istream_iterator 绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。 标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取没什么差别。但是，如果我们创建了一个istream_iterator，没有使用就销毁了，或者我们正在从两个不同的对象同步读取同一个流，那么何时读取可能就很重要了。 应用：用一对istream_iterator来调用accumulate 12istream_iterator&lt;int&gt; in(cin), eof;cout&lt;&lt;accumulate(in, eof, 0)&lt;&lt;endl; 二、ostream_iterator 用法示例：用ostream_iterator来输出 值的序列 12345678910/* 写法1 */vector&lt;int&gt; vec&#123;0,1,2,3,4,5,6&#125;;ostream_iterator&lt;int&gt; out_iter(cout, &quot; &quot;);for (const auto&amp; n : vec) *out_iter++ = n; // 0 1 2 3 4 5 6 // 等价 // out_iter = n; // 不推荐，因为上面的写法更易阅读/* 写法2 */copy(vec.begin(), vec.end(), out_iter); 要求： 要输出的类型 定义了&lt;&lt; 第二个可选参数表示：在输出的每个元素后都会打印该字符（必须是c风格字符串——字符串字面常量或以空字符结尾的字符数组的指针） ostream_iterator必须绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator 应用：（书P362） 1 10.4.3 反向迭代器返回笔记9.2.1 rbegin(),rend(), crbegin(),crend() forward_list和流迭代器不能创建反向迭代器 reverse_iterator的base()将反向迭代器转换为普通迭代器（在容器中正向移动） 应用： 123456789101112/*例1*/sort(vec.begin(), vec.end()); // 顺序sort(vec.rbegin(), vec.rend()); // 逆序/*例2*///first,middle,lastauto comma = find(line.cbegin(), line.cend(), &#x27;,&#x27;);cout&lt;&lt;string(line.cbegin(), comma);//firstauto rcomma = find(line.crbegin(), line.crend(), &#x27;,&#x27;);cout&lt;&lt;string(line.crbegin(), rcomma);//tsalcout&lt;&lt;string(rcomma.base(),line.cend());//last 10.5 泛型算法结构10.5.1 五类迭代器任何算法最基本的特性是 它要求其迭代器提供哪些操作。 类似容器，迭代器也定义了一组公共操作。迭代器按其提供的操作分类，这些分类形成了一种层次，除了输出迭代器外，一个高层类别的迭代器支持低层类别迭代器的所有操作。 C++标准指明了泛型和数值算法的每个迭代器参数的最小类别（至少应该达到的类别）。例如，find 算法在个序列上进行一遍扫描，对元素进行只读操作，因此至少需要输入迭代器。对每个迭代器参数来说，其能力必须与规定的最小类别至少相当。向算法传递一个能力更差的迭代器会产生错误。 迭代器提供的操作可以划分为5类。每个算法都会对 它的每个迭代器参数 指明 需要提供哪类迭代器。 迭代器类别简述： 10.5.2 算法形参模式 dest 表示算法可以写入的目的位置迭代器 使用dest时，算法假定：按其需要写入的数据，不管写入多少元素都是安全的 如果dest是一个直接指向容器的迭代器，算法将输出数据写到容器中已存在的元素内 beg2 接受单独beg2的算法 假定从beg2开始的序列 至少 与beg和end所表示的范围 一样大 10.5.3 算法命名规范 一些算法使用重载形式传递一个谓词 _if版本的算法 接受一个元素值的算法通常有一个不同名的版本，接受一个谓词以替代元素值，这类接受谓词参数的算法都附加_if。 示例 12find(beg,end,val);//查找范围内val第一次出现的位置find_if(beg,end,pred);//查找第一个令pred为真的元素的位置 _copy版本的算法 默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个_copy 示例 12reverse(begin,end); // 反向输入范围中的序列reverse_copy(begin,end,dest); // 将元素按逆序拷贝到dest 一些算法同时提供_if和_copy，如remove_if和remove_copy_if 10.6 特定容器算法 对于list和forward_list，应该 优先使用成员函数版本的算法 而不是通用算法 链表类型还定义了splice成员（链表特有，splice和splice_after） 链表特有的操作会改变容器 多数链表特有的算法都与其通用版本很相似，但不完全相同。链表特有版本与通用版本间的一个至关重要的区别是链表版本 会 改变底层的容器。例如，remove 的链表版本会删除指定的元素。unique 的链表版本会删除第二个和后继的重复元素。 类似的，merge和splice 会销毁其参数。例如，通用版本的merge 将合并的序列写到一个给定的目的迭代器：两个输入序列是不变的。而链表版本的 merge 函数会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用 merge 的链表对象中。在merge 之后，来自两个链表中的元素仍然存在，但它们都已在同一个链表中。 十一 关联容器 map &amp; set map中的元素是键值对 set每个元素只包含一个关键字 8个容器见的不同体现在3个维度上 map or set 要求不重复关键字 or 允许重复关键字 multi 顺序存储 or 无序存储 unordered 有序存储会自动排序 1234multimap&lt;string,string&gt; authors&#123;&#123;&quot;Alain&quot;,&quot;a&quot;&#125;, &#123;&quot;Stanley&quot;,&quot;c++Primer&quot;&#125;, &#123;&quot;Alain&quot;,&quot;b&quot;&#125;, &#123;&quot;Blain&quot;,&quot;c&quot;&#125;&#125;; 也可以对一个关联容器进行列表初始化 11.1 简单使用关联容器 map map是键值对的集和 map通常被称为关联数组，可使用key而不是位置作为下标来查找val map&lt;key的类型，val的类型&gt; –&gt; 每个元素是一个pair类型，.first 表示key，.second表示val set set就是关键字的简单集和。 值就是关键字 简单应用：单词计数 123456789101112map&lt;string,size_t&gt; word_cnt;set&lt;string&gt; exclude&#123;&quot;the&quot;,&quot;a&quot;,&quot;an&quot;,&quot;but&quot;&#125;; //忽略计数的单词string word;while(cin&gt;&gt;word) if(exclude.find(word) == exclude.end()) // 没找到，返回尾后指针 ++word_cnt[word]; // ++是将val加1for(const auto &amp;w:word_cnt)&#123; cout&lt;&lt;w.first&lt;&lt;&quot; occurs &quot;&lt;&lt;w.second &lt;&lt;((w.second&gt;1)?&quot; times &quot;:&quot; time &quot;)&lt;&lt;endl;&#125; 11.2 关联容器概述11.2.1 如何定义关联式容器 除了不支持顺序容器的push_back等位置操作，以及构造函数和插入操作这些接受一个元素值和一个数量值的操作外，都支持[笔记9.2中表9.2](#9.2 容器库概览)的普通容器操作。 关联容器的迭代器都是双向的 初始化 初始化时，没有muti的关联容器会自动删除key重复的元素 11.2.2 关键字类型的要求 对于有序容器，关键字类型必须定义元素比较的方法。默认情况下标准库使用key类型的&lt;运算符来比较两个关键字。 key类型可以提供自己的操作来替代默认的&lt;，遵循严格弱序（小于等于） key如果没有自定义的&lt;运算符，也可使用关键字类型的比较函数，下例所示 1234567// 比较函数bool compareIsbn(const Sales_data &amp;sd1, const Sales_data &amp;sd2)&#123; return sd1.isbn() &lt; sd2.isbn();&#125;// 定义mutisetmutiset&lt;Sales_data, decltype(compareIsbn) *&gt; bookstore(); // decltype作用于函数时，返回函数类型而非指针类型，所以要另加*号 元素的操作类型（比较函数）也是容器类型的一部分 操作类型也仅仅只是类型，当创建容器时，才会以构造函数参数的形式提供真正的比较操作。 11.2.3 pair #include &lt;utility&gt; pair上的操作 如何创建一个pair对象 1234567891011/*写法1*/&#123;key,val&#125;;/*写法2*/pair&lt;key_type,val_type&gt;(key,val); /*写法3*/make_pair(key,val);/*隐式构造一个空的pair*/pair&lt;key_type,val_type&gt;(); 11.3 关联容器操作11.3.1 获得关联容器中元素的类型 &amp; 容器迭代器 关键字是const的，不能随便改变一个元素的关键字 1.类型别名 2.不能改变map的key的值，因为是const的 3.set的val就是key，同样是const的 虽然set 类型同时定义了iterator和const_iterator类型，但两种类型都只允许只读访问 set 中的元素。 与不能改变一个map 元素的关键字一样，一个 set 中的关键字也是 const 的。 同样可由++迭代器遍历关联容器 关联容器和算法 通常不对关联容器使用泛型算法——关键字是const的 关联容器可用于只读容器的算法——不过建议使用成员函数 在实际编程中，如果我们真要对一个关联容器使用算法，要么是将它当作一个源序列，要么当作一个目的序列。 11.3.2 添加元素 非muti在构造时会自动忽略重复的项 对map进行insert，切记所需元素类型的pair insert&#x2F;emplace的返回值 对于非muti，返回一个pair。first是一个指向插入的元素的迭代器。second是一个bool，指出 插入成功（true） 还是 已在容器中（false） 对于first，通常用auto代替，详细的结构如下： 123map&lt;string,size_t&gt; word_cnt;pair&lt;map&lt;string,size_t&gt;::iterator, bool&gt; ret = word_cnt.insert(&#123;word,1&#125;); 对muti，返回值为指向新元素的迭代器，没有bool 应用：添加具有相同关键字的多个元素 11.3.3 删除元素 11.3.4 map的下标操作 仅map和unordered_map支持下标操作 如果关键字不在map&#x2F;unordered_map中，会创建该关键字。初始化顺序如下： 由于下标运算符可能插入一个新元素，所以只能对非const使用 解引用迭代器和下标操作所得到的值不同，前者为（value_type）,后者为（mapped_type） 11.3.5 访问元素 只是为了判断特定元素在不在容器中，find是最佳选择，下标运算会有副作用 muti容器中，具有相同关键字的多个元素相邻存储 1234567891011multimap&lt;string,string&gt; authors&#123;&#123;&quot;Alain&quot;,&quot;a&quot;&#125;, &#123;&quot;Stanley&quot;,&quot;c++Primer&quot;&#125;, &#123;&quot;Alain&quot;,&quot;b&quot;&#125;, &#123;&quot;Blain&quot;,&quot;c&quot;&#125;&#125;;string author&#123;&quot;Alain&quot;&#125;;auto entries = authors.count(author); // 元素个数auto iter = authors.find(author); // 作者的第一本书while (entries--)&#123; cout&lt;&lt;iter-&gt;second&lt;&lt;&quot; &quot;; // a b ++iter;&#125; 针对muti，lower_bound和upper_bound lower_bound返回的迭代器指向第一个具有给定关键字的元素 upper_bound返回的迭代器指向最后一个具有给定关键字的元素之后的位置 如果给定关键字不存在，则两个函数指向相同的位置——第一个安全的插入点（即能够保持容器顺序的插入位置） 12345678910111213//等价上例multimap&lt;string,string&gt; authors&#123;&#123;&quot;Alain&quot;,&quot;a&quot;&#125;, &#123;&quot;Stanley&quot;,&quot;c++Primer&quot;&#125;, &#123;&quot;Alain&quot;,&quot;b&quot;&#125;, &#123;&quot;Blain&quot;,&quot;c&quot;&#125;&#125;;string author&#123;&quot;Alain&quot;&#125;;for(auto beg = authors.lower_bound(author), end = authors.upper_bound(author); beg != end; ++beg)&#123; cout&lt;&lt;beg-&gt;second&lt;&lt;&quot; &quot;; // a b&#125; equal_bound 此函数接受一个关键字，返回一个选代器对pair。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素（相当于lower_bound），第二个迭代器指向最后一个匹配元素之后的位置(相当于upper_bound)。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置（同样类似lower_bound和upper_bound）。 示例 123456789101112//等价上例multimap&lt;string,string&gt; authors&#123;&#123;&quot;Alain&quot;,&quot;a&quot;&#125;, &#123;&quot;Stanley&quot;,&quot;c++Primer&quot;&#125;, &#123;&quot;Alain&quot;,&quot;b&quot;&#125;, &#123;&quot;Blain&quot;,&quot;c&quot;&#125;&#125;;string author&#123;&quot;Alain&quot;&#125;;for(auto pos = authors.equal_range(author); pos.first != pos.second; ++pos.first)&#123; cout&lt;&lt;pos.first-&gt;second&lt;&lt;&quot; &quot;; // a b&#125; 11.4 无序容器 通常可以用无序容器替换对应的有序容器，反之亦然。但是，由于元素未按顺序存储，一个使用无序容器的输出（通常）会与使用有序容器的版本不同。 管理桶 无序容器的形式如下图所示 无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。 对于相同的参数，哈希函数必须总是产生相同的结果。理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但是，将不同关键字的元素映射到相同的桶也是允许的。当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在桶中搜索通常都是很快的操作。但是，如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作。 无序容器的管理操作 无序容器对key类型的要求 无序容器需要==来比较元素和hash&lt;key_type&gt;来生成每个元素的hash值 可以通过重载关键字类型的默认操作，类定义无序容器： 12345678910111213141516171819202122232425class Sales_data&#123;public: explicit Sales_data(string isbn):m_isbn(std::move(isbn))&#123;&#125; string isbn() const &#123; return m_isbn;&#125;private: string m_isbn;&#125;;size_t hasher(const Sales_data &amp;sd)&#123; return hash&lt;string&gt;()(sd.isbn());&#125;bool eqop(const Sales_data &amp;lhs, const Sales_data &amp;rhs)&#123; return lhs.isbn() == rhs.isbn();&#125;int main()&#123; using sd_mutiset = unordered_set&lt;Sales_data, decltype(hasher)*, decltype(eqop)*&gt;; sd_mutiset bookstore(42, hasher, eqop);//桶数目、哈希函数指针、相等性判断运算符指针 //如果Sales_data中重载了==，可省略等号 unordered_set&lt;Foo,decltype(FooHash)*&gt; fooSet(10,FooFash); return 0;&#125; 十二 动态内存12.1 动态内存与智能指针使用动态内存的原因： 程序不知道自己使用多少个对象 程序不知道所需对象的准确类型 程序需要在对个对象间共享数据 12.1.1 shared_ptr make_shared() 最安全的分配和使用动态内存的方法. 返回一个shared_ptr，指向函数在动态内存中分配的对象 #include &lt;memery&gt; 类似emplace，make_shared()用其参数构造给定类型的对象 1shared_ptr&lt;string&gt; ptr = make_shared&lt;string&gt;(10,&#x27;9&#x27;);// 9999999999 shared_ptr 自动销毁所管理的对象，自动释放关联的内存（析构函数） 如果是容器中的元素，不用时记得用erase删除 如果多个对象共享底层数据（使用动态内存的原因），当某个对象被销毁时，我们不能单方面地销毁底层数据 12.1.2 new &amp; delete（原文：12.1.2 直接管理内存） 直接管理内存的类不能依赖类对象的拷贝、赋值和销毁操作的任何默认定义。（相对于智能指针容易出错） 初始化方式 123456int *p = new int; //默认构造int *p = new int(); // 值初始化int *p = new int(5); // 传统构造方式int *p = new int&#123;5&#125;;//列表初始化string *p = new string(10,&#x27;9&#x27;);//*p为&quot;9999999999&quot;,注意&#x27;9&#x27;是单引号的字符 值初始化 对于自定义构造函数会执行默认构造函数，默认&#x2F;值初始化没有差别； 而对于内置类型， 建议使用值初始化，而不是默认初始化 。 1234int *p0 = new int;//默认初始化，*p0的值未定义int *p1 = new int();//值初始化，*p1=0string *p2 = new string;//string有默认构造函数，*p=&quot;&quot; 同样，对于自定义类中的那些依赖于编译器合成的默认构造函数的内置类型成员，如果未在类内被初始化，那么它们的值也是未定义的。 如果提供了括号包围的初始化器，则可以用auto 1auto p = new auto(obj); 动态分配const对象 123//const int *pci = new const int; //错误const int *pci = new const int(1024);const string *pcs = new const string; // string有默认构造函数，隐式初始化 类似其他任何 const 对象，一个动态分配的 const 对象必须进行初始化。 对于一个定义了默认构造函数的类类型，其const 动态对象可以隐式初始化，而其他类型的对象就必须显式初始化。 由于分配的对象是 const 的，new 返回的指针是一个指向const的指针。 内存耗尽，会抛出bab_alloc异常，可以通过定位new的方式阻止其抛出异常 12#include &lt;new&gt;int *p = new (nothrow) int(); //如果分配失败，返回一个空指针，而不是抛出异常 delete（书本P409~P411）都是在讲delete的用法，并没有特别的知识。需要注意的地方有： delete销毁给定的指针指向的对象，并释放其内存 delete之后，指针变为空悬指针，最好将指针置为nullptr delete指向数组的指针 123456auto *p = new string(10, &#x27;9&#x27;);delete p;auto *p1 = new int[5];//delete p1;//只会删除数组中的一个元素delete[] p1; //告诉编译器，将要删除的是数组 12.1.3 shared_ptr &amp; new 可以使用new通过值初始化的方式构造智能指针 1shared_ptr&lt;int&gt; p(new int(42)); 接受指针参数的智能指针构造函数时explicit的，不能使用隐式转换构造指针指针，有如下几种错误情况： 12345678910111213141516171819202122232425/*例1*/shared_ptr&lt;int&gt; p = new int(42);// 错误/*例2*/shared_ptr&lt;int&gt; clone(int p)&#123; //return new int(p); // 错误 return shared_ptr&lt;int&gt;(new int(p)); // 正确，显式转换&#125;/*例3*/ // &lt;-- 不要混用普通指针和智能指针，推荐使用make_sharedvoid process(shared_ptr&lt;int&gt; ptr)&#123;&#125;//--------------------// 错误int *x = new int(42);//process(x); //错误,不可隐式转换process(shared_ptr&lt;int&gt;(x)); // 错误。虽然合法，但x在process结束时会被释放int j = *x; //未定义行为，x已经被释放//--------------------//正确的写法shared_ptr&lt;int&gt; p(new int(42));process(p); // 引用计数+1int i = *p; //仍然存在 不要混用普通指针和智能指针，推荐使用make_shared。 当将一个 shared_ptr 绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr。一旦这样做了，我们就不应该再使用内置指针来访问 shared_ptr所指向的内存了。如上例3错误写法所示。 也不要使用get初始化另一个智能指针或为智能指针赋值——get()返回内置指针，如果delete了，指针指针就失效了。 reset()用一个新的指针赋予一个shared_ptr，常与unique()（注意：是shared_ptr的成员函数，不是unique_ptr&lt;&gt;）一起用，来控制多个shared_ptr共享的对象。 123456789shared_ptr&lt;string&gt; a,b;shared_ptr&lt;string&gt; p(new string(&quot;x&quot;));a = p, b = p;if(!p.unique()) p.reset(new string(*p));*p+=string(&quot;y&quot;);cout&lt;&lt;*p&lt;&lt;endl; // xycout&lt;&lt;*a&lt;&lt;endl; //xcout&lt;&lt;*b&lt;&lt;endl; //x 12.1.4 智能指针 &amp; 异常 如果在new和delete之间发生了异常，且异常没有在函数内部被捕获，new的内存就永远无法释放了——使用智能指针就不会有这样的问题。 智能指针陷阱 shared_ptr额外的用法 ——释放哑类（没有析构函数的类）（书P416）利用shared_ptr并指定删除器（deleter），当func()退出时（即使由于异常而退出），哑类对象也会被正常关闭 1234567891011121314151617struct destination&#123;&#125;;//目的ipstruct connection&#123;&#125;; connection connect(destination *);void disconnect(connection); // 断开connect连接（析构）//删除器（deleter）void end_disconnect(connection *p /*指向 shared_ptr尖括号中类型 的指针*/)&#123; disconnect(*p);&#125;void func(destination &amp;d)&#123; connection c = connect(&amp;d); // 如果我们在f()退出前没有调用disconnect，就无法关闭c了 // 利用shared_ptr并指定删除器，当f()退出时（即使由于异常而退出），connection也会被正常关闭，如下: shared_ptr&lt;connection&gt; p(&amp;c, end_disconnect); // 第二个参数指定自定义的删除器（指向函数的指针）&#125; 12.1.5 unique_ptr 独占、“拥有” 初始化unique_ptr必须采用直接初始化形式。 不支持普通拷贝和赋值。但是有个例外：可以拷贝或赋值一个将要被销毁的unique_ptr，如 12345678unique_ptr&lt;int&gt; clone(int p)&#123; return unique_ptr&lt;int&gt; (new int(p));&#125;unique_ptr&lt;int&gt; clone(int p)&#123; unique_ptr&lt;int&gt; ret(new int(p)); return ret;&#125; 虽然不能拷贝和赋值unique_ptr，但是可以通过调用release或reset将指针的所有权转移（非const） reset（重置）就是将std::unique_ptr指向新的资源。由于std::unique_ptr就是最后一个指向当前资源的智能指针，因此，在重置前需要销毁回收当前的资源。 12345unique_ptr&lt;string&gt; p2();unique_ptr&lt;string&gt; p3(new string(&quot;p3&quot;));p2.reset(p3.release()); // reset释放p2原来的指向的内存，并令p2指向内存// release返回p3当前指向的内存地址后，令p3 == nullptr release函数可以释放所有权，并返回指向std::unique_ptr所管理的资源的指针。 注意：**release仅仅释放了所有权，并没有销毁回收所管理的资源**。而回收内存资源的责任交还给了使用者。 123456789/*例1*/p2.release(); //错误，p2不会释放内存，并且我们丢失了指针auto p = p2.release(); // 正确，但要记得手动 delete p/*例2*/unique_ptr&lt;string&gt; p3(new string(&quot;p3&quot;));string *pstr = p3.release();cout&lt;&lt;*pstr; //终端输出： p3delete pstr; 书中示例 1234unique_ptr&lt;string&gt; p1(new string(&quot;p1&quot;));unique_ptr&lt;string&gt; p2(p1.release()); //**release只是将p1置空（p1==nullptr），并没有销毁原来指向的内存**unique_ptr&lt;string&gt; p3(new string(&quot;p3&quot;));p2.reset(p3.release()); // reset释放p2原来的指向的内存，并令p2指向内存 参考文献 Effective Modern C++(18): std::unique_ptr - 知乎 (zhihu.com) 向unique_ptr传递删除器 与shared_ptr不同，需要在&lt;&gt;指定删除器函数类型 1unique_ptr&lt;objType,decltype(deleteFunc)*&gt; n(new ObjType, deleteFunc) 用unique_ptr重写shared_ptr网络连接的例子 1234567891011121314151617struct destination&#123;&#125;;//目的ipstruct connection&#123;&#125;; connection connect(destination *);void disconnect(connection); // 断开connect连接（析构）//删除器（deleter）void end_disconnect(connection *p /*指向 shared_ptr尖括号中类型 的指针*/)&#123; disconnect(*p);&#125;void func(destination &amp;d)&#123; connection c = connect(&amp;d); // 如果我们在f()退出前没有调用disconnect，就无法关闭c了 // 利用unique_ptr并指定删除器，当f()退出时（即使由于异常而退出），connection也会被正常关闭，如下: unique_ptr&lt;connection,decltype(end_disconnect)*&gt; p(&amp;c, end_disconnect); // 第二个参数指定自定义的删除器（指向函数的指针）&#125; 12.1.6 weak_ptr weak_ptr的主要特点 weak_ptr(见表 12.5)是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个 weak_ptr 绑定到一个 shared_ptr 不会改变shared_ptr的引用计数。一旦最后一个指向对象的 shared_ptr 被销毁，对象就会被释放。即使有 weak_ptr 指向对象，对象也还是会被释放，因此，weak_ptr 的名字抓住了这种智能指针“弱”共享对象的特点。 weak_ptr需要用shared_ptr初始化 12auto p = make_shared&lt;int&gt; (42);weak_ptr&lt;int&gt; wp(p); 调用lock()以使用weak_ptr 由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock() 12345if(shared_ptr&lt;int&gt; np = wp.lock())&#123; // lock检查weak_ptr指向的对象是否存在； // 如果存在，返回指向共享对象的shared_ptr // 否则返回空&#125; 12.2 动态数组建议使用容器，而不是动态分配的数组 12.2.1 new &amp; 数组一、两种声明方法1234567// 声明// 法1int *pia = new int[42]; // 必须指定大小，必须是整形，但不一定是常量表达式// 法2typedef int arrT[42];int *p = new arrT ; 分配一个数组会得到一个元素类型的指针，分配的内存不是数组类型。 不能调用begin和end 不能使用范围for 原文 分配一个数组会得到一个元素类型的指针 虽然我们通常称 new T[]分配的内存为“动态数组”，但这种叫法某种程度上有些误导。当用 new 分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。即使我们使用类型别名定义了一个数组类型，new 也不会分配一个数组类型的对象。在上例中，我们正在分配一个数组的事实甚至都是不可见的一一连[num]都没有。new 返回的是一个元素类型的指针。 由于分配的内存并不是一个数组类型，因此不能对动态数组调用 begin 或end(参见3.5.3 节，第106 页)。这些函数使用数组维度(回忆一下，维度是数组类型的一部分)来返回指向首元素和尾后元素的指针。出于相同的原因，也不能用范围 for 语句来处理所谓的)动态数组中的元素。 二、初始化1234567int *pia = new int[42]; // 10个未初始化的int。内置类型未初始化，其中的值是未定义的int *pia2 = new int[42]();int *pia3 = new int[10]&#123;0,1,2,3,4,5,6,7,8,9&#125;;string *psa = new string[10]; // 10个值初始化的空stirng，string中有默认构造函数string *psa2 = new string[10]();string *psa3 = new string[10]&#123;&quot;a&quot;,&quot;an&quot;,&quot;the&quot;,string(3,&#x27;x&#x27;)&#125;; 如果，初始化器中数目大于指定的元素数，new失败，不会分配任何内存，抛出bad_array_new_length异常（#include &lt;new&gt;） 虽然我们可用空括号对数组中的元素进行值初始化，但不能在括号中给出初始化器。意味着不能用auto分配数组——笔记12.1.2 new &amp; delete节–&gt;值初始化–&gt;第4小点 动态分配一个空数组是合法的 123456789char arr[0]; // 错误，不能定义长度为0的数组char *cp = new char[0]; //正确，但cp不能解引用。可用于循环的比较操作，如下/*动态分配一个空数组，用于循环的比较操作*/size_t n = get_size();int *p = new int[n]; // n为0，算法依然成立for(int *q = p; q != p+n; ++q)&#123; /*处理数组*/&#125; 三、释放动态数组必须带有方括号，不论是那种初始化形式。例： 12int *pia2 = new int[42]();delete[] pia2; 四、智能指针和动态数组 unique_ptr 标准库提供了一个 管理new分配的数组的 unique_ptr版本，销毁时将自动调用delete[] 1234// unique_ptr&lt;int[]&gt; up = new int[10]; //No viable conversion from &#x27;int *&#x27; to &#x27;unique_ptr&lt;int[]&gt;&#x27;unique_ptr&lt;int[]&gt; up(new int[10]&#123;1,2&#125;);auto p = up.release(); // 书P425说的是销毁其*指针*，而不是说销毁指针指向的元素cout&lt;&lt;*p; //终端输出： 1 也可以使用下标运算符，但不支持 点和箭头 运算符 123for(size_t i = 0; i != 10; ++i)&#123; up[i] = i;&#125; unique_ptr管理数组的方式汇总 shared_ptr shared_ptr不直接支持动态管理数组，需要我们：1）提供删除器；2）使用get()获取数组首元素指针，以访问数组中的元素。 提供删除器（否则，shared_ptr将用delete销毁其所指向的对象） 12shared_ptr&lt;int&gt; sp(new int[10], [](int *p)&#123; delete[] p; &#125;);sp.reset();// 将调用我们提供的删除器 使用get()获取数组首元素指针，以访问数组中的元素 123for(size_t i = 0; i != 10; ++i)&#123; *(sp.get() + i) = i; // 使用get()获得内置指针&#125; 12.2.2 allocator类 #include &lt;memory&gt; 目的：先分配内存，在需要的时候再在该内存创建对象。（区别于new等同时分配内存和创建对象） 基础用法示例 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;int main()&#123; int n = 5; allocator&lt;string&gt; alloc; // 可以分配string内存的allocator对象 auto const p = alloc.allocate(n); // 分配5个未初始化的string的内存 auto q = p; // q指向构造元素之后的位置 // construct(指向当前要填充位置的指针，...构造函数所需的参数...) alloc.construct(q++); // *q为空字符串 alloc.construct(q++,10,&#x27;c&#x27;); //*q为&quot;cccccccccc&quot; alloc.construct(q++,&quot;hi&quot;); // *q为&quot;hi&quot;// cout&lt;&lt;*q&lt;&lt;endl;//灾难：q指向未构造的内存，不能在未构造的情况下使用原始内存 cout&lt;&lt;*(q-1)&lt;&lt;endl; //hi // 当我们用完对象后，必须对每个构造的元素调用destroy()销毁 while (q != p) alloc.destroy(--q); // 只能对真正构造了的元素调用destory // 一旦元素销毁，就可以用该内存保存其他的string元素 // 程序结束，释放alloc申请的内存（要先对所有元素destory） alloc.deallocate(p,n); // p必须指向由allocate分配的内存，n必须等于allocate分配的大小&#125; 拷贝和填充未初始化的内存 书中例子：作为一个例子，假定有一个 int 的 vector，希望将其内容拷贝到动态内存中。我们将分配一块比 vector 中元素所占用空间大一倍的动态内存，然后将原 vector 中的元素拷贝到前一半空间，对后一半空间用一个给定值进行填充: 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;#include &lt;vector&gt;int main()&#123; vector&lt;int&gt; v&#123;0,1,2,3,4&#125;; allocator&lt;int&gt; alloc; auto const p = alloc.allocate(v.size() * 2); auto q = uninitialized_copy(v.begin(),v.end(), p); // p:第三个参数**必须指向未构造的内存** // q:指向最后一个构造的元素之后的位置 q = uninitialized_fill_n(q,v.size(), 42); // 在目的指针（q）指向的内存中创建给定数目（v.size()）个对象，用给定的值（42）对他们进行初始化 while(p!=q)&#123; cout&lt;&lt;*(--q)&lt;&lt;&quot; &quot;; //输出： 42 42 42 42 42 4 3 2 1 0 alloc.destroy(q); &#125; alloc.deallocate(q,v.size()*2); return 0;&#125; 跳过的书中例子的记录P391 一个单词转换的map P404 ~ P406 StrBlob类P420底部 ~ P422 核查指针类 —— 为StrBlob定义一个伴随指针类 P432 ~ P435 文本查询类的定义 ------类设计者工具------ 十三 拷贝控制 拷贝构造、拷贝赋值和析构 ：big three —— 侯捷《面向对象高级编程》 13.1,13.2：拷贝 13.4：移动 13.1 拷贝、赋值和析构13.1.1 拷贝构造12345class Foo&#123; public: Foo(); //默认构造 Foo(const Foo&amp;); // 拷贝构造&#125;; 第一个参数必须是自身类型的引用，且几乎总是一个const，且额外参数都有默认值 不应该是explicit static成员不被拷贝（拷贝每个非static成员） 一：拷贝初始化拷贝初始化依靠拷贝构造函数或移动构造函数来完成。——左值拷贝，右值移动 拷贝初始化的发生条件： = 作为实参 传递给一个非引用的形参 返回类型为非引用的函数 返回一个对象 列表初始化一个数组的元素或一个聚合类中的成员 标准库容器调用insert或push等 二：拷贝初始化的限制总结：主要是针对explicit的限制，拷贝构造不可隐式转化，可直接构造为临时对象再使用 –&gt; 当传递一个实参或从函数返回一个值时，不可隐式使用explicit，需要像示例2最后一行一样使用。 参考： [1] Copy-initialization [2] C++复制初始化的限制 —— 对[1]的翻译 相比于直接初始化，复制初始化有更加严格的限制。 1：在复制初始化时，不能使用声明为explicit的构造函数进行的隐式转换。而直接初始化则是允许的： 1234567struct Exp &#123; explicit Exp(const char*) &#123;&#125; &#125;; // not convertible from const char*Exp e1(&quot;abc&quot;); // OKExp e2 = &quot;abc&quot;; // Error, copy-initialization does not consider explicit constructor struct Imp &#123; Imp(const char*) &#123;&#125; &#125;; // convertible from const char*Imp i1(&quot;abc&quot;); // OKImp i2 = &quot;abc&quot;; // OK Exp类中的构造函数声明为了explicit，因此，复制初始化Exp e2 &#x3D; “abc”将会发生编译错误：error: conversion from ‘const char [4]’ to non-scalar type ‘Exp’ requested. Imp类中的构造函数没有声明为explicit，因此，可以用字符串”abc”进行直接初始化或复制初始化Imp的对象。 2：在复制初始化中，使用隐式转换时，必须是从初始化器（&#x3D;右边的表达式）可以直接转换为被初始化对象，而不是间接的。在直接初始化中，可以使用从初始化器到构造函数参数的隐式转换。 12345struct S &#123; S(std::string) &#123;&#125; &#125;; // implicitly convertible from std::string S s1(&quot;abc&quot;); // OK: conversion from const char[4] to std::stringS s2 = &quot;abc&quot;; // Error: no conversion from const char[4] to SS s3 = std::string(&quot;abc&quot;); // OK: conversion from std::string to S 类S有一个接受std::string参数的构造函数，因此，可以使用”const char*”直接初始化S的对象s1。这里的转换序列是：const char* à std::string à struct S； 复制初始化中，则不允许这种转换，因为它不是直接转换，而是间接转换，因此，s2的初始化就会发生编译错误； 复制初始化中，可以使用直接隐式转换，因此，可以使用std::string的对象，初始化s3。 三：编译器可以绕过拷贝构造函数参考文献 C++ primer P442 P447:在拷贝初始化过程中，编译器可以跳过拷贝构造函数，直接创建对象。即，编译器允许将下面的代码 1string null_book = &quot;999&quot;; //1 改写为 1string null_book(&quot;999&quot;); //2 由于string的构造函数不是一个explicit的，所以说string类型允许从const char* 到string的隐式转换。 在行1中，首先将”999”隐式转化为一个string的临时对象，然后应该调用string的拷贝构造函数对null_book初始化。即 12string temp_str(&quot;999&quot;);string null_book = temp_str; //或者 string null_book(temp_str); 在这里编译器会进行优化，跳过拷贝构造函数直接创建对象，使临时变量直接成为所要创建的对象。 类似的下面代码也会跳过拷贝构造函数 1string str = string(); 但是在这种情况下，拷贝构造函数必须是public的，否则编译会不通过。可能是因为如果拷贝构造函数是private的话，编译器会理解为不能够使用拷贝构造函数，进而不会进行这种优化。 13.1.2 拷贝赋值 在类中重载=运算符，必须是成员函数 通常应该返回指向其左侧运算对象的引用 标准库通常要求保存在容器中的类型要具有赋值运算符 将右侧的非static成员赋予左侧（xxx除外） 1234567class Foo&#123;public: Foo&amp; operator=(const Foo &amp;f)&#123; //this-&gt;xxx = f.xxx; return *this; &#125;&#125;; 注意：将于笔记13.2详细说明 拷贝赋值运算符与往常一样执行类似拷贝构造函数和析构函数的工作。即，它必须递增右侧运算对象的引用计数(即，拷贝构造函数的工作)，并递减左侧运算对象的引用计数，在必要时释放使用的内存(即，析构函数的工作)。 必须处理自赋值（自己赋值给自己） 13.1.3 析构函数13.1.3.1 什么时候需要析构函数 什么时候需要析构函数？一般是成员通过new动态申请了内存的时候。（管理类外资源的类） 因为：隐式销毁一个内置指针类型的成员不会delete它所指向的对象。 13.1.3.2 什么时候调用析构函数？变量在离开其作用域时被销毁。 当一个对象被销毁时，其成员被销毁 容器（包括数组）被销毁时，其元素被销毁 对于动态分配的对象,当对指向它的指针应用delete运算符时被销毁(参见12.1.2节，第409页)。 对于临时对象，当创建它的完整表达式结束时被销毁 析构函数调用过程（P446） 如同构造函数有一个初始化部分和一个函数体，析构函数也有一个函数体和一个析构部分。 在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。 在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。 要认识到析构函数体自身并不直接销毁成员是非常重要的：成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。 13.1.3.3 三&#x2F;五法则需要析构函数的类也需要拷贝构造和拷贝赋值 需要拷贝构造的类也需要拷贝赋值，反之亦然。但不必然要求析构函数。 13.1.4 控制是否使用默认（合成）函数13.1.4.1 =default &amp; =delete 显式地要求编译器使用默认版本：=default 123456789class Sales_data&#123; public: Sales_data() = default; // 类内 = default将被声明为内联 Sales_data(const Sales_data &amp;) = default; Sales_data&amp; operator=(const Sales_data &amp;); ~Sales_data() = default;&#125;;Sales_data&amp; Sales_data::operator=(const Sales_data &amp;) = default; // 这样写就不是内联 阻止拷贝：=delete 1234567class noCopy&#123; noCopy() = default; noCopy(const noCopy &amp;) = delete; noCopy &amp; operator=(const noCopy &amp;) = delete; ~noCopy() = default; //析构函数不能是=delete，否则会导致一系列问题&#125;; 何时阻止拷贝？例如：iostream类阻止了拷贝，以避免多个对象读取或写入相同的io缓冲 =delete必须出现在函数第一次声明的时候 可以对任何函数=delete：用于引导函数匹配过程。（析构函数除外) 对上一点的补充：**析构函数不能是=delete**，否则 1)无法定义该类型的变量或临时对象；且如果它被包含进另一个类，则导致外层的类也不能定义变量或临时对象 2)无法释放指向该类型的动态分配到指针（可以new但不能delete） 13.1.4.2 何时合成的拷贝控制成员被定义为删除（P450）:question:有点乱 如果类的某个成员的析构函数是删除的或不可访问的(例如，是 private 的),则类的合成析构函数被定义为删除的。 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的,或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器(参见2.6.1节，第65页)，或是类有一个 const 成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。 总结：本质上，如果一个类中，存在某个数据成员不能默认构造、拷贝、赋值或销毁，则该类对应的成员函数将被定义为删除（&#x3D;delete）。 类中存在引用成员或无法默认构造的const成员类，编译器不会合成默认构造函数。 类中存在引用成员或无法默认构造的const成员类，编译器不会合成拷贝赋值运算符。 13.1.4.3 private拷贝控制没有=delete前（c++11前），通过声明（但不定义）private的拷贝构造和拷贝赋值，可以阻止任何拷贝该类对象的企图。 private：试图拷贝对象的用户代码将在编译阶段被标记为错误 不定义：成员函数或友元函数中的拷贝操作将会导致链接错误 13.2 拷贝控制和资源管理管理类外资源的类有两种拷贝方式：（a）拷贝指针指向的对象；（b）拷贝指针本身。 13.2.1 行为像值的类——拷贝指针指向的对象一 定义一个拷贝构造函数，完成string 的拷贝，而不是拷贝指针 定义一个析构函数来释放string 定义一个拷贝赋值运算符来释放对象当前的 string，并从右侧运算对象拷贝string 二 其中，尤其需要注意拷贝赋值的写法： 拷贝赋值运算符组合了类似拷贝构造函数和析构函数的工作： 赋值运算符左侧：销毁左侧运算对象的资源——（析构函数的构造） 赋值运算符右侧：从右侧运算对象拷贝数据到左侧运算对象——（拷贝构造的工作） 必须处理自赋值 需要异常安全——当异常发生时，能将左侧运算对象置于一个有意义的状态 三 示例如下 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;string&gt;using namespace std;class HasPtr &#123;public: HasPtr(const string&amp; s = string()) : ps(new string(s)), i(0) &#123;&#125; // 构造 HasPtr(const HasPtr&amp; p) : ps(new string(*p.ps)), i(p.i) &#123;&#125; // 拷贝构造 HasPtr&amp; operator=(const HasPtr&amp; p); // &lt;-特别需要注意拷贝赋值 ~HasPtr() &#123; delete ps; &#125; //析构private: string* ps; int i;&#125;;HasPtr&amp; HasPtr::operator=(const HasPtr&amp; p)&#123; auto newp = new string(*p.ps); // 现将数据保存在额外的空间中，避免因自赋值而将自身销毁 delete ps; // 先释放当前对象指针指向的空间 ps = newp; // 后从右侧对象拷贝数据 i = p.i; return *this;&#125;/*错误案例*/HasPtr&amp; HasPtr::operator=(const HasPtr&amp; p)&#123; /*如果有如下情况，ps将会指向无效内存： * HasPtr a； * a = a; * 调用operator=时，先将a.ps销毁了，又让a.ps指向了已经被销毁的空间，而产生未定义行为 */ delete ps; ps = new string(*(p.ps)); i = p.i; return *this;&#125; 13.2.2 行为像指针的类——拷贝指针本身同样要注意拷贝赋值的写法： 拷贝赋值运算符组合了类似拷贝构造函数和析构函数的工作： 需要递增右侧运算对象的引用计数（拷贝构造） 递减左侧运算对象的引用计数，并在必要时释放资源（析构） 处理自赋值 异常安全 示例 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;string&gt;using namespace std;class HasPtr &#123;public: HasPtr(const string&amp; s = string()) : ps(new string(s)), i(0) ,use(new size_t(i))&#123;&#125; //构造 HasPtr(const HasPtr&amp; p) : ps(p.ps), i(p.i), use(p.use) &#123; ++*use; &#125; // 拷贝构造 HasPtr&amp; operator=(const HasPtr&amp; p); // 拷贝赋值 ~HasPtr() &#123; if (--*use == 0) &#123; // 如果引用计数变为0，则释放内存 delete ps; delete use; &#125; &#125;private: string* ps; int i; size_t* use; // 引用计数器，保存在动态内存中&#125;;HasPtr&amp; HasPtr::operator=(const HasPtr&amp; p)&#123; ++*p.use; // 递增右侧运算对象的引用计数，可以避免自赋值被销毁：当=两边相同时，在递减之前，计数器已经被递增过了 if (--*use == 0) &#123; // 递减左对象的引用计数 delete ps; delete use; &#125; this-&gt;ps = p.ps; this-&gt;i = p.i; this-&gt;use = p.use; return *this;&#125; 13.2.3 交换操作 与拷贝控制成员不同，swap并不是必要的。但是，对于分配了资源的类，定义swap可能是一种很重要的优化手段。 一：编写自定义swap两个类型交换的传统做法： 123HasPtr tmp = v1;v1 = v2;v2 = tmp; 可通过重载swap的默认行为，实现两个自定义类的交换： 12345678910class HasPtr&#123; friend void swap(HasPtr &amp;, HasPtr &amp;); // 定义为友元以访问类的private成员&#125;;inlinevoid swap(HasPtr &amp;l, HasPtr &amp;r)&#123; using std::swap; swap(l.ps, r.ps); // 交换指针 swap(l.i,r.i); // 交换int成员&#125; 调用HasPtr定义的swap: 1234567891011121314class Foo&#123; friend void swap(Foo &amp;, Foo &amp;); private: HasPtr h;&#125;;inline void swap(Foo &amp;r, Foo &amp;l)&#123; using std::swap; swap(r.h, l.h); // 自定义版本的swap优先级高于std::swap, 此处会调用类中重载的版本 //交换Foo的其他成员&#125; 建议使用using std::swap的写法： 二：在赋值构造中使用swap拷贝交换技术：将左侧运算对象与右侧运算对象的一个副本进行交换。 优势：自动处理了自赋值情况 且 天然异常安全。 1234HasPtr &amp; HasPtr::operator=(const HasPtr rhs)&#123; // &lt;-注意：参数以值方式传递 swap(*this,rhs); return *this; // rhs被销毁&#125; 13.3 两个例子13.3.1 拷贝控制示例Message.hpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#pragma once#include &quot;Folder.hpp&quot;#include &lt;string&gt;#include &lt;set&gt;using namespace std;class Message&#123; friend class Folder; friend void swap(Message&amp; l, Message&amp; r);public: explicit Message(const string str = &quot;&quot;) :contents(str) &#123;&#125; Message(const Message&amp;);//拷贝构造 Message&amp; operator=(const Message&amp;); ~Message() &#123; remove_from_folders(); &#125; //从给定folder中添加/删除本message void save(Folder&amp; f) &#123; this-&gt;folders.insert(&amp;f); f.addMsg(this); &#125; void remove(Folder&amp; f) &#123; this-&gt;folders.erase(&amp;f); f.remMsg(this); &#125;private: string contents; set&lt;Folder*&gt; folders; // 包含本message的folder void add_to_folders(const Message&amp;m) &#123; // 将本message添加到指向m的folder中 for (auto f : m.folders) &#123; f-&gt;addMsg(this); &#125; &#125; void remove_from_folders() &#123; for (auto f : this-&gt;folders) &#123; f-&gt;remMsg(this); &#125; &#125;&#125;;Message::Message(const Message&amp;m) :contents(m.contents), folders(m.folders)&#123; add_to_folders(m);&#125;inline Message&amp; Message::operator=(const Message&amp;r)&#123; remove_from_folders(); contents = r.contents; folders = r.folders; add_to_folders(r); return *this;&#125;void swap(Message&amp; l, Message&amp; r) &#123; using std::swap; //将每个消息的指针从它（原来）所在的Folder中删除 for (auto f: l.folders) f-&gt;remMsg(&amp;l); for (auto f : r.folders) f-&gt;remMsg(&amp;r); swap(l.folders, r.folders); // 交换set swap(l.contents, r.contents); // 交换string //将每个Message的指针添加到它的（新）Folder中&#125; 13.3.2 动态内存管理类StrVec类 13.4 :star:对象移动（书P470） 为何使用移动？ 提升性能。在某些情况下，对象拷贝后机立即被销毁了，在这种情况下，移动而非拷贝对象会大幅度提升性能。 不能被共享的资源（io类或unique_ptr），不可被拷贝但可以移动。 在旧 C++标准中，没有直接的方法移动对象。因此，即使不必拷贝对象的情况下，我们也不得不拷贝。如果对象较大，或者是对象本身要求分配内存空间(如 string)，进行不必要的拷贝代价非常高。类似的，在旧版本的标准库中，容器中所保存的类必须是可拷贝的。但在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能被移动即可。 13.4.1 什么是右值引用一、左值和右值左值：表示一个对象的身份，通常可以被取地址。 左值引用的作用对象：不能将左值引用绑定到要求转换的表达式、字面值常量、返回右值的表达式。 右值：表示一个对象的值，通常无法取地址。 右值引用的作用对象：不能将右值引用直接绑定到左值，如必须要绑定，则要先用std::move将左值转换成右值，再右值引用。 左值和右值的对比： 二、右值引用右值引用就是必须绑定到右值的引用，通过&amp;&amp;表示。 右值引用的一个重要性质：只能绑定到一个将要销毁的对象上，从而将一个右值引用的资源“移动”到另一个对象上。 示例 12345678910/*使用*/int main() &#123; int&amp;&amp; rr1 = 42; int&amp;&amp; rr2 = std::move(rr1); cout &lt;&lt; rr2 &lt;&lt; endl; // 42 int&amp;&amp; rr3 = 42; cout &lt;&lt; rr3 &lt;&lt; endl; // 42 return 0;&#125; 13.4.2 std::move() 通过std::move将左值转化为右值（原文：使用std::move获得绑定到左值上的右值引用） move的作用是偷取（窃取）其他变量里的资源变为自己的（是资源所有权的变更，而不是拷贝资源），如内存、线程等等，而不必自己再从0获取。很显然这样可以节约一些程序开销。 123456int &amp;&amp;rr1 = 42; // 正确，字面值常量是右值int &amp;&amp;rr2 = rr1; // 错误，rr1是左值，右值引用只能绑定右值。（变量（rr1）可以看做没有运算符的表达式，而表达式都是左值）int &amp;&amp;rr3 = std::move(rr1); // 正确，使用std::move获得绑定到左值上的右值引用（我的理解：将左值转化为右值）//之后，可以销毁rr1的源对象，也可以赋予它新值，但是不可再使用rr1源对象的值 #include &lt;utility&gt; 我们可以销毁一个移后源对象（此处指rr1），也可以赋予它新值，但不能使用一个移后源对象的值。 move 调用告诉编译器:我们有一个左值，但我们希望像一个右值一样处理它。我们必须认识到，调用 move 就意味着承诺：除了对 rr1 赋值或销它外，我们将不再使用它。在调用move之后，我们不能对移后源对象的值做任何假设。 移动操作还必须保证源对象可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值。 另一方面，移动操作对移后源对象中留下的值没有任何要求。因此，我们不可对其值进行假设，我们的程序也不应依赖于移后源对象中的数据。 使用move 的代码应该使用 std::move而不是move（不提供using声明）。这样做可以避免潜在的名字冲突。 13.4.3 自定义类中的移动构造和移动赋值对于移动构造和移动赋值： 从给定对象窃取资源而不是拷贝资源，不新分配任何内存 **必须在声明和定义中都标记为noexcept**，通知标准库不抛出任何异常（为什么需要noexcpt，书P474，:question:） **源对象的所有指针置为nullptr**，确保移后源对象处于一个可析构的状态（必须确保移后源对象被销毁是无害的） 后续程序不应依赖移后源对象中的数据 13.4.3.1 移动构造模板： 1234567891011121314151617#include &lt;string&gt;class StrVec &#123;public: /*移动构造函数*/ StrVec(StrVec&amp;&amp; s) noexcept // 移动操作不应抛出任何异常 //成员初始化器接管s中的资源 :elements(s.elements),first_free(s.first_free),cap(s.cap) &#123; // 源对象的指针全都要置空，确保移后源对象处于一个可析构的状态 s.elements = s.first_free = s.cap = nullptr; &#125;private: string* elements; string* first_free; string* cap;&#125;; 第一个参数须是该类型的右值引用，额外参数必须有默认值。（类似拷贝构造） 13.4.3.2 移动赋值类似拷贝赋值： 析构函数+移动构造 必须正确处理自赋值 模板： 123456789101112131415161718192021222324#include &lt;string&gt;class StrVec &#123;public: /*拷贝赋值*/ StrVec&amp; operator=(StrVec&amp;&amp; s) noexcept &#123; //if语句检测自赋值：对于“=”两端相同的资源，避免在使用右侧运算对象之前就释放了左侧对象（避免将自身释放） if (this != &amp;s) &#123; // s是左值，取地址 /*this-&gt;*/free(); // 释放左侧运算对象所使用的内存 elements = s.elements; first_free = s.first_free; cap = s.cap; // 将s置于可析构状态 s.elements = s.first_free = s.cap = nullptr; // 源对象的指针全都要置空 &#125; return *this; &#125;private: string* elements; string* first_free; string* cap;&#125;; 13.4.3.3 合成的移动操作何时会生成合成移动操作？ 只有当一个类 没有定义任何自己版本的拷贝控制成员， 且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。 何时移动操作被定义为删除？(P476 ) 与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是: 有类成员定义了自己的拷贝构造函数且未定义移动构造函数， 或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的。 类似拷贝构造函数，如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。 类似拷贝赋值运算符，如果有类成员是 const 的或是引用，则类的移动赋值运算符被定义为删除的。 移动操作和合成拷贝之间的关系： 如果类定义了一个移动构造函数和（或）一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除。 因此，定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。 移动右值，拷贝左值，但如果没有移动构造函数，右值也将被拷贝。 –&gt;拷贝也是一种形式的“移动”，并且几乎是安全的。 移动右值，拷贝左值：一个类既有拷贝构造，又有移动构造，编译器会实现最优匹配 如果没有移动构造函数，右值也将被拷贝。此种情况，即使通过std::move也会调用拷贝构造 12345678910class Foo&#123;public: Foo() = default; Foo(const Foo &amp;); // 拷贝构造 //未定义移动构造&#125;;Foo x;Foo y(x); // 拷贝构造Foo z(std::move(x)); // 拷贝构造，因为没有定义移动构造；此处会将 Foo&amp;&amp; 隐式转化为 const Foo&amp; 13.4.3.4 三&#x2F;五法则 所有五个拷贝控制成员应该看作一个整体： 一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。如前所述，某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作(参见13.1.4 节，第447页)。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。 13.4.5 （基于）拷贝并交换（技术的）赋值运算符即，添加了移动构造函数之后，类中使用拷贝并交换技术的重载赋值运算符既是拷贝赋值，也是移动赋值。具体是那种赋值方式依赖于operator=()的实参类型：拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——移动右值，拷贝左值。如此，一个operator&#x3D;函数就实现了拷贝赋值和移动赋值两种功能。 123456789class HasPtr&#123;public: // 添加移动构造 HasPtr(HasPtr &amp;&amp;p)noexcept:ps(p.ps),i(p.i)&#123;p.ps=0;&#125; // 赋值运算符既是拷贝赋值，也是移动赋值 HasPtr &amp;operator=(HasPtr rhs)&#123; swap(*this,rhs); return *this; &#125;&#125;; 参考书中的论述： 值得注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁掉原对象，因此你只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法。 联想：operator&#x3D;的作用包括构造+析构——对左对象析构并将右对象拷贝（移动）到左对象。 13.4.4 移动迭代器 解引用移动迭代器生成右值引用 调用make_move_iterator()将一个迭代器转为移动迭代器：make_move_iterator(begin()) 移动迭代器支持正常的迭代器操作，我们可以将一对移动迭代器传递给算法。 值得注意的是： 值得注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁掉原对象，因此你只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法。 13.5 右值引用和成员函数13.5.1 重载拷贝版本和移动版本1234567891011121314151617class StrVec&#123;public: void push_back(const string&amp;s)&#123; // 拷贝：绑定到int //... alloc.construct(first_free++, s); &#125; void push_back(string &amp;&amp;s)&#123; // 移动：只能绑定到类型为int的可修改的右值 //... alloc.construct(first_free++, std::move(s)); &#125;&#125;;//-----------使用StrVecStrVec vec;string s = &quot;a&quot;;vec.push_back(s); // 调用拷贝的版本vec.push_back(&quot;done&quot;); //调用移动的版本：临时对象/常量调用右值的版本 区分拷贝和移动的重载函数通常由一个版本接受一个const T&amp;，而另一个版本接受一个T&amp;&amp; 13.5.2 引用限定符对一个右值进行赋值居然是成立的： 12string s1 = &quot;a&quot;, s2 = &quot;b&quot;;s1 + s2 = &quot;c&quot;; // 对s1和s2的连接结果赋值 在新标准下可以阻止这一情况的发生：在参数列表后放置一个引用限定符： 1234Class Foo&#123;public: Foo &amp;operator=(const Foo &amp;) &amp;;//只能向可修改的左值赋值&#125;; 引用限定符可以是&amp;或&amp;&amp;，指出this可以指向一个左值或一个右值； 只能用于非static成员函数（类似const） 必须同时出现在函数的声明和定义中 可以与const连用，引用限定符必须在const之后： 1234class Foo&#123;public: Foo someM() const &amp;; // 必须注意const和&amp;的顺序&#125;; 如果一个成员函数有引用限定符，则具有相同参数列表的所有参数版本都必须加引用限定符。（相同参数列表的重载版本要么都加，要么都不加引用限定符） 就像一个成员函数可以根据是否有 const 来区分其重载版本一样(书：参见7.3.2节第247页)，引用限定符也可以区分重载版本。而且，我们可以综合引用限定符和 const 来区分一个成员函数的重载版本。 12345678910111213class Foo&#123;puiblic: Foo sorted() &amp;&amp;; //Foo sorted() const; // 错误 Foo sorted() const &amp;; Foo sorted(int *); Foo sorted(int *) const;&#125;;//----------------编译器会根据调用sorted的对象的左值/右值属性来确定使用哪个sorted版本retVal().sorted(); // retVal()是右值，调用&amp;&amp;版本retFoo().sorted(); // retFoo()是左值，调用const &amp;版本 十四 重载运算与类型转换14.1 基本概念 除了重载的函数调用运算符operator()外，其他重载运算符不能含有默认实参。 对于一个运算符函数来说，它或是类的成员，或至少含有一个类类型的参数。–&gt;当运算符作用于内置类型（如int）的运算对象，我们无法改变该运算符的含义 12//错误:不能为int重定义内置的运算符int operator+(int, int); 可以直接调用重载的运算符函数 1234567//1,等价data1+data2;operator+(data1, data2);//2,等价data1+=data2;data1.operator+=(data2); 通常情况下，可以重载却不应重载：逗号、取地址、逻辑与&#x2F;或（原因：重载版本无法保留求值顺序和&#x2F;或短路求值属性，导致运算符不符合用户习惯） 何时使用运算符重载？ 只有当操作的含义对于用户来说清晰明了时才可以重载运算符。如果用户对运算符可能有多种理解，重载运算符将产生二义性。 使用与内置类型一致的含义： 有operator==，也应有operator!=；有operator&lt;，也应有其他关系运算符。 有算符运算符或为运算符，最好也提供复合运算符。如有operator+，也应有operator+=，并用+=（复合）来实现+（算数）。 重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容： 逻辑运算符和关系运算符应该返回 bool， 算术运算符应该返回一个类类型的值， 赋值运算符和复合赋值运算符则应该返回左侧运算对象的一个引用。 作为成员还是非成员? 1234// 例如string s = &quot;w&quot;;string t = s+&quot;hi&quot;; // 等价s.operator+(&quot;hi&quot;);string u = &quot;hi&quot;+s; // 如果+是string的成员，则产生错误 关于对称性的解释：如+，a+b&#x3D;&#x3D;b+a –&gt;对称性 因为标准库中，string将+定义成了普通的非成员函数，所以”hi”+s等价于operator+(“hi”,s)。 和任何其他函数调用一样，每个实参都能被转换成形参类型。唯一的要求是至少有一个运算对象是类类型，并且两个运算对象都能准确无误地转换成string。 14.2 输入和输出运算符非成员 14.2.1 operator&lt;&lt; 例子 123456ostream &amp;operator&lt;&lt;(ostream&amp;os, const Sales_data &amp;item)&#123; os&lt;&lt;item.isbn() &lt;&lt; &quot; &quot;&lt;&lt; item.units_sold &lt;&lt; &quot; &quot; &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_price(); return os;&#125; operator&lt;&lt;应尽量减少格式化操作，更不应打印换行符。 operator&lt;&lt;必须是非成员函数，又因需要读写非公成员，一般设置为友元。 14.2.2 operator&gt;&gt; 例子 123456789101112istream &amp;operator&gt;&gt;(istream &amp;is, Sales_data &amp;item)&#123; double price; is&gt;&gt;item.bookNo&gt;&gt;item.units_sold&gt;&gt;price; if(is) // 检查输入是否成功 item.revenue = item.units_sold * price; else // 输入失败，对象被赋予默认状态 // 当读取操作发生错误时， item = Sales_data(); return is;&#125; operator&gt;&gt;必须处理输入可能失败的情况。利用if(is)检查是否输入成功。 当流含有错误类型的数据时，读取操作可能失败：如输入的是int，读取的对象要求string 当读取到达文件尾 或 遇到输入流的其他错误 operator&gt;&gt;也应该设置流的条件状态以标识出失败信息： 通常情况下，只需设置failbit 除此之外，设置eofbit表示文件耗尽，badbit表示流被破坏等 14.3 算数和关系运算符 通常情况下，我们把算数和关系运算符定义成非成员函数以允许左侧或右侧的运算对象进行转换 形参一般为常量的引用，const Sales_data &amp;lhs 14.3.1 算数运算符 最有效的方式是使用复合赋值来定义算数运算符，+= –&gt; + 14.3.2 相等运算符 相等运算符和不相等运算符中的一个应该把工作委托给另一个 14.3.3 关系运算符 因为关联容器和一些算法要用到小于运算符，所以定义operator&lt;会比较有用 如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑为这个类定义&lt;运算符；顺序关系应与关联容器中对关键字的要求一致。 如果该类同时包含==，则当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符；特别是，如果两个对象时!=的，那么一个对象应该&lt;另外一个。（解释：P498-14.3.2-（第5段）尽管……） 14.4 赋值运算符 赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。 赋值，除了移动赋值和拷贝赋值，还可接受元素列表 1234567891011121314vector&lt;string&gt; v;v = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;class StrVec&#123;public: StrVec &amp;operator=(std::initializer_list&lt;std::string&gt; il)&#123; auto data = alloc_n_copy(il.begin(), il.end()); // 分配空间并拷贝元素 /*this-&gt;*/free(); // 释放当前对象的内存 elements = data.first; // 更新数据成员使其指向新的空间 first_free = cap = data.second; return *this; &#125;&#125; 赋值运算符必须释放当前内存，在创建新内存。 此处不同的是，不必检查自我赋值 复合赋值运算符 1234Sales_data &amp;Sales_data::operator+=(const Sales_data &amp;rhs)&#123; //... return *this;&#125; 14.5下标运算符 operator[]必须是成员函数 通常返回访问元素的引用 通常同时定义常量版本和非常量版本： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;class StrVec &#123;public: std::string&amp; operator[](std::size_t n) &#123; return elements[0]; &#125; const std::string&amp; operator[](std::size_t n) const &#123; return elements[0]; &#125; std::size_t size() const &#123; elements-&gt;size(); &#125;private: std::string elements[];&#125;;int main()&#123; StrVec svec; const StrVec&amp; cvec = svec; if (svec.size() &amp;&amp; svec[0].empty()) &#123; svec[0] = &quot;zero&quot;; //cvec[0] = &quot;zero&quot;;//没有与这些操作数匹配的&quot;=&quot;运算符.操作数类型为: const std::string = const char [5] &#125;&#125; 14.6 递增递减运算符 建议是类的成员 示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class StrBlobPtr &#123;public: /* 前置 */ // 如果显示调用则：p.operator++(); StrBlobPtr&amp; operator++(); // 返回递增或递减后对象的**引用** StrBlobPtr&amp; operator--(); /* 后置 */ // 后置版本接受一个额外的（不被使用的）int类型的形参，该形参仅用于重载(用于区分前置和后置) // 如果显示调用则：p.operator++(0); StrBlobPtr operator++(int); // 应该返回对象的原值，返回的形式是一个**值**而非引用 StrBlobPtr operator--(int);&#125;;StrBlobPtr&amp; StrBlobPtr::operator++()&#123; check(curr, &quot;increment past end of StrBlobPtr.&quot;); // check的作用： // 1-检查StrBlobPtr是否有效 // 2-索引值是否有效 --&gt;curr已经到达vector末尾，则抛出异常 ++curr; return *this;&#125;StrBlobPtr&amp; StrBlobPtr::operator--()&#123; --curr; check(curr, &quot;decrement past begin of StrBlobPtr.&quot;); // curr如果已经是0，`--`后将是一个表示无效下标的非常大的正数值 return *this;&#125;StrBlobPtr StrBlobPtr::operator++(int)&#123; StrBlobPtr ret = *this; ++*this; return ret;&#125;StrBlobPtr StrBlobPtr::operator--(int)&#123; StrBlobPtr ret = *this; --*this; return ret;&#125; 14.7 成员访问运算符 常用语迭代器类及智能指针类 箭头运算符(-&gt;)必须是类的成员，解引用运算符(*)通常是类的成员。 这两个函数都是const函数，返回非const的引用或指针 示例 1234567891011121314class StrBlobPtr &#123;public: /* 成员访问运算符 */ std::string&amp; operator*() const &#123; auto p = check(curr, &quot;dereference past end.&quot;); // 检查curr是否在合法范围内 return (*p)[curr]; // *p为对象所指的vector &#125; std::string* operator-&gt;() const &#123; // 将实际工作交于operator*(),返回解引用结果的地址 return &amp;this-&gt;operator*(); &#125;&#125;; 对箭头运算符返回值有限定，只能用于获取成员。 重载的箭头运算符必须返回类的指针 或 自定义了箭头运算符的某个类的对象 对于point-&gt;mem，只能有两种含义，具体取决于point的类型： 如果point是一个指针类型，那么point-&gt;mem等价于(*point).mem，表示访问指针point指向的对象的mem成员。 如果point是一个类类型的对象，并且该类重载了operator-&gt;，那么point-&gt;mem会调用point.operator-&gt;()来获取一个指针，然后再访问该指针的mem成员。 这样的机制允许类型设计者为其类对象提供类似于指针的接口，使得使用这些对象时能够有类似直接使用指针一样的语法和方便性。 14.8 函数调用运算符14.8.1 基础 必须是成员函数 函数对象：对象的行为像函数一样。 123456789101112131415#include &lt;iostream&gt;struct absInt &#123; int operator()(int val)const &#123; return val &lt; 0 ? -val : val; &#125;&#125;;int main()&#123; int i = -42; absInt absObj; int res = absObj(i); std::cout &lt;&lt; res &lt;&lt; std::endl; // 42&#125; 函数对象常常作为泛型算法的实参 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;class PrintString&#123;public: PrintString(ostream&amp; o = cout, char c = &#x27; &#x27;) :os(o), step(c) &#123;&#125; void operator()(const string&amp; s)const &#123; os &lt;&lt; s &lt;&lt; step; &#125;private: ostream&amp; os; char step;&#125;;int main() &#123; // 基本用法 string s = &quot;s&quot;; PrintString priterner; priterner(s); // s // 函数对象常常作为泛型算法的实参 vector&lt;string&gt; vs&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;; for_each(vs.begin(), vs.end(), PrintString(cerr,&quot; &quot;)); // a b c // 首次时，PrintString()创建临时对象； // 之后for_each()的内部代码会调用这个对象（此时运行operator()）以排序&#125; 14.8.2 lambda表达式与operator()一、无捕获行为的lambda 1234567891011121314151617181920212223[](const string &amp;a, const string &amp;b)&#123;return a.size() &lt; b.size();&#125;// 等价class ShorterString&#123;public: bool operator()(const string &amp;s1, const string &amp;s2) const //默认情况下lambda不能改变它捕获的变量。 //因此在默认情况下，由lambda产生的类当中的函数调用运算符是一个const成员函数。 //如果lambda被声明为可变的，则调用运算符就不是const的了。 &#123; return s1.size() &lt; s2.size(); &#125;&#125;;/*于是有*/stable_short(words.begin(), words.end(), [](const string &amp;a, const string &amp;b) &#123;return a.size() &lt; b.size();&#125;);// 等价stable_short(words.begin(), words.end(),ShorterString());//第三个实参是新构建的Shorterstring对象，当stable_sort内部的代码每次比较两个string时就会“调用”这一对象，//此时该对象将调用运算符的函数体，判断第一个string的大小小于第二个时返回 true。 二、有捕获行为的lambda 如我们所知，当一个lambda 表达式通过引用捕获变量时，将由程序负责确保lambda执行时引用所引的对象确实存在(参见10.3.3节，第350页)。因此，编译器可以直接使用该引用而无须在lambda产生的类中将其存储为数据成员。 相反，通过值捕获的变量被拷贝到lambda中(参见10.3.3节，第350页)。因此，这种lambda产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。 如， 12auto wc = find_if(words.begin(), words.end(), [sz](const string&amp; a) &#123;return a.size() &gt;= sz; &#125;); lambda将产生如下类， 1234567891011121314class SizeComp &#123;public: SizeComp(std::size_t n) :sz(n) &#123;&#125; bool operator()(const string&amp; s) const &#123; return s.size() &gt;= sz; &#125;private: std::size_t sz;&#125;;//lambda表达式产生的类不含默认构造函数、赋值运算符及默认析构函数;//它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定 则find_if等价于， 1auto wc = find_if(words.begin(), words.end(),SizeComp(sz)); 14.8.3 标准库定义的函数对象 标准库（#include &lt;functional&gt;）定义了一组表示算数运算、关系运算符和逻辑运算符的类，每个类分别定义了执行命名操作的调用运算符。 示例 12345plus&lt;int&gt; intAdd;int sum = intAdd(10,20); //sum=30negate&lt;int&gt; intNeg; // 取反int neg = intNeg(-10); // neg = 10 在算法中使用标准库函数 表示运算符的函数对象类常用来替换算法中的默认运算符 12// 默认使用operator&lt;将序列升序，可做如下更改使其降序排列sort(svec.begin(), svec.end(), greater&lt;string&gt;); // 大于比较运算 标准库规定其函数对于指针同样使用 首先对于顺序容器，我们之前曾经介绍过比较两个无关指针将产生未定义的行为(书：参见3.5.3节，第107页)，然而我们可能会希望通过比较指针的内存地址来排序指针的vector。直接这么做将产生未定义的行为，因此我们可以使用一个标准库函数对象来实现该目的: 123456vector&lt;string*&gt; nameTab;// 错误，nameTab中的指针彼此没有关联，&lt;将产生未定义行为sort(nameTab.begin(), nameTab.end(), [](string* a, string* b) &#123;return a &lt; b; &#125;); // 妄图通过比较内存地址，类排序vector，将不会成功// 正确,标准库规定指针的less是定义良好的sort(nameTab.begin(), nameTab.end(), less&lt;string*&gt;()); 其次，关联容器可以直接排序指针，而无需显式地声明。 关联容器使用 less&lt;key_type&gt;对元素排序，因此我们可以定义一个指针的set或者在map中 使用指针作为关键值而无须直接声明less。 14.8.4 可调用对象与function C++语言中有几种可调用的对象：函数、函数指针、lambda表达式(书：参见10.3.2节，第 346页)、bind 创建的对象(书：参见10.3.4节，第354页)以及重载了函数调用运算符的类。 不同的类型可能具有相同的调用方式 1234567891011121314// 如下可调用对象// 1int add(int i, int j)&#123;return i+j;&#125;// 2auto mod = [](int i, int j)&#123;return i%j; &#125;;// 3struct divide&#123; int operator()(int i, int j)&#123; return i/j; &#125;&#125;;// 具有相同的调用形式int(int, int) 使用map创建函数表用于存储可调用这些对象的“指针” 123456map&lt;string, int(*)(int, int)&gt; binops;binops.insert(&#123;&quot;+&quot;,add&#125;); // &#123;&quot;+&quot;,add&#125;:pair// 但是不能将mod和divide存入binops// 问题在于mod是个lambda表达式，而每个lambda有其自己的类型，该类型与存储在binops中的值的类型不匹配// 如何才能将mod和divide存入binops呢？使用function&lt;T&gt; 使用function&lt;T&gt; #include &lt;functional&gt; 示例 1234567891011121314151617181920212223242526272829303132333435// 1.函数int add(int i, int j) &#123; return i + j; &#125;// 2.lambdaauto mod = [](int i, int j) &#123;return i % j; &#125;;// 3.可调用对象struct divide &#123; int operator()(int i, int j) &#123; return i / j; &#125;&#125;;int main()&#123; function&lt;int(int, int)&gt; f1 = add; // 函数指针 function&lt;int(int, int)&gt; f2 = divide(); // 函数对象类的对象 function&lt;int(int, int)&gt; f3 = mod; // lambda cout &lt;&lt; f1(4, 2) &lt;&lt; endl; // 6 cout &lt;&lt; f2(4, 2) &lt;&lt; endl; // 2 cout &lt;&lt; f3(4, 2) &lt;&lt; endl; // 0 // 构建map函数表 map&lt;string, function&lt;int(int, int)&gt;&gt; binops = &#123; &#123;&quot;+&quot;,add&#125;, // 函数指针 &#123;&quot;-&quot;,std::minus&lt;int&gt;()&#125;, // 标准库中的函数对象 &#123;&quot;/&quot;,divide()&#125;, // 用户定义的函数对象 &#123;&quot;*&quot;,[](int i, int j) &#123;return i * j; &#125;&#125;, // 未命名的lambda &#123;&quot;%&quot;,mod&#125; // 命名的lambda &#125;; cout &lt;&lt; binops[&quot;+&quot;](10, 5) &lt;&lt; endl; // 15 cout &lt;&lt; binops[&quot;-&quot;](10, 5) &lt;&lt; endl; // 5 cout &lt;&lt; binops[&quot;/&quot;](10, 5) &lt;&lt; endl; // 2 cout &lt;&lt; binops[&quot;*&quot;](10, 5) &lt;&lt; endl; // 50 cout &lt;&lt; binops[&quot;%&quot;](10, 5) &lt;&lt; endl; // 0&#125; 但是我们不能不能直接将重载的函数名置于function&lt;T&gt;中 123456789// 1int add(int i, int j)&#123;return i+j;&#125;// 2.重载addSales_data add(const Sales_data &amp;, const Sales_data &amp;);map&lt;string, function&lt;int(int, int)&gt;&gt; binops;binops.insert(&#123;&quot;+&quot;,add&#125;); // 错误：哪一个add？// 两种方法解决该二义性问题 将函数指针传入function，而不是直接传入重载的函数的名字 12int (*fp)(int, int) = add;binops.insert(&#123;&quot;+&quot;,fp&#125;); 用lambda消除二义性 1binops.insert(&#123;&quot;+&quot;,[](int i, int j)&#123; return add(a,b);&#125;&#125;); 14.9 重载、类型转换与运算符14.9.1 类型转换运算符1operator type() const &#123;&#125;; type可以是void之外的任意类型； type不允许转换成数组或者函数类型，但允许转换成指针（包括数组指针及函数指针）或引用类型。 type也是该函数的返回类型 没有显式返回类型，type()中也不能写形参 必须定义成类的成员函数 一般定义成const（类型转换通常不改变转换对象的内容） 举例 12345678910111213141516class SmallInt&#123;public: SmallInt(int i = 0):val(i)&#123; if(i &lt;0 || i &gt; 255) throw std::out_of_range(&quot;Bad SmallInt value.&quot;); &#125; operator int() const &#123; return val;&#125;private: std::size_t val;&#125;;int main()&#123; SmallInt si; si = 4; // 4被隐式转换为SmallInt，然后调用SmallInt::operator= si + 3; // si被隐式转化为int，后执行整数加法&#125; 然而，隐式转换有时会带来一些问题(书P515底~516顶)： 123//operator bool()引发的问题int i = 42;cin &lt;&lt; i; 上述代码的解释：cin没有定义&lt;&lt;，这段代码本应报错。然而，cin中使用了operator bool()，将cin隐式转化成了bool，bool又被提升为了int，并被作为内置左移运算符的左侧运算对象。最终，提升后的bool（0或1）被左移了42个位置。 因此在必要的时候，需要用explicit禁用隐式转换 12345678910111213141516class SmallInt&#123;public: SmallInt(int i = 0):val(i)&#123; if(i &lt;0 || i &gt; 255) throw std::out_of_range(&quot;Bad SmallInt value.&quot;); &#125; explicit operator int() const &#123; return val;&#125;private: std::size_t val;&#125;;int main()&#123; SmallInt si; si = 4; // 4被隐式转换为SmallInt，然后调用SmallInt::operator= static_cast&lt;int&gt;(si) + 3; // si被显式转换&#125; 值得注意，在下列情况（表达式被用作条件时），显式类型转换将被隐式地执行： if、while、do的条件部分 for语句头的条件表达式 ？ ：的条件表达式 ！，||，&amp;&amp; 对于上文因为operator bool()引发的问题，将其定义为explicit后，只有在条件中，才会隐式转换： 1while(std::cin &gt;&gt; value)&#123;&#125; 对于此过程的解释：while 语句的条件执行输入运算符，它负责将数据读入到 value 并返回cin。为了对条件求值，cin被istream operator bool类型转换函数隐式地执行了转换。如果cin的条件状态是 good(参见8.1.2 节，第280 页)，则该函数返回为真；否则该函数返回为假。 bool 的类型转换通常用在条件部分，因此operator bool一般定义成explicit 14.9.2 避免有二义性的类型转换（:question:有些难以理解） 不要在两个类之间构建相同的类型转换，反例如下： 123456789101112131415161718struct A&#123; A() = default; A(const B&amp;); // 以B为参数的构造函数，B-&gt;A&#125;;struct B&#123; operator A() const; //类型转换运算符，B-&gt;A&#125;;A f(const A&amp;);B b;A a = f(b); // 二义性错误，不知道调用f(B::operator A())还是f(A::A(const B&amp;))//如何解决上述问题？//显式调用类型转换运算符 或 转换构造函数A a1 = f(b.operator A());A a2 = f(A(b));//注意，不可用强制类型转换，因为其本身也会碰到二义性问题 二义性与转换目标为内置类型的多重类型转换 12345678910111213141516171819struct A&#123; // 最好不要创建两个转换源都是算数类型的类型转换，反例： A(int = 0); A(double); // 最好不要创建两个转换对象都是算数类型的类型转换，反例： operator int() const; operator double const;&#125;;void f2(long double);A a;f2(a); // 二义性错误：f(A::operator int())还是f(A::operator double()) ?long lg;A a2(lg); //二义性错误：A::A(int)还是A::A(double) ?short s = 42;A a3(s); // 使用A::A(int),把short提升为int的优先级 大于 short提升为double 总结 重载函数与转换构造函数 调用重载函数时，如果多个类型转换都提供了同一种可行的匹配，则这些类型转换优先级一样（书：这些类型转换一样好） 123456789101112131415// 两个转换构造函数struct C &#123; C(int);&#125;;struct D &#123; D(int);&#125;;// 重载的manip()void manip(const C&amp;);void manip(const D&amp;);manip(10); // 二义性错误，manip(C(10))还是manip(D(10));manip(C(10)); // 正确，需要显式声明 重载函数与用户定义的类型转换同时，这种情况也不会考虑任何可能出现的优先级 12345678910111213struct C &#123; C(int);&#125;;struct E&#123; E(double);&#125;;// 重载的manip()void manip2(const C&amp;);void manip2(const E&amp;);manip2(10); // 二义性错误，manip(C(10))还是manip(E(double(10))) ? 只有当重载函数能通过同一个类型转换函数得到匹配时，我们才会考虑其中的类型转换（:question:同一类型转换指？原文书P520中间） 如果在调用重载函数时我们需要使用构造函数或者强制类型转换来改变实参的类型，则这通常意味着程序的设计存在不足。 14.9.3 函数匹配与重载的运算符 当在表达式中使用重载的运算符时，无法判断在使用的是成员函数还是非成员函数，他们都在候选函数集中。 123// a + b 可能是a.operator+(b);operator+(a,b); 对比：调用一个命名函数时，具有该名字的成员函数和非成员函数不会彼此重载，因为他们的调用语法是不同的。 如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。 1234567891011121314151617181920class SmallInt &#123; friend SmallInt operator+(const SmallInt&amp;, const SmallInt&amp;);public: SmallInt(int = 0) &#123;&#125;; // int -&gt; SmallInt operator int() const &#123; return val; &#125; // SmallInt -&gt; intprivate: std::size_t val;&#125;;SmallInt s1, s2;SmallInt s3 = s1 + s2; // 正确，使用重载的operator+int i = s3 + 0; // 二义性错误// 我们可以把0转换成SmallInt，然后使用SmallInt的+;// 或者把s3转换成int，然后对于两个int 执行内置的加法运算。 15 面向对象程序设计15.1 OOP：概述oop核心思想：数据抽象、继承、动态绑定。（或者说：封装、继承、多态） 数据抽象：类的接口与实现分离 继承 12345678910class Quote&#123;public: std::string isbn() const; virtual double net_price(std::size_t n) const; // 虚函数&#125;;class Bulk_quote : public Quote&#123; // public继承，我们完全可以把Bulk_quote的对象当成Quote的对象来用public: double net_price(std::size_t n) const override; // 重写&#125;; 动态绑定（或者说运行时绑定） 函数的运行版本由实参决定 当我们使用基类的引用、指针调用一个虚函数时，将引发动态绑定 12345678910double print_total(const Quote&amp; item, size_t n)&#123; double ret = item.net_price(n); // 当item是Quote类型时调用Quote::net_price() // 当item是Bulk_quote类型时调用Bulk_quote::net_price() cout&lt;&lt;&quot;isbn: &quot;&lt;&lt;item.isbn() &lt;&lt;&quot; sold: &quot;&lt;&lt;n&lt;&lt;&quot; total due: &quot;&lt;&lt;ret&lt;&lt;endl; return ret;&#125; 15.2 定义基类和派生类15.2.1 定义基类 基类通常都会定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。 任何构造函数之外的非静态函数，都可以是虚构函数 virtul只能出现在类内的声明语句之前，而不能用于类外部的函数定义 15.2.2 定义派生类 继承列表中，访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见。 如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。此外，我们能将公有派生类型的对象绑定到基类的引用或指针上。因为我们在派生列表中使用了public，所以 Bulk_quote的接口隐式地包含 isbn 函数，同时在任何需要 Quote的引用或指针的地方我们都能使用Bulkquote的对象。 派生类中的虚函数 覆盖虚函数：如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员,派生类会直接继承其在基类中的版本。 override的位置：写在声明语句最后。 在形参列表后面、或者在const成员函数的 const 关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字override。 派生类对象及派生类向基类的类型转换 因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上 1234567Quote item; // 基类对象Bulk_quote bulk; // 子类对象Quote *p = &amp;item; // p指向Quote对象p = &amp;bulk; // p指向bulk的Quote部分Quote &amp;r = bulk; // p绑定到bulk的Quote部分// 以上两个转换被称为 派生类到基类的转换 --&gt; 继承的关键所在 这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方;同样的，我们也可以把派生类对象的指针用在需要基类指针的地方。 在派生类中构造基类 每个类控制它自己的成员初始化过程 尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。 123456789class Bulk_quote : public Quote&#123;public: Bulk_quote(const std::string&amp; book, double p, std::size_t qty, double disc) :Quote(book, p) /* 通过初始化列表将实参传递给基类构造函数,否则基类部分会执行默认初始化 */ , min_qty(qty), discount(disc)&#123;&#125; private: std::size_t min_qty; double discount;&#125;; 在派生类中使用基类成员 对于派生类，访问自己的成员和访问基类成员的方式一样。 派生类的作用域嵌套在基类的作用域之内。因此，对于派生类的一个成员来说，它使用派生类成员的方式与使用基类成员的方式没什么不同。 然而，即使访问方式一样，也不能直接初始化基类的成员。 必须明确一点:每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。 因此，派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。 继承与静态成员 :question: 派生类的声明 派生类的声明中包含类名但不得包含其派生列表。 派生列表及与定义有关的其他细节必须与类的主题一起出现。 示例 12class Bulk_quote : public Quote; // 错误，派生列表不能出现在这里class Bulk_quote; // 正确，声明派生类的正确方式 被用作基类的类 如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。 – &gt; 一个类不能派生其本身 示例 12class Quote; // 声明但未定义class Bulk_quote : public Quote&#123;&#125;; // 错误，必须被定义Quote 防止继承的发生 在类名后面加final，以阻止继承 在函数后面加final，任何尝试覆盖该函数的操作都将引发错误。 1234567struct D2:B&#123; void f1(int) const final;&#125;;struct D3 :D2&#123; void f2(); void f1(int) const; //错误，D2已经声明为final&#125;; 15.2.3 类型转换与继承派生类 –&gt; 基类的隐式转换 我们可以将基类的指针或引用绑定到派生类对象上。 当使用基类的**引用(或指针)**时，实际上我们并不清楚该引用(或指针)所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象（动态类型）。 区分静态类型和动态类型 静态类型：字面上要求的类型 动态类型：多态、动态绑定的类型 如果表达式既不是引用也不是指针，则其动态类型 &#x3D;&#x3D; 静态类型。 但是不存在 基类 –&gt; 派生类的隐式转换 因为 这样有可能会访问 基类中本不存在的对象 12Quote base;Bulk_quote * bulkP = &amp;base; // 错误，不能将基类转化为派生类 即使一个基类指针或引用绑定在一个派生类对象上，也不能执行基类向派生类的转换。 123Bulk_quote bulk;Quote *itemP = &amp;bulk; // 正确，动态类型是Bulk_quoteBulk_qoute *bulk = itemP; // 错误，不能将基类转换成派生类（除非使用强制转换static_cast） 对象之间不存在类型转换（能转换，但是会丢失派生类中，基类没有的数据） 具体表述：派生类向基类的自动类型转换只对指针或引用有效，在派生类类型和基类类型之间不存在这样的转换。 原因：当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生部分被忽略掉（切掉）了。 123Bulk_quote bulk;Quote item(bulk); // 使用Quote::Quote(const Quote&amp;)，只能构造派生类中的基类部分item = bulk; // 使用Quote::operator=(const Quote&amp;),只能处理基类中自己的成员 15.3 虚函数 我们必须为每一个虚函数提供定义，而不管他是否被用到 对虚函数的调用可能在运行时才会被解析 动态绑定只有当我们通过指针或引用调用虚函数时才会发生 当通过普通类型（非指针非引用）的表达式调用虚函数，不会发生动态绑定，只会运行静态类型的函数 note 派生类中的虚函数 也是虚函数 函数类型与基类一致（返回值类型、形参类型）。但是有一个例外情况： final和override说明符 使用override标记了某个函数，但该函数并没有覆盖已经存在的虚函数，编译器将报错 在类名后面加final，以阻止继承 在函数后面加final，任何尝试覆盖该函数的操作都将引发错误 虚函数和默认实参 如果虚函数使用了默认实参，则基类和派生类中定义的默认实参最好一致。 和其他函数一样，虚函数也可以拥有默认实参(参见6.5.1节，第211页)。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。 换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。如果派生类函数依赖不同的实参，则程序结果将与我们的预期不符。 回避虚函数机制 在某些情况下，希望虚函数的调用不要动态绑定： 1double undiscounted = baseP-&gt;Quote::net_price(42); // &#x27;Quote::&#x27;指明调用Quote的net_price(),而不管baseP的动态类型到底是什么 什么情况下使用呢？通常是 当一个派生类的虚函数 调用 它覆盖的基类的虚函数版本 时。如果没有作用域运算符，将会被解析为派生类自身的调用，将导致无限递归。 15.4 抽象基类 一个纯虚函数无须定义，在结尾处加上=0 含有纯虚函数的类是抽象基类 不能创建抽象基类的对象 不重写纯虚函数的派生类也是抽象基类 派生类构造函数只能初始化它的直接基类 12345678910111213141516171819class Disc : public Quote&#123;public: Disc() = default; Disc(const string &amp;book, double price, size_t qty, double disc) :Quote(book, price), quantity(qty), discount(disc)&#123;&#125; double net_price(size_t) const = 0; protected: size_t quantity = 0; double discount = 0.0;&#125;;class Bulk_quote : public Disc&#123; Bulk_quote() = default; Bulk_quote(const string &amp;book, double price, size_t qty, double disc) :Disc(book, price, qty, disc)&#123;&#125; // &lt;-- 初始化它的直接基类,而不是初始化Quote double net_price(size_t) const override;&#125;; 15.5 访问控制与继承15.6 继承中的类作用域15.7 构造函数和拷贝控制15.8 容器和继承16 模板与泛型编程------高级主题------","tags":["c++","读书笔记"],"categories":["读书笔记","C++ Primer"]},{"title":"git基本操作","path":"/2024/01/03/git基本操作/","content":"目录 基本配置 建立本地仓库 推送到远程仓库 1 基本配置1.1 配置基本信息12git config --global user.name “itcast”git config --global user.email “hello@itcast.cn” 1.2 查看配置信息12git config --global user.namegit config --globa user.email 1.3 设置常用指令别名 打开用户目录，创建 .bashrc 文件 部分windows系统不允许用户创建点号开头的文件，可以打开gitBash,执行 touch ~/.bashrc 在 .bashrc 文件中输入如下内容： 1234#用于输出git提交日志 alias git-log=&#x27;git log --pretty=oneline --all --graph --abbrev-commit&#x27; #用于输出当前目录所有文件及基本信息 alias ll=&#x27;ls -al&#x27; 打开gitBash，执行 source ~/.bashrc 1.4 解决GitBash乱码问题 打开GitBash执行下面命令 1git config --global core.quotepath false $&#123;git_home&#125;/etc/bash.bashrc 文件最后加入下面两行 12export LANG=&quot;zh_CN.UTF-8&quot; export LC_ALL=&quot;zh_CN.UTF-8&quot; 2 建立本地仓库2.1 基本步骤 git init (初始化) git add 单个文件名或git add . (工作区 –&gt; 暂存区) git commit -m &#39;注释内容&#39; (暂存区 –&gt; 本地仓库) 2.2 版本控制 git status (查看的修改的状态（暂存区、工作区）) git-log (查看日志) git log [option] （查看日志） options all 显示所有分支 pretty&#x3D;oneline 将提交信息显示为一行 abbrev-commit 使得输出的commitId更简短 graph 以图的形式显示 git reset --hard commitID (版本回退，commitID可使用git-log查看) git reflog (查看已经删除的提交记录) 根目录创建 .gitignore 文件 添加文件至忽略列表 123456789101112# no .a files *.a # but do track lib.a, even though you&#x27;re ignoring .a files above !lib.a # only ignore the TODO file in the current directory, not subdir/TODO /TODO # ignore all files in the build/ directory build/ # ignore doc/notes.txt, but not doc/server/arch.txt doc/*.txt # ignore all .pdf files in the doc/ directory doc/**/*.pdf 2.3 分支 git branch 分支名 (创建分支) git checkout 分支名 (切换到分支) git checkout -b 分支名 （创建并切换分支） git merge 分支名 (合并分支，前提是已经git checkout master) 如果有冲突，手动解决冲突. git branch -d 分支名 （删除分支） git branch -D 分支名 (强制删除分支) 3 Git远程仓库3.1 Gitee 生成SSH公钥 ssh-keygen -t rsa 不断回车 获取公钥 cat ~/.ssh/id_rsa.pub 配置公钥 验证是否配置成功 ssh -T git@gitee.com 添加远端仓库 git remote add origin git@gitee.com:...... 查看远程仓库 git remote 推送到远程仓库 git push --set-upstream origin master （–set-upstream 建立本地与远端的联系(首次)） git push (非首次) 查看本地分支与远程分支的关联关系 git branch -vv 克隆 git clone &lt;仓库路径&gt; [本地目录] (仓库路径使用SSH地址) 抓取：将仓库里的更新都抓取到本地，但不合并 git fetch [remote name] [branch name] 拉取：将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge git pull [remote name] [branch name] fetch和pull 如果不指定远端名称和分支名，则抓取所有并更新当前分支 在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要推送到远程仓库，此时B用户晚于A用户，故需要先拉取远程仓库的提交，经过合并后才能推送到远端分支。 3.2 GitHub配置ssh密钥的方法：https://www.cnblogs.com/Maurice-code/p/10531303.html git clone 出现fatal: unable to access ‘https://github.com 的解决方法：将命令行的https改为git即可. [参考连接][1] 黑马程序员Git教程[2] Github文档[3] 最好的git教程: Learn Git Branching","tags":["git"],"categories":["随笔","git"]},{"title":"hoxe+github建站笔记","path":"/2024/01/02/hexo+github建站笔记/","content":"1.前言在ubuntu上利用hexo+github建站网上有很多博文，但是由于时效原因，24年1月2日配置的时候遇到一些问题。遂本文对于细节不提而用步骤带过，主要汇总一下利用hexo中文官网文档安装遇到的问题，需要有一丢丢linux基础。 2.开胃菜 安装 Hexo 相当简单，只需要先安装下列应用程序即可： Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本) Git 2.1安装git1sudo apt install git 2.2安装node.js 摘自 NodeSource Download and import the Nodesource GPG key 1234sudo apt-get updatesudo apt-get install -y ca-certificates curl gnupgsudo mkdir -p /etc/apt/keyringscurl -fsSL https://deb.nodesource.com/gpgkey/nodesource-repo.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/nodesource.gpg Create deb repository 12NODE_MAJOR=20echo &quot;deb [signed-by=/etc/apt/keyrings/nodesource.gpg] https://deb.nodesource.com/node_$NODE_MAJOR.x nodistro main&quot; | sudo tee /etc/apt/sources.list.d/nodesource.list Optional: NODE_MAJOR can be changed depending on the version you need. （可选项）：选择node.js版本 1234NODE_MAJOR=16NODE_MAJOR=18NODE_MAJOR=20NODE_MAJOR=21 Run Update and Install 12sudo apt-get updatesudo apt-get install nodejs -y 3.正餐3.1安装hexo1npm install -g hexo-cli 3.2初始化1234hexo init &lt;folder&gt;cd &lt;folder&gt;npm installhexo g # 生成静态文件，即public文件夹 此刻，在指定文件夹下生成了网站目录如下，对各目录的解释见hexo文档 . 建站和Hexo搭建个人博客——系列教程。 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 3.3本地验证运行下面代码后，命令行中提示的网址，在本地查看网站 1hexo server # 或者 hexo s 4.github部署4.1github端 建立名为 &lt;你的 GitHub 用户名&gt;.github.io 的储存库 参考我的Git基本操作笔记第三节1~4点，gitee改成github 参考http://t.csdnimg.cn/X3vjf ，获得person access token github右上角头像 - &gt; settings 左侧菜单栏，滑到最下面，选择Developer settings 左侧菜单栏，选择personal access tokens -&gt; tokens(classic) -&gt; Generate new token -&gt; Generate new token(classic) expiration可选无限（no expiration） 下面的方框全选 点generate token 保存好生成的token，据说以后查不到了 4.2本地端 安装 hexo-deployer-git如下， 1npm install hexo-deployer-git --save 在 _config.yml 中添加以下配置（如果配置已经存在，请将其替换为如下）: 12345deploy: type: git repo: # 复制仓库的ssh # 如我的是，git@github.com:Hezexian/hezexian.github.io.git branch: gh-pages 执行 hexo clean &amp;&amp; hexo deploy 这一步会让你输入github名字密码，其中密码是4.1节生成的token 执行完这一步，hexo文档被同步至github 浏览&lt;你的 GitHub 用户名&gt;.github.io 第三步执行完需要等一会儿网站才能打开，别心急 :) 5.更新文章法1：将xxx.md文件添加进source&#x2F;_posts中 注意md文件写标头，参考：写作，Front-matter 123456789---title: hexo+github建站笔记date: 2024/1/2 19:29categories: - 啥都会一点tags:- hexo- 博客--- 接着在hexo目录中 12345678# 清除缓存hexo clean # 生成public，静态网页hexo g # 推送 githubhexo d 法2：12# 三种布局 post、page 和 drafthexo new [layout] &lt;title&gt; 问题butterfly主题分类、归档404按照官方文档的说法: 前往你的 Hexo 博客的根目錄 輸入 hexo new page categories 你會找到 source/categories/index.md 這個文件 修改這個文件： 記得添加 type: &quot;categories&quot;, 如下。 12345---title: 分類date: 2018-01-05 00:00:00type: &quot;categories&quot;--- 还是不行，原来是包没有安装：npm list对比 12345678910111213├── hexo-deployer-git@3.0.0├── hexo-generator-archive@2.0.0├── hexo-generator-category@2.0.0├── hexo-generator-index@3.0.0├── hexo-generator-tag@2.0.0├── hexo-math@4.0.0├── hexo-renderer-ejs@2.0.0├── hexo-renderer-marked@6.0.0├── hexo-renderer-pug@3.0.0├── hexo-renderer-stylus@2.1.0├── hexo-server@3.0.0├── hexo-theme-landscape@0.0.3└── hexo@6.3.0 安装： 12npm install hexo-generator-category --savenpm install hexo-generator-archive --save","tags":["环境配置","hexo","博客"],"categories":["随笔","hexo"]},{"title":"相机旋转矩阵相关","path":"/2023/12/26/旋转矩阵/","content":"综述 写论文时一些旋转矩阵的问题没有搞懂，问了问chat gpt，将其回答记录如下。 插件问题导致第一次加载网页时，公式没法正常显示，刷新一下即可。 旋转矩阵简述旋转矩阵是一个3x3的矩阵，通常表示三维空间中的旋转变换。其9个元素分别代表了旋转矩阵的三列向量。具体而言，假设旋转矩阵为： $$R &#x3D; \\begin{bmatrix}r_{11} &amp; r_{12} &amp; r_{13} \\r_{21} &amp; r_{22} &amp; r_{23} \\r_{31} &amp; r_{32} &amp; r_{33}\\end{bmatrix}$$ 其中，$r_{ij}$表示矩阵中第i行第j列的元素。这些元素可以按列或按行解释，一般来说： 第一列 $(r_{11},r_{21},r_{31})$表示X轴的旋转方向； 第二列$(r_{12}, r_{22}, r_{32})$表示Y轴的旋转方向； 第三列$(r_{13}, r_{23}, r_{33})$表示Z轴的旋转方向。 这样，每一列就代表了旋转后X、Y、Z轴在原坐标系中的方向。这也意味着，一个向量在经过该旋转矩阵变换后，其坐标将由原来的坐标系变换到新的坐标系。 旋转矩阵如何作用于物体绕x轴旋转角度为$\\theta$的旋转矩阵可以表示为：$$R_x(\\theta) &#x3D; \\begin{bmatrix}1 &amp; 0 &amp; 0 \\0 &amp; \\cos(\\theta) &amp; -\\sin(\\theta) \\0 &amp; \\sin(\\theta) &amp; \\cos(\\theta)\\end{bmatrix}$$ 绕y轴旋转角度为$\\theta$的旋转矩阵可以表示为：$$R_y(\\theta) &#x3D; \\begin{bmatrix}\\cos(\\theta) &amp; 0 &amp; \\sin(\\theta) \\0 &amp; 1 &amp; 0 \\-\\sin(\\theta) &amp; 0 &amp; \\cos(\\theta)\\end{bmatrix}$$ 绕z轴旋转角度为$\\theta$的旋转矩阵可以表示为：$$R_z(\\theta) &#x3D; \\begin{bmatrix}\\cos(\\theta) &amp; -\\sin(\\theta) &amp; 0 \\\\sin(\\theta) &amp; \\cos(\\theta) &amp; 0 \\0 &amp; 0 &amp; 1\\end{bmatrix}$$ 则，绕xyz轴旋转角度为$\\theta$的旋转矩阵可以表示为：$$R_{xyz}(\\theta) &#x3D; R_x(\\alpha) \\cdot R_y(\\beta) \\cdot R_z(\\gamma)$$ 其中，$\\alpha$、$\\beta$和$\\gamma$分别表示绕x、y和z轴旋转的角度。$R_x(\\alpha)$、$R_y(\\beta)$和$R_z(\\gamma)$分别是绕x、y和z轴旋转角度为$\\alpha$、$\\beta$和$\\gamma$的旋转矩阵。具体的计算步骤如下： 计算绕x轴旋转角度为$\\alpha$的旋转矩阵$R_x(\\alpha)$。 计算绕y轴旋转角度为$\\beta$的旋转矩阵$R_y(\\beta)$。 计算绕z轴旋转角度为$\\gamma$的旋转矩阵$R_z(\\gamma)$。 将三个旋转矩阵按照顺序相乘，得到绕xyz轴旋转角度为$\\theta$的旋转矩阵$R_{xyz}(\\theta)$。 请注意，这里的旋转顺序是先绕x轴、再绕y轴、最后绕z轴。如果旋转顺序不同，得到的旋转矩阵也会不同。 例如，当绕z轴旋转$\\theta &#x3D; 45^\\circ$时，旋转矩阵为：$$R_z(45^\\circ) &#x3D; \\begin{bmatrix}\\cos(45^\\circ) &amp; -\\sin(45^\\circ) &amp; 0 \\\\sin(45^\\circ) &amp; \\cos(45^\\circ) &amp; 0 \\0 &amp; 0 &amp; 1\\end{bmatrix} &#x3D; \\begin{bmatrix}\\frac{\\sqrt{2}}{2} &amp; -\\frac{\\sqrt{2}}{2} &amp; 0 \\\\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2} &amp; 0 \\0 &amp; 0 &amp; 1\\end{bmatrix}$$ 比较两个旋转矩阵之间的差异比较两个旋转矩阵之间的差异大小通常使用矩阵之间的距离或相似度来衡量。以下是一些常用的方法： Frobenius范数：计算两个矩阵之间的Frobenius范数，即矩阵元素差的平方和的平方根。假设A和B是两个$n \\times n$的矩阵，则它们之间的Frobenius距离为： $$||A - B||F &#x3D; \\sqrt{\\sum{i&#x3D;1}^{n}\\sum_{j&#x3D;1}^{n} |A_{ij} - B_{ij}|^2}$$ 旋转矩阵的距离度量：针对旋转矩阵，可以使用专门的距离度量，如旋转矩阵之间的角度差或扭曲度等。 相似性度量：除了距离度量外，也可以使用相似性度量来比较两个旋转矩阵。常见的相似性度量包括相关系数、余弦相似度等。 特征值分解：对两个矩阵进行特征值分解，然后比较它们的特征值和特征向量，以评估它们之间的差异。选择适当的方法取决于你对差异的具体定义和应用场景。 要计算两个旋转矩阵之间的余弦相似度，可以使用以下步骤： 将两个旋转矩阵表示为四元数或旋转向量的形式。四元数和旋转向量是旋转矩阵的紧凑表示形式，便于计算相似度。 将四元数或旋转向量归一化，以确保它们表示的旋转是单位旋转。 使用内积公式计算两个归一化后的四元数或旋转向量之间的余弦相似度。对于四元数表示，余弦相似度计算公式为： $$\\text{similarity} &#x3D; \\frac{q_1 \\cdot q_2}{|q_1| \\cdot |q_2|}$$ 其中$q_1$和$q_2$分别是两个归一化后的四元数。对于旋转向量表示，余弦相似度计算公式为： $$\\text{similarity} &#x3D; \\frac{r_1 \\cdot r_2}{|r_1| \\cdot |r_2|}$$ 其中$r_1$和$r_2$分别是两个归一化后的旋转向量。 这样，通过计算归一化后的四元数或旋转向量之间的余弦相似度，可以得到两个旋转矩阵之间的相似度度量。余弦相似度的取值范围为[-1, 1]，值越接近1表示相似度越高，值越接近-1表示相似度越低。 在Python中，你可以使用NumPy库来进行旋转矩阵的计算和相似度度量。以下是一个简单的示例代码，演示如何计算两个旋转矩阵之间的余弦相似度： 12345678910111213141516import numpy as np# 定义两个旋转矩阵R1 = np.array([[1, 0, 0], [0, 0, -1], [0, 1, 0]])R2 = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0]])# 计算旋转矩阵的转置R1_T = R1.T# 计算旋转矩阵的Frobenius范数frobenius_norm = np.linalg.norm(R1 - R2, &#x27;fro&#x27;)# 计算旋转矩阵的余弦相似度cosine_similarity = np.sum(R1 * R2) / (np.linalg.norm(R1) * np.linalg.norm(R2))print(&quot;Frobenius范数:&quot;, frobenius_norm)print(&quot;余弦相似度:&quot;, cosine_similarity) 在这个示例中，我们首先定义了两个3x3的旋转矩阵R1和R2。接着，我们计算了它们之间的Frobenius范数和余弦相似度。你可以使用这个代码作为起点，根据你的具体需求来计算任意两个旋转矩阵之间的余弦相似度。 余弦相似度的取值范围应该是[-1, 1]，其中1表示完全相似，-1表示完全不相似。如果计算得到的余弦相似度为负数，这可能是由于计算过程中的舍入误差或错误导致的。在实际应用中，余弦相似度通常不会为负数。如果你计算得到的余弦相似度为负数，你可以检查计算过程中是否存在错误，例如矩阵的归一化错误、向量的方向错误等。另外，确保计算中使用的向量或矩阵是正确的，并且在计算余弦相似度之前，进行了正确的预处理，例如归一化。 r12,r22,r32比较稳定说明什么$r_{12}$、$r_{22}$、$r_{32}$是旋转矩阵的第二列，分别表示旋转后Y轴在原坐标系中的方向。这三个元素的稳定性指的是它们在旋转矩阵中的变化相对较小，或者说在不同的旋转中变化不明显。如果$r_{12}$、$r_{22}$、$r_{32}$比较稳定，说明在旋转变换中，Y轴的方向相对较为稳定，即旋转主要发生在其他轴上。这可能表示物体主要围绕X轴或Z轴旋转，而Y轴的方向相对不变。在某些应用中，对于特定的物体运动或场景，这种稳定性可能具有特殊的意义。例如，在飞行器的姿态控制中，如果Y轴方向保持稳定，可能表示飞行器在水平方向上的姿态较为稳定。总体而言，$r_{12}$、$r_{22}$、$r_{32}$的稳定性可以提供关于旋转矩阵和物体运动的一些信息，但具体解释还需要考虑特定情境和应用。 参考文献[1]三维坐标系旋转——旋转矩阵到旋转角之间的换算.https://blog.csdn.net/c20081052/article/details/89479970","tags":["视觉slam","计算机视觉"],"categories":["随笔","视觉slam"]},{"title":"cmake包含vslam常用库","path":"/2023/04/26/cmake包含vslam常用库/","content":"1234567891011121314151617181920212223242526272829303132333435363738394041cmake_minimum_required(VERSION 3.20)project(6)set(CMAKE_CXX_STANDARD 23) # OpenCVfind_package(OpenCV REQUIRED)include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;) # Eigenfind_package(Eigen3 REQUIRED)include_directories($&#123;EIGEN3_INCLUDE_DIR&#125;) # Pangolinfind_package(Pangolin REQUIRED)include_directories($&#123;Pangolin_INCLUDE_DIRS&#125;) # Sophusfind_package(Sophus REQUIRED)include_directories($&#123;Sophus_INCLUDE_DIRS&#125;) # fmtfind_package(fmt REQUIRED)include_directories($&#123;FMT_DIR&#125;/include) # Ceresfind_package(Ceres REQUIRED)include_directories($&#123;CERES_INCLUDE_DIRS&#125;) # g2ofind_package(g2o REQUIRED)include_directories($&#123;G2O_INCLUDE_DIRS&#125;) add_executable(gaussNewton gaussNewton.cpp)target_link_libraries(gaussNewton $&#123;OpenCV_LIBS&#125; Eigen3::Eigen $&#123;Pangolin_LIBRARIES&#125; Sophus::Sophus fmt::fmt $&#123;CERES_LIBRARIES&#125; g2o::core g2o::stuff)","tags":["视觉slam","c++","cmake"],"categories":["随笔","视觉slam"]},{"title":"cmake+mingw32+win11+clion编译OpenCV4.5+contrib","path":"/2022/06/09/cmake+mingw32+win11+clion编译OpenCV4.5+contrib/","content":"step1 准备必要环境注意：以下软件的安装路径中不要有中文或空格！(尤其是mingw32) 安装cmake(不要安装最新的CMake,最好差3个版本以下)添加到环境变量： 默认安装环境： 安装mingw32：在mingw32下载处下载x86_64-posix-seh版本;将bin文件夹路径添加至环境变量，cmd中输入g++ --version查看是否成功 安装python3: 123#pip install boost(3.10.5出错)pip install cmakepip install dlib 安装visual studio step2 下载opencv下载地址：opencv 下载sources;contrib 将contrib文件夹移动到opencv文件夹下 在opencv文件夹中新建build文件夹 step3 第一次编译 注意网络问题(只可意会不可言传) 打开cmake gui where is the sources code:填写opencv路径 where to build the binarise:填写自己创建的build的地址 按钮：configure-&gt;在弹出的窗口中选择mingw makefiles-&gt;use default native compilers step4 第二次编译 add entry-&gt;name:ENABLE_CXX11; type:BOOL; value:打上对勾 OPENCV_ENABLE_ALLOCATOR_STATS 取消对勾 OPENCV_EXTRA_MODULES_PATH:填写contrib&#x2F;modules的路径 modules&#x2F;videoio&#x2F;src&#x2F;cap_dshow.cpp中， 123#define NO_DSHOW_STRSAFE#if defined _WIN32 &amp;&amp; define HAVE_DSHOW#include &quot;cap_dshow.hpp&quot; 按钮：configure + generate step5 进入build文件夹1234cmd&gt;&gt; cd build文件夹路径&gt;&gt; mingw32-make&gt;&gt; mingw32-make install step6 将编译好的opencv添加进环境变量 name：OpenCV_DIR value：build文件夹下的install文件夹的路径 path 新建：%OpenCV_DIR%\\x64\\mingw\\bin step7 在clion中测试cmake文件 1234567cmake_minimum_required(VERSION 3.17)project(1_demo)set(CMAKE_CXX_STANDARD 11)find_package(OpenCV REQUIRED)include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)add_executable(main main.cpp)target_link_libraries(main $&#123;OpenCV_LIBS&#125;) cpp文件 1234567#include &quot;opencv2/opencv.hpp&quot;using namespace cv;int main() &#123;Mat img = imread(&quot;1.jpg&quot;); //绝对路径imshow(&quot;1&quot;, img);waitKey(0);&#125;","tags":["opencv","视觉slam","环境配置"],"categories":["随笔","opencv"]},{"title":"孙鑫VC++深入详解","path":"/2021/06/01/孙鑫VC++深入详解/","content":"第一章 Windows程序内部运行机制1.1 API和SDK API:Windows操作系统提供给应用程序编程的接口。 SDK（软件开发包）:用于开发的所有资源的集合。 1.2 窗口和句柄 窗口 句柄：系统在创建资源时会为他们分配内存，并返回这些资源的标识号，即句柄。(类似于指针）窗口句柄(HWND)、图标(HICON)、光标(HCURSOR)、画刷(HBRUSH) 1.3 消息和队列消息（先进先出） 12345678typedef struct tagMSG &#123; HWND hwnd; //HWND:窗口变量，hwnd:消息所属的窗口 UINT message; //message消息标识符，数值定义为WM_XXX (P4) WPARAM wParam; LPARAM lParam; //指定消息的附加信息，ASCII等 DWORD time; //消息投递到消息队列中的时间 POINT pt; //当前鼠标的位置&#125; MSG, *PMSG; 1.4 WinMain Win32实现的步骤 定义WinMain函数； 创建窗口； 消息循环； 窗口过程函数。 1.4.1 WinMain函数的定义winmain函数是程序入口函数，由系统调用。 123456int WINAPI WinMain( HINSTANCE hInstance, // handle to current instance HINSTANCE hPrevInstance, // handle to previous instance，always NULL in Win32 LPSTR lpCmdLine, // 空终止的字符串，指定传递给应用程序的命令行参数 int nCmdShow // 指定窗口应该如何显示 ); 1.4.2 窗口的创建 步骤 设计窗口类； 注册窗口； 创建窗口； 显示及更新窗口； 1.4.2.1 设计窗口类12345678910111213141516typedef struct _WNDCLASS //窗口类&#123; UINT style; /*（P7知识点方框）窗口样式； CS_XXX(都只有一位是1，且1位各不相同：位标志)； 多种特点组合用（|）号； 去掉style中的样式用（&amp;~）*/ WNDPROC lpfnWndProc; //指向回调函数的指针；在特定的事件发生时，用于对该事件的响应 int cbClsExtra; int cbWndExtra; //cbClsExtra和cbWndExtra两个附加内存，一般都为0 HINSTANCE hInstance; //实例句柄 HICON hIcon; //图标句柄；HICON LoadIcon(HINSTANCE hInstance, LPCTSTR lpIconName); HCURSOR hCursor; //光标句柄；HCURSOR LoadCursor(HINSTANCE hInstance,LPCTSTR lpCursorName); HBRUSH hbrBackground; //画刷句柄，背景颜色；wndcls.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH); LPCTSTR lpszMenuName; //菜单名字，NULL LPCTSTR lpszClassName; //类名，和创建窗口CreateWindow函数中的lpClassName一致&#125; WNDCLASS, *PWNDCLASS; 1.4.2.2 注册窗口1ATOM RegisterClass( CONST WNDCLASS *lpWndClass ); // 注册窗口 1.4.2.3 创建窗口1234567891011121314151617HWND CreateWindow( LPCTSTR lpClassName, // registered class name，与窗口类WNDCLASS中的lpszClassName一致 LPCTSTR lpWindowName, // window name， DWORD dwStyle, /*window style；和WNDCLASS中的style不同，style是指定具体窗口的样式，dwstyle是窗口都具有的样式 常用WS_OVERLAPPEDWINDOW*/ int x, // horizontal position of window int y, // vertical position of window int nWidth, // window width int nHeight, // window height; /*如果x设为CW_USEDEFAULT,系统为窗口选择左上角并忽略y; nWidth设为CW_USEDEFAULT，系统为默认大小并忽略nHeight。 窗口之间的父子关系，子窗口必须有WS_CHILD*/ HWND hWndParent, // handle to parent or owner window（父窗口句柄）；NULL HMENU hMenu, // menu handle or child identifier;NULL HINSTANCE hInstance, // handle to application instance;hInstance LPVOID lpParam // window-creation data;NULL); 注意：创建窗口成功，函数返回系统为该窗口分配的句柄，否则返回NULL。创建窗口之前应先定义一个窗口句柄变量来接收创建窗口之后返回的句柄值。 1.4.2.4 显示及更新窗口显示窗口 1234BOOL ShowWindow( HWND hWnd, // 哪一个窗口？ int nCmdShow // 如何显示？；常用SW_SHOWNORMAL); 更新窗口 123BOOL UpdateWindow( HWND hWnd // handle to window); 1.4.3 消息循环123456BOOL GetMessage( LPMSG lpMsg, // 指向一个消息结构体MSG，GetMessage取出的消息放入该结构体对象中 HWND hWnd, // handle to window，设为NULL接收所用窗口 UINT wMsgFilterMin, // first message UINT wMsgFilterMax // last message；范围过滤，获得所有消息则设为0); 注意：GetMessage函数除了接收到WM_QUIT（退出消息）外都返回非零值，出错返回-1。 通常编写的消息循环代码如下： 123456MSG msg;//声明消息结构体变量while(GetMessage(&amp;msg,NULL,0,0))//没接收到WM_QUIT时一致循环&#123; TranslateMessage(&amp;msg);//将WM_KEYDOWN和WM_KEYUP转化为WM_CHAR,不修改原消息 DispatchMessage(&amp;msg);//将消息发送至操作系统，后者用窗口过程函数对消息响应； Dispatch：派遣&#125; 1.4.2窗口创建和1.4.3消息循环都包含在WinMain函数体内 1.4.4 窗口过程函数即回调函数 123456LRESULT CALLBACK WindowProc( HWND hwnd, // 窗口句柄 UINT uMsg, // 消息代码 WPARAM wParam, // first message parameter LPARAM lParam // second message parameter); 过程函数名WindowProc可以换，但要和声明保持一致。 使用switch&#x2F;case来对不同消息作出不同反应。 如下方例子中的过程函数所示。 课后程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#define _CRT_SECURE_NO_DEPRECATE#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;stdexcept&gt;/*******************函数声明****************************/LRESULT CALLBACK WinSunProc( HWND hwnd, // handle to window UINT uMsg, // message identifier WPARAM wParam, // first message parameter LPARAM lParam // second message parameter);/*******************WinMain函数*************************/int WINAPI WinMain( HINSTANCE hInstance, // handle to current instance HINSTANCE hPrevInstance, // handle to previous instance LPSTR lpCmdLine, // command line int nCmdShow // show state)&#123; /*设计一个窗口类*/ WNDCLASS wndcls; wndcls.cbClsExtra = 0; wndcls.cbWndExtra = 0; wndcls.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH); wndcls.hCursor = LoadCursor(NULL, IDC_CROSS); wndcls.hIcon = LoadIcon(NULL, IDI_ERROR); wndcls.hInstance = hInstance; wndcls.lpfnWndProc = WinSunProc; wndcls.lpszClassName=&quot;hezexian2021&quot;; wndcls.lpszMenuName = NULL; wndcls.style = CS_HREDRAW | CS_VREDRAW; RegisterClass(&amp;wndcls); /*创建窗口*/ HWND hwnd; hwnd = CreateWindow(&quot;hezexian2021&quot;, &quot;He Zexian&#x27;s home.&quot;, WS_OVERLAPPEDWINDOW, 0, 0, 600, 400, NULL, NULL, hInstance, NULL); /*显示及刷新窗口*/ ShowWindow(hwnd, SW_SHOWNORMAL); UpdateWindow(hwnd); /*消息循环*/ MSG msg; while (GetMessage(&amp;msg, NULL, 0, 0)) &#123; TranslateMessage(&amp;msg);//将WM_KEYDOWN和WM_KEYUP转化为WM_CHAR,不修改原消息 DispatchMessage(&amp;msg);//将消息发送至操作系统，后者用窗口过程函数对消息响应 &#125; return msg.wParam;&#125;/*******************窗口过程函数*************************/LRESULT CALLBACK WinSunProc( HWND hwnd, // handle to window UINT uMsg, // message identifier WPARAM wParam, // first message parameter LPARAM lParam // second message parameter)&#123; switch (uMsg) &#123; case WM_CHAR: char szChar[20]; sprintf(szChar, &quot;char code is %d&quot;, wParam); MessageBox(hwnd, szChar, &quot;char&quot;, 0); break; case WM_LBUTTONDOWN: MessageBox(hwnd, &quot;mouse clicked&quot;, &quot;message&quot;, 0); HDC hdc; //要在窗口中输出文字或显示图形，要用到设备描述表（DC）。DC是一个包含设备信息的结构体，所有的图形操作都是利用DC来完成。 //定义类型为HDC的变量hdc hdc = GetDC(hwnd); //GetDC返回与特定窗口相关联的DC句柄 TextOut(hdc, 0, 50, &quot;何泽贤之家&quot;,strlen(&quot;何泽贤之家&quot;)); ReleaseDC(hwnd, hdc); //在使用完GetDC后一定要注意释放 break; case WM_PAINT://窗口重绘 HDC hDC; PAINTSTRUCT ps; hDC = BeginPaint(hwnd, &amp;ps); TextOut(hDC, 0, 0, &quot;http://www.hezexian.org&quot;, strlen(&quot;http://www.hezexian.org&quot;)); EndPaint(hwnd, &amp;ps);//WM_PAINT、BeginPaint、EndPaint一起用，而不能用GetDC break; case WM_CLOSE://关闭消息 if (IDYES == MessageBox(hwnd, &quot;是否真的结束了？&quot;, &quot;message&quot;, MB_YESNO)) &#123; DestroyWindow(hwnd);//销毁窗口 &#125; break; //此时窗口销毁，但程序还在后台运行 case WM_DESTROY: PostQuitMessage(0);//在响应消息后,投递一个退出的消息使用程序安全退出 break; default: return DefWindowProc(hwnd, uMsg, wParam, lParam);//调用缺省的消息处理过程函数，对没有处理的其他消息以默认处理 &#125; return 0;&#125; 补充：1、如遇到cannot convert from ‘const char [7]’ to ‘LPCWSTR’的错误，请对工程进行字符设置菜单栏-&lt;项目-&lt;xxx 属性-&lt;配置属性-&lt;高级-&lt;字符集,改成“not set”或改成“Use Multi-Byte Character Set”。2、vs2019–Windows桌面应用程序 参考文献[1] VC深入详解 孙鑫 第一章 Windows程序内部运行机制 - focusahaha - 博客园 (cnblogs.com).https://www.cnblogs.com/focusahaha/p/12601081.html[2]孙鑫.VC深度详解修订版[M]. 北京:电子工业出版社, 2012. 1-26. 第二章 掌握C++2.1 从结构到类2.1.1 结构体的定义 C++相比于C的特性：封装性、继承性、多态性； 对象具有状态和行为，状态保存在成员变量中，行为通过函数实现； 标准输入输出流对象：cin（&gt;&gt;）默认键盘 和 cout（&lt;&lt;）、cerr（&lt;&lt;）默认显示器；自动根据数据类型调整输入输出格式； 结构体中的函数称为成员函数。 程序2.1 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std; //error C1083: 无法打开包括文件:“iostream.h”: No such file or directorystruct point&#123; int x, y; //状态 void output() //行为 &#123; cout &lt;&lt; &quot;x=&quot;&lt;&lt; x &lt;&lt; endl &lt;&lt; &quot;y=&quot; &lt;&lt; y &lt;&lt; endl;//endl是换行符 &#125;&#125;pt;//注意分号int main()&#123; cout &lt;&lt; &quot;请输入x和y的值：&quot; &lt;&lt; endl; cin &gt;&gt; pt.x; cin &gt;&gt; pt.y; pt.output(); //注意括号 return 0;&#125; 2.1.2 结构体与类在C++中，结构体（struct）和类（class）可以通用。区别在于访问控制的差异： struct默认访问控制标识符public；public：可以在类的外部进行访问 class默认访问控制标识符private；private：只能在类的内部进行访问 protective。 程序2.2：将程序2.1中的struct point修改为class point 123456789class point //类：抽象出一些事物共有的属性&#123;public: int x, y; void output() &#123; cout &lt;&lt; &quot;x=&quot;&lt;&lt; x &lt;&lt; endl &lt;&lt; &quot;y=&quot; &lt;&lt; y &lt;&lt; endl; &#125;&#125;pt; //实例化了一个对象==类的实例化：具有具体的属性值 2.2 C++的特性2.2.1 类与对象类：抽象出一些事物共有的属性；对象：有具体的属性值。 2.2.2 构造函数作用：在定义对象的同时，对成员变量进行初始化；创建对象本身（分配内存）规定：构造函数的名字和类名相同（唯一性）；没用返回值；可以有参数。注意： 如果一个类没有定义任何构造函数，那么C会提供一个默认的不带参构造函数。而只要类中定义了一个构造函数，C便不再提供任何其他构造函数； 每个类必须有一个构造函数，没有构造函数不能创建任何对象。构造函数如代码2.3所示。 2.2.3 析构函数~类名(); //对象生命周期结束，释放其占用资源；是一个对象最后调用的成员函数注意：析构函数不允许有返回值，更不允许有参数，并且一个类中只有一个构造函数。代码2.3：构造函数和析构函数 12345678910111213class point //类名：point&#123;public: int x , y; point() //构造函数 point() &#123; x = 0; //在类中定义成员变量时，不能直接给其赋值(如int x=0;)，而是在构造函数中赋值(P37提示) y = 0; &#125; ~point() //析构函数 ~point() &#123; &#125;&#125;; 2.2.4 函数的重载条件：函数参数类型、个数不同才能构成重载。注意： 只有函数的返回值类型不同，不能重载； 重载时，注意函数带有默认参数的情况。(P38) 对比覆盖：重载是发生在同一个类当中；覆盖是发生在父类和子类之间 代码2.4 函数的重载 1234567891011121314151617181920class point&#123;public: int x , y; point() //函数1 &#123; x = 0; y = 0; &#125; point(int a, int b) //重载，函数2 &#123; x = a; y = b; &#125; &#125;;void main()&#123; point pt(5,5); //C++根据参数类型和个数，执行函数2&#125; 2.2.5 this指针 this指针是一个隐含的指针，指向对象本身，代表对象的地址。 用法：当形参的变量名和成员变量的变量名冲突时，可用this-&gt;来区别对哪一个变量进行赋值。(P40) this-&gt;x是对成员变量进行赋值；x是对形参赋值。 2.2.6 类的继承2.2.6.1 继承例如：class fish : public animal&#123;&#125;; animal是父类，fish是子类。子类fish以public（公有）的方式继承父类animal。 子类除了自己的成员变量和成员方法外，还可以继承父类的成员变量和成员方法。 构造函数和析构函数的调用次序： 2.2.6.2 在子类中调用父类带参数的构造函数例如：父类构造函数： animal(int h , int w)&#123;&#125;则在构造子类时，应该显式地去调用父类的带参数构造函数： fish():animal(400,300)&#123;&#125; 2.2.6.3 类的继承及类中成员的访问特性3种访问权限修饰符：public：定义的成员可以在任何地方被访问；protected：定义的成员只能在该类及其子类中访问；private：定义的成员只能在该类自身中访问。&#x3D;&#x3D;&gt;不能被子类继承 3种继承方式： 2.2.6.4 多重继承定义形式：class B: public C , public D了解父类表顺序对调用构造函数和析构函数的影响。对于上面的例子，先构造C再构造D，先析构D再析构C。 2.2.7 虚函数与多态性、纯虚函数2.2.7.1虚函数与多态性**程序 2.5 ** 12345678910111213141516171819202122232425262728(P49)...class animal&#123;public: ... void breathe()&#123;cout&lt;&lt;&quot;animal breathe&quot;&lt;&lt;endl;&#125; /*注意此时不是虚函数*/&#125;;class fish : public animal&#123;public: ... void breathe()&#123;cout&lt;&lt;&quot;fish bubble&quot;&lt;&lt;endl;&#125;&#125;void breathetest(animal* pan)&#123; pan-&gt;breathe();&#125;void main()&#123; animal* pan; //指向animal类的指针pan fish fi; pan = &amp;fi; //将fish类的对象fi的地址直接赋给指向animal类的指针变量pan breathetest(pan);&#125;/*输出animal breathe*/ 1、fish对象也是一个animal类，C++自动进行类型转换；反之，不能把animal对象看成fish对象。 2、当我们将fish转化为animal时，该对象就会被认为是原对象内存模型的上半部分。 3、将父类函数修改为虚函数，输出结果为fish bubble。 1234(P49)... virtual void breathe() //虚函数 .../*输出fish bubble*/ 虚函数：用virtual关键字申明的函数–&gt;多态性；迟邦定：编译时并不确定具体调用的函数，而是在运行时依据对象的类型来确认调用的是哪一个函数。 概括(用法)：在父类的函数前加上virtual关键字，在子类重写该函数，运行时将会根据对象的实际类型来调用相应的函数。 2.2.7.2 纯虚函数 纯虚函数不被具体实现，是抽象类，不能实例化对象。 纯虚函数可以让类先具有一个操作名称，而没有操作内容，在子类继承时再去具体定义。 写法： 1virtual void breathe() = 0 ; //1、等于0；2、无函数体 注意：子类如果有对父类虚函数的覆盖定义，无论该覆盖定义是否有virtual，都是虚函数。 2.2.8函数的覆盖和隐藏2.2.8.1 覆盖1、覆盖(P52)：发生在父类和子类之间 的 函数完全一样（函数名、参数列表），编译器根据实际类型确定要调用的函数。2、对比重载：重载是发生在同一个类当中；覆盖是发生在父类和子类之间 程序2.6 函数的覆盖 123456789101112131415161718192021222324class animal&#123;public: virtual void breathe() &#123; cout&lt;&lt;&quot;animal breathe&quot;&lt;&lt;endl; &#125;&#125;;class fish : public animal&#123;public: void breathe() //覆盖 &#123; cout&lt;&lt;&quot;fish bubble&quot;&lt;&lt;endl; &#125;&#125;;void main()&#123; fish fi; fi.breathe();&#125;/*输出fish bubble*/ 2.2.8.2 隐藏两种父类函数隐藏的情况： 子类和父类函数完全相同（函数名、参数列表），但父类函数没有virtual，则父类函数被隐藏。 子类和父类函数同名，但参数列表不同，则父类函数被隐藏。 区别隐藏与覆盖：覆盖是发生在父类与子类之间，两个函数必须完全相同且都是虚函数。否则就是隐藏。 2.2.9 引用定义形式： 12int a;int &amp;b = a; //引用必须在申明时就初始化，与a绑定;后面不会再与其他变量绑定 注意： 引用只是一个别名，不占用内存空间；此处要和指针区分开来。 引用多用于函数的形参定义。如程序2.4所示。 程序2.7 引用示例 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std; //换成引用意思表达更清晰：/*以下为用指针交换数据*/void change(int* a,int* b); //void change(int&amp; a,int&amp; b);int main()&#123; int x = 5, y = 3; cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; &quot;y=&quot; &lt;&lt; y &lt;&lt; endl; change(&amp;x,&amp;y); //是对x和y的地址互换还是对x和y互换？ change(x,y); cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; &quot;y=&quot; &lt;&lt; y &lt;&lt; endl; return 0;&#125;void change(int* a, int* b) //void change(int a,int b)&#123; //&#123; int c; // int c; c = *a; // c = a; *a = *b; // a = b; *b = c; // b = c;&#125; //&#125; 2.2.10 C++类设计习惯和头文件重复包含问题的解决1、头文件存放类的定义及类成员函数的声明；源文件存放类中成员函数的实现。 2、注意文件包含；#include &quot;animal.h&quot; //&quot;&quot;，从当前目录开始搜索，然后是系统目录和PATH环境变量所列出的目录#include &lt;iostream&gt; //&lt;&gt;，从系统目录开始搜索，然后是PATH环境变量所列出的目录。``不搜索当前目录注意子类的头文件中也要包含父类的头文件，如fish.h中的#include “animal.h”。 3、::是作用域表示符，表明函数或数据成员属于哪个类；前面如果不跟类名，表示全局函数（即非成员函数）或全局数据。 4、在头文件中声明函数时用了virtual，在源文件中就不用写virtual。 5、要解决类重复定义的问题，要使用条件预处理指令（如课后程序animal.h和fish.h所示） 程序2.8 条件预处理指令解决类重复定义的问题 123456789#ifndef ANIMAL_H_H //如果没有定义ANIMAL_H_H，就定义ANIMAL_H_H，接着申明animal类 //如果定义过了ANIMAL_H_H，直接跳至endif#define ANIMAL_H_Hclass animal&#123;&#125;;#endif 2.2.11 VC++程序编译连接的原理与过程1、编译：头文件不参与编译源文件单独编译XXX.obj目标文件2、链接 编译链接过程如下。 课后程序animal.h 1234567891011121314151617/*animal.h*/#ifndef ANIMAL_H_H //如果没有定义ANIMAL_H_H，就定义ANIMAL_H_H，接着申明animal类 //如果定义过了ANIMAL_H_H，直接跳至endif#define ANIMAL_H_Hclass animal&#123;public: animal(); ~animal(); void eat(); void sleep(); virtual void breathe();&#125;;#endif animal.cpp 123456789101112131415161718192021222324252627/*animal.cpp*/#include &lt;iostream&gt;#include &quot;animal.h&quot;using namespace std;animal::animal()&#123;&#125;animal::~animal()&#123;&#125;void animal::eat()&#123;&#125;void animal::sleep()&#123;&#125;void animal::breathe() //在头文件中有virtual,则在源文件中不用加virtual&#123; cout &lt;&lt; &quot;animal breathe&quot; &lt;&lt; endl;&#125; fish.h 1234567891011121314/*fish.h*/#include &quot;animal.h&quot; //fish类从animal类继承#ifndef FISH_H_H#define FISH_H_Hclass fish :public animal //结构体、类名后面没有括号()&#123;public: void breathe();&#125;;#endif fish.cpp 1234567891011/*fish.cpp*/#include &lt;iostream&gt;#include &quot;fish.h&quot;using namespace std;void fish::breathe()&#123; cout &lt;&lt; &quot;fish bubble&quot; &lt;&lt; endl;&#125; main.cpp 123456789101112131415161718192021/*main.cpp*/#include &quot;animal.h&quot;#include &quot;fish.h&quot;void breathetest(animal* pan)&#123; pan-&gt;breathe();&#125;int main()&#123; animal* pan; fish fi; animal an; pan = &amp;fi; breathetest(pan); pan = &amp;an; breathetest(pan); return 0;&#125; 运行结果 问题及反思vs2019编程出现的问题：1、建立C++空项目后，要在右侧工程的源文件的文件夹下创建XXX.cpp文件； 否则编译时无法启动程序XXX.exe，系统找不到指定文件。 2、头文件#include &lt;iostream.h&gt;后添加using namespace std；否则报错：error C1083: 无法打开包括文件:“iostream.h”: No such file or directory3、定义结构体或类时，别忘记最后的分号；结构体名或类名后面没有小括号；4、引用成员函数别忘记括号：pt.output();5、.sln为项目文件 参考文献[1]&lt;https://blog.csdn.net/weixin_43751983&#x2F;article&#x2F;details&#x2F;91147918 &gt;this指针[2]孙鑫.VC++深度详解修订版[M]. 北京:电子工业出版社, 2012. 27-62. 第三章 MFC框架程序剖析3.1创建MFC AppWizard如何利用vs2019创建MFC应用见参考文献[1]需要注意的地方有[1]创建MFC单文档应用程序 [2]开启类视图窗口 3.2基于MFC的程序框架剖析在MFC中，类的命名都以C开头；对于单文档应用程序，如图3.2所示，都有： CAboutDlg帮助类，同于说明这个工程的开发信息； CMainFrame主框架类； C工程名App应用程序入口； C工程名Doc文档类，用来管理、存放数据； C工程名View用来将文档中的数据可视化。 CMainFrame类和CTestView类都有一个共同的基类：Cwnd类，其封装了与窗口相关的操作。 3.2.1 MFC中的WinMain函数文件路径（在安装路径下直接搜索MFC,找到mfc）：D:\\Program Files (x86)\\visualstudio\\VC\\Tools\\MSVC\\14.29.30037\\atlmfc\\src，打开appmodul.cpp 查找WinMain 12345678extern &quot;C&quot; int WINAPI_tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, //右键_tWinMain,单击转到定义：#define _tWinMain WinMain _In_ LPTSTR lpCmdLine, int nCmdShow)#pragma warning(suppress: 4985)&#123; // call shared/exported WinMain return AfxWinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow);&#125; 3.2.1.1 theApp全局对象以简单的C++源程序为例，在入口函数main()加载之前，就已经为全局变量（对象）分配了内存空间，并为其赋了初值。对于一个全局对象来说，此时就会调用该对象的构造函数构造该对象并进行初始化操作，然后才是进入main()函数。(P72例3-4已标出先后顺序) 对于MFC来说，通过产生一个应用程序类的对象来唯一标识应用程序的实例。每个MFC程序有且仅有一个从应用程序类（CWinApp）派生的类；每个MFC程序实例有且仅有一个该派生类的实例化对象，即theApp全局对象，theApp表示了该应用程序本身。theApp的定义如程序3.1所示，在test.cpp中查看。 程序3.1 theApp全局对象 123456789/*test.cpp*/// 唯一的 CtestApp 对象CtestApp theApp; //theApp是CtestApp的一个对象，注意其是一个全局对象/*test.h*/class CtestApp : public CWinApp //CtestApp继承于CWinApp，后者表示应用程序类&#123;......&#125; 文件路径（在安装路径下直接搜索MFC,找到mfc）：D:\\Program Files (x86)\\visualstudio\\VC\\Tools\\MSVC\\14.29.30037\\atlmfc\\src，打开appcore.cpp 查找CWinApp（184行）其中，程序3.2 12345CWinApp::CWinApp(LPCTSTR lpszAppName) //注意此处有参数&#123; ... pModuleState-&gt;m_pCurrentWinApp = this; //此处this代表子类CTestApp的对象，即theApp ...&#125; 程序3.3 12345class CWinApp : public CWinThread&#123;... explicit CWinApp(LPCTSTR lpszAppName = NULL); // app name defaults to EXE name;构造函数形参有默认值默认值 ...&#125;; 补充：如果某个函数的参数有默认值，那么在调用该函数时可以传参，也可以不传参直接使用默认值。 由程序3.3可见，来CWinApp类的定义时，CWinApp的构造函数的形参有默认值NULL。因此，在调用CWinApp类的构造函数时，不用显式地传参。 3.2.1.2 AfxWinMain函数WinMain函数实际上是通过调用AfxWinMain函数来完成它的功能的。其中，Afx前缀的函数代表应用程序框架函数，辅助我们生成应用程序框架的应用模型。在MFC中，Afx为前缀的函数都是全局函数，可以在程序的任何位置调用。 在AfxWinMain函数的定义中，有程序3.4 12345678910111213/*pThread和pApp这两个指针是一致的，这两个指针都指向CTestApp类的对象，即theApp全局对象*/ CWinThread* pThread = AfxGetThread(); CWinApp* pApp = AfxGetApp();/*MFC内部管理所调用的函数*/ if (pApp != NULL &amp;&amp; !pApp-&gt;InitApplication()) goto InitFailure;/*调用的是子类InitInstance()：因为在父类CWinApp中的InitInstance()是虚函数*/ if (!pThread-&gt;InitInstance())&#123;&#125;/*消息循环*/ nReturnCode = pThread-&gt;Run(); 3.2.1.3 InitInstance函数见程序3.4的第九行。 3.2.2 MFC框架窗口3.2.2.1 设计和注册窗口窗口类的注册是由位于wincore.cpp的AfxEndDeferRegisterClass函数完成的。AfxEndDeferRegisterClass函数预定义了几种缺省的窗口类，首先判断窗口类的类型，再赋予其相应的类名。部分代码如书本p79所示。 接着调用AfxRegisterClass函数注册从窗口类,该函数首先获得窗口类信息，窗口已经注册，返回真。否则注册该窗口类。 注意：AfxRegisterClass实际上就是AfxEndDeferRegisterClass（宏定义）； 3.2.2.2 创建窗口窗口的创建是由CWnd类中的CreateEx函数完成的。定义：afxwin.h,实现：wincore.cpp。（以Ex结尾的函数表示扩展函数。） CreateEx函数不是虚函数，CFrameWnd类的Create函数内调用的实际上就是CWnd类的CreatEx函数。CreateEx函数内部调用的PreCreateWindow函数是一个虚函数，在产生窗口之前有机会修改窗口外观。 3.2.2.3 显示和更新窗口CTestApp中名为m_pMainWnd的成员变量保存了应用程序框架窗口（CMainFrame）对象的指针，在InitInstance函数（初始化工作：注册、显示、更新）内部：程序3.5 123// 唯一的一个窗口已初始化，因此显示它并对其进行更新 m_pMainWnd-&gt;ShowWindow(SW_SHOW);//显示 m_pMainWnd-&gt;UpdateWindow();//更新 3.2.3 消息循环见程序3.4的第12行。在thrdcore.cpp中/*消息循环*/\tnReturnCode = pThread-&gt;Run(); 书本p85例3-16，该函数主要结构是一个for循环，在收到WM_QUIT时退出。在循环中的PumpMessage()与第一章的SDK编程的消息处理代码一致。 3.2.4 MFC运行过程梳理 3.3 窗口类、窗口对象与窗口3.3.1 三者之间的关系:: 前面没有东西，表示所使用的函数是一个全局函数。如果当前定义的成员函数与内部调用的API函数重名，后者必须加 :: ，否则报错。 C窗口类对象与窗口并不是一回事，他们之间唯一的关系是C窗口类对象内部定义了一个窗口句柄变量，保存了与这个C窗口类对象相关的那个窗口的句柄。窗口销毁时，与之对应的C窗口类对象销毁与否要看其生命周期是否结束。但C++窗口类对象销毁时，与之相关的窗口也将销毁。 上段话用自己的话说：在窗口销毁后，CWnd的成员变量m_hWnd设为NULL，并没有被销毁（也有可能被销毁：对象生命周期结束（函数运行到右大括号“}”））；而在C++窗口类对象析构时，窗口被销毁。 在系统文件afxwin.h中,CWnd已有一个用于保存句柄的成员变量m_hWnd,ShowWindow()和UpdateWindow()不需要再传递这个句柄，因为它已经是成员变量。程序3.6 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*afxwin.h*/class CWnd : public CCmdTarget&#123; DECLARE_DYNCREATE(CWnd)protected: static const MSG* PASCAL GetCurrentMessage();// Attributespublic: HWND m_hWnd; // must be first data member ...... &#125;;/*lesson3:\\\\wainmain.cpp*/int WINAPI WinMain( HINSTANCE hInstance, // handle to current instance HINSTANCE hPrevInstance, // handle to previous instance LPSTR lpCmdLine, // command line int nCmdShow // show state)&#123; //设计窗口类 ... //注册窗口类 ... //创建窗口类 CWnd wnd; wnd.CreateEx(...); wnd.ShowWindow(SW_SHOWNORMAL); wnd.UpdateWindow(); /* 对比第一章： 创建窗口 HWND hwnd; hwnd = CreateWindowEx(); 显示及刷新窗口 ::ShowWindow(hwnd, SW_SHOWNORMAL); ::UpdateWindow(hwnd); 注意ShowWindow和UpdateWindow的参数，原因是：CWnd类定义过了一个HWND类型的成员变量m_hWnd用于保存这个窗口的句柄， 在调用CWnd类中的ShowWindow显示窗口时，就不在需要传递这个句柄了，因为它已经是成员变量了，该函数可以直接使用它。 在窗口销毁后，CWnd的成员变量m_hWnd设为NULL，并没有被销毁；而在C++窗口类对象析构时，窗口被销毁。 */ //消息循环 ... return 0; &#125; 3.3.2 在窗口中显示按钮CButton的Create函数声明：BOOL Create( LPCTSTR lpszCaption, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID ); lpszCaption：按钮文本； dwStyle：按钮风格+窗口风格； rect：定义一个矩形区域； pParentWnd：指定父窗口。MFC不再通过窗口句柄，而是通过一个与窗口相关的C++窗口类对象指针来传递窗口对象。 nID:按钮控件标识。可取整数随机值。在框架窗口产生之后，再创建该标识，否则没地方放置。 窗口创建时都会产生WM_Create消息，OnCreate函数用于相应这条窗口创建消息。 如果将按钮创建在CMainFrame::OnCreate()函数内，按钮的父窗口是主框架窗口，此时按钮遮挡住了保存等按钮。 改为在CTestView.cpp中创建button，首先在testView.cpp中创建OnCreate函数，步骤如问题及反思[3]所示。运行结果如下。 而将m_btn.Create()中的this改为GetParent(),运行结果变为 可见，按钮的位置与其父窗口有关，与创建它的代码所在的类无关。 将按钮窗口销毁，m_btn并没有销毁，因为m_btn是CTestView类的一个成员变量，其生命周期与CTestView对象一致。 课后程序123456789101112131415161718192021222324252627282930313233343536373839404142/*testview.h*/class CtestView : public CView&#123;...private: CButton m_btn; //在定义类的成员变量时都以&quot;m_&quot;为前缀，表明这个变量是类的成员变量&#125;;/*testview.cpp*/int CtestView::OnCreate(LPCREATESTRUCT lpCreateStruct)&#123; if (CView::OnCreate(lpCreateStruct) == -1) return -1; /*CButton的Create函数声明：BOOL Create( LPCTSTR lpszCaption, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID );*/// m_btn.Create(_T(&quot;button&quot;), WS_CHILD | BS_DEFPUSHBUTTON, CRect(0, 0, 100, 100), this, 123);// m_btn.ShowWindow(SW_SHOWNORMAL);//窗口显示 m_btn.Create(_T(&quot;button&quot;), WS_CHILD | BS_DEFPUSHBUTTON |WS_VISIBLE , CRect(0, 0, 100, 100), this, 123);// m_btn.Create(_T(&quot;button&quot;), WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON, CRect(0, 0, 100, 100), GetParent(), 123); /* &quot;按钮&quot;：名称； CRect(0,0,100,100)：矩形区域； 123：ID号。 * WS_CHILD（窗口风格）:The window is a child window. A window with this style cannot have a menu bar. BS_DEFPUSHBUTTON（按钮风格）:下按按钮风格 WS_VISIBLE:The window is initially visible. * this指针（代表对象本身） GetParent():Call this function to get a pointer to a child window&#x27;s parent window */ /* C2664 “BOOL CButton::Create(LPCTSTR,DWORD,const RECT &amp;,CWnd *,UINT)”: 无法将参数 1 从“const char [7]”转换为“LPCTSTR” test E:\\VCProject\\Lesson3\\test\\test\\MainFrm.cpp 68 解决方法： 方法1、&quot;button&quot;改为_T(&quot;button&quot;)[2] 方法2、调试&gt;&gt;XXX调试属性&gt;&gt;配置属性&gt;&gt;高级&gt;&gt;高级属性&gt;&gt;字符集，改为：使用多字节字符集[3] */ return 0;&#125; 运行结果： 问题及反思[1]如何利用vs2019创建MFC应用见参考文献[1] [2]C2664\t“BOOL CButton::Create(LPCTSTR,DWORD,const RECT &amp;,CWnd *,UINT)”: 无法将参数 1 从“const char [7]”转换为“LPCTSTR”解决方法：方法1、”button”改为_T(“button”)方法2、调试&gt;&gt;XXX调试属性&gt;&gt;配置属性&gt;&gt;高级&gt;&gt;高级属性&gt;&gt;字符集，改为：使用多字节字符集 [3]vs2019为一个类添加某函数的方法如下所示。第四步单击最右侧向下小三角，选择Add OnCreate。 参考文献[1] &lt;https://blog.csdn.net/m0_37062716&#x2F;article&#x2F;details&#x2F;113827243?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source&#x3D;distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control &gt;.安装MFC,创建MFC工程文件 [2]&lt;https://blog.csdn.net/huijie4728/article/details/50487315&gt; . 问题及反思[2] [3]&lt;https://blog.csdn.net/feilong911hao/article/details/39231533?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source&#x3D;distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&gt; . 问题及反思[2] [4]孙鑫.VC++深度详解修订版[M]. 北京:电子工业出版社, 2012. 63-99. 第四章4.1 MFC消息映射机制4.1.1 classwizard所有操作，包括鼠标点击鼠标移动等操作都只能由视类窗口捕获。因为视类窗口在框架窗口之上，如果在框架窗口操作。就会被视类窗口覆盖而看不见了。 删除通过向导添加的消息响应函数时，应在向导中删除。 4.1.2 消息映射机制一个MFC消息响应函数在程序中有3处相关信息： 1、消息响应函数原型 123456/*drawView.h*/// 生成的消息映射函数protected: DECLARE_MESSAGE_MAP()public: afx_msg void OnLButtonDown(UINT nFlags, CPoint point); 2、消息映射宏 消息映射宏ON_WM_LBUTTONDOWN()的作用：把消息(WM_LBUTTONDOWN)与消息响应函数(OnLButtonDown)关联起来。 1234567BEGIN_MESSAGE_MAP(CdrawView, CView) // 标准打印命令 ON_COMMAND(ID_FILE_PRINT, &amp;CView::OnFilePrint) ON_COMMAND(ID_FILE_PRINT_DIRECT, &amp;CView::OnFilePrint) ON_COMMAND(ID_FILE_PRINT_PREVIEW, &amp;CView::OnFilePrintPreview) ON_WM_LBUTTONDOWN()END_MESSAGE_MAP() 3、消息响应函数的定义 1234567/*drawView.cpp*/void CdrawView::OnLButtonDown(UINT nFlags, CPoint point)&#123; // TODO: 在此添加消息处理程序代码和/或调用默认值 MessageBox(&quot;click down&quot;); CView::OnLButtonDown(nFlags, point);&#125; MFC消息映射方式的具体实现：在每个能接受和处理消息的类中，定义一个消息和消息函数静态对照表，即消息映射表。在消息映射表中，消息和对应的消息处理函数指针成对出现。某个类能处理的所有信息及其对应的消息处理函数地址都列在这个类对应的静态表中。当有消息需要处理时，程序只能搜索该消息静态表，查看表中是否含有该消息，就知道该类能否处理此消息。如果能处理，则同样依照静态表能很容易找到并调用对应的消息处理函数。 4.2 绘制线条在基类中添加成员变量的原因：可以一直存在；而在子类中，程序运行到右}，变量的生命周期就结束了。 1234class CdrawView : public CView&#123;...private: CPoint m_ptOrigin; ...&#125;; 在构造函数中将m_ptOrigin赋0以初始化后，在消息响应函数中将鼠标按下的信息保存到基类的成员变量m_ptOrigin中 12345678void CdrawView::OnLButtonDown(UINT nFlags, CPoint point)&#123;//CPoint point接收按下鼠标左键的位置 m_ptOrigin = point; /*保存该位置到基类的成员变量； **当前的鼠标坐标也就是划线的起点坐标。 */ CView::OnLButtonDown(nFlags, point); &#125; 最后添加WM_LButtonUp. 4.2.1 利用SDK全局函数实现划线功能1234567891011121314151617//具体实现如下：void CdrawView::OnLButtonUp(UINT nFlags, CPoint point)&#123; // 获取设备描述表 HDC hdc; hdc = ::GetDC(m_hWnd); //移动到线条的起点 MoveToEx(hdc , m_ptOrigin.x , m_ptOrigin.y , NULL); //划线 LineTo(hdc , point.x , point.y ); //释放设备描述表 ::ReleaseDC(m_hWnd , hdc); CView::OnLButtonUp(nFlags, point); 1、获取设备描述表(平台SDK的GetDC) 12345//字典//平台SDK的GetDCHDC GetDC( HWND hWnd); 123456789101112131415//本例HDC hdc;//HDC:A handle to a device context (DC)./*device context (DC):There are four types of DCs: display, printer, memory (or compatible), and information. Each type serves a specific purpose*/hdc = ::GetDC(m_hWnd);/*用自己的话说（暂时的理解是），HWND hWnd就是当前窗口，HDC hdc就是用来画画的，GetDC()就是把当前窗口中用来画画的一部分（DC）取出来赋给hdc变量,意思是接下来的画的东西都会保存在hdc上，也就是保存在了hWnd当前窗口的DC上*/ //注意最后释放 ::ReleaseDC(m_hWnd , hdc);//将m_hWnd窗口的hdc释放 2、鼠标移动到线条的起点 12345678BOOL MoveToEx( HDC hdc, //设备描述表句柄 int x, int y, //起点坐标 LPPOINT lppt //指向point结构体的指针，保存移动操作前鼠标的位置坐标);MoveToEx(hdc , m_ptOrigin.x , m_ptOrigin.y , NULL); 3、划线 1234567BOOL LineTo( HDC hdc, int x, int y//终点坐标);LineTo(hdc , point.x , point.y ); 4.2.2 利用MFC的CDC类实现画图功能MFC为我们提供了一个设备描述表的封装类CDC，该类封装了所有绘图操作。该类中的数据成员m_hDC保存与CDC类相关的DC句柄，因此不需要DC句柄作为参数，其作用类似m_hWnd。而平台SDK提供的全局TextOut()则不然。 1234567891011void CdrawView::OnLButtonUp(UINT nFlags, CPoint point)&#123; CDC* pDC = GetDC(); //此处的GetDC是CWnd()的而不是平台SDK的。 pDC-&gt;MoveTo(m_ptOrigin);//从什么位置 /*pDC是指向CDC类的指针，MoveTo()是CDC类的函数，所以用指向符-&gt;*/ /*如果是CDC类的对象的话就用“.”号*/ pDC-&gt;LineTo(point);//画线到什么位置 ReleaseDC(pDC); CView::OnLButtonUp(nFlags, point);&#125; 此处的GetDC是CWnd()的而不是平台SDK的。对比4.2.1的GetDC 123//字典CWnd::GetDC CDC* GetDC( ); 4.2.3 利用MFC的CClientDC类实现画图功能CClientDC类派生于CDC类，并在构造函数时自动调用GetDC和ReleaseDC 123456789101112131415161718void CdrawView::OnLButtonUp(UINT nFlags, CPoint point)&#123; CClientDC dc(this);/*CClientDC dc(CWnd* pWnd);**CWnd* pWnd是指向窗口的指针，此处需要指向视类窗口对象，即CdrawView。**在CdrawView::OnLButtonUp(...)中使用this指向CdrawView自己。*//*DetParent()返回父类窗口的指针*/ dc.MoveTo(m_ptOrigin); dc.LineTo(point);/*这里CClientDC类型的变量dc是一个对象，因此使用点操作符来调用该对象的函数；**4.2.2中，pDC是指向CDC类的指针，MoveTo()是CDC类的函数，所以用指向符-&gt; */ CView::OnLButtonUp(nFlags, point);&#125; 4.2.4 利用MFC的CWindowDC类实现画图功能CWindowDC类派生于CDC类，并在构造函数时自动调用GetDC和ReleaseDC，调用方式与CClientDC一样。 不同于CClientDC的是，CWindowDC可以访问整个窗口区域，包括框架窗口的客户区（菜单栏以下）和非客户区（标题栏和菜单栏）；而CClientDC最多只能到客户区。 12345678910void CdrawView::OnLButtonUp(UINT nFlags, CPoint point)&#123; CWindowDC dc(GetDesktopWindow());//整个桌面窗口 //CWindowDC dc(GetParent());//框架窗口，包括客户区和非客户区 //CWindowDC dc(this);//视类窗口 dc.MoveTo(m_ptOrigin); dc.LineTo(point); CView::OnLButtonUp(nFlags, point);&#125; 4.2.5 在桌面窗口划线见4.2.4。 4.2.6 绘制线条色彩12345678910111213void CdrawView::OnLButtonUp(UINT nFlags, CPoint point)&#123; CPen pen(PS_SOLID, 1, RGB(255, 0, 0)); CClientDC dc(this); //只创建CPen不会生效，还要将其选入设备描述表 CPen* pOldPen = dc.SelectObject(&amp;pen); dc.MoveTo(m_ptOrigin); dc.LineTo(point); //还原设备描述表 dc.SelectObject(pOldPen); CView::OnLButtonUp(nFlags, point);&#125; 1、Cpen类创建画笔对象，该类封装了画笔的相关操作 CPen (int nPenStyle , int Width , COLORREF crColor); 三个参数分别代表线形、线宽和颜色。 颜色用RGB(r,g,b)表示，每个参数都是0~255之间。黑色全0，白色全255. 2、在程序中构造GDI对象后,该对象不会立即生效，必须**(作用1)选入设备描述表后，才会生效。SelectObject()函数除了实现以上操作，还会(作用2)返回指向先前被选中对象的指针**，以在完成绘画后，还原设备描述表。 小结：需要使用SelectObject()选入设备描述表：CPen类、Rectangle函数 4.3 画刷4.3.1 简单画刷利用CBrush类创建画刷对象，以填充一块区域。 CBrush(COLORREF crColor ) 123456789void CdrawView::OnLButtonUp(UINT nFlags, CPoint point)&#123; CBrush brush(RGB(255 , 0, 0));//创建红色画刷 CClientDC dc(this);//创建并获取设备描述表 //利用红色画刷填充鼠标拖拽过程中产生的矩形区域 dc.FillRect(CRect(m_ptOrigin, point), &amp;brush); CView::OnLButtonUp(nFlags, point);&#125; 1、FillRect函数：利用画刷填充鼠标拖拽过程中产生的矩形区域，包括左边和上部边界，不填充右边和底部边界。 void FillRect( LPCRECT lpRect, CBrush* pBrush ); 1、lpRect：指向一个RECT结构体或CRect对象指针。本例使用CRect()函数,即 CRect( POINT topLeft, POINT bottomRight );第一个参数是左上角点，第二个参数是右下角点，以确定一个矩形。 2、pBrush：指向用于填充矩形的画刷对象的指针。 4.3.2 位图画刷CBrush类中有如下构造函数：CBrush (CBitmap* pBitMap);其中，CBitmap类是位图类。创建CBitmap对象时，仅调用其构造函数，并不能得到有用的位图对象，还需要调用初始化函数来初始化该位图对象。本例中用加载位图的初始化函数：LoadBitmap(UINT nIDResource);。其中，nIDResource是资源ID号，在资源视图中查看，如图4.6所示。 1234567891011void CdrawView::OnLButtonUp(UINT nFlags, CPoint point)&#123; CBitmap bitmap;//创建位图对象 bitmap.LoadBitmap(IDB_BITMAP1);//初始化位图对象 CBrush brush(&amp;bitmap);//将位图对象装进画刷 CClientDC dc(this);//创建并获取设备描述表 //用位图填充矩形区域 dc.FillRect(CRect(m_ptOrigin , point) , &amp;brush); CView::OnLButtonUp(nFlags, point);&#125; 1、位图的创建过程如下所示。 2、资源ID在资源视图中查看 4.3.3 透明画刷12345678910111213void CdrawView::OnLButtonUp(UINT nFlags, CPoint point)&#123; CClientDC dc(this); //创建空画刷 CBrush* pBrush = CBrush::FromHandle( (HBRUSH) GetStockObject(NULL_BRUSH)); //将画刷选入设备描述表 CBrush* pOldBrush = dc.SelectObject(pBrush); dc.Rectangle(CRect(m_ptOrigin, point)); dc.SelectObject(pBrush); CView::OnLButtonUp(nFlags, point);&#125; 1、GetStockObject()函数,获取一个黑点或白色的画刷句柄 GetStockObject(NULL_BRUSH);获取一个空画刷 123HGDIOBJ GetStockObject( int fnObject // stock object type); 再利用强制类型转换，将HGDIOBJ类型转换为HBRUSH类型 1(HBRUSH) GetStockObject(NULL_BRUSH); 2、FromHandle()函数将画刷句柄转化为画刷对象 123456789static CBrush* PASCAL FromHandle( HBRUSH hBrush );/*Parameters(参数)hBrush Specifies the HANDLE to a Windows CE GDI brush. *//*Return ValueA pointer to a CBrush object if successful; otherwise, it is NULL */ static静态成员函数P126 (1)静态成员函数和静态成员变量属于类本身，而不属于某一个变量，在类加载的时候，既为他们分配了空间，所以可以通过类名::函数名或类名:变量名来访问。而非静态成员函数和非静态成员变量属于对象的方法和数据，即应先产生类的对象，再通过类的对象去引用。 (2)在静态成员函数中是不能调用非静态成员的，包括非静态成员函数和非静态成员变量；静态成员函数只能访问静态成员变量。而非静态成员函数中是可以调用静态成员函数的。 (1)和(2)小结：也就是说，无论采用什么样的操作，代码都是在内存中运行的。程序只有在内存中占有一席之地，才能够访问它。 (3)对于静态成员变量，必须对其初始化，并且应在类的定义之外. 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;class Point&#123;public: static void init();//静态成员函数 &#123; cout&lt;&lt;&quot;x = &quot;&lt;&lt;x&lt;&lt;endl; &#125; static int x;//静态成员变量&#125;; int Point::x = 0;//知识点(3)：1初始化2在类外初始化void main()&#123; Point::init();//知识点(1)：用类名::函数名来直接调用&#125; /*结果输出x = 0*/ 4.4 绘制连续线条为捕获鼠标移动过程的每一个点，可以通过捕获鼠标移动消息(WM_MouseMove)来实现。只要鼠标在程序窗口中移动，都会进入这个消息响应函数中。 123456789101112131415161718192021222324252627282930313233343536373839/*drawView.h*/class CdrawView : public CView&#123;...private: BOOL m_bdraw;//判断鼠标左键是否按下去，按下为真，否则为假 &#125;;/*drawView.cpp*/void CdrawView::OnLButtonDown(UINT nFlags, CPoint point)&#123; m_ptOrigin = point; m_bdraw = 1; CView::OnLButtonDown(nFlags, point);&#125;void CdrawView::OnLButtonUp(UINT nFlags, CPoint point)&#123; m_bdraw = 0; CView::OnLButtonUp(nFlags, point);&#125;void CdrawView::OnMouseMove(UINT nFlags, CPoint point)&#123; CClientDC dc(this); CPen pen(PS_SOLID , 1 , RGB(255 , 0 , 0)); CPen* pOldPen = dc.SelectObject(&amp;pen); if (m_bdraw == 1) &#123; dc.MoveTo(m_ptOrigin);//第一次左键按下 dc.LineTo(point);//将起点与终点连线 m_ptOrigin = point; /*绘制完当前线段后，立即将上一段的终点位置赋给下一段的起点*/ dc.SelectObject(pOldPen); &#125; CView::OnMouseMove(nFlags, point);&#125; 4.5 绘制扇形效果线条12345678void CdrawView::OnMouseMove(UINT nFlags, CPoint point)&#123; ... dc.LineTo(m_ptOld);//表示鼠标移动过程中的连线中，每个极小的线段 //m_ptOrigin = point;//修改起点信息 m_ptOld = point;//m_ptOld用于保存鼠标上一个移动点 ...&#125; 问题及反思[1]位图创建过程见4.3.2 参考文献[1]孙鑫.VC++深度详解修订版[M]. 北京:电子工业出版社, 2012. 100-134. 第五章5.1 插入符5.1.1 创建插入符在窗口创建之后的WM_CREATE消息响应函数OnCreate中添加创建插入符代码： void CreateSolidCaret(int nWidth , int nHeight);若参数为0，则使用系统定义。 接着，使用ShowCaret();显示插入符。 对于CreateSolidCaret()的两个参数，可以根据字体度量信息自动调整插入符： BOOL GetTextMetrics( LPTEXTMATRIC lpMetrics ) const;其中，参数要求一个指向TEXTMETRIC结构体的指针，函数从DC中获取字体度量信息后填充进这个结构体。 经常用到的TEXTMETRIC结构体变量： int tmHeight; &#x2F;&#x2F;tmAscent+tmDescent int tmAscent; &#x2F;&#x2F;升序高度 int tmDescent; &#x2F;&#x2F;降序高度 int tmAveCharWidth; &#x2F;&#x2F;平均宽度 int tmMaxCharWidth; &#x2F;&#x2F;最大字符宽度 1234567891011121314int CtextView::OnCreate(LPCREATESTRUCT lpCreateStruct)&#123; if (CView::OnCreate(lpCreateStruct) == -1) return -1; // TODO: 在此添加您专用的创建代码 CClientDC dc(this); TEXTMETRIC tm; dc.GetTextMetrics(&amp;tm); CreateSolidCaret(tm.tmAveCharWidth / 8 , tm.tmHeight); //除以8是经验值 ShowCaret(); return 0;&#125;//创建插入符 5.1.2 创建图形插入符void CreateCaret(CBitmap* pBitmap);创建图形插入符 12345678910111213int CtextView::OnCreate(LPCREATESTRUCT lpCreateStruct)&#123; if (CView::OnCreate(lpCreateStruct) == -1) return -1; // TODO: 在此添加您专用的创建代码//CBitmap对象在基类CView中创建 bitmap.LoadBitmap(IDB_BITMAP1); CreateCaret(&amp;bitmap); ShowCaret(); return 0;&#125;//位图插入符 5.2 窗口重绘5.2.1 OnDraw函数窗口重绘时，已输入的文字或图形就会被擦除。如想要保留，则需要WM_PAINT的消息响应函数OnCreate将内容再次输出（重绘）。 字符串类CString,其对象可以当作普通变量赋值、相加。 CDC类封装的TetOut(x,y,str);在指定位置显示字符串。 5.2.2 添加字符串资源BOOL LoadString(UINT nID); 其中，nID为字符串资源标识，如下图所示。 123456789101112131415void CtextView::OnDraw(CDC* pDC)&#123; CtextDoc* pDc = GetDocument(); ASSERT_VALID(pDoc); if (!pDoc) return; // TODO: 在此处为本机数据添加绘制代码 CString str; str = &quot;VC++深入编程&quot;; pDC-&gt;TextOut(0,0,str); str.LoadString(IDS_STRINGVC); pDC-&gt;TextOut(0,50,str);&#125; 5.3 路径层1、步骤： 打开路径层：BeginPath 利用GDI提供的绘图函数绘图 关闭路径层：EndPath 2、CSize GetTextExtent(str)：获取某个特定字符串的宽度和高度,返回CSize对象。和GetTextMetrics（字体度量）区分。 3、裁剪区域：可以理解为一个绘图区域，大小可以由我们来控制，以后的绘图操作仅限于这个矩形区域内。 CDC类提供了BOOL SelectClipPath(int nMod);用于把当前设置的路径层和DC中已有的剪裁区域按照一定指定的模式进行一个互操作。 nMod是用于指定互操作的模式，如： RGN_DIFF：新的剪裁区域包含当前剪裁区域，但排除当前路径层区域。 RGN_AND：剪裁区域和路径层的交集 小结：如果希望整幅图形中的某一部分与其他部分有所区别，就可以把这个部分的图形放置在一个路径层中，然后利用SelectClipPath函数设置一种模式，让路径层和剪裁区域进行互操作以达到一种特殊的效果。 5.4 字符输入利用CString类对象可以直接字符输入。 输入字符，就会有WM_CHAR消息，在OnChar消息处理函数中写代码，说明要如何处理该消息。 设置插入符位置函数：CWnd类中的SetCaretPos(POINT point);函数。将插入符移动到鼠标左键单击处。 清除字符可以直接用CString类中的Empty() 来实现。 1、回车处理（ASCII为0x0d） 插入符横坐标不变，纵坐标发生变化：当前插入点的纵坐标加上字体高度 123456if(0x0d == nChar)&#123; m_strLine.Empty();//清空当前字符串 m_ptOrigin.y += tm.tmHeight;//移动插入点 dc.TextOut(m_ptOrigin.x , m_ptOrigin.y , m_strLine);//在新的插入点输出&#125; 2、退格键（ASCII为0x08） 步骤： 设置文本颜色为背景色：virtual COLORREF SetTextColor( COLORREF crColor );返回原来的颜色。CDC::GetBkColor()获取背景色。 输出 在字符串变量中删除要删除的文字CString Left( int nCount ) const;其中，nCount指字符串左边指定数目的字符。int GetLength( ) const;获取长度。 还原文字颜色 输出 12345678if(0x08 == nChar)&#123; COLORREF clr = dc.SetTextColor(dc.GetBkColor());//设置文本颜色为背景色 dc.TextOut(m_ptOrigin.x , m_ptOrigin.y , str);//输出 m_strLine = m_strLine.Left(m_strLine.GetLength() - 1);//在字符串变量中删除要删除的文字 dc.SetTextColor(clr);//还原文字颜色 dc.TextOut(m_ptOrigin.x , m_ptOrigin.y , m_strLine);//输出&#125; 3、设置字体 1、创建字体对象； 2、CFont类设置字体 BOOL CreatePointFont( int nPointSize, LPCTSTR lpszFaceName, CDC* pDC = NULL ); (字体高度，字体名称，NULL) 3、将字体选入DC，SelectObject(CFont *font); 4、字幕变色功能 CDC::DrawText函数 在指定矩形范围内输出文字。 int DrawText(const CString&amp; str, LPRECT lpRect, UINT nFormat ); （要输出的字符串，文字显示范围的矩形，文本的输出格式） CWnd::SetTimer函数 定时器函数UINT SetTimer( UINT nIDEvent, UINT nElapse, void (CALLBACK EXPORT* lpfnTimer)( HWND, UINT, UINT, DWORD) ); UINT nIDEvent：非零定时器标识，函数调用成功，则返回标识； UINT nElapse：以毫秒为单位的时间间隔，即每隔多长时间发送一次定时器消息WM_TIMER。程序在OnTimer函数中编写。 CALLBACK EXPORT* lpfnTimer：如果设置了该回调函数，则系统调用该回调函数处理消息。如果NULL，则窗口对象CWnd来处理 参考文献：[1]孙鑫.VC++深度详解修订版[M]. 北京:电子工业出版社, 2012. 135-161. 第六章 菜单一、创建菜单项资源管理器→menu项→双击IDR_MAINFRAME打开菜单编辑器 pop-up类型的菜单是弹出式菜单，不能进行命令响应。 ID号的命名规则： IDM菜单资源 IDC光标资源 IDI图标资源 二、为菜单项添加响应函数打开ClassWizard【类向导】， 区别Message中的COMMAND和UPDATE_COMMAND_UICOMMAND处理该菜单对应的功能。UPDATE_COMMAND_UI处理菜单应对的用户界面。 菜单项响应顺序：view→doc→mainframe→App Windows消息的分类1、标准消息：除 WM_COMMAND 之外，所有以 WM_开头的消息都是标准消息。CWnd类，都可以接收到这类消息。2、命令消息：来自菜单、加速键或工具栏按钮的消息。这类消息都以 WM_COMMAND 形式呈现。在 MFC 中，通过菜单项的标识（ID）来区分不同的命令消息；在 SDK 中，通过消息的wParam 参数识别。从 CCmdTarget 派生的类，都可以接收到这类消息。3、通告消息：由控件产生的消息，例如按钮的单击、列表框的选择等。目的是为了向其父窗口（通常是对话框）通知事件的发生。这类消息也是以 WM_COMMAND 形式呈现。从CCmdTarget 派生的类，都可以接收到这类消息。实际上，CWnd 类派生于 CCmdlTarget类。也就是说凡是从 CWnd 派生的类，它们既可以接收标准消息，也可以接收命令消息和通告消息。而对于那些从 CCmdTarget 派生的类，则只能接收命令消息和通告消息，不能接收标准消息。 菜单消息响应过程：mainframe类接收消息→view首先处理，若不行→doc→mainframe→App 三、基本菜单操作1、了解菜单结构 程序的主菜单属于框架窗口，因此要在框架类的OnCreate中编程。 2、标记菜单获取程序菜单栏：CWnd类 CMenu* GetMenu( ) const; 获取子菜单：CMenu类CMenu* GetSubMenu( int nPos ) const;参数是子菜单的索引号,注意分隔栏也占据索引号。 添加或移除标记：CMenu类UINT CheckMenuItem( UINT nIDCheckItem, UINT nCheck ); Parameters_nIDCheckItem_：Specifies the menu item to be checked, as determined by nCheck._nCheck_Specifies ：how to check the menu item and how to determine the position of the item in the menu. The nCheck parameter can be a combination of MF_CHECKED or MF_UNCHECKED with MF_BYPOSITION or MF_BYCOMMAND flags. MF_BYCOMMAND 指定第一个参数通过ID MF_BYPOSITION 指定第一个参数通过索引号 MF_CHECKED 设置复选标记 MF_UNCHECKED 移走复选标记 1GetMenu()-&gt;GetSubMenu(0)-&gt;CheckMenuItem(0,MF_BYPOSITION | MF_CHECKED); 3、默认菜单项（粗体）注意子菜单只能有一个默认菜单项。 CMenu类BOOL SetDefaultItem( UINT uItem, BOOL fByPos = FALSE ); 1GetMenu()-&gt;GetSubMenu(0)-&gt;SetDefaultItem(2,MF_BYPOSITION); 4、图形标记菜单CMenu类：BOOL SetMenuItemBitmaps( UINT nPosition, UINT nFlags, const CBitmap* pBmpUnchecked, const CBitmap* pBmpChecked ); pBmpUnchecked是取消选中时的位图；pBmpchecked是选中状态时的位图。 获取系统的信息度量：int GetSystemMetrics( int nIndex);其中，参数用于指定希望获取哪部分的系统信息。SM_CXMENUCHECK和SM_CYMENUCHECK用于获取菜单项标记图形的默认尺寸。 CString类的Format函数类似C中的printf。 12345678CBitmap m_bitmap;//头文件全局变量m_bitmap.LoadBitmap(IDB_BITMAP1);GetMenu()-&gt;GetSubMenu(0)-&gt;SetMenuItemBitmaps(0, MF_BYPOSITION, &amp;m_bitmap, &amp;m_bitmap);Ctring str;str.Format(&quot;x = %d , y = %d&quot;, GetSystemMetrics(SM_CXMENUCHECK), GetSystemMetrics(SM_CYMENUCHECK));MessageBox(str); 5、禁用菜单项CMenu类：UINT EnableMenuItem( UINT nIDEnableItem, UINT nEnable ); nEnable： MF_BYCOMMAND Specifies that the parameter gives the command ID of the existing menu item. This is the default. MF_BYPOSITION Specifies that the parameter gives the position of the existing menu item. The first item is at position 0. MF_DISABLED Disables the menu item so that it cannot be selected but does not dim it. MF_ENABLED Enables the menu item so that it can be selected and restores it from its dimmed state. MF_GRAYED Disables the menu item so that it cannot be selected and dims it. 常把MF_GRAYED和MF_DISABLED放在一起使用。 发现不能正常禁用？ &#x2F;&#x2F; NOTE: m_bAutoMenuEnable is set to FALSE in the constructor of &#x2F;&#x2F; CMainFrame so no ON_UPDATE_COMMAND_UI or ON_COMMAND handlers are &#x2F;&#x2F; needed, and CMenu::EnableMenuItem() will work as expected. 即在CMainFrame构造函数中添加m_bAutoMenuEnable &#x3D; FALSE; 6、移除和装载菜单CWnd类：BOOL SetMenu( CMenu* pMenu );CMenu* pMenu 指向一个新的菜单对象，若值为NULL，则移除当前菜单。 123456789/*移除菜单*/SetMenu(NULL);/*装载菜单资源*/Cmenu menu;//1、框架类成员变量2、若是局部变量，结尾一定要加Detach函数menu.LoadMenu(IDR_MAINFRAME);SetMenu(&amp;menu);menu.Detach();//menu是局部变量的情况，将菜单句柄与菜单对象分离 四、MFC菜单命令更新机制菜单项状态的维护依赖于CN_UPDATE_COMMAND_UI消息，该消息智能用于菜单项，不能用于永久显示的顶级菜单（即弹出式菜单）。 在BEGIN_MESSAGE_MAP和END_MESSAGE_MAP之间添加宏以捕获消息 1234BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)//自动添加的 ON_WM_CREATE() ON_UPDATE_COMMAND_UI(ID_FILE_NEW, &amp;CMainFrame::OnUpdateFileNew)END_MESSAGE_MAP() 1234567void CMainFrame::OnUpdateEditCut(CCmdUI* pCmdUI)//消息响应函数&#123; // TODO: 在此添加命令更新用户界面处理程序代码 pCmdUI-&gt;Enable();&#125;/*CCmdUI类决定一个菜单项是否可以使用(Enable)，是否有标记(SetCheck)，改变菜单项文本(SetText)*//*CCmdUI类有成员变量m_nID保存对象ID和m_nIndex保存对象索引*/ 如果只是利用禁用菜单项，菜单项变灰禁用，但工具栏按钮依然能够使用。而如果使用命令更新机制，则都不能使用。 五、快捷菜单（上下文菜单、右键菜单） 为CView类添加一个WM_CONTEXTMENU消息处理函数，当鼠标右键单击窗口时，就会调用该函数。 显示快捷菜单函数： BOOL TrackPopupMenu( UINT nFlags, int x, int y, CWnd* pWnd, LPCRECT lpRect = NULL ); 12345678910void CmenuView::OnContextMenu(CWnd* pWnd, CPoint point)&#123; // TODO: 在此处添加消息处理程序代码 CMenu popmenu; popmenu.LoadMenu(IDR_POPMENU1); //读取资源 popmenu.GetSubMenu(0)-&gt;TrackPopupMenu( TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON, point.x, point.y, this);&#125;/*TPM_LEFTALIGN定位弹出菜单，使其左侧与 x 指定的坐标对齐。*/ 六、动态菜单操作1、针对子菜单的动态操作1、把一个新的子菜单添加到菜单栏末尾。CMenu类：BOOL AppendMenu ( UINT nFlags, UINT nIDNewItem = 0, LPCTSTR lpszNewItem = NULL); CMenu类：CreateMenu()创建一个弹出菜单，并与CMenu对象关联 1234CMenu m_menu;//成员变量m_menu.CreateMenu();GetMenu()-&gt;AppendMenu(MF_POPUP, (UINT)m_menu.m_hMenu, &quot;TEST&quot;); 2、两个子菜单中间插入子菜单。CMenu类： BOOL InsertMenu( UINT nPosition, UINT nFlags, UINT nIDNewItem = 0, LPCTSTR lpszNewItem = NULL ); 用法类似AppendMenu 3、删除子菜单或菜单项。CMenu类：BOOL DeleteMenu( UINT nPosition, UINT nFlags ); 1234//删除子菜单 GetMenu()-&gt;DeleteMenu(0,MF_BYPOSITION );//删除菜单项GetMenu()-&gt;GetSubMenu(1)-&gt;DeleteMenu(0,MF_BYPOSITION ); 2、针对菜单项的动态操作1、插入菜单项同样使用AppendMenu和InsertMenu 123m_menu.AppendMenuA(MF_STRING, 111, &quot;hello&quot;);//往弹出菜单TEST中添加菜单项GetMenu()-&gt;GetSubMenu(0)-&gt;AppendMenu(MF_STRING, 113, &quot;hello1&quot;);//往文件子菜单末尾添加菜单项GetMenu()-&gt;GetSubMenu(0)-&gt;InsertMenu(1, MF_BYPOSITION | MF_STRING , 112 , &quot;VC编程&quot;); 3、为 动态添加的菜单项 添加响应函数12345678910111213141516171819202122232425//在头文件resource.h中创建菜单资源ID#define IDM_HELLO 111//源文件中m_menu.AppendMenuA(MF_STRING, IDM_HELLO, &quot;hello&quot;);//遵循消息映射机制：增加3处代码实现消息响应//1、在响应这个菜单命令的类中添加响应函数原型，位于声明消息映射宏之上，（第11行所示）protected: afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct); afx_msg void OnHello(); DECLARE_MESSAGE_MAP() //2、在源文件的消息映射表中添加消息映射，消息映射宏是ON_COMMAND宏，（第17行所示）//注意：消息映射表中，代码结尾不加分号BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd) ON_WM_CREATE() ON_COMMAND(IDM_HELLO,OnHello)END_MESSAGE_MAP()//3、添加消息响应函数定义void CMainFrame::OnHello()&#123; MessageBox(&quot;Hello&quot;);&#125; 第七章 对话框（一）1、基本知识控件：通常作为对话框的子窗口创建 对话框的种类： 模态对话框：对话框显示时，程序暂停执行，直到关闭对话框。 非模态：显示对话框时，可以执行其他任务。 2、创建和显示CDialog对话框资源类 1.新建一个MFC类与该对话框关联：双击新建的对话框。 新建对话框资源后有两个按钮，功能一样（关闭对话框），返回值不同。 OK IDOK OnOK Cancel IDCANCEL OnCancel 2.**DoDataExchange()**：完成对话框数据的交换和校验。 3.在视类中 **CDialog::DoModal**创建并显示模态对话框 **CDialog::EndDialog**关闭模态对话框 3、创建动态按钮1.视类→工具箱→对话框编辑器 创建一个按钮。 2.为该按钮添加功能 类向导→选择该对象对应的BN_CLICKED（按钮被单击的消息）消息 123456789101112131415161718192021222324在CTestDlg类添加private: CButton m_btn;//动态按钮对象 BOOL isbtncreate;//判断动态按钮是否被创建，在构造函数中初始化为0void CTestDlg::OnClickedBtnAdd()&#123; // TODO: 在此添加控件通知处理程序代码 //动态创建按钮 //static BOOL isbtncreate = 0; if (isbtncreate == 0)//判断动态按钮是否被创建, &#123; //CButton::Create创建按钮 m_btn.Create(_T(&quot;new&quot;), WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON, CRect(0, 0, 100, 100), this, 123); isbtncreate = 1; &#125; else &#123; m_btn.DestroyWindow();//销毁窗口 isbtncreate = 0; &#125;&#125; 初始化变量的两种方法 1.创建成员变量，并在构造函数中初始化； 2.创建静态局部变量同时初始化。 4、对话框控件1.静态文本控件IDC_STATIC不能响应消息，可通过修改ID来响应消息 **CWnd::GetDlgItem**获取对话框子控件的指针 **CWnd::GetWindowText**获取窗口文本 **CWnd::SetWindowText**设置窗口文本 1234567891011121314void CTestDlg::OnClickedNumber1()&#123; // TODO: 在此添加控件通知处理程序代码 CString str; if (GetDlgItem(IDC_NUMBER1)-&gt;GetWindowText(str),str == &quot;数值1&quot;) //逗号表达式，返回最后一个表达式的值 &#123; GetDlgItem(IDC_NUMBER1)-&gt;SetWindowText(&quot;Number1&quot;); &#125; else &#123; GetDlgItem(IDC_NUMBER1)-&gt;SetWindowText(&quot;数值1&quot;); &#125;&#125; 最后在属性中选中通知（Notify）选项，否则不能向其父窗口发送鼠标事件。 2.编辑框控件🌟GetDlgItem()获取编辑框框窗口对象的指针 1.法一：**GetDlgItem→Get(Set)WindowText** 123456789101112131415161718void CTestDlg::OnClickedBtnAdd()&#123; // TODO: 在此添加控件通知处理程序代码 //编辑框控件法一： CWnd::GetDlgItem()-&gt;Get(Set)WindowText();获取(设置)指定窗口文本 int num1, num2, num3; char ch1[10], ch2[10], ch3[10]; GetDlgItem(IDC_EDIT1)-&gt;GetWindowText(ch1, 10);//(指向存放字符串内存的指针，最大字符数目) GetDlgItem(IDC_EDIT2)-&gt;GetWindowText(ch2, 10); num1 = atoi(ch1);//atoi字符串-&gt;数值 num2 = atoi(ch2); num3 = num1 + num2; _itoa_s(num3, ch3, 10);//itoa数值-&gt;字符串，这里的10代表10进制 GetDlgItem(IDC_EDIT3)-&gt;SetWindowText(ch3);//将ch3中的字符串显示在编辑框中 &#125; 2.法二：**Get(Set)DlgItemText** &#x3D;GetDlgItem+Get(Set)WindowText 12345678910111213141516171819void CTestDlg::OnClickedBtnAdd()&#123; // TODO: 在此添加控件通知处理程序代码 //编辑框控件法二：CWnd::Get(Set)DlgItemText()获取指定控件上的文本 int num1 = 0, num2 = 0, num3 = 0; char ch1[10], ch2[10], ch3[10]; GetDlgItemText(IDC_EDIT1, ch1,10); GetDlgItemText(IDC_EDIT2, ch2,10);//=GetDlgItem + GetWindowText num1 = atoi(ch1); num2 = atoi(ch2); num3 = num1 + num2; _itoa_s(num3, ch3, 10); SetDlgItemText(IDC_EDIT3, ch3);&#125; 改写： 1234567891011121314151617181920void CTestDlg::OnClickedBtnAdd()&#123; // TODO: 在此添加控件通知处理程序代码 //编辑框控件法二：CWnd::Get(Set)DlgItemText()获取指定控件上的文本 int num1 = 0, num2 = 0, num3 = 0;// char ch1[10], ch2[10], ch3[10]; CString str1, str2, str3; GetDlgItemText(IDC_EDIT1, str1); GetDlgItemText(IDC_EDIT2, str2); num1 = atoi(str1); num2 = atoi(str2); num3 = num1 + num2;// str3 = (CString)num3;//错误 C2440 “类型强制转换” : 无法从“int”转换为“CString”//Format是CString类的一个成员函数，它通过格式操作使任意类型的数据转换成一个字符串。 str3.Format(&quot;%d&quot;,num3); SetDlgItemText(IDC_EDIT3, str3);&#125; 3.**CWnd::Get(Set)DlgItemInt**返回指定控件的文本并将其转换为一个整数值。 12345678910void CTestDlg::OnClickedBtnAdd()&#123; int num1 = 0, num2 = 0, num3 = 0; num1 = GetDlgItemInt(IDC_EDIT1); num2 = GetDlgItemInt(IDC_EDIT2); num3 = num1 + num2; SetDlgItemInt(IDC_EDIT3, num3);&#125; 4.控件与整型变量相关联（注意DoDataExchange和UpdateData一起用） 步骤：项目→类向导→成员变量→IDC_EDIT1→添加变量→类别（值）→变量名称→变量类型→其他（最大值、最小值等） 系统为我们创建的代码： 12345678910111213141516171819202122232425262728 /*1、头文件定义*/ // 编辑框与数值变量相关联 int m_num1; int m_num2; int m_num3; /*2、构造函数初始化*/CTestDlg::CTestDlg(CWnd* pParent /*=nullptr*/) : CDialog(IDD_DIALOG1, pParent) //数值变量初始化 , m_num1(0) , m_num2(0) , m_num3(0) &#123; &#125; /*3、DoDataExchange将对话框控件与类成员变量相关联，要配合UpDateDate使用*/ void CTestDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialog::DoDataExchange(pDX); //控件与数值变量关联 DDX_Text(pDX, IDC_EDIT1, m_num1);//DDX_前缀用于数据交换 DDV_MinMaxInt(pDX, IDC_EDIT1, 0, 100);//设定数值范围，DDV_数据校验 DDX_Text(pDX, IDC_EDIT2, m_num2); DDX_Text(pDX, IDC_EDIT3, m_num3); &#125; 自己编写的代码： 123456789 void CTestDlg::OnClickedBtnAdd()&#123; //法四：控件与数值变量相关联 UpdateData();//和DoDataExchange配合使用，参数为TRUE(缺省)：函数获取对话框数据 m_num3 = m_num1 + m_num2; UpdateData(FALSE);//参数为FALSE：以变量的值来初始化对话框控件&#125; 自动消息提示框： 5.控件与控件变量相关联 123456789101112131415161718系统自动添加 /*1、头文件定义*/ //编辑框与控件变量相关联 CEdit m_edit1; CEdit m_edit2; CEdit m_edit3; /*2、DoDataExchange将对话框控件与类成员变量相关联，要配合UpDateDate使用*/ void CTestDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialog::DoDataExchange(pDX); //控件与控件变量关联 DDX_Control(pDX, IDC_EDIT1, m_edit1); DDX_Control(pDX, IDC_EDIT2, m_edit2); DDX_Control(pDX, IDC_EDIT3, m_edit3); 12345678910111213141516手动添加 //法五：控件与控件变量相关联 int num1 = 0, num2 = 0, num3 = 0; char ch1[10], ch2[10], ch3[10]; m_edit1.GetWindowText(ch1, 10); m_edit2.GetWindowText(ch2, 10); num1 = atoi(ch1); num2 = atoi(ch2); num3 = num1 + num2; _itoa_s(num3, ch3, 10); m_edit3.SetWindowText(ch3); 6.**SendMessage()**发送消息 1234567891011121314 int num1 = 0, num2 = 0, num3 = 0; char ch1[10], ch2[10], ch3[10]; ::SendMessage(GetDlgItem(IDC_EDIT1)-&gt;m_hWnd, WM_GETTEXT, 10, (LPARAM)ch1);//获取编辑框窗口对象的指针 ::SendMessage(m_edit2.m_hWnd, WM_GETTEXT, 10, (LPARAM)ch2);//第一个参数直接利用控件变量获取句柄//Windows系统中，获取文本的消息是WM_GETTEXT，将系统指定窗口的文本复制到调用者提供的一个缓存中//wParam指定复制的字符数，lParam保存窗口文本的缓存地址 num1 = atoi(ch1); num2 = atoi(ch2); num3 = num1 + num2; _itoa_s(num3, ch3, 10); m_edit3.SendMessage(WM_SETTEXT, 0, (LPARAM)ch3);//WM_SETTEXT设置窗口文本的消息，lParam指定设置窗口文本的字符串地址 7.**SendDlgItemMessage()**直接给对话框的子控件发送消息 12345678910111213//法七：int num1 = 0, num2 = 0, num3 = 0;char ch1[10], ch2[10], ch3[10];SendDlgItemMessage(IDC_EDIT1, WM_GETTEXT, 10, (LPARAM)ch1);SendDlgItemMessage(IDC_EDIT2, WM_GETTEXT, 10, (LPARAM)ch2);num1 = atoi(ch1);num2 = atoi(ch2);num3 = num1 + num2;_itoa_s(num3, ch3, 10);SendDlgItemMessage(IDC_EDIT3, WM_SETTEXT, 0, (LPARAM)ch3); 补充： 12345678 //设置复选内容 SendDlgItemMessage(IDC_EDIT3, EM_SETSEL, 1, 3);// EM_GETSEL获得编辑框中的复选内容//EM_SETSEL设置……，EM表示Edit Control Message//wParam接收复选内容开始位置，lParam ……结束位置.//wParam=0，lParam=-1,表示所有文本 m_edit3.SetFocus();//设置光标 5、对话框的伸缩CWnd::SetWindowPosBOOL SetWindowPos (const CWnd* pWndInsertAfter, int x, int y, int cx, int cy, UINT nFlags)&#x2F;&#x2F; 设置窗口位置、大小、z次序等 CWnd::GetDlgItemThis method retrieves a pointer to the specified control or child window in a dialog box or other window. The pointer returned is usually cast to the type of control identified by nID.CWnd GetDlgItem (int* nID )const; CWnd::SetDlgItemTextvoid SetDlgItemText(int nID, LPCTSTR lpszString);&#x2F;&#x2F; 将nID中的文本设置为_lpszString_ CWnd::GetWindowRectvoid GetWindowRect(LPRECT lpRect)const;&#x2F;&#x2F; 获得窗口尺寸 CRect::IsRectNull CRect::IsRectEmpty 12345678910111213141516171819202122232425262728293031323334void CTestDlg::OnBnClickedButton1()&#123; // TODO: 在此添加控件通知处理程序代码 CString str; if (GetDlgItemText(IDC_BUTTON1,str),str == &quot;收缩&lt;&lt;&quot;) &#123; SetDlgItemText(IDC_BUTTON1, &quot;括展&gt;&gt;&quot;); &#125; else &#123; SetDlgItemText(IDC_BUTTON1, &quot;收缩&lt;&lt;&quot;); &#125; static CRect rectlarge;//原对话框尺寸 static CRect rectsmall;//切割后的尺寸 if (rectlarge.IsRectNull())//判断矩形区域是否为空 &#123; CRect rectseparator;//分割线的尺寸 GetDlgItem(IDC_SEPARATOR)-&gt;GetWindowRect(rectseparator);//获得分割线的尺寸 GetWindowRect(rectlarge);//获得原对话框的尺寸 rectsmall.top = rectlarge.top; rectsmall.left = rectlarge.left; rectsmall.right = rectlarge.right; rectsmall.bottom = rectseparator.bottom;//将对话框底部的尺寸更改 &#125; if (str == &quot;收缩&lt;&lt;&quot;) &#123; SetWindowPos(NULL, 0, 0, rectsmall.Width(), rectsmall.Height(), SWP_NOMOVE | SWP_NOZORDER);//设置窗口的位置和大小 &#125; else &#123; SetWindowPos(NULL, 0, 0, rectlarge.Width(), rectlarge.Height(), SWP_NOMOVE | SWP_NOZORDER); &#125;&#125; 6、输入焦点的传递1234567891011121314151617181920212223242526272829303132333435363738394041void CTestDlg::OnBnClickedOk()//注释掉默认的OnOK&#123; GetNextDlgTabItem(GetFocus())-&gt;SetFocus();//按照TAB顺序循环查找【格式】-&gt;【TAB顺序】// CDialog::OnOK();&#125;WNDPROC prevproc;//窗口过程类型，接收先前的窗口过程。窗口过程函数是全局函数，里面的函数不能再用CWnd的成员函数，只能用API函数LRESULT CALLBACK WinEnterProc//windowproc函数( HWND hwnd, // handle to window UINT uMsg, // message identifier WPARAM wParam, // first message parameter LPARAM lParam // second message parameter)&#123; if (uMsg == WM_CHAR &amp;&amp; wParam == 0x0d) &#123;// ::SetFocus(::GetNextWindow(hwnd, GW_HWNDNEXT));// ::SetFocus(::GetWindow(hwnd, GW_HWNDNEXT)); ::SetFocus(::GetNextDlgTabItem(::GetParent(hwnd), hwnd, 0));//SetFocus设置焦点，GetFocus得到焦点 //GetNextWindow、GetWindow获得下一个窗口的句柄 //GetNextDlgTabItem按照TAB顺序转移焦点// return 1; &#125; else//按下的按键不是回车，让先前的窗口过程来处理 &#123; return prevproc(hwnd,uMsg,wParam,lParam); &#125;&#125;BOOL CTestDlg::OnInitDialog()//对话框及其子控件创建完成将要显示之前调用。虚函数。 CDialog::OnInitDialog(); // TODO: 在此添加额外的初始化 //SetWindowLong修改指定窗口的属性，本例修改已指定的过程函数 prevproc = (WNDPROC)SetWindowLong(GetDlgItem(IDC_EDIT1)-&gt;m_hWnd, GWL_WNDPROC/*设置新的窗口过程地址*/, (LONG)WinEnterProc/*新的窗口过程地址*/); return TRUE; // return TRUE unless you set the focus to a control // 异常: OCX 属性页应返回 FALSE&#125; 7、默认按钮的说明收缩按钮设置为默认按钮，即在其属性对话框中选择default button选项，就不会再由CTestDlg类的OnOK函数来响应。当用户按下回车键时，windows将查看对话框中是否存在默认按钮, 如果没有默认按钮，就会调用虚拟的OnOK函数, 即没有默认ok按钮。这个默认OnOK函数的ID是IDOK。而不是IDC_OK. 第八章 对话框21、逃跑按钮&#x2F;*逃跑按钮创建过程1、创建新类（专注于逃跑功能）*存储地址的变量*OnMouseMove()2、CTestDlg.h控件与控件变量关联，即创建了新类的对象3、CTestDlg.cpp的OnInitDialog()中两个对象存储对方首地址4、鼠标移动OnMouseMove()接收WM_MOUSEMOVE消息，执行程序*&#x2F; 2、属性表单的创建一个属性表单是由一个或多个属性页组成，属性页对应MFC中的CPropertyPage类，一个属性页的标题就是选项卡的名称。 步骤： 1、创建属性页 2、添加控件 组框Group Box 单选按钮Radio Button 复选框Check Box 列表框控件List Box 静态文本控件Static Box 组合框Combo Box simple，能输入，总是显示列表框 dropdown，能输入只有单击下拉列表后，列表框才弹出 droplist,只读，只能从下来列表选择内容 3、为对话框资源创建新类 1.创建新类步骤：参考1，在“添加MFC类”中添加类名与ID号一致，基类中选择相应的类型 属性页CPropertyPage 属性表单CPropertySheet 2.在属性表单（CPropSheet）中，创建三个属性页对象，并在构造函数中初始化。用AddPage将属性页添加进属性表单，构造函数指明了2中实例化对象的方法（ID&#x2F;字符串） CPropSheet::AddPage将属性页添加到属性表单中 OnPropertysheet::DoModal()创建模态属性表单 1234567891011121314151617181920212223 /*定义*/ //自定义成员变量 PROP1 m_prop1; PROP2 m_prop2; PROP3 m_prop3; /*初始化*/ CPropSheet::CPropSheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage) :CPropertySheet(nIDCaption, pParentWnd, iSelectPage)//用ID号来构造属性表单&#123; //初始化属性页 AddPage(&amp;m_prop1);//CPropSheet::AddPage将属性页添加到属性表单中 AddPage(&amp;m_prop2); AddPage(&amp;m_prop3);&#125;CPropSheet::CPropSheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage) :CPropertySheet(pszCaption, pParentWnd, iSelectPage)//用字符串来构造属性表单&#123; AddPage(&amp;m_prop1); AddPage(&amp;m_prop2); AddPage(&amp;m_prop3);&#125; 3.在视类中创建菜单命令响应函数，用字符串实例化属性表单对象，并用DoModal创建模态属性表单 1234567void CpropView::OnPropertysheet()&#123; // TODO: 在此添加命令处理程序代码 CPropSheet propsheet(&quot;属性表单&quot;);//使用字符串构造属性表单对象// propsheet.SetWizardMode();//创建向导样式时添加 propsheet.DoModal();//创建模态属性表单&#125; 3、向导的创建1、更改向导底部按钮CPropertySheet::SetWizardButtons 12345678910BOOL PROP1::OnSetActive()//右键PROP1类-&gt;类向导-&gt;虚函数-&gt;OnSetActive-&gt;编辑代码&#123; // TODO: 在此添加专用代码和/或调用基类 CPropertySheet* psheet = (CPropertySheet*)GetParent();//属性页的父窗口属性表单，并将CWnd*转换为CPropertySheet* psheet-&gt;SetWizardButtons(PSWIZB_NEXT);//CPropertySheet::SetWizardButtons设置对话框上的按钮 return CPropertyPage::OnSetActive();&#125;PROP2,PROP3过程类似，SetWizardButtons参数不同。 1、设置第一个属性页 将第一个单选按钮设置为Group属性以添加成员变量。第一个单选按钮设置为Group后，之后的按钮和这个按钮属于同一组，直到遇到下一个Group。同一组内的控件关联的成员变量的值依次为1、2、3… 单击【下一步】，调用OnWizardNext()虚函数 12345678910111213141516171819202122232425262728293031323334353637/*PROP1.h*/ int m_occupation;/*PROP1.cpp*/ //构造函数PROP1::PROP1() : CPropertyPage(IDD_PROP1) , m_occupation(-1)&#123;&#125;//数据交换void PROP1::DoDataExchange(CDataExchange* pDX)&#123; CPropertyPage::DoDataExchange(pDX); DDX_Radio(pDX, IDC_RADIO1, m_occupation);//单选按钮和成员变量之间的数据交换&#125;//判断LRESULT PROP1::OnWizardNext()//单击【下一步】，调用OnWizardNext()虚函数&#123; // TODO: 在此添加专用代码和/或调用基类 UpdateData();//系统通过调用UpdateData()来调用DoDataExchange以完成控件与变量的数据交换 //TRUE从控件得到成员变量的值。 FAUSE用成员变量的值初始化控件 if (m_occupation == -1)//用户没有选择职业 &#123; MessageBox(&quot;请选择职业！&quot;); return -1;//OnWizardNext()返回0，进入下一个属性 //返回-1，禁止属性页变更 &#125; if (m_workaddress == &quot;&quot; )//工作地点为空 &#123; MessageBox(&quot;请选择工作地点！&quot;); return -1; &#125; return CPropertyPage::OnWizardNext();//进入下一个页面&#125; 12345678910111213BOOL PROP1::OnInitDialog()&#123; CPropertyPage::OnInitDialog(); // TODO: 在此添加额外的初始化 CListBox* listbox = (CListBox*)GetDlgItem(IDC_LIST1); listbox-&gt;AddString(&quot;北京&quot;);//CListBox::AddString添加字符串到列表框 listbox-&gt;AddString(&quot;天津&quot;); listbox-&gt;AddString(&quot;上海&quot;); return TRUE; // return TRUE unless you set the focus to a control // 异常: OCX 属性页应返回 FALSE&#125; 2、设置第二个属性页 操作类似第一个属性页 1234567891011121314LRESULT PROP2::OnWizardNext()&#123; // TODO: 在此添加专用代码和/或调用基类 UpdateData(); if (m_football || m_basketball || m_volleyball || m_swim) &#123; return CPropertyPage::OnWizardNext(); &#125; else &#123; MessageBox(&quot;请选择那你的兴趣爱好！&quot;); return -1;//返回-1，禁止属性页变更 &#125;&#125; 3、设置第三个属性页 CComboBox::AddString向组合框的列表框中添加字符串选项 CComboBox::SetCurSel选择列表框中的一个字符串，并将其显示在该组合框的编辑框中 12345678910111213141516BOOL PROP3::OnInitDialog()&#123; CPropertyPage::OnInitDialog(); //组合框控件由一个编辑框和一个列表框组成 //CComboBox::AddString向组合框的列表框中添加字符串选项 //CComboBox::SetCurSel(set current selection)选择列表框中的一个字符串，并将其显示在该组合框的编辑框中 CComboBox* combobox = (CComboBox*)GetDlgItem(IDC_COMBO1); combobox-&gt;AddString(&quot;1000元以下&quot;); combobox-&gt;AddString(&quot;1000元-2000元&quot;); combobox-&gt;AddString(&quot;2000元-3000元&quot;); combobox-&gt;AddString(&quot;3000元以上&quot;);//取消属性框中的排序功能以关闭自动排序 combobox-&gt;SetCurSel(0); return TRUE; // return TRUE unless you set the focus to a control // 异常: OCX 属性页应返回 FALSE&#125; CComboBox::GetCurSel得到当前选项的索引值 CComboBox::GetLBText得到对应索引值的文本并存储在字符串中 1234567891011/*提取用户的薪资选项，并存储在m_strsalary中*/BOOL PROP3::OnWizardFinish()&#123; // TODO: 在此添加专用代码和/或调用基类 int index; CComboBox* combobox = (CComboBox*)GetDlgItem(IDC_COMBO1); index = combobox -&gt;GetCurSel();//得到当前选项的索引值 combobox-&gt;GetLBText(index, m_strsalary);//得到对应索引值的文本并存储在字符串m_strsalary中 return CPropertyPage::OnWizardFinish();&#125; 4、将结果在视类显示 memset初始化数组 Invalidate();&#x2F;&#x2F;让视类窗口无效，从而引起重绘，然后在OnDraw中完成信息的输 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106 /*propView.h*/ //自定义成员变量 int m_ioccupation; //职业 CString m_strworkaddress;//工作地点 BOOL m_blike[4];//爱好 CString m_strsalary;//薪资水平 /*propView.cpp*/ //构造函数中初始化CpropView::CpropView() noexcept&#123; // TODO: 在此处添加构造代码 m_ioccupation = -1; //职业,对于一个组，未选为-1 m_strworkaddress = &quot;&quot;;//工作地点 memset(m_blike , 0 , sizeof(m_blike));//爱好,将m_blike内存的sizeof(m_blike)个字节设为0 m_strsalary = &quot;&quot;;//薪资水平&#125;/*一般情况下，CPropertySheet 类的 DoModal 函数的返回值是 IDOK 或 IDCANCEL。但是如果属性表单已经被创建为向导了,那么该函数的返回值将是 ID_WIZFINISH 或 IDCANCEL.因此,在程序中应该对属性表单对象的 DoModal 函数的返回值进行判断，如果返回的是【完成】按钮的 ID:ID_WIZFINISH，那么才进行输出处理。*/void CpropView::OnPropertysheet()//菜单项响应函数&#123; // TODO: 在此添加命令处理程序代码 CPropSheet propsheet(&quot;属性表单&quot;);//使用字符串构造属性表单对象 propsheet.SetWizardMode();//设置向导样式// propsheet.DoModal();//创建模态属性表单 if (ID_WIZFINISH == propsheet.DoModal())//属性表单被创建向导，DoModal()返回ID_WIZFINISH &#123; m_ioccupation = propsheet.m_prop1.m_occupation;//向导.属性页.属性页成员 m_strworkaddress = propsheet.m_prop1.m_workaddress; m_blike[0] = propsheet.m_prop2.m_football; m_blike[1] = propsheet.m_prop2.m_basketball; m_blike[2] = propsheet.m_prop2.m_volleyball; m_blike[3] = propsheet.m_prop2.m_swim; m_strsalary = propsheet.m_prop3.m_strsalary; Invalidate();//让视类窗口无效，从而引起重绘，然后在OnDraw中完成信息的输出 &#125;&#125;//窗口重绘void CpropView::OnDraw(CDC* pDC)&#123; CpropDoc* pDoc = GetDocument(); ASSERT_VALID(pDoc); if (!pDoc) return; // TODO: 在此处为本机数据添加绘制代码 CFont font; font.CreatePointFont(100, &quot;宋体&quot;,pDC);//创建字体 CFont* pfont; pfont = pDC-&gt;SelectObject(&amp;font);//将字体选入设备描述表，并保存旧字体 //职位 CString position; position = &quot;你的职业:&quot;; switch (m_ioccupation) &#123; case 0: position += &quot;程序员&quot;; break; case 1: position += &quot;系统工程师&quot;; break; case 2: position += &quot;项目经理&quot;; break; &#125; pDC-&gt;TextOut(0, 0, position);//将文本展示在视类窗口 TEXTMETRIC tm; pDC-&gt;GetTextMetrics(&amp;tm); //工作地点 CString workplace; workplace = &quot;你的工作地点:&quot;; workplace += m_strworkaddress; pDC-&gt;TextOut(0, tm.tmHeight, workplace); //兴趣爱好 CString hobby; hobby = &quot;你的爱好:&quot;; if (m_blike[0]) hobby += &quot;足球 &quot;; if (m_blike[1]) hobby += &quot;篮球 &quot;; if (m_blike[2]) hobby += &quot;排球 &quot;; if (m_blike[3]) hobby += &quot;游泳 &quot;; pDC-&gt;TextOut(0, tm.tmHeight*2, hobby); //薪资 CString salary; salary = &quot;你的薪资水平:&quot;; salary += m_strsalary; pDC-&gt;TextOut(0, tm.tmHeight*3, salary); pDC-&gt;SelectObject(pfont);&#125; 第九章 定制应用程序外观4、工具栏编程ToolBar1.在工具栏上添加、删除按钮 创建按钮：按钮和菜单项用一样的ID 按钮之间的分隔符：用鼠标把按钮向右拖动一段距离 删除按钮：将按钮脱出工具栏 2.创建工具栏 分析系统创建的工具栏 1234567891011121314151617181920cmainframe头文件中CToolBar m_wndToolBar;cmainframe.cpp中int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)&#123;......if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) || !m_wndToolBar.LoadToolBar(IDR_MAINFRAME)) &#123; TRACE0(&quot;未能创建工具栏 &quot;); return -1; // 未能创建 &#125; .... // TODO: 如果不需要可停靠工具栏，则删除这三行 m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);//工具栏对象的成员函数EnableDocking，表示工具栏对象可以停靠 //CBRS_ALIGN_ANY允许停靠在任意位置 EnableDocking(CBRS_ALIGN_ANY);//CFrameWnd对象的EnableDocking成员函数，表示主框架窗口可以被停靠 DockControlBar(&amp;m_wndToolBar);//工具栏停靠在主框架窗口上 创建自定义工具栏(参照系统工具栏) 1.新建ToolBar资源 2.构造ToolBar对象 3.调用Create函数创建工具栏，并将其与ToolBar对象关联 4.LoadToolBar加载工具栏 5.设置停靠位置 12345678910111213141516头文件 CToolBar m_newtoolbar;//2.构造ToolBar对象 源文件 if (!m_newtoolbar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_RIGHT | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) || !m_newtoolbar.LoadToolBar(IDR_TOOLBAR1))//3.调用Create函数创建工具栏，并将其与ToolBar对象关联//4.LoadToolBar加载工具栏 &#123; TRACE0(&quot;未能创建工具栏 &quot;); return -1; // 未能创建 &#125; //5.设置停靠位置 m_newtoolbar.EnableDocking(CBRS_ALIGN_ANY); DockControlBar(&amp;m_newtoolbar); 改进方法**CFrameWnd::ShowControlBar**隐藏或显示指定的控制条 12345678910111213141516171819202122void CMainFrame::OnViewNewtoolbar()&#123; /* if (!m_newtoolbar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_RIGHT | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) || !m_newtoolbar.LoadToolBar(IDR_TOOLBAR1)) &#123; TRACE0(&quot;未能创建工具栏 &quot;); return -1; // 未能创建 m_newtoolbar.EnableDocking(CBRS_ALIGN_ANY); DockControlBar(&amp;m_newtoolbar); */ ShowControlBar(&amp;m_newtoolbar, !m_newtoolbar.IsWindowVisible(), 1);&#125;void CMainFrame::OnUpdateViewNewtoolbar(CCmdUI* pCmdUI)&#123; // 在菜单项前添加标记,见第六章 pCmdUI-&gt;SetCheck(m_newtoolbar.IsWindowVisible());&#125; 5、状态栏StatusBar步骤： 1.在资源视图String Table中添加响应的ID 2.在源文件中将响应的ID添加进indicator（状态行指示器）中 系统创建的状态栏 12345678910111213141516171819 CStatusBar m_wndStatusBar;//定义默认状态栏对象static UINT indicators[] =&#123; ID_SEPARATOR, // 状态行指示器 ID_INDICATOR_CAPS, ID_INDICATOR_NUM, ID_INDICATOR_SCRL,// IDS_TIMER,// IDS_PROGRESS,&#125;; //OnCreate()中 if (!m_wndStatusBar.Create(this))//创建状态栏对象 &#123; TRACE0(&quot;未能创建状态栏 &quot;); return -1; // 未能创建 &#125; m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));//设置状态指示器(数组设置状态栏内容，数组元素个数) 123456789101112131415在OnTimer()中添加//在状态栏显示动态变化的系统时间 CTime time;//接收系统时间 CString str;//系统时间文本 CClientDC dc(this);//调用GetTextExtent() CSize sz;//接收时间字符串大小 int indicatorindex = 0;//indicator索引 time = CTime::GetCurrentTime();//获取系统时间保存进time中 str = time.Format(&quot;%H:%M:%S&quot;);//将time中的时间格式化 indicatorindex = m_wndStatusBar.CommandToIndex(IDS_TIMER);//获取ID在indicator中的索引 sz = dc.GetTextExtent(str);//获取文本显示宽度 m_wndStatusBar.SetPaneInfo(indicatorindex, IDS_TIMER, SBPS_NORMAL, sz.cx);//设置状态栏右侧小窗口属性 m_wndStatusBar.SetPaneText(indicatorindex, str);//将str显示到indicator数组对应的小窗口 6、进度栏CProgressCtrl::Create&#x2F;&#x2F;进度栏类CProgressCtrlBOOL Create( DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID);&#x2F;&#x2F; 创建进度栏 CProgressCtrl::SetPosint SetPos( int nPos);&#x2F;&#x2F; 设置进度栏当前进度 CStatusBar::GetItemRectvoid GetItemRect(int nIndex,LPRECT lpRect)const;&#x2F;&#x2F; 得到状态栏小窗格大小 🌟补充消息响应过程 1.头文件声明（定义）函数afx_msg LRESULT OnProgress(WPARAM, LPARAM); 2.消息与函数关联ON_MESSAGE(UM_PROGRESS, &amp;OnProgress) 3.实现函数LRESULT CMainFrame::OnProgress(WPARAM wParam, LPARAM lParam) 123456789101112131415161718void CMainFrame::OnPaint()//窗口大小发生变化-&gt;窗口重绘-&gt;重新获得rect&#123; CPaintDC dc(this); // device context for painting // TODO: 在此处添加消息处理程序代码 // 不为绘图消息调用 CFrameWnd::OnPaint() CRect rect; m_wndStatusBar.GetItemRect(5, &amp;rect);//获得窗格大小并储存在rect中 if (!m_progress.m_hWnd)//如果句柄没有值，说明对象没有创建 &#123; m_progress.Create(WS_VISIBLE | WS_CHILD | PBS_SMOOTH, rect, &amp;m_wndStatusBar, 123);//创建进度栏，WS_CHILD:The window is a child window. &#125; else &#123; m_progress.MoveWindow(rect);//移动窗格，The CRect object or RECT structure that specifies the new size and position. &#125; m_progress.SetPos(50);//设置进度&#125; 7、在状态栏上显示鼠标当前位置123456789101112131415161718void CstyleView::OnMouseMove(UINT nFlags, CPoint point)//视类中捕获鼠标移动的消息WM_MOUSEMOVE&#123; // TODO: 在此添加消息处理程序代码和/或调用默认值 CString str; str.Format(&quot;x = %d y = %d&quot;,point.x, point.y);//格式化鼠标位置 ((CMainFrame*)GetParent())-&gt;m_wndStatusBar.SetWindowText(str); /*上述代码中，首先格式化鼠标当前位置的信息。然后为了把该信息显示在状态栏的第一个窗格上，需要获取状态栏对象。而状态栏对象是在框架类窗口中定义的，同时，框架类窗口是视类窗口的父窗口，因此在视类对象中通过调用 GetParent 函数就可以得到视类的父窗口，即框架窗口。因为该函数返回的是一个CWnd 类型的指针，而这里需要的是 CMainFrame 类型的指针，所以需要进行一个转换。然后利用框架窗口对象去调用该对象内部的状态栏成员变量：m_wndStatusBar，以得到状态栏对象，*/ /*因为上述代码用到了框架类的类型，所以要在头文件中包含框架类头文件*/ CView::OnMouseMove(nFlags, point); &#125; 十、绘图控制1、简单绘图CPen pen SelectObject GetStockObject FromHandle SetPixel Rectangle Ellipse 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/*头文件*///自定义成员变量private: UINT m_nDrawType;//标记用户选择那种图形 CPoint m_ptOrigin;//保存鼠标左键按下的点/*构造函数*/CGraphicView::CGraphicView() noexcept&#123; // TODO: 在此处添加构造代码 m_nDrawType = 0;//初始化绘图图形类型 m_ptOrigin = 0;&#125;/*视类消息处理程序*/void CGraphicView::OnDot()//点&#123; // TODO: 在此添加命令处理程序代码 m_nDrawType = 1;&#125;void CGraphicView::OnLine()//直线&#123; // TODO: 在此添加命令处理程序代码 m_nDrawType = 2;&#125;void CGraphicView::OnRectangle()//矩形&#123; // TODO: 在此添加命令处理程序代码 m_nDrawType = 3;&#125;void CGraphicView::OnEllipse()//椭圆&#123; // TODO: 在此添加命令处理程序代码 m_nDrawType = 4;&#125;void CGraphicView::OnLButtonDown(UINT nFlags, CPoint point)&#123; // TODO: 在此添加消息处理程序代码和/或调用默认值 m_ptOrigin = point;//保存鼠标左键按下的位置 CView::OnLButtonDown(nFlags, point);&#125;void CGraphicView::OnLButtonUp(UINT nFlags, CPoint point)//鼠标左键抬起，实现绘图功能&#123; // TODO: 在此添加消息处理程序代码和/或调用默认值 CClientDC dc(this);//绘图操作首先要有DC对象 CPen pen(PS_SOLID, 10, RGB(255,0,0));//线条的颜色由DC中的画笔颜色确定，构造CPen对象并指定其颜色 dc.SelectObject(&amp;pen);//将画笔选入设备描述表 //加载资源用LoadBitmap等，CDC对象用SelectObject(&amp;xxx) CBrush* pBrush = CBrush::FromHandle((HBRUSH)GetStockObject(NULL_BRUSH));//GetStockObject调用NULL_BRUSH创建透明画刷 //CBrush的静态成员变量FromHandle将画刷句柄转化为指向画刷对象的指针 //FromHandle的参数是HBRUSH类型，强制类型转化 dc.SelectObject(pBrush);//将画刷选入设备描述表 switch (m_nDrawType) &#123; case 1: dc.SetPixel(point, RGB(255,0,0));//在指定的点设置一个像素 break; case 2: dc.MoveTo(m_ptOrigin); dc.LineTo(point); break; case 3: dc.Rectangle(CRect(m_ptOrigin,point));//利用CRect对象绘制矩形 break; case 4: dc.Ellipse(CRect(m_ptOrigin, point));//绘制椭圆 default: break; &#125; CView::OnLButtonUp(nFlags, point);&#125; 注意将CDC对象加入设备miaoshub； 注意静态成员函数的调用方式：要声明是哪个类的。 2、线宽线型（设置对话框）1、将设置对话框创建一个新的对话框类 2、在主菜单添加设置菜单项并设置消息响应函数 3、控件关联无符号整型变量，View类创建同类型变量以保存其值 12345678910111213void CGraphicView::OnSetting()&#123; // TODO: 在此添加命令处理程序代码 CSettingDlg dlg;//实例化设置对话框对象 dlg.m_nLineWidth = m_nLineWidth;//保持之前设置过的线宽 dlg.m_nLineStyle = m_nLineStyle;//保持之前设置过的线型 if (IDOK == dlg.DoModal()) &#123; m_nLineWidth = dlg.m_nLineWidth;//保存新设置的值 m_nLineStyle = dlg.m_nLineStyle;//保存设置的线型，WINGDI.h定义了一些符号常量，包括线型 //本例设置的对话框的线型排序正好按照WINGDI.h的顺序定义 &#125;&#125; 3、颜色对话框CColorDialog默认颜色对话框类了解（m_cc、CHOOSECOLOR、rgbResult、Flags (CC_RGBINIT)） 12345678910111213141516void CGraphicView::OnColor()&#123; // TODO: 在此添加命令处理程序代码 CColorDialog colordlg;//CColorDialog颜色对话框类 colordlg.m_cc.Flags |= CC_RGBINIT;//设置颜色对话框初始选择的颜色，需要设置该对话框的CC_RGBINIT标记 /*实际上，当在创建 CColorDialog 对象 dlg 时，它的数据成员 m_cc 中的 Flags 成员已经具有了一些初始的默认标记。 当我们将 CC_RGBINTT 标记直接赋给 Flags 成员时，就相当于将 Flags 成员初始默认的标记都去掉了。 这里不能给 Flags 标记直接赋值，应利用或操作（|）将CC_RGBINIT 标记与 Flags 先前的标记组合起来。*/ colordlg.m_cc.rgbResult = m_ctr;//保持之前设置过的颜色 if (IDOK == colordlg.DoModal())//创建颜色对话框 &#123; m_ctr = colordlg.m_cc.rgbResult;//CColorDialog类有一个结构体类型的变量m_cc //CHOOSECOLOR结构体的rgbResult变量保存了用户选择的颜色 //将用户选择的颜色保存在m_ctr中 &#125;&#125; 4、字体对话框DeleteObject释放这个字体资源 CFont::CreateFontIndirect利用lpLogFont指向的LOGFONT结构体中的一些特征初始化CFont对象 Invalidate()引起窗口重绘 1234567891011121314151617181920212223242526272829303132头文件CFont m_font;//字体对象CString m_strFontName;//保存所选字体的名称源文件void CGraphicView::OnFont()&#123; // TODO: 在此添加命令处理程序代码 CFontDialog fontdlg;//字体对话框对象 if (IDOK == fontdlg.DoModal()) &#123; if (m_font.m_hObject) /*利用CGdiobject 对象的数据成员 m_hObject 来判断 m_font 对象是否已经与某个字体资源相关联了， 该变量保存了与CGdiObject对象相关联的Windows GDI 的资源句柄。 如果已经有关联了，则调用 DeleteObject 释放这个字体资源*/ &#123; m_font.DeleteObject(); &#125; m_font.CreateFontIndirect(fontdlg.m_cf.lpLogFont);//CFont::CreateFontIndirect利用lpLogFont指向的LOGFONT结构体中的一些特征初始化CFont对象 m_strFontName = fontdlg.m_cf.lpLogFont-&gt;lfFaceName;//lfFaceName保存了字体名字 Invalidate(); /*窗口的客户区无效意味着需要重绘，例如，如果一个被其它窗口遮住的窗口变成了前台窗口， 那么原来被遮住的部分就是无效的，需要重绘。这时Windows会在应用程序的消息队列中放置WM_PAINT消息。 MFC为窗口类提供了WM_PAINT的消息处理函数OnPaint，OnPaint负责重绘窗口。 视图类有一些例外，在视图类的OnPaint函数中调用了OnDraw函数，实际的重绘工作由OnDraw来完成。*/ /*系统会在多个不同的时机发送WM_PAINT消息： 当第一次创建一个窗口时，当改变窗口的大小时，当把窗口从另一个窗口背后移出时，当最大化或最小化窗口时，等等， 这些动作都是由系统管理的，应用只是被动地接收该消息，在消息处理函数中进行绘制操作； 大多数的时候应用也需要能够主动引发窗口中的绘制操作，比如当窗口显示的数据改变的时候， 这一般是通过InvalidateRect和 InvalidateRgn函数来完成的。*/ &#125;&#125; 5、示例对话框1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void CSettingDlg::OnChangeLineWidth()//对编辑框控件中的文本改变时，会向父窗口发送EN_CHANGE消息&#123; Invalidate();//让窗口重绘以在OnPaint中完成示例线条的绘制&#125;void CSettingDlg::OnClickedRadio1()//单击Radio Button时，按钮会向对话框发送BN_CLICKED消息&#123; Invalidate();&#125;void CSettingDlg::OnClickedRadio2()&#123; // TODO: 在此添加控件通知处理程序代码 Invalidate();&#125;void CSettingDlg::OnClickedRadio3()&#123; // TODO: 在此添加控件通知处理程序代码 Invalidate();&#125;void CSettingDlg::OnPaint()&#123; CPaintDC dc(this); // device context for painting // TODO: 在此处添加消息处理程序代码 // 不为绘图消息调用 CDialog::OnPaint() UpdateData();//当控件与一个成员变量相关联时，如果想让控件上的值反应到成员变量上，必须调用UpdateData() CPen pen(m_nLineStyle, m_nLineWidth, m_clr); dc.SelectObject(&amp;pen); CRect rect; GetDlgItem(IDC_SAMPLE)-&gt;GetWindowRect(&amp;rect); /*要想在组框中绘图，那么首先要得到组框的矩形区域范围。 这可以通过调用GetDlgltem 函数来得到指向组框窗口对象的指针， 然后利用 GetWindowRect 函数获得组框窗口矩形区域的大小,参数是指向CRect或RECT结构体的变量，接收屏幕坐标 需要提醒读者注意的是，这里不能直接调用 GetWindowRect 函数，否则得到的将是对话框的矩形区域大小。*/ ScreenToClient(&amp;rect);//得到矩形区域的大小后，将其原点从屏幕坐标转化为客户坐标（即将应用程序坐标转化为设置对话框坐标） dc.MoveTo(rect.left+20,rect.top+rect.Height()/2);//组框左上角的y值+矩形区域高度的一半，即将线条移动到示例窗口中间 dc.LineTo(rect.right - 20, rect.top + rect.Height() / 2);&#125; 6、改变对话框及其控件的背景和文本WM_CTLCOLOR1、改变对话框及其控件的背景 123456789101112131415161718192021222324252627282930//头文件声明 CBrush m_brush;//画刷//构造函数初始化 m_clr = RGB(255,0,0); m_brush.CreateSolidBrush(RGB(0,0,255));//利用CreateSolidBrush函数将m_brush初始化画刷颜色//消息响应函数HBRUSH CSettingDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)//每一个控件（对话框和子控件）在绘制时都发送WM_CTLCOLOR消息&#123; HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor); // TODO: 在此更改 DC 的任何特性 // TODO: 如果默认的不是所需画笔，则返回另一个画笔 if (IDC_LINE_STYLE == pWnd-&gt;GetDlgCtrlID())//判断是否为线型组框 &#123; pDC-&gt;SetTextColor(RGB(255,0,0));//设置文本颜色为红色 pDC-&gt;SetBkMode(TRANSPARENT);//将控件上的文字背景设置为透明 return m_brush;//如果想要改变背景颜色，只需要自定义一个画刷，然后让OnColor函数返回这个画刷句柄即可 &#125; if (IDC_LINE_WIDTH == pWnd-&gt;GetDlgCtrlID()) &#123; pDC-&gt;SetTextColor(RGB(255, 0, 0));// pDC-&gt;SetBkMode(TRANSPARENT); pDC-&gt;SetBkColor(RGB(255, 0, 0));//设置窗口背景色 return m_brush; &#125; return hbr;&#125; 2、改变控件的文本 123456789101112131415161718192021//头文件声明private: CFont m_font;//改变控件上的文本字体 //构造函数初始化 m_font.CreatePointFont(200,&quot;华文行楷&quot;);//初始化字体 //消息响应函数 HBRUSH CSettingDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)//每一个控件（对话框和子控件）在绘制时都发送WM_CTLCOLOR消息&#123; HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor); // TODO: 在此更改 DC 的任何特性 // TODO: 如果默认的不是所需画笔，则返回另一个画笔 if (IDC_TEXT == pWnd-&gt;GetDlgCtrlID()) &#123; pDC-&gt;SelectObject(&amp;m_font);//将字体选入设备描述表-&gt;改变字体 &#125; return hbr;&#125; 3、改变按钮的背景色及文本 7、位图的显示123456789101112131415161718192021BOOL CGraphicView::OnEraseBkgnd(CDC* pDC)//擦除背景时，系统发送WM_ERASEBKGND消息&#123; // TODO: 在此添加消息处理程序代码和/或调用默认值 CBitmap bitmap; bitmap.LoadBitmap(IDB_BITMAP1); BITMAP bmp;//定义BITMAP结构体变量 bitmap.GetBitmap(&amp;bmp);//CBitmap::GetBitmap用位图信息填充BITMAP结构体 CDC dcCompatible;//创建兼容DC dcCompatible.CreateCompatibleDC(pDC);//兼容DC(源DC)和当前DC兼容 dcCompatible.SelectObject(&amp;bitmap);//将位图选入兼容DC，从而确定兼容DC显示表面的大小 CRect rect; GetClientRect(&amp;rect);//获得目的DC客户区大小// pDC-&gt;BitBlt(0, 0, rect.Width(), rect.Height(), &amp;dcCompatible, 0, 0, SRCCOPY);//BitBlt()将源DC的位图1:1复制到目的DC pDC-&gt;StretchBlt(0, 0, rect.Width(), rect.Height(), &amp;dcCompatible, 0, 0,bmp.bmWidth,bmp.bmHeight, SRCCOPY); //StretchBlt复制位图并实现拉伸或压缩；bmp.bmWidth,bmp.bmHeight存储源矩形的宽度和高度 return TRUE;//已经擦除过窗口背景了，返回非零值// return CView::OnEraseBkgnd(pDC);//将窗口背景擦除&#125; &#x2F;&#x2F;构造函数初始化","tags":["c++","读书笔记","mfc"],"categories":["读书笔记","孙鑫VC++深入详解"]},{"path":"/live2d-widget-master/autoload.js","content":"// live2d_path 参数建议使用绝对路径 // const live2d_path = \"https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/\"; const live2d_path = \"/live2d-widget-master/\"; // 封装异步加载资源的方法 function loadExternalResource(url, type) { return new Promise((resolve, reject) => { let tag; if (type === \"css\") { tag = document.createElement(\"link\"); tag.rel = \"stylesheet\"; tag.href = url; } else if (type === \"js\") { tag = document.createElement(\"script\"); tag.src = url; } if (tag) { tag.onload = () => resolve(url); tag.onerror = () => reject(url); document.head.appendChild(tag); } }); } // 加载 waifu.css live2d.min.js waifu-tips.js if (screen.width >= 768) { Promise.all([ loadExternalResource(live2d_path + \"waifu.css\", \"css\"), loadExternalResource(live2d_path + \"live2d.min.js\", \"js\"), loadExternalResource(live2d_path + \"waifu-tips.js\", \"js\") ]).then(() => { // 配置选项的具体用法见 README.md initWidget({ waifuPath: live2d_path + \"waifu-tips.json\", // apiPath: \"https://www.hekeke.top/live2d_api/\", cdnPath: \"https://fastly.jsdelivr.net/gh/fghrsh/live2d_api/\", tools: [ \"quit\"] }); }); } console.log(` く__,.ヘヽ. / ,ー､ 〉 ＼ ', !-─‐-i / /´ ／｀ｰ' L/／｀ヽ､ / ／, /| , , ', ｲ / /-‐/ ｉ L_ ﾊ ヽ! i ﾚ ﾍ 7ｲ｀ﾄ ﾚ'ｧ-ﾄ､!ハ| | !,/7 '0' ´0iソ| | |.从\" _ ,,,, / |./ | ﾚ'| i＞.､,,__ _,.イ / .i | ﾚ'| | / k_７_/ﾚ'ヽ, ﾊ. | | |/i 〈|/ i ,.ﾍ | i | .|/ / ｉ： ﾍ! ＼ | kヽ>､ﾊ _,.ﾍ､ /､! !'〈//｀Ｔ´', ＼ ｀'7'ｰr' ﾚ'ヽL__|___i,___,ンﾚ|ノ ﾄ-,/ |___./ 'ｰ' !_,.: `);"},{"path":"/live2d-widget-master/live2d.min.js","content":"!function(t){function i(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,i),o.l=!0,o.exports}var e={};i.m=t,i.c=e,i.d=function(t,e,r){i.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:r})},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,\"a\",e),e},i.o=function(t,i){return Object.prototype.hasOwnProperty.call(t,i)},i.p=\"\",i(i.s=4)}([function(t,i,e){\"use strict\";function r(){this.live2DModel=null,this.modelMatrix=null,this.eyeBlink=null,this.physics=null,this.pose=null,this.debugMode=!1,this.initialized=!1,this.updating=!1,this.alpha=1,this.accAlpha=0,this.lipSync=!1,this.lipSyncValue=0,this.accelX=0,this.accelY=0,this.accelZ=0,this.dragX=0,this.dragY=0,this.startTimeMSec=null,this.mainMotionManager=new h,this.expressionManager=new h,this.motions={},this.expressions={},this.isTexLoaded=!1}function o(){AMotion.prototype.constructor.call(this),this.paramList=new Array}function n(){this.id=\"\",this.type=-1,this.value=null}function s(){this.nextBlinkTime=null,this.stateStartTime=null,this.blinkIntervalMsec=null,this.eyeState=g.STATE_FIRST,this.blinkIntervalMsec=4e3,this.closingMotionMsec=100,this.closedMotionMsec=50,this.openingMotionMsec=150,this.closeIfZero=!0,this.eyeID_L=\"PARAM_EYE_L_OPEN\",this.eyeID_R=\"PARAM_EYE_R_OPEN\"}function _(){this.tr=new Float32Array(16),this.identity()}function a(t,i){_.prototype.constructor.call(this),this.width=t,this.height=i}function h(){MotionQueueManager.prototype.constructor.call(this),this.currentPriority=null,this.reservePriority=null,this.super=MotionQueueManager.prototype}function l(){this.physicsList=new Array,this.startTimeMSec=UtSystem.getUserTimeMSec()}function $(){this.lastTime=0,this.lastModel=null,this.partsGroups=new Array}function u(t){this.paramIndex=-1,this.partsIndex=-1,this.link=null,this.id=t}function p(){this.EPSILON=.01,this.faceTargetX=0,this.faceTargetY=0,this.faceX=0,this.faceY=0,this.faceVX=0,this.faceVY=0,this.lastTimeSec=0}function f(){_.prototype.constructor.call(this),this.screenLeft=null,this.screenRight=null,this.screenTop=null,this.screenBottom=null,this.maxLeft=null,this.maxRight=null,this.maxTop=null,this.maxBottom=null,this.max=Number.MAX_VALUE,this.min=0}function c(){}var d=0;r.prototype.getModelMatrix=function(){return this.modelMatrix},r.prototype.setAlpha=function(t){t>.999&&(t=1),t"},{"path":"/live2d-widget-master/package-lock.json","content":"{\"name\":\"live2d-widget\",\"version\":\"0.9.0\",\"lockfileVersion\":3,\"requires\":true,\"packages\":{\"\":{\"name\":\"live2d-widget\",\"version\":\"0.9.0\",\"license\":\"GPL-3.0-or-later\",\"devDependencies\":{\"@fortawesome/fontawesome-free\":\"^6.2.0\",\"@rollup/plugin-node-resolve\":\"^15.0.0\",\"@rollup/pluginutils\":\"^5.0.1\",\"rollup\":\"^3.2.3\",\"terser\":\"^5.15.1\"}},\"node_modules/@fortawesome/fontawesome-free\":{\"version\":\"6.5.1\",\"resolved\":\"https://registry.npmjs.org/@fortawesome/fontawesome-free/-/fontawesome-free-6.5.1.tgz\",\"integrity\":\"sha512-CNy5vSwN3fsUStPRLX7fUYojyuzoEMSXPl7zSLJ8TgtRfjv24LOnOWKT2zYwaHZCJGkdyRnTmstR0P+Ah503Gw==\",\"dev\":true,\"hasInstallScript\":true,\"engines\":{\"node\":\">=6\"}},\"node_modules/@jridgewell/gen-mapping\":{\"version\":\"0.3.5\",\"resolved\":\"https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.5.tgz\",\"integrity\":\"sha512-IzL8ZoEDIBRWEzlCcRhOaCupYyN5gdIK+Q6fbFdPDg6HqX6jpkItn7DFIpW9LQzXG6Df9sA7+OKnq0qlz/GaQg==\",\"dev\":true,\"dependencies\":{\"@jridgewell/set-array\":\"^1.2.1\",\"@jridgewell/sourcemap-codec\":\"^1.4.10\",\"@jridgewell/trace-mapping\":\"^0.3.24\"},\"engines\":{\"node\":\">=6.0.0\"}},\"node_modules/@jridgewell/resolve-uri\":{\"version\":\"3.1.2\",\"resolved\":\"https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz\",\"integrity\":\"sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==\",\"dev\":true,\"engines\":{\"node\":\">=6.0.0\"}},\"node_modules/@jridgewell/set-array\":{\"version\":\"1.2.1\",\"resolved\":\"https://registry.npmjs.org/@jridgewell/set-array/-/set-array-1.2.1.tgz\",\"integrity\":\"sha512-R8gLRTZeyp03ymzP/6Lil/28tGeGEzhx1q2k703KGWRAI1VdvPIXdG70VJc2pAMw3NA6JKL5hhFu1sJX0Mnn/A==\",\"dev\":true,\"engines\":{\"node\":\">=6.0.0\"}},\"node_modules/@jridgewell/source-map\":{\"version\":\"0.3.6\",\"resolved\":\"https://registry.npmjs.org/@jridgewell/source-map/-/source-map-0.3.6.tgz\",\"integrity\":\"sha512-1ZJTZebgqllO79ue2bm3rIGud/bOe0pP5BjSRCRxxYkEZS8STV7zN84UBbiYu7jy+eCKSnVIUgoWWE/tt+shMQ==\",\"dev\":true,\"dependencies\":{\"@jridgewell/gen-mapping\":\"^0.3.5\",\"@jridgewell/trace-mapping\":\"^0.3.25\"}},\"node_modules/@jridgewell/sourcemap-codec\":{\"version\":\"1.4.15\",\"resolved\":\"https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.4.15.tgz\",\"integrity\":\"sha512-eF2rxCRulEKXHTRiDrDy6erMYWqNw4LPdQ8UQA4huuxaQsVeRPFl2oM8oDGxMFhJUWZf9McpLtJasDDZb/Bpeg==\",\"dev\":true},\"node_modules/@jridgewell/trace-mapping\":{\"version\":\"0.3.25\",\"resolved\":\"https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.25.tgz\",\"integrity\":\"sha512-vNk6aEwybGtawWmy/PzwnGDOjCkLWSD2wqvjGGAgOAwCGWySYXfYoxt00IJkTF+8Lb57DwOb3Aa0o9CApepiYQ==\",\"dev\":true,\"dependencies\":{\"@jridgewell/resolve-uri\":\"^3.1.0\",\"@jridgewell/sourcemap-codec\":\"^1.4.14\"}},\"node_modules/@rollup/plugin-node-resolve\":{\"version\":\"15.2.3\",\"resolved\":\"https://registry.npmjs.org/@rollup/plugin-node-resolve/-/plugin-node-resolve-15.2.3.tgz\",\"integrity\":\"sha512-j/lym8nf5E21LwBT4Df1VD6hRO2L2iwUeUmP7litikRsVp1H6NWx20NEp0Y7su+7XGc476GnXXc4kFeZNGmaSQ==\",\"dev\":true,\"dependencies\":{\"@rollup/pluginutils\":\"^5.0.1\",\"@types/resolve\":\"1.20.2\",\"deepmerge\":\"^4.2.2\",\"is-builtin-module\":\"^3.2.1\",\"is-module\":\"^1.0.0\",\"resolve\":\"^1.22.1\"},\"engines\":{\"node\":\">=14.0.0\"},\"peerDependencies\":{\"rollup\":\"^2.78.0||^3.0.0||^4.0.0\"},\"peerDependenciesMeta\":{\"rollup\":{\"optional\":true}}},\"node_modules/@rollup/pluginutils\":{\"version\":\"5.1.0\",\"resolved\":\"https://registry.npmjs.org/@rollup/pluginutils/-/pluginutils-5.1.0.tgz\",\"integrity\":\"sha512-XTIWOPPcpvyKI6L1NHo0lFlCyznUEyPmPY1mc3KpPVDYulHSTvyeLNVW00QTLIAFNhR3kYnJTQHeGqU4M3n09g==\",\"dev\":true,\"dependencies\":{\"@types/estree\":\"^1.0.0\",\"estree-walker\":\"^2.0.2\",\"picomatch\":\"^2.3.1\"},\"engines\":{\"node\":\">=14.0.0\"},\"peerDependencies\":{\"rollup\":\"^1.20.0||^2.0.0||^3.0.0||^4.0.0\"},\"peerDependenciesMeta\":{\"rollup\":{\"optional\":true}}},\"node_modules/@types/estree\":{\"version\":\"1.0.5\",\"resolved\":\"https://registry.npmjs.org/@types/estree/-/estree-1.0.5.tgz\",\"integrity\":\"sha512-/kYRxGDLWzHOB7q+wtSUQlFrtcdUccpfy+X+9iMBpHK8QLLhx2wIPYuS5DYtR9Wa/YlZAbIovy7qVdB1Aq6Lyw==\",\"dev\":true},\"node_modules/@types/resolve\":{\"version\":\"1.20.2\",\"resolved\":\"https://registry.npmjs.org/@types/resolve/-/resolve-1.20.2.tgz\",\"integrity\":\"sha512-60BCwRFOZCQhDncwQdxxeOEEkbc5dIMccYLwbxsS4TUNeVECQ/pBJ0j09mrHOl/JJvpRPGwO9SvE4nR2Nb/a4Q==\",\"dev\":true},\"node_modules/acorn\":{\"version\":\"8.11.3\",\"resolved\":\"https://registry.npmjs.org/acorn/-/acorn-8.11.3.tgz\",\"integrity\":\"sha512-Y9rRfJG5jcKOE0CLisYbojUjIrIEE7AGMzA/Sm4BslANhbS+cDMpgBdcPT91oJ7OuJ9hYJBx59RjbhxVnrF8Xg==\",\"dev\":true,\"bin\":{\"acorn\":\"bin/acorn\"},\"engines\":{\"node\":\">=0.4.0\"}},\"node_modules/buffer-from\":{\"version\":\"1.1.2\",\"resolved\":\"https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.2.tgz\",\"integrity\":\"sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==\",\"dev\":true},\"node_modules/builtin-modules\":{\"version\":\"3.3.0\",\"resolved\":\"https://registry.npmjs.org/builtin-modules/-/builtin-modules-3.3.0.tgz\",\"integrity\":\"sha512-zhaCDicdLuWN5UbN5IMnFqNMhNfo919sH85y2/ea+5Yg9TsTkeZxpL+JLbp6cgYFS4sRLp3YV4S6yDuqVWHYOw==\",\"dev\":true,\"engines\":{\"node\":\">=6\"},\"funding\":{\"url\":\"https://github.com/sponsors/sindresorhus\"}},\"node_modules/commander\":{\"version\":\"2.20.3\",\"resolved\":\"https://registry.npmjs.org/commander/-/commander-2.20.3.tgz\",\"integrity\":\"sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ==\",\"dev\":true},\"node_modules/deepmerge\":{\"version\":\"4.3.1\",\"resolved\":\"https://registry.npmjs.org/deepmerge/-/deepmerge-4.3.1.tgz\",\"integrity\":\"sha512-3sUqbMEc77XqpdNO7FRyRog+eW3ph+GYCbj+rK+uYyRMuwsVy0rMiVtPn+QJlKFvWP/1PYpapqYn0Me2knFn+A==\",\"dev\":true,\"engines\":{\"node\":\">=0.10.0\"}},\"node_modules/estree-walker\":{\"version\":\"2.0.2\",\"resolved\":\"https://registry.npmjs.org/estree-walker/-/estree-walker-2.0.2.tgz\",\"integrity\":\"sha512-Rfkk/Mp/DL7JVje3u18FxFujQlTNR2q6QfMSMB7AvCBx91NGj/ba3kCfza0f6dVDbw7YlRf/nDrn7pQrCCyQ/w==\",\"dev\":true},\"node_modules/fsevents\":{\"version\":\"2.3.3\",\"resolved\":\"https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz\",\"integrity\":\"sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==\",\"dev\":true,\"hasInstallScript\":true,\"optional\":true,\"os\":[\"darwin\"],\"engines\":{\"node\":\"^8.16.0 || ^10.6.0 || >=11.0.0\"}},\"node_modules/function-bind\":{\"version\":\"1.1.2\",\"resolved\":\"https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz\",\"integrity\":\"sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==\",\"dev\":true,\"funding\":{\"url\":\"https://github.com/sponsors/ljharb\"}},\"node_modules/hasown\":{\"version\":\"2.0.2\",\"resolved\":\"https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz\",\"integrity\":\"sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==\",\"dev\":true,\"dependencies\":{\"function-bind\":\"^1.1.2\"},\"engines\":{\"node\":\">= 0.4\"}},\"node_modules/is-builtin-module\":{\"version\":\"3.2.1\",\"resolved\":\"https://registry.npmjs.org/is-builtin-module/-/is-builtin-module-3.2.1.tgz\",\"integrity\":\"sha512-BSLE3HnV2syZ0FK0iMA/yUGplUeMmNz4AW5fnTunbCIqZi4vG3WjJT9FHMy5D69xmAYBHXQhJdALdpwVxV501A==\",\"dev\":true,\"dependencies\":{\"builtin-modules\":\"^3.3.0\"},\"engines\":{\"node\":\">=6\"},\"funding\":{\"url\":\"https://github.com/sponsors/sindresorhus\"}},\"node_modules/is-core-module\":{\"version\":\"2.13.1\",\"resolved\":\"https://registry.npmjs.org/is-core-module/-/is-core-module-2.13.1.tgz\",\"integrity\":\"sha512-hHrIjvZsftOsvKSn2TRYl63zvxsgE0K+0mYMoH6gD4omR5IWB2KynivBQczo3+wF1cCkjzvptnI9Q0sPU66ilw==\",\"dev\":true,\"dependencies\":{\"hasown\":\"^2.0.0\"},\"funding\":{\"url\":\"https://github.com/sponsors/ljharb\"}},\"node_modules/is-module\":{\"version\":\"1.0.0\",\"resolved\":\"https://registry.npmjs.org/is-module/-/is-module-1.0.0.tgz\",\"integrity\":\"sha512-51ypPSPCoTEIN9dy5Oy+h4pShgJmPCygKfyRCISBI+JoWT/2oJvK8QPxmwv7b/p239jXrm9M1mlQbyKJ5A152g==\",\"dev\":true},\"node_modules/path-parse\":{\"version\":\"1.0.7\",\"resolved\":\"https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz\",\"integrity\":\"sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==\",\"dev\":true},\"node_modules/picomatch\":{\"version\":\"2.3.1\",\"resolved\":\"https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz\",\"integrity\":\"sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==\",\"dev\":true,\"engines\":{\"node\":\">=8.6\"},\"funding\":{\"url\":\"https://github.com/sponsors/jonschlinkert\"}},\"node_modules/resolve\":{\"version\":\"1.22.8\",\"resolved\":\"https://registry.npmjs.org/resolve/-/resolve-1.22.8.tgz\",\"integrity\":\"sha512-oKWePCxqpd6FlLvGV1VU0x7bkPmmCNolxzjMf4NczoDnQcIWrAF+cPtZn5i6n+RfD2d9i0tzpKnG6Yk168yIyw==\",\"dev\":true,\"dependencies\":{\"is-core-module\":\"^2.13.0\",\"path-parse\":\"^1.0.7\",\"supports-preserve-symlinks-flag\":\"^1.0.0\"},\"bin\":{\"resolve\":\"bin/resolve\"},\"funding\":{\"url\":\"https://github.com/sponsors/ljharb\"}},\"node_modules/rollup\":{\"version\":\"3.29.4\",\"resolved\":\"https://registry.npmjs.org/rollup/-/rollup-3.29.4.tgz\",\"integrity\":\"sha512-oWzmBZwvYrU0iJHtDmhsm662rC15FRXmcjCk1xD771dFDx5jJ02ufAQQTn0etB2emNk4J9EZg/yWKpsn9BWGRw==\",\"dev\":true,\"bin\":{\"rollup\":\"dist/bin/rollup\"},\"engines\":{\"node\":\">=14.18.0\",\"npm\":\">=8.0.0\"},\"optionalDependencies\":{\"fsevents\":\"~2.3.2\"}},\"node_modules/source-map\":{\"version\":\"0.6.1\",\"resolved\":\"https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz\",\"integrity\":\"sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==\",\"dev\":true,\"engines\":{\"node\":\">=0.10.0\"}},\"node_modules/source-map-support\":{\"version\":\"0.5.21\",\"resolved\":\"https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.21.tgz\",\"integrity\":\"sha512-uBHU3L3czsIyYXKX88fdrGovxdSCoTGDRZ6SYXtSRxLZUzHg5P/66Ht6uoUlHu9EZod+inXhKo3qQgwXUT/y1w==\",\"dev\":true,\"dependencies\":{\"buffer-from\":\"^1.0.0\",\"source-map\":\"^0.6.0\"}},\"node_modules/supports-preserve-symlinks-flag\":{\"version\":\"1.0.0\",\"resolved\":\"https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz\",\"integrity\":\"sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==\",\"dev\":true,\"engines\":{\"node\":\">= 0.4\"},\"funding\":{\"url\":\"https://github.com/sponsors/ljharb\"}},\"node_modules/terser\":{\"version\":\"5.29.2\",\"resolved\":\"https://registry.npmjs.org/terser/-/terser-5.29.2.tgz\",\"integrity\":\"sha512-ZiGkhUBIM+7LwkNjXYJq8svgkd+QK3UUr0wJqY4MieaezBSAIPgbSPZyIx0idM6XWK5CMzSWa8MJIzmRcB8Caw==\",\"dev\":true,\"dependencies\":{\"@jridgewell/source-map\":\"^0.3.3\",\"acorn\":\"^8.8.2\",\"commander\":\"^2.20.0\",\"source-map-support\":\"~0.5.20\"},\"bin\":{\"terser\":\"bin/terser\"},\"engines\":{\"node\":\">=10\"}}}}"},{"path":"/live2d-widget-master/package.json","content":"{\"name\":\"live2d-widget\",\"version\":\"0.9.0\",\"description\":\"Live2D widget for web pages\",\"main\":\"autoload.js\",\"type\":\"module\",\"scripts\":{\"build\":\"rollup -c rollup.config.js -f iife | terser -c -m > waifu-tips.js\",\"build-dev\":\"rollup -c rollup.config.js -f iife -o waifu-tips.js -w\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/stevenjoezhang/live2d-widget.git\"},\"keywords\":[\"Live2d\"],\"author\":\"stevenjoezhang \",\"license\":\"GPL-3.0-or-later\",\"bugs\":{\"url\":\"https://github.com/stevenjoezhang/live2d-widget/issues\"},\"homepage\":\"https://github.com/stevenjoezhang/live2d-widget#readme\",\"devDependencies\":{\"@fortawesome/fontawesome-free\":\"^6.2.0\",\"@rollup/plugin-node-resolve\":\"^15.0.0\",\"@rollup/pluginutils\":\"^5.0.1\",\"rollup\":\"^3.2.3\",\"terser\":\"^5.15.1\"}}"},{"path":"/live2d-widget-master/rollup.config.js","content":"import { nodeResolve } from \"@rollup/plugin-node-resolve\"; import { createFilter } from \"@rollup/pluginutils\"; function string(opts = {}) { if (!opts.include) { throw Error(\"include option should be specified\"); } const filter = createFilter(opts.include, opts.exclude); return { name: \"string\", transform(code, id) { if (filter(id)) { return { code: `export default ${JSON.stringify(code)};`, map: { mappings: \"\" } }; } }, renderChunk(code, chunk, outputOptions = {}) { return `/*! * Live2D Widget * https://github.com/stevenjoezhang/live2d-widget */ ` + code; } }; } export default { input: \"src/waifu-tips.js\", plugins: [nodeResolve(), string({ include: \"**/*.svg\", })] };"},{"path":"/live2d-widget-master/waifu-tips.js","content":"/*! * Live2D Widget * https://github.com/stevenjoezhang/live2d-widget */ !function(){\"use strict\";function e(e){return Array.isArray(e)?e[Math.floor(Math.random()*e.length)]:e}let t;function o(o,s,n){if(!o||sessionStorage.getItem(\"waifu-text\")&&sessionStorage.getItem(\"waifu-text\")>n)return;t&&(clearTimeout(t),t=null),o=e(o),sessionStorage.setItem(\"waifu-text\",n);const i=document.getElementById(\"waifu-tips\");i.innerHTML=o,i.classList.add(\"waifu-tips-active\"),t=setTimeout((()=>{sessionStorage.removeItem(\"waifu-text\"),i.classList.remove(\"waifu-tips-active\")}),s)}class s{constructor(e){let{apiPath:t,cdnPath:o}=e,s=!1;if(\"string\"==typeof o)s=!0,o.endsWith(\"/\")||(o+=\"/\");else{if(\"string\"!=typeof t)throw\"Invalid initWidget argument!\";t.endsWith(\"/\")||(t+=\"/\")}this.useCDN=s,this.apiPath=t,this.cdnPath=o}async loadModelList(){const e=await fetch(`${this.cdnPath}model_list.json`);this.modelList=await e.json()}async loadModel(t,s,n){if(localStorage.setItem(\"modelId\",t),localStorage.setItem(\"modelTexturesId\",s),o(n,4e3,10),this.useCDN){this.modelList||await this.loadModelList();const o=e(this.modelList.models[t]);loadlive2d(\"live2d\",`${this.cdnPath}model/${o}/index.json`)}else loadlive2d(\"live2d\",`${this.apiPath}get/?id=${t}-${s}`),console.log(`Live2D 模型 ${t}-${s} 加载完成`)}async loadRandModel(){const t=localStorage.getItem(\"modelId\"),s=localStorage.getItem(\"modelTexturesId\");if(this.useCDN){this.modelList||await this.loadModelList();const s=e(this.modelList.models[t]);loadlive2d(\"live2d\",`${this.cdnPath}model/${s}/index.json`),o(\"我的新衣服好看嘛？\",4e3,10)}else fetch(`${this.apiPath}rand_textures/?id=${t}-${s}`).then((e=>e.json())).then((e=>{1!==e.textures.id||1!==s&&0!==s?this.loadModel(t,e.textures.id,\"我的新衣服好看嘛？\"):o(\"我还没有其他衣服呢！\",4e3,10)}))}async loadOtherModel(){let e=localStorage.getItem(\"modelId\");if(this.useCDN){this.modelList||await this.loadModelList();const t=++e>=this.modelList.models.length?0:e;this.loadModel(t,0,this.modelList.messages[t])}else fetch(`${this.apiPath}switch/?id=${e}`).then((e=>e.json())).then((e=>{this.loadModel(e.model.id,0,e.model.message)}))}}const n={hitokoto:{icon:'\\x3c!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc. --\\x3e',callback:function(){fetch(\"https://v1.hitokoto.cn\").then((e=>e.json())).then((e=>{const t=`这句一言来自 「${e.from}」，是 ${e.creator} 在 hitokoto.cn 投稿的。`;o(e.hitokoto,6e3,9),setTimeout((()=>{o(t,4e3,9)}),6e3)}))}},asteroids:{icon:'\\x3c!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc. --\\x3e',callback:()=>{if(window.Asteroids)window.ASTEROIDSPLAYERS||(window.ASTEROIDSPLAYERS=[]),window.ASTEROIDSPLAYERS.push(new Asteroids);else{const e=document.createElement(\"script\");e.src=\"https://fastly.jsdelivr.net/gh/stevenjoezhang/asteroids/asteroids.js\",document.head.appendChild(e)}}},\"switch-model\":{icon:'\\x3c!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc. --\\x3e',callback:()=>{}},\"switch-texture\":{icon:'\\x3c!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc. --\\x3e',callback:()=>{}},photo:{icon:'\\x3c!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc. --\\x3e',callback:()=>{o(\"照好了嘛，是不是很可爱呢？\",6e3,9),Live2D.captureName=\"photo.png\",Live2D.captureFrame=!0}},info:{icon:'\\x3c!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc. --\\x3e',callback:()=>{open(\"https://github.com/stevenjoezhang/live2d-widget\")}},quit:{icon:'\\x3c!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc. --\\x3e',callback:()=>{localStorage.setItem(\"waifu-display\",Date.now()),o(\"愿你有一天能与重要的人重逢。\",2e3,11),document.getElementById(\"waifu\").style.bottom=\"-500px\",setTimeout((()=>{document.getElementById(\"waifu\").style.display=\"none\",document.getElementById(\"waifu-toggle\").classList.add(\"waifu-toggle-active\")}),3e3)}}};function i(t){const i=new s(t);function c(t){let s,n,i=!1,c=t.message.default;window.addEventListener(\"mousemove\",(()=>i=!0)),window.addEventListener(\"keydown\",(()=>i=!0)),setInterval((()=>{i?(i=!1,clearInterval(s),s=null):s||(s=setInterval((()=>{o(c,6e3,9)}),2e4))}),1e3),o(function(e){if(\"/\"===location.pathname)for(let{hour:t,text:o}of e){const e=new Date,s=t.split(\"-\")[0],n=t.split(\"-\")[1]||s;if(s{for(let{selector:n,text:i}of t.click)if(s.target.closest(n))return i=e(i),i=i.replace(\"{text}\",s.target.innerText),void o(i,4e3,8)})),t.seasons.forEach((({date:t,text:o})=>{const s=new Date,n=t.split(\"-\")[0],i=t.split(\"-\")[1]||n;n.split(\"/\")[0]{document.hidden||o(t.message.visibilitychange,6e3,9)}))}localStorage.removeItem(\"waifu-display\"),sessionStorage.removeItem(\"waifu-text\"),document.body.insertAdjacentHTML(\"beforeend\",' '),setTimeout((()=>{document.getElementById(\"waifu\").style.bottom=0}),0),function(){n[\"switch-model\"].callback=()=>i.loadOtherModel(),n[\"switch-texture\"].callback=()=>i.loadRandModel(),Array.isArray(t.tools)||(t.tools=Object.keys(n));for(let e of t.tools)if(n[e]){const{icon:t,callback:o}=n[e];document.getElementById(\"waifu-tool\").insertAdjacentHTML(\"beforeend\",`${t}`),document.getElementById(`waifu-tool-${e}`).addEventListener(\"click\",o)}}(),function(){let e=localStorage.getItem(\"modelId\"),o=localStorage.getItem(\"modelTexturesId\");null===e&&(e=4,o=53),i.loadModel(e,o),fetch(t.waifuPath).then((e=>e.json())).then(c)}()}window.initWidget=function(e,t){\"string\"==typeof e&&(e={waifuPath:e,apiPath:t}),document.body.insertAdjacentHTML(\"beforeend\",' 看板娘 ');const o=document.getElementById(\"waifu-toggle\");o.addEventListener(\"click\",(()=>{o.classList.remove(\"waifu-toggle-active\"),o.getAttribute(\"first-time\")?(i(e),o.removeAttribute(\"first-time\")):(localStorage.removeItem(\"waifu-display\"),document.getElementById(\"waifu\").style.display=\"\",setTimeout((()=>{document.getElementById(\"waifu\").style.bottom=0}),0))})),localStorage.getItem(\"waifu-display\")&&Date.now()-localStorage.getItem(\"waifu-display\"){o.classList.add(\"waifu-toggle-active\")}),0)):i(e)}}();"},{"path":"/live2d-widget-master/waifu-tips.json","content":"{\"mouseover\":[{\"selector\":\"#live2d\",\"text\":[\"干嘛呢你，快把手拿开～～\",\"鼠…鼠标放错地方了！\",\"你要干嘛呀？\",\"喵喵喵？\",\"怕怕(ノ≧∇≦)ノ\",\"非礼呀！救命！\",\"这样的话，只能使用武力了！\",\"我要生气了哦\",\"不要动手动脚的！\",\"真…真的是不知羞耻！\",\"Hentai！\"]},{\"selector\":\"#waifu-tool-hitokoto\",\"text\":[\"猜猜我要说些什么？\",\"我从青蛙王子那里听到了不少人生经验。\"]},{\"selector\":\"#waifu-tool-asteroids\",\"text\":[\"要不要来玩飞机大战？\",\"这个按钮上写着「不要点击」。\",\"怎么，你想来和我玩个游戏？\",\"听说这样可以蹦迪！\"]},{\"selector\":\"#waifu-tool-switch-model\",\"text\":[\"你是不是不爱人家了呀，呜呜呜～\",\"要见见我的姐姐嘛？\",\"想要看我妹妹嘛？\",\"要切换看板娘吗？\"]},{\"selector\":\"#waifu-tool-switch-texture\",\"text\":[\"喜欢换装 PLAY 吗？\",\"这次要扮演什么呢？\",\"变装！\",\"让我们看看接下来会发生什么！\"]},{\"selector\":\"#waifu-tool-photo\",\"text\":[\"你要给我拍照呀？一二三～茄子～\",\"要不，我们来合影吧！\",\"保持微笑就好了～\"]},{\"selector\":\"#waifu-tool-info\",\"text\":[\"想要知道更多关于我的事么？\",\"这里记录着我搬家的历史呢。\",\"你想深入了解我什么呢？\"]},{\"selector\":\"#waifu-tool-quit\",\"text\":[\"到了要说再见的时候了吗？\",\"呜呜 QAQ 后会有期……\",\"不要抛弃我呀……\",\"我们，还能再见面吗……\",\"哼，你会后悔的！\"]},{\"selector\":\".menu-item-home a\",\"text\":[\"点击前往首页，想回到上一页可以使用浏览器的后退功能哦。\",\"点它就可以回到首页啦！\",\"回首页看看吧。\"]},{\"selector\":\".menu-item-about a\",\"text\":[\"你想知道我家主人是谁吗？\",\"这里有一些关于我家主人的秘密哦，要不要看看呢？\",\"发现主人出没地点！\"]},{\"selector\":\".menu-item-tags a\",\"text\":[\"点击就可以看文章的标签啦！\",\"点击来查看所有标签哦。\"]},{\"selector\":\".menu-item-categories a\",\"text\":[\"文章都分类好啦～\",\"点击来查看文章分类哦。\"]},{\"selector\":\".menu-item-archives a\",\"text\":[\"翻页比较麻烦吗，那就来看看文章归档吧。\",\"文章目录都整理在这里啦！\"]},{\"selector\":\".menu-item-friends a\",\"text\":[\"这是我的朋友们哦ヾ(◍°∇°◍)ﾉﾞ\",\"要去大佬们的家看看吗？\",\"要去拜访一下我的朋友们吗？\"]},{\"selector\":\".menu-item-search a\",\"text\":[\"找不到想看的内容？搜索看看吧！\",\"在找什么东西呢，需要帮忙吗？\"]},{\"selector\":\".menu-item a\",\"text\":[\"快看看这里都有什么呢？\"]},{\"selector\":\".site-author\",\"text\":[\"我家主人好看吗？\",\"这是我家主人(*´∇｀*)\"]},{\"selector\":\".site-state\",\"text\":[\"这是文章的统计信息～\",\"要不要点进去看看？\"]},{\"selector\":\".feed-link a\",\"text\":[\"这里可以使用 RSS 订阅呢！\",\"利用 feed 订阅器，就能快速知道博客有没有更新了呢。\"]},{\"selector\":\".cc-opacity, .post-copyright-author\",\"text\":[\"要记得规范转载哦。\",\"所有文章均采用 CC BY-NC-SA 4.0 许可协议～\",\"转载前要先注意下文章的版权协议呢。\"]},{\"selector\":\".links-of-author\",\"text\":[\"这里是主人的常驻地址哦。\",\"这里有主人的联系方式！\"]},{\"selector\":\".followme\",\"text\":[\"手机扫一下就能继续看，很方便呢～\",\"扫一扫，打开新世界的大门！\"]},{\"selector\":\".fancybox img, img.medium-zoom-image\",\"text\":[\"点击图片可以放大呢！\"]},{\"selector\":\".copy-btn\",\"text\":[\"代码可以直接点击复制哟。\"]},{\"selector\":\".highlight .table-container, .gist\",\"text\":[\"GitHub！我是新手！\",\"PHP 是最好的语言！\"]},{\"selector\":\"a[href^='mailto']\",\"text\":[\"邮件我会及时回复的！\",\"点击就可以发送邮件啦～\"]},{\"selector\":\"a[href^='/tags/']\",\"text\":[\"要去看看 {text} 标签么？\",\"点它可以查看此标签下的所有文章哟！\"]},{\"selector\":\"a[href^='/categories/']\",\"text\":[\"要去看看 {text} 分类么？\",\"点它可以查看此分类下的所有文章哟！\"]},{\"selector\":\".post-title-link\",\"text\":[\"要看看 {text} 这篇文章吗？\"]},{\"selector\":\"a[rel='contents']\",\"text\":[\"点击来阅读全文哦。\"]},{\"selector\":\"a[itemprop='discussionUrl']\",\"text\":[\"要去看看评论吗？\"]},{\"selector\":\".beian a\",\"text\":[\"我也是有户口的人哦。\",\"我的主人可是遵纪守法的好主人。\"]},{\"selector\":\".container a[href^='http'], .nav-link .nav-text\",\"text\":[\"要去看看 {text} 么？\",\"去 {text} 逛逛吧。\",\"到 {text} 看看吧。\"]},{\"selector\":\".back-to-top\",\"text\":[\"点它就可以回到顶部啦！\",\"又回到最初的起点～\",\"要回到开始的地方么？\"]},{\"selector\":\".reward-container\",\"text\":[\"我是不是棒棒哒～快给我点赞吧！\",\"要打赏我嘛？好期待啊～\",\"主人最近在吃土呢，很辛苦的样子，给他一些钱钱吧～\"]},{\"selector\":\"#wechat\",\"text\":[\"这是我的微信二维码～\"]},{\"selector\":\"#alipay\",\"text\":[\"这是我的支付宝哦！\"]},{\"selector\":\"#bitcoin\",\"text\":[\"这是我的比特币账号！\"]},{\"selector\":\"#needsharebutton-postbottom .btn\",\"text\":[\"好东西要让更多人知道才行哦。\",\"觉得文章有帮助的话，可以分享给更多需要的朋友呢。\"]},{\"selector\":\".need-share-button_weibo\",\"text\":[\"微博？来分享一波喵！\"]},{\"selector\":\".need-share-button_wechat\",\"text\":[\"分享到微信吧！\"]},{\"selector\":\".need-share-button_douban\",\"text\":[\"分享到豆瓣好像也不错！\"]},{\"selector\":\".need-share-button_qqzone\",\"text\":[\"QQ 空间，一键转发，耶～\"]},{\"selector\":\".need-share-button_twitter\",\"text\":[\"Twitter？好像是不存在的东西？\"]},{\"selector\":\".need-share-button_facebook\",\"text\":[\"emmm…FB 好像也是不存在的东西？\"]},{\"selector\":\".post-nav-item a[rel='next']\",\"text\":[\"来看看下一篇文章吧。\",\"点它可以看下一篇文章哦！\",\"要翻到下一篇文章吗？\"]},{\"selector\":\".post-nav-item a[rel='prev']\",\"text\":[\"来看看上一篇文章吧。\",\"点它可以看上一篇文章哦！\",\"要翻到上一篇文章吗？\"]},{\"selector\":\".extend.next\",\"text\":[\"去下一页看看吧。\",\"点它可以前进哦！\",\"要翻到下一页吗？\"]},{\"selector\":\".extend.prev\",\"text\":[\"去上一页看看吧。\",\"点它可以后退哦！\",\"要翻到上一页吗？\"]},{\"selector\":\"input.vnick\",\"text\":[\"该怎么称呼你呢？\",\"留下你的尊姓大名！\"]},{\"selector\":\".vmail\",\"text\":[\"留下你的邮箱，不然就是无头像人士了！\",\"记得设置好 Gravatar 头像哦！\",\"为了方便通知你最新消息，一定要留下邮箱！\"]},{\"selector\":\".vlink\",\"text\":[\"快快告诉我你的家在哪里，好让我去参观参观！\"]},{\"selector\":\".veditor\",\"text\":[\"想要去评论些什么吗？\",\"要说点什么吗？\",\"觉得博客不错？快来留言和主人交流吧！\"]},{\"selector\":\".vcontrol a\",\"text\":[\"你会不会熟练使用 Markdown 呀？\",\"使用 Markdown 让评论更美观吧～\"]},{\"selector\":\".vemoji-btn\",\"text\":[\"要插入一个萌萌哒的表情吗？\",\"要来一发表情吗？\"]},{\"selector\":\".vpreview-btn\",\"text\":[\"要预览一下你的发言吗？\",\"快看看你的评论有多少负熵！\"]},{\"selector\":\".vsubmit\",\"text\":[\"评论没有审核，要对自己的发言负责哦～\",\"要提交了吗，请耐心等待回复哦～\"]},{\"selector\":\".vcontent\",\"text\":[\"哇，快看看这个精彩评论！\",\"如果有疑问，请尽快留言哦～\"]}],\"click\":[{\"selector\":\"#live2d\",\"text\":[\"是…是不小心碰到了吧…\",\"萝莉控是什么呀？\",\"你看到我的小熊了吗？\",\"再摸的话我可要报警了！⌇●﹏●⌇\",\"110 吗，这里有个变态一直在摸我(ó﹏ò｡)\",\"不要摸我了，我会告诉老婆来打你的！\",\"干嘛动我呀！小心我咬你！\",\"别摸我，有什么好摸的！\"]},{\"selector\":\".veditor\",\"text\":[\"要吐槽些什么呢？\",\"一定要认真填写喵～\",\"有什么想说的吗？\"]},{\"selector\":\".vsubmit\",\"text\":[\"输入验证码就可以提交评论啦～\"]}],\"seasons\":[{\"date\":\"01/01\",\"text\":\"元旦了呢，新的一年又开始了，今年是{year}年～\"},{\"date\":\"02/14\",\"text\":\"又是一年情人节，{year}年找到对象了嘛～\"},{\"date\":\"03/08\",\"text\":\"今天是国际妇女节！\"},{\"date\":\"03/12\",\"text\":\"今天是植树节，要保护环境呀！\"},{\"date\":\"04/01\",\"text\":\"悄悄告诉你一个秘密～今天是愚人节，不要被骗了哦～\"},{\"date\":\"05/01\",\"text\":\"今天是五一劳动节，计划好假期去哪里了吗～\"},{\"date\":\"06/01\",\"text\":\"儿童节了呢，快活的时光总是短暂，要是永远长不大该多好啊…\"},{\"date\":\"09/03\",\"text\":\"中国人民抗日战争胜利纪念日，铭记历史、缅怀先烈、珍爱和平、开创未来。\"},{\"date\":\"09/10\",\"text\":\"教师节，在学校要给老师问声好呀～\"},{\"date\":\"10/01\",\"text\":\"国庆节到了，为祖国母亲庆生！\"},{\"date\":\"11/05-11/12\",\"text\":\"今年的双十一是和谁一起过的呢～\"},{\"date\":\"12/20-12/31\",\"text\":\"这几天是圣诞节，主人肯定又去剁手买买买了～\"}],\"time\":[{\"hour\":\"6-7\",\"text\":\"早上好！一日之计在于晨，美好的一天就要开始了～\"},{\"hour\":\"8-11\",\"text\":\"上午好！工作顺利嘛，不要久坐，多起来走动走动哦！\"},{\"hour\":\"12-13\",\"text\":\"中午了，工作了一个上午，现在是午餐时间！\"},{\"hour\":\"14-17\",\"text\":\"午后很容易犯困呢，今天的运动目标完成了吗？\"},{\"hour\":\"18-19\",\"text\":\"傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红～\"},{\"hour\":\"20-21\",\"text\":\"晚上好，今天过得怎么样？\"},{\"hour\":\"22-23\",\"text\":[\"已经这么晚了呀，早点休息吧，晚安～\",\"深夜时要爱护眼睛呀！\"]},{\"hour\":\"0-5\",\"text\":\"你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？\"}],\"message\":{\"default\":[\"好久不见，日子过得好快呢……\",\"大坏蛋！你都多久没理人家了呀，嘤嘤嘤～\",\"嗨～快来逗我玩吧！\",\"拿小拳拳锤你胸口！\",\"记得把小家加入收藏夹哦！\"],\"console\":\"哈哈，你打开了控制台，是想要看看我的小秘密吗？\",\"copy\":\"你都复制了些什么呀，转载要记得加上出处哦！\",\"visibilitychange\":\"哇，你终于回来了～\"}}"},{"path":"/live2d-widget-master/waifu.css","content":"#waifu-toggle { background-color: #fa0; border-radius: 5px; bottom: 66px; color: #fff; cursor: pointer; font-size: 12px; left: 0; margin-left: -100px; padding: 5px 2px 5px 5px; position: fixed; transition: margin-left 1s; width: 60px; writing-mode: vertical-rl; } #waifu-toggle.waifu-toggle-active { margin-left: -50px; } #waifu-toggle.waifu-toggle-active:hover { margin-left: -30px; } #waifu { bottom: -1000px; left: 0; line-height: 0; margin-bottom: -10px; position: fixed; transform: translateY(3px); transition: transform .3s ease-in-out, bottom 3s ease-in-out; z-index: 1; } #waifu:hover { transform: translateY(0); } #waifu-tips { animation: shake 50s ease-in-out 5s infinite; background-color: rgba(236, 217, 188, .5); border: 1px solid rgba(224, 186, 140, .62); border-radius: 12px; box-shadow: 0 3px 15px 2px rgba(191, 158, 118, .2); font-size: 14px; line-height: 24px; margin: -30px 20px; min-height: 70px; opacity: 0; overflow: hidden; padding: 5px 10px; position: absolute; text-overflow: ellipsis; transition: opacity 1s; width: 250px; word-break: break-all; } #waifu-tips.waifu-tips-active { opacity: 1; transition: opacity .2s; } #waifu-tips span { color: #0099cc; } #live2d { cursor: grab; height: 300px; position: relative; width: 300px; } #live2d:active { cursor: grabbing; } #waifu-tool { color: #aaa; opacity: 0; position: absolute; right: -10px; top: 70px; transition: opacity 1s; } #waifu:hover #waifu-tool { opacity: 1; } #waifu-tool span { display: block; height: 30px; text-align: center; } #waifu-tool svg { fill: #7b8c9d; cursor: pointer; height: 25px; transition: fill .3s; } #waifu-tool svg:hover { fill: #0684bd; /* #34495e */ } @keyframes shake { 2% { transform: translate(.5px, -1.5px) rotate(-.5deg); } 4% { transform: translate(.5px, 1.5px) rotate(1.5deg); } 6% { transform: translate(1.5px, 1.5px) rotate(1.5deg); } 8% { transform: translate(2.5px, 1.5px) rotate(.5deg); } 10% { transform: translate(.5px, 2.5px) rotate(.5deg); } 12% { transform: translate(1.5px, 1.5px) rotate(.5deg); } 14% { transform: translate(.5px, .5px) rotate(.5deg); } 16% { transform: translate(-1.5px, -.5px) rotate(1.5deg); } 18% { transform: translate(.5px, .5px) rotate(1.5deg); } 20% { transform: translate(2.5px, 2.5px) rotate(1.5deg); } 22% { transform: translate(.5px, -1.5px) rotate(1.5deg); } 24% { transform: translate(-1.5px, 1.5px) rotate(-.5deg); } 26% { transform: translate(1.5px, .5px) rotate(1.5deg); } 28% { transform: translate(-.5px, -.5px) rotate(-.5deg); } 30% { transform: translate(1.5px, -.5px) rotate(-.5deg); } 32% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 34% { transform: translate(2.5px, 2.5px) rotate(-.5deg); } 36% { transform: translate(.5px, -1.5px) rotate(.5deg); } 38% { transform: translate(2.5px, -.5px) rotate(-.5deg); } 40% { transform: translate(-.5px, 2.5px) rotate(.5deg); } 42% { transform: translate(-1.5px, 2.5px) rotate(.5deg); } 44% { transform: translate(-1.5px, 1.5px) rotate(.5deg); } 46% { transform: translate(1.5px, -.5px) rotate(-.5deg); } 48% { transform: translate(2.5px, -.5px) rotate(.5deg); } 50% { transform: translate(-1.5px, 1.5px) rotate(.5deg); } 52% { transform: translate(-.5px, 1.5px) rotate(.5deg); } 54% { transform: translate(-1.5px, 1.5px) rotate(.5deg); } 56% { transform: translate(.5px, 2.5px) rotate(1.5deg); } 58% { transform: translate(2.5px, 2.5px) rotate(.5deg); } 60% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 62% { transform: translate(-1.5px, .5px) rotate(1.5deg); } 64% { transform: translate(-1.5px, 1.5px) rotate(1.5deg); } 66% { transform: translate(.5px, 2.5px) rotate(1.5deg); } 68% { transform: translate(2.5px, -1.5px) rotate(1.5deg); } 70% { transform: translate(2.5px, 2.5px) rotate(.5deg); } 72% { transform: translate(-.5px, -1.5px) rotate(1.5deg); } 74% { transform: translate(-1.5px, 2.5px) rotate(1.5deg); } 76% { transform: translate(-1.5px, 2.5px) rotate(1.5deg); } 78% { transform: translate(-1.5px, 2.5px) rotate(.5deg); } 80% { transform: translate(-1.5px, .5px) rotate(-.5deg); } 82% { transform: translate(-1.5px, .5px) rotate(-.5deg); } 84% { transform: translate(-.5px, .5px) rotate(1.5deg); } 86% { transform: translate(2.5px, 1.5px) rotate(.5deg); } 88% { transform: translate(-1.5px, .5px) rotate(1.5deg); } 90% { transform: translate(-1.5px, -.5px) rotate(-.5deg); } 92% { transform: translate(-1.5px, -1.5px) rotate(1.5deg); } 94% { transform: translate(.5px, .5px) rotate(-.5deg); } 96% { transform: translate(2.5px, -.5px) rotate(-.5deg); } 98% { transform: translate(-1.5px, -1.5px) rotate(-.5deg); } 0%, 100% { transform: translate(0, 0) rotate(0); } }"},{"path":"/live2d-widget-master/demo/demo.html","content":"Live2D 看板娘 / Demo #github svg { transition: all 1s; fill: #222; color: #fff; position: absolute; top: 0; right: 0; border: 0; width: 80px; height: 80px; } #github:hover svg { width: 160px; height: 160px; }"},{"path":"/live2d-widget-master/demo/login.html","content":"看板娘登陆平台 html, body { height: 100%; } body { display: flex; align-items: center; justify-content: center; padding-top: 40px; padding-bottom: 40px; background-color: #f5f5f5; } .form-signin { width: 100%; max-width: 330px; padding: 15px; margin: 0 auto; } .form-signin .checkbox { font-weight: 400; } .form-signin .form-control { position: relative; box-sizing: border-box; height: auto; padding: 10px; font-size: 16px; } .form-signin .form-control:focus { z-index: 2; } .form-signin input[type=text] { margin-bottom: -1px; border-bottom-right-radius: 0; border-bottom-left-radius: 0; } .form-signin input[type=password] { margin-bottom: 10px; border-top-left-radius: 0; border-top-right-radius: 0; } #stage { position: relative; } #stage img { width: 100%; margin-bottom: 20px; border-radius: 20px; } #stage button { position: absolute; padding: 0; } #inner { position: relative; background-color: #999; clip-path: circle(120px at center); } #cover { position: absolute; background-color: #CB3837; width: 100%; height: 100%; bottom: 10%; transition: all 1s; box-shadow: 0 0 0 5px rgba(0, 0, 0, .1); } #text { position: absolute; bottom: 30%; font-size: 2em; left: 50%; transform: translateX(-50%); opacity: 0.4; font-weight: bold; } #detail { position: absolute; background: rgba(255, 255, 255, .1); width: 100%; height: 10px; bottom: 0; } #handle { position: absolute; background: #ccc; bottom: -2px; box-shadow: 0 1px 0 1px rgba(0, 0, 0, .1); height: 8px; left: 50%; margin-left: -15px; width: 30px; cursor: pointer; } #info { left: 40px; bottom: 20px; } #refresh { right: 40px; bottom: 20px; } #live2d { cursor: grab; height: 300px; width: 300px; } #live2d:active { cursor: grabbing; } MIMIPOWERED 看板娘登陆平台 用户名 密码 记住我 登录 Copyleft &copy; Mimi 2019 /* * _(:з」∠)_ * Created by Shuqiao Zhang in 2019. * https://zhangshuqiao.org */ /* * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. */ window.addEventListener(\"load\", () => { \"use strict\"; if (!CSS.supports(\"clip-path\", \"circle(120px at center)\")) { document.getElementById(\"stage\").innerHTML = ''; return; } const apiPath = \"https://live2d.fghrsh.net/api\"; let state = 0, loading = false, modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); if (modelId === null) { modelId = 1; modelTexturesId = 53; } loadModel(modelId, modelTexturesId); function loadModel(modelId, modelTexturesId) { localStorage.setItem(\"modelId\", modelId); if (modelTexturesId === undefined) modelTexturesId = 0; localStorage.setItem(\"modelTexturesId\", modelTexturesId); loadlive2d(\"live2d\", `${apiPath}/get/?id=${modelId}-${modelTexturesId}`, null); console.log(\"live2d\", `模型 ${modelId}-${modelTexturesId} 加载完成`); setTimeout(() => { coverPosition(\"80%\"); state = 2; }, 2000); } function loadRandModel() { const modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); fetch(`${apiPath}/rand_textures/?id=${modelId}-${modelTexturesId}`) .then(response => response.json()) .then(result => { loadModel(modelId, result.textures.id); setTimeout(() => { state = 2; coverPosition(\"80%\"); loading = false; }, 1000); }); } function coverPosition(pos) { document.getElementById(\"cover\").style.bottom = pos; } document.getElementById(\"info\").addEventListener(\"click\", () => { fetch(\"https://v1.hitokoto.cn\") .then(response => response.json()) .then(result => { alert(\"「\" + result.hitokoto + \"」——\" + result.from); }); }); document.getElementById(\"refresh\").addEventListener(\"click\", () => { if (loading) return; state = 0; coverPosition(\"10%\"); loading = true; setTimeout(loadRandModel, 1000); }); document.getElementById(\"handle\").addEventListener(\"click\", () => { if (state === 1) { state = 2; coverPosition(\"80%\"); } else if (state === 2) { state = 1; coverPosition(\"20%\"); } }); document.querySelector(\"input[type=password]\").addEventListener(\"focus\", () => { if (state === 2) { state = 1; coverPosition(\"20%\"); } }); document.querySelector(\"input[type=password]\").addEventListener(\"blur\", () => { if (state === 1) { state = 2; coverPosition(\"80%\"); } }); });"},{"path":"/live2d-widget-master/src/index.js","content":"import Model from \"./model.js\"; import showMessage from \"./message.js\"; import randomSelection from \"./utils.js\"; import tools from \"./tools.js\"; function loadWidget(config) { const model = new Model(config); localStorage.removeItem(\"waifu-display\"); sessionStorage.removeItem(\"waifu-text\"); document.body.insertAdjacentHTML(\"beforeend\", ` `); // https://stackoverflow.com/questions/24148403/trigger-css-transition-on-appended-element setTimeout(() => { document.getElementById(\"waifu\").style.bottom = 0; }, 0); (function registerTools() { tools[\"switch-model\"].callback = () => model.loadOtherModel(); tools[\"switch-texture\"].callback = () => model.loadRandModel(); if (!Array.isArray(config.tools)) { config.tools = Object.keys(tools); } for (let tool of config.tools) { if (tools[tool]) { const { icon, callback } = tools[tool]; document.getElementById(\"waifu-tool\").insertAdjacentHTML(\"beforeend\", `${icon}`); document.getElementById(`waifu-tool-${tool}`).addEventListener(\"click\", callback); } } })(); function welcomeMessage(time) { if (location.pathname === \"/\") { // 如果是主页 for (let { hour, text } of time) { const now = new Date(), after = hour.split(\"-\")[0], before = hour.split(\"-\")[1] || after; if (after userAction = true); setInterval(() => { if (userAction) { userAction = false; clearInterval(userActionTimer); userActionTimer = null; } else if (!userActionTimer) { userActionTimer = setInterval(() => { showMessage(messageArray, 6000, 9); }, 20000); } }, 1000); showMessage(welcomeMessage(result.time), 7000, 11); window.addEventListener(\"mouseover\", event => { for (let { selector, text } of result.mouseover) { if (!event.target.closest(selector)) continue; if (lastHoverElement === selector) return; lastHoverElement = selector; text = randomSelection(text); text = text.replace(\"{text}\", event.target.innerText); showMessage(text, 4000, 8); return; } }); window.addEventListener(\"click\", event => { for (let { selector, text } of result.click) { if (!event.target.closest(selector)) continue; text = randomSelection(text); text = text.replace(\"{text}\", event.target.innerText); showMessage(text, 4000, 8); return; } }); result.seasons.forEach(({ date, text }) => { const now = new Date(), after = date.split(\"-\")[0], before = date.split(\"-\")[1] || after; if ((after.split(\"/\")[0] { if (!document.hidden) showMessage(result.message.visibilitychange, 6000, 9); }); } (function initModel() { let modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); if (modelId === null) { // 首次访问加载 指定模型 的 指定材质 modelId = 4; // 模型 ID modelTexturesId = 53; // 材质 ID } model.loadModel(modelId, modelTexturesId); fetch(config.waifuPath) .then(response => response.json()) .then(registerEventListener); })(); } function initWidget(config, apiPath) { if (typeof config === \"string\") { config = { waifuPath: config, apiPath }; } document.body.insertAdjacentHTML(\"beforeend\", ` 看板娘 `); const toggle = document.getElementById(\"waifu-toggle\"); toggle.addEventListener(\"click\", () => { toggle.classList.remove(\"waifu-toggle-active\"); if (toggle.getAttribute(\"first-time\")) { loadWidget(config); toggle.removeAttribute(\"first-time\"); } else { localStorage.removeItem(\"waifu-display\"); document.getElementById(\"waifu\").style.display = \"\"; setTimeout(() => { document.getElementById(\"waifu\").style.bottom = 0; }, 0); } }); if (localStorage.getItem(\"waifu-display\") && Date.now() - localStorage.getItem(\"waifu-display\") { toggle.classList.add(\"waifu-toggle-active\"); }, 0); } else { loadWidget(config); } } export default initWidget;"},{"path":"/live2d-widget-master/src/message.js","content":"import randomSelection from \"./utils.js\"; let messageTimer; function showMessage(text, timeout, priority) { if (!text || (sessionStorage.getItem(\"waifu-text\") && sessionStorage.getItem(\"waifu-text\") > priority)) return; if (messageTimer) { clearTimeout(messageTimer); messageTimer = null; } text = randomSelection(text); sessionStorage.setItem(\"waifu-text\", priority); const tips = document.getElementById(\"waifu-tips\"); tips.innerHTML = text; tips.classList.add(\"waifu-tips-active\"); messageTimer = setTimeout(() => { sessionStorage.removeItem(\"waifu-text\"); tips.classList.remove(\"waifu-tips-active\"); }, timeout); } export default showMessage;"},{"path":"/live2d-widget-master/src/model.js","content":"import showMessage from \"./message.js\"; import randomSelection from \"./utils.js\"; class Model { constructor(config) { let { apiPath, cdnPath } = config; let useCDN = false; if (typeof cdnPath === \"string\") { useCDN = true; if (!cdnPath.endsWith(\"/\")) cdnPath += \"/\"; } else if (typeof apiPath === \"string\") { if (!apiPath.endsWith(\"/\")) apiPath += \"/\"; } else { throw \"Invalid initWidget argument!\"; } this.useCDN = useCDN; this.apiPath = apiPath; this.cdnPath = cdnPath; } async loadModelList() { const response = await fetch(`${this.cdnPath}model_list.json`); this.modelList = await response.json(); } async loadModel(modelId, modelTexturesId, message) { localStorage.setItem(\"modelId\", modelId); localStorage.setItem(\"modelTexturesId\", modelTexturesId); showMessage(message, 4000, 10); if (this.useCDN) { if (!this.modelList) await this.loadModelList(); const target = randomSelection(this.modelList.models[modelId]); loadlive2d(\"live2d\", `${this.cdnPath}model/${target}/index.json`); } else { loadlive2d(\"live2d\", `${this.apiPath}get/?id=${modelId}-${modelTexturesId}`); console.log(`Live2D 模型 ${modelId}-${modelTexturesId} 加载完成`); } } async loadRandModel() { const modelId = localStorage.getItem(\"modelId\"), modelTexturesId = localStorage.getItem(\"modelTexturesId\"); if (this.useCDN) { if (!this.modelList) await this.loadModelList(); const target = randomSelection(this.modelList.models[modelId]); loadlive2d(\"live2d\", `${this.cdnPath}model/${target}/index.json`); showMessage(\"我的新衣服好看嘛？\", 4000, 10); } else { // 可选 \"rand\"(随机), \"switch\"(顺序) fetch(`${this.apiPath}rand_textures/?id=${modelId}-${modelTexturesId}`) .then(response => response.json()) .then(result => { if (result.textures.id === 1 && (modelTexturesId === 1 || modelTexturesId === 0)) showMessage(\"我还没有其他衣服呢！\", 4000, 10); else this.loadModel(modelId, result.textures.id, \"我的新衣服好看嘛？\"); }); } } async loadOtherModel() { let modelId = localStorage.getItem(\"modelId\"); if (this.useCDN) { if (!this.modelList) await this.loadModelList(); const index = (++modelId >= this.modelList.models.length) ? 0 : modelId; this.loadModel(index, 0, this.modelList.messages[index]); } else { fetch(`${this.apiPath}switch/?id=${modelId}`) .then(response => response.json()) .then(result => { this.loadModel(result.model.id, 0, result.model.message); }); } } } export default Model;"},{"path":"/live2d-widget-master/src/tools.js","content":"import fa_comment from \"@fortawesome/fontawesome-free/svgs/solid/comment.svg\"; import fa_paper_plane from \"@fortawesome/fontawesome-free/svgs/solid/paper-plane.svg\"; import fa_user_circle from \"@fortawesome/fontawesome-free/svgs/solid/circle-user.svg\"; import fa_street_view from \"@fortawesome/fontawesome-free/svgs/solid/street-view.svg\"; import fa_camera_retro from \"@fortawesome/fontawesome-free/svgs/solid/camera-retro.svg\"; import fa_info_circle from \"@fortawesome/fontawesome-free/svgs/solid/circle-info.svg\"; import fa_xmark from \"@fortawesome/fontawesome-free/svgs/solid/xmark.svg\"; import showMessage from \"./message.js\"; function showHitokoto() { // 增加 hitokoto.cn 的 API fetch(\"https://v1.hitokoto.cn\") .then(response => response.json()) .then(result => { const text = `这句一言来自 「${result.from}」，是 ${result.creator} 在 hitokoto.cn 投稿的。`; showMessage(result.hitokoto, 6000, 9); setTimeout(() => { showMessage(text, 4000, 9); }, 6000); }); } const tools = { \"hitokoto\": { icon: fa_comment, callback: showHitokoto }, \"asteroids\": { icon: fa_paper_plane, callback: () => { if (window.Asteroids) { if (!window.ASTEROIDSPLAYERS) window.ASTEROIDSPLAYERS = []; window.ASTEROIDSPLAYERS.push(new Asteroids()); } else { const script = document.createElement(\"script\"); script.src = \"https://fastly.jsdelivr.net/gh/stevenjoezhang/asteroids/asteroids.js\"; document.head.appendChild(script); } } }, \"switch-model\": { icon: fa_user_circle, callback: () => {} }, \"switch-texture\": { icon: fa_street_view, callback: () => {} }, \"photo\": { icon: fa_camera_retro, callback: () => { showMessage(\"照好了嘛，是不是很可爱呢？\", 6000, 9); Live2D.captureName = \"photo.png\"; Live2D.captureFrame = true; } }, \"info\": { icon: fa_info_circle, callback: () => { open(\"https://github.com/stevenjoezhang/live2d-widget\"); } }, \"quit\": { icon: fa_xmark, callback: () => { localStorage.setItem(\"waifu-display\", Date.now()); showMessage(\"愿你有一天能与重要的人重逢。\", 2000, 11); document.getElementById(\"waifu\").style.bottom = \"-500px\"; setTimeout(() => { document.getElementById(\"waifu\").style.display = \"none\"; document.getElementById(\"waifu-toggle\").classList.add(\"waifu-toggle-active\"); }, 3000); } } }; export default tools;"},{"path":"/live2d-widget-master/src/utils.js","content":"function randomSelection(obj) { return Array.isArray(obj) ? obj[Math.floor(Math.random() * obj.length)] : obj; } export default randomSelection;"},{"path":"/live2d-widget-master/src/waifu-tips.js","content":"import initWidget from \"./index.js\"; window.initWidget = initWidget;"}]