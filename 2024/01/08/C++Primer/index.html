
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.27.0" theme-name="Stellar" theme-version="1.27.0">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>C++ Primer - 何泽贤的图书室</title>

  
    <meta name="description" content="前言  固然，轻薄短小的书籍乍见之下让所有读者心情轻松，但如果舍弃太多应该深入的地方不谈，也难免令人行止失据，进退两难。 …… 作为一个好的学习者，背景不是重点，重要的是，你是否具备正确的学习态度。起步固然可从轻松小品开始，但如果碰上大部头巨著就退避三舍、逃之夭夭，面对任何技术只求快餐速成，学语言却从来不写程序，那就绝对没有成为高手乃至专家的一天。 有些人的学习，自练就一身钢筋铁骨，可以在热带丛">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer">
<meta property="og:url" content="https://hezexian.github.io/2024/01/08/C++Primer/index.html">
<meta property="og:site_name" content="何泽贤的图书室">
<meta property="og:description" content="前言  固然，轻薄短小的书籍乍见之下让所有读者心情轻松，但如果舍弃太多应该深入的地方不谈，也难免令人行止失据，进退两难。 …… 作为一个好的学习者，背景不是重点，重要的是，你是否具备正确的学习态度。起步固然可从轻松小品开始，但如果碰上大部头巨著就退避三舍、逃之夭夭，面对任何技术只求快餐速成，学语言却从来不写程序，那就绝对没有成为高手乃至专家的一天。 有些人的学习，自练就一身钢筋铁骨，可以在热带丛">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401081030476.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401081025034.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401081104469.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401101530079.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401101536561.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401110941997.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401111004548.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401111025007.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401111524526.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401111547255.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401121552247.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401121142358.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401131600803.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401131603212.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401141127468.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401141128465.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401141601280.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401131535739.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401151047619.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401151426222.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401171100692.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401171607017.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401181007150.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401181617249.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401221042529.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401212100323.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401212228151.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401232246190.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401242153870.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401242233996.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401251044101.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401242237156.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401242235255.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401251631905.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401260921334.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401260943509.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401261224291.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401261613618.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401261224557.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401261757615.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401261226532.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401271500480.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401271525056.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401271558280.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401271611838.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401271615161.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401280912213.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401280928465.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401272203790.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281520448.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281553783.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281619598.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401282149718.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281801235.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281035812.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281102757.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281122221.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401291125010.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401291152804.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401291126731.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401291602660.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402021136952.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402021052259.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402031036331.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402031140878.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402031523800.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402031523918.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402032113033.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402032150537.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402042051427.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402042108959.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402042147204.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402042148050.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402050716864.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402052128072.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402050956853.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402050957004.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051032678.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402050959875.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051455057.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051458429.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051500619.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051501346.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051515470.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051531873.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051559437.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051600520.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402052102580.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402052147283.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402052154316.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402060925431.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402052211491.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402061053237.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402061545630.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402062126441.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402061628874.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402062201953.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402062227111.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402062228056.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402071759152.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402071812706.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402072147044.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402072209158.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402201501741.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402201622418.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/1708483132022.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402211708483950.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402221708579013.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403131710318400.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403141710401943.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403171710648132.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403171710654733.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403181710750203.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403192013939.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403231430309.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403231444209.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251657214.png">
<meta property="og:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251658982.png">
<meta property="article:published_time" content="2024-01-07T16:00:00.000Z">
<meta property="article:modified_time" content="2024-03-16T16:00:00.000Z">
<meta property="article:author" content="He Zexian">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="读书笔记">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401081030476.png">
  
  
  
  <meta name="keywords" content="c++,读书笔记">

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="何泽贤的图书室" type="application/atom+xml">
  

  <link rel="stylesheet" href="/css/main.css?v=1.27.0">

  
    <link rel="shortcut icon" href="/imgs/webicon.png">
  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/imgs/photo.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">何泽贤的图书室</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2024/03/26/%E9%83%AD%E5%A4%A9%E7%A5%A551%E5%8D%95%E7%89%87%E6%9C%BA%E7%AC%AC%E4%BA%8C%E7%89%88/"><span class="title">郭天祥51单片机第二版</span></a><a class="item title" href="/2022/06/09/cmake+mingw32+win11+clion%E7%BC%96%E8%AF%91OpenCV4.5+contrib/"><span class="title">cmake+mingw32+win11+clion编译OpenCV4.5+contrib</span></a><a class="item title" href="/2024/01/03/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"><span class="title">git基本操作</span></a><a class="item title" href="/2024/02/15/lsky+1panel+https+%E9%9B%A8%E4%BA%91%E9%85%8D%E7%BD%AE/"><span class="title">1panel+雨云服务器+https配置lsky-pro（兰空图床）</span></a><a class="item title" href="/2024/02/24/%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AEPlatformIO%E7%94%9F%E6%88%90HEX%E6%96%87%E4%BB%B6/"><span class="title">通过代码配置PlatformIO生成HEX文件</span></a><a class="item title" href="/2024/02/19/Qt%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83%EF%BC%8C%E5%90%AB%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"><span class="title">qt程序打包发布，含三方库</span></a><a class="item title" href="/2024/01/31/emit%E5%92%8Cconnect%E7%9A%84%E9%A1%BA%E5%BA%8F/"><span class="title">emit和connect的顺序问题</span></a><a class="item title" href="/2021/06/01/%E5%AD%99%E9%91%ABVC++%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3/"><span class="title">孙鑫VC++深入详解</span></a><a class="item title" href="/2024/02/19/vmware%E5%AE%89%E8%A3%85%E8%BF%87%E5%A2%9E%E5%BC%BA%E5%B7%A5%E5%85%B7%E8%BF%98%E6%98%AF%E6%97%A0%E6%B3%95%E6%8B%96%E6%94%BE/"><span class="title">vmware安装过增强工具还是无法拖放</span></a><a class="item title" href="/2024/02/27/protues%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/"><span class="title">protues配置相关</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> <span class="sep"></span> <a class="cap breadcrumb-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C-Primer/">C++ Primer</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2024-01-07T16:00:00.000Z">2024-01-08</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-03-16T16:00:00.000Z">2024-03-17</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>C++ Primer</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<blockquote>
<p><strong>固然，轻薄短小的书籍乍见之下让所有读者心情轻松，但如果舍弃太多应该深入的地方不谈，也难免令人行止失据，进退两难。</strong></p>
<p>……</p>
<p><strong>作为一个好的学习者，背景不是重点，重要的是，你是否具备正确的学习态度。起步固然可从轻松小品开始，但如果碰上大部头巨著就退避三舍、逃之夭夭，面对任何技术只求快餐速成，学语言却从来不写程序，那就绝对没有成为高手乃至专家的一天。</strong></p>
<p><strong>有些人的学习，自练就一身钢筋铁骨，可以在热带丛林中披荆斩棘，在莽莽草原中追奔逐北。有些人的学习，既未习惯大部头书，也未习惯严谨格调，更未习惯自修勤学，是温室里的一朵花，没有自立自强的本钱</strong>。</p>
<p>——《Essential C++》前言，侯捷</p>
</blockquote>
<h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1>
<p>[1] <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/cpp-standard-library-reference?view=msvc-170">C++ 标准库参考 (STL)—Microsoft</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://cplusplus.com">cplusplus.com</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/C%2B%2B%E6%A8%99%E6%BA%96%E5%87%BD%E5%BC%8F%E5%BA%AB">stl—wiki</a></p>
<div align="center"><h1>------C++ 基础------</h1></div>
<h1 id="二-变量和基本类型"><a class="markdownIt-Anchor" href="#二-变量和基本类型"></a> 二 变量和基本类型</h1>
<h2 id="21-基本内置类型"><a class="markdownIt-Anchor" href="#21-基本内置类型"></a> 2.1 基本内置类型</h2>
<h3 id="211-变量类型的大小"><a class="markdownIt-Anchor" href="#211-变量类型的大小"></a> 2.1.1 变量类型的大小</h3>
<p>下图列出了各类型的最小尺寸。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401081030476.png" alt="数据类型最小大小" style="zoom:67%;" />
<h3 id="212-符号"><a class="markdownIt-Anchor" href="#212-符号"></a> 2.1.2 符号</h3>
<ul>
<li>
<p>整型</p>
<ul>
<li>int：正数、负数和0</li>
<li>usigned int: 大于0</li>
</ul>
</li>
<li>
<p>字符型</p>
<ul>
<li>char :在有些机器上是signed，有些机器是unsigned</li>
<li>signed char</li>
<li>unsigned char</li>
</ul>
</li>
</ul>
<p>如何选择？</p>
<ul>
<li>
<p>明知数值不可能为负，用无符号</p>
</li>
<li>
<p>整数运算用int、long long</p>
</li>
<li>
<p>浮点用double</p>
</li>
</ul>
<h3 id="213类型转化"><a class="markdownIt-Anchor" href="#213类型转化"></a> 2.1.3类型转化</h3>
<ul>
<li>
<p>❓有个不明白的地方，不明白怎么算的:(P33)赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。</p>
</li>
<li>
<p>当一个算术表达式中既有无符号又有int，int就会转换成无符号，有可能引发错误。  &lt;-混用引发错误</p>
</li>
</ul>
<h2 id="22-字面值常量"><a class="markdownIt-Anchor" href="#22-字面值常量"></a> 2.2 字面值常量</h2>
<ul>
<li>
<p>整型和浮点型</p>
<ul>
<li>自动选择能匹配的空间最小的一个作为其数据类型</li>
<li>十进制不会是负数。符号不在字面值之内，负号的作用是对字面值取负</li>
<li>科学计数法指数部分用E或e标识</li>
</ul>
</li>
<li>
<p>字符和字符串字面值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> <span class="comment">// 字符, &#x27;a&#x27;</span></span><br><span class="line"><span class="string">&quot;a&quot;</span> <span class="comment">// 字符串，&#x27;a&#x27;+&#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则实际上是一个整体</span></span><br><span class="line">std::cout&lt;&lt; <span class="string">&quot;a really, really long string literal &quot;</span></span><br><span class="line">        &lt;&lt;<span class="string">&quot;that spans two lines&quot;</span> &lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>转义<br />
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chuijingjing/p/9246669.html">常用转义字符</a></p>
</li>
<li>
<p>布尔和指针</p>
<ul>
<li>bool ：true ，false</li>
<li>指针：nullptr</li>
</ul>
</li>
</ul>
<p>如何指定字面值类型？</p>
<ul>
<li>通过添加下表的前缀和后缀，改变整型、浮点型和字符型字面值的默认类型<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401081025034.png" alt="指定字面值类型" style="zoom:67%;" /></li>
</ul>
<h2 id="23-变量"><a class="markdownIt-Anchor" href="#23-变量"></a> 2.3 变量</h2>
<h3 id="231-了解变量"><a class="markdownIt-Anchor" href="#231-了解变量"></a> 2.3.1 了解变量</h3>
<ul>
<li>
<p>定义</p>
</li>
<li>
<p>初始化</p>
<ul>
<li>初始化不是赋值：
<ul>
<li>初始化是创建变量时赋予其一个初始值；</li>
<li>赋值是把对象的当前值擦除，而以一个新值替代。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>四种初始化方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能有信息丢失的风险</span></span><br><span class="line"><span class="type">long</span> <span class="type">double</span> b = <span class="number">3.1415929</span></span><br><span class="line"><span class="type">int</span> a = b;  <span class="comment">// a = 3, 信息丢失</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(b)</span></span>;  <span class="comment">// a = 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用列表初始化，存在上述风险将报错</span></span><br><span class="line"><span class="type">int</span> a = &#123;b&#125;;</span><br><span class="line"><span class="type">int</span> a&#123;b&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>默认初始化</p>
<ul>
<li>
<p>内置类型默认初始化的值由定义的位置决定</p>
<ul>
<li>定义与任何函数体之外 ，初始化为0</li>
<li>…内，不被默认初始化，变量值未定义</li>
</ul>
</li>
<li>
<p><strong>建议初始化每一个内置类型的变量</strong></p>
</li>
</ul>
</li>
<li>
<p>声明和定义的关系</p>
<ul>
<li>
<p>声明使得名字为程序所知；定义负责创建与名字关联的实体，并申请存储空间。</p>
</li>
<li>
<p>只能被定义一次，可以被声明多次。</p>
</li>
<li>
<p>如果想声明一个变量而非定义，使用<code>extern</code>，并且不要显示地初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;     <span class="comment">//仅声明</span></span><br><span class="line"><span class="type">int</span> i ;         <span class="comment">//声明并定义</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在函数体内部，初始化一个又<code>extern</code>标记的变量，将引发错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i = <span class="number">3.14</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果要在多个文件中使用同一个变量，必须将声明和定义分离。变量的定义必须出现且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。例，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Class2.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class2::<span class="built_in">print_i</span>();  <span class="comment">// 重点输出：Class2: 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class2.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;    <span class="comment">// &lt;- 注意这里，如果不写就会报：i未声明标识符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Class2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print_i</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Class2: &quot;</span>&lt;&lt;i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Class2.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> i = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>标识符</p>
<ul>
<li>用户自定义标识符中不能连续出现两个下划线；不能下划线紧邻大写字母；定义在函数体外的标识符不能以下划线开头。</li>
<li>变量名一般小写字母；类名以大写字母开头</li>
</ul>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401081104469.png" style="zoom:67%;" />
</li>
</ul>
<h3 id="232-作用域"><a class="markdownIt-Anchor" href="#232-作用域"></a> 2.3.2 作用域</h3>
<p>对于嵌套作用域：</p>
<ul>
<li>作用域中一旦声明了某个名字，它所嵌套着的所有作用域都能访问这个名字。</li>
<li>同时，允许在内层作用域中重新定义外层作用域中已有的名字。</li>
<li><code>::</code>访问全局变量。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; endl; 		<span class="comment">//42,0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; endl;		<span class="comment">//0,0</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ::a &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; endl;	<span class="comment">//42,0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="24-复合类型"><a class="markdownIt-Anchor" href="#24-复合类型"></a> 2.4 复合类型</h2>
<ul>
<li>声明语句：一条语句声明由一个基本数据类型和紧随其后的声明符列表组成。</li>
<li>指针和引用，前后的类型都要严格匹配</li>
</ul>
<h3 id="241-引用"><a class="markdownIt-Anchor" href="#241-引用"></a> 2.4.1 引用</h3>
<ul>
<li>引用必须被初始化，且只能绑定到对象上，不能与字面值或某个表达式的计算结果绑定；</li>
<li>无法令引用重新绑定到另一个对象；</li>
<li>引用本身不是对象，所以不能定义引用的引用</li>
</ul>
<h3 id="242-指针"><a class="markdownIt-Anchor" href="#242-指针"></a> 2.4.2 指针</h3>
<ul>
<li>
<p>指针本身是一个对象；</p>
</li>
<li>
<p>无须在定义时赋初值；</p>
</li>
<li>
<p>引用不是对象，没有实际地址，不能定义指向引用的指针；但指针是对象，存在对指针的引用，例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> *&amp;r = p; <span class="comment">// r是对指针p的引用</span></span><br></pre></td></tr></table></figure>
<p>注：上面的代码如何阅读？从又向左阅读r的定义，离变量名最近的符号（此处为<code>&amp;</code>）对变量的类型有直接的影响，因此上文中r是一个引用。</p>
</li>
</ul>
<p><code>void *</code>可用于存放任意对象的地址，我们不清楚其到底指向的是什么类型的对象，也无法访问其指向的内存空间中的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">void</span> *ptr = &amp;a;</span><br><span class="line">cout&lt;&lt;*ptr&lt;&lt;endl; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<p>定义多个变量时，类型修饰符（如 *）只修饰一个变量，对该声明语句中的其他变量，不产生任何作用。例，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样写容易产生误导</span></span><br><span class="line"><span class="type">int</span>* p1,p2;        <span class="comment">// p1是指向int的指针，p2是int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议写成</span></span><br><span class="line"><span class="type">int</span> *p1, p2;</span><br></pre></td></tr></table></figure>
<h2 id="25-const"><a class="markdownIt-Anchor" href="#25-const"></a> 2.5 const</h2>
<ul>
<li>const的宗旨：<strong>任何试图改变<code>const</code>修饰的变量都将引发错误</strong></li>
<li>const对象一旦创建就不能改变，因此必须初始化，初始值可以是任意复杂表达式</li>
<li>默认状态下，const对象仅在文件内生效。如果想要在多个文件中共享，最好的办法是不管是声明还是定义都加上<code>extern</code>关键字。</li>
</ul>
<h3 id="251-常量引用"><a class="markdownIt-Anchor" href="#251-常量引用"></a> 2.5.1 常量引用</h3>
<ul>
<li>
<p>即对const的引用</p>
</li>
<li>
<p>初始化常量引用允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">//const int temp = a;  // &lt;-编译器内部自己做的操作,生成一个临时变量</span></span><br><span class="line"><span class="comment">//const int &amp;r = temp; //&lt;-编译器内部自己做的操作，将引用绑定到一个临时变量上</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = a;  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>const的左值引用可以绑定到右值<br />
<a href="#1361-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8">右值引用</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i*<span class="number">42</span>; <span class="comment">// 错误，左值引用不可绑定到右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = i*<span class="number">42</span>; <span class="comment">// 正确，const的左值引用可以绑定到右值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="252-指针和const"><a class="markdownIt-Anchor" href="#252-指针和const"></a> 2.5.2 指针和const</h3>
<ul>
<li>
<p>指针常量 – 指向常量的指针</p>
<ul>
<li>
<p>想要存放常量对象的地址，只能使用指向常量的指针；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span>  <span class="type">double</span> *cptr = &amp;pi;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>允许一个指向常量的指针指向非常量对象。</p>
</li>
</ul>
</li>
<li>
<p>常量指针 – 指针本身是一个常量</p>
<ul>
<li>
<p>把*放在const之后，用以说明指针是一个常量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> ptr = &amp;a;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="253-顶层const和底层const"><a class="markdownIt-Anchor" href="#253-顶层const和底层const"></a> 2.5.3 顶层const和底层const</h3>
<ul>
<li>顶层const表示指针本身是一个常量。推广：任意的对象是常量，如算术类型、类、指针…</li>
<li>底层const表示指针所指的对象是常量。推广：指针和引用等复合类型的基本类型部分有关。</li>
</ul>
<p>当执行拷贝时，</p>
<ul>
<li>顶层const不受影响；</li>
<li>底层const对象必须具有相同的const资格，或者两个对象的数据类型必须能够转换。</li>
</ul>
<h3 id="254-常量表达式和constexpr"><a class="markdownIt-Anchor" href="#254-常量表达式和constexpr"></a> 2.5.4 常量表达式和constexpr</h3>
<ul>
<li>
<p>常量表达式</p>
<ul>
<li>
<p>常量表达式是指：值不会改变 且 在编译过程就能得到计算结果 的表达式</p>
</li>
<li>
<p>一个对象是不是常量表达式有其数据类型和初始值共同决定</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********** 例1 **************/</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mf = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = mf +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********** 例2 **************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>();  <span class="comment">// 通过</span></span><br><span class="line">    cout &lt;&lt; sz &lt;&lt; endl;    <span class="comment">// 输出1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>constexpr</code> – 由编译器来验证变量是否是一个常量表达式。声明为<code>constexpr</code>的变量:</p>
<ul>
<li>
<p>一定是一个常量</p>
</li>
<li>
<p>必须用常量表达式初始化</p>
</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********** 例1 **************/</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mf = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit = mf +<span class="number">1</span>;</span><br><span class="line"><span class="comment">/*********** 例2 **************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int get_size() &#123; return 1; &#125; //C++表达式必须含有常量值,无法调用非constexpr函数 </span></span><br><span class="line"><span class="comment">//const int get_size() &#123; return 1; &#125; //同上</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">get_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>(); </span><br><span class="line">    cout &lt;&lt; sz &lt;&lt; endl;    <span class="comment">// 输出1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>字面值类型</p>
<ul>
<li>
<p>算术类型、引用和指针都属于，可被定义为constexpr；</p>
<p>注意：</p>
<ul>
<li>
<p>引用和指针初始值受限：必须是0或者nullptr，或者存储于某个固定地址中的对象。函数提内的对象一般不在固定地址，不能用constexpr；允许函数定义的一类超出函数体本身的变量，其存在于固定地址，constexpr引用（指针）也能（绑定）指向该变量。</p>
</li>
<li>
<p>constexpr定义了一个指针，constexpr仅对指针本身有效，对指针所指的对象无关 &lt;-顶层const。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *q = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// 类似</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> q = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------</span></span><br><span class="line"><span class="comment">//可得</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> *p  = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// 类似</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>io、string等不属于字面值类型</p>
</li>
</ul>
</li>
<li>
<p>constexpr函数<a href="#653-constexpr%E5%87%BD%E6%95%B0">（笔记6.5.3）</a></p>
</li>
<li>
<p>constexpr类<a href="#742-constexpr%E7%B1%BB">（笔记7.4.2）</a></p>
</li>
</ul>
<h2 id="26-处理类型"><a class="markdownIt-Anchor" href="#26-处理类型"></a> 2.6 处理类型</h2>
<h3 id="261-类型别名"><a class="markdownIt-Anchor" href="#261-类型别名"></a> 2.6.1 类型别名</h3>
<ul>
<li>
<p><code>typedef</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages;</span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">//base = double, p = double *</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>using</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> wages = <span class="type">double</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>需要注意的是，<strong>类型别名不能直接往代码中替换，要将类型别名看成一个整体</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *pstring; <span class="comment">//pstring = char *</span></span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">// 指针本身是一个常量，char *const cstr = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接替换是错误的：</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *cstr = <span class="number">0</span>; <span class="comment">//指向常量的指针</span></span><br></pre></td></tr></table></figure>
<h3 id="262-auto"><a class="markdownIt-Anchor" href="#262-auto"></a> 2.6.2 auto</h3>
<ul>
<li>
<p>auto定义的变量必须有初始值</p>
</li>
<li>
<p>编译器以引用对象的类型作为auto的类型（auto会忽略引用）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, &amp; r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r; <span class="comment">// auto = int</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>auto一般会忽略掉顶层const，保留底层const。想要保留顶层const，则需要手动指出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i, &amp; cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;  <span class="comment">//int (顶层const)</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;  <span class="comment">//int  （顶层const）</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;  <span class="comment">//int *  （顶层const）</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;  <span class="comment">//const int *  （底层const）</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = ci; <span class="comment">//const int  (为保留顶层const而手动指出)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>auto和引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;g = ci; <span class="comment">//g 的类型为const int &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//auto &amp;h = 42; //错误，不能为非常量引用绑定字面值</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;h = <span class="number">42</span>;  <span class="comment">//const int &amp;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>利用auto在一条语句中声明多个变量时，这多个变量的初始值必须是同一类型。</p>
</li>
</ul>
<h3 id="263-decltype"><a class="markdownIt-Anchor" href="#263-decltype"></a> 2.6.3 decltype</h3>
<ul>
<li>
<p>选择并返回操作数的数据类型 – 编译器分析表达式并得到其类型，却不计算其值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func</span>()) sun = x;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用）&lt;-区别于auto</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x= <span class="number">0</span>;  <span class="comment">// const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x; <span class="comment">//const int &amp;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>decltype和引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(r+<span class="number">0</span>) b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype(*p) c; //出错，“引用变量c需要初始值设定项”</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c = i; <span class="comment">//c的类型是int &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(i) d;  <span class="comment">// int</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) e = i;  <span class="comment">//int &amp;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>decltype(r)</code>的结果是引用，如果想让结果类型是r所指的类型，只需把r作为表达式的一部分，如<code>decltype(r+0)</code></li>
<li><strong>decltype表达式的类型是解引用操作，将得到引用类型</strong>，因此必须初始化，如<code>decltype(*p) c = i;</code></li>
<li><strong><code>decltype((variable))</code>  （注意是双层括号）的结果永远是引用类型</strong></li>
</ul>
</li>
</ul>
<h1 id="三-字符串-向量和数组"><a class="markdownIt-Anchor" href="#三-字符串-向量和数组"></a> 三 字符串、向量和数组</h1>
<h2 id="31-using"><a class="markdownIt-Anchor" href="#31-using"></a> 3.1 <code>using</code></h2>
<ul>
<li>
<p>每个名字都需要独立的<code>using</code>声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意：头文件中不应包含<code>using</code> &lt;-否则，每个使用该头文件的代码都会包含该声明，从而引起命名的冲突。</p>
</li>
</ul>
<h2 id="32-string"><a class="markdownIt-Anchor" href="#32-string"></a> 3.2 string</h2>
<p>[笔记9.6 - string专题](# 9.6 string专题)</p>
<h3 id="321-初始化"><a class="markdownIt-Anchor" href="#321-初始化"></a> 3.2.1 初始化</h3>
<ul>
<li>拷贝初始化。<code>string s = &quot;a&quot;;</code></li>
<li>直接初始化。<code>string s(&quot;a&quot;);</code></li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401101530079.png" alt="初始化string的方式" /></p>
<p><a href="#962-%E6%9E%84%E9%80%A0string%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95">笔记9.6.2 其他初始化string的方法</a></p>
<h3 id="322-string对象的操作"><a class="markdownIt-Anchor" href="#322-string对象的操作"></a> 3.2.2 string对象的操作</h3>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401101536561.png" alt="string的操作" /></p>
<ul>
<li>
<p>读写</p>
<ul>
<li>
<p>读取操作时，string对象会自动忽略开头的空白，并从真正的第一个字符开始读起，直到遇到下一个空白。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入&quot;  hello world&quot;;</span></span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl; <span class="comment">//hello</span></span><br><span class="line"></span><br><span class="line">string s1,s2;</span><br><span class="line">cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">cout &lt;&lt; s1&lt;&lt;s2&lt;&lt;endl; <span class="comment">//helloworld</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//endl 结束当前行，刷新缓冲区</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>读取未知数量的string对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;s)&#123; <span class="comment">//遇到文件结束标记或非法输入，循环结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>读取一整行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string line;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin,line))&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>getline</code>从给定的输入流中读取内容，直到遇到换行符为止（换行符也被读取进来了），将内容存入string对象中（不存换行符）。</li>
<li>如果一开始就是换行符，则得到空的string对象。</li>
<li>和cin一样返回流参数，因此可作为循环的判断条件</li>
</ul>
</li>
</ul>
</li>
<li>
<p>size</p>
<ul>
<li><code>size()</code>返回一个<code>string::size_type</code>类型的值，是一个无符号类型的值，因此要避免与有符号数混用所带来的问题。</li>
</ul>
</li>
<li>
<p>相加<br />
<strong>当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符两侧的<font color="red">运算对象至少有一个是string</font>.</strong><br />
<a href="#141-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">14.1最后一点，<code>operator+</code>在string类中为非成员</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string s1 = s+<span class="string">&quot;,&quot;</span>; <span class="comment">//正确</span></span><br><span class="line">string s2 = <span class="string">&quot;hello&quot;</span>+<span class="string">&quot;,&quot;</span>; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line">string s3 = s+<span class="string">&quot;,&quot;</span>+<span class="string">&quot;hello&quot;</span>; <span class="comment">//正确</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">string s3 = (s+<span class="string">&quot;,&quot;</span>)+<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">string tmp = s1+<span class="string">&quot;,&quot;</span>;</span><br><span class="line">string s3 = tmp+<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">string s4 = <span class="string">&quot;hello&quot;</span>+<span class="string">&quot;,&quot;</span>+s; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="323-处理string对象中的字符"><a class="markdownIt-Anchor" href="#323-处理string对象中的字符"></a> 3.2.3 处理string对象中的字符</h3>
<ul>
<li>处理函数</li>
</ul>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401110941997.png" alt="cctype头文件中的函数" style="zoom:67%;" />
<ul>
<li>
<p>范围for</p>
<ul>
<li>注意declaration是引用时，是直接对experssion中原来的元素进行操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(declaration : experssion)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>下标运算符（[ ]）接收的输入是<code>string::size_type</code>类型的值，返回值是该位置上字符的引用。</p>
<ul>
<li><code>str[str.size()-1]</code>是最后一个字符</li>
<li>在访问指定字符之前，需要检查字符串是否为空：<code>if(!str.isempty())&#123; /*访问指定字符*/&#125;</code>，并注意下标的合法范围<code>[0 , str.size())</code>。</li>
</ul>
</li>
</ul>
<h2 id="33-vector"><a class="markdownIt-Anchor" href="#33-vector"></a> 3.3 vector</h2>
<h3 id="331-初始化vector对象"><a class="markdownIt-Anchor" href="#331-初始化vector对象"></a> 3.3.1 初始化vector对象</h3>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401111004548.png" alt="初始化vector对象的方法" style="zoom:67%;" />
<ul>
<li>
<p>使用拷贝初始化（=）只能提供一个初始值；</p>
</li>
<li>
<p>类内初始值只能使用拷贝初始化或使用花括号形式的初始值；</p>
</li>
<li>
<p>列表初始化使用{}，而不是()</p>
<ul>
<li>
<p>值得注意的是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v1&#123;<span class="number">10</span>&#125;;             <span class="comment">// 10个默认初始化的元素</span></span><br><span class="line">vector&lt;string&gt; v2&#123;<span class="number">10</span>,<span class="string">&quot;hi&quot;</span>&#125;;        <span class="comment">// 10个值为hi的元素</span></span><br></pre></td></tr></table></figure>
<p>以上两者都不是列表初始化，花括号的值必须与元素类型相同，显然不能用int初始化string对象，因此上面两者的花括号中都不能作为元素的初始值。在无法执行列表初始化后，编译器会尝试用默认值初始化vector对象。</p>
</li>
</ul>
</li>
</ul>
<h3 id="332-vector操作"><a class="markdownIt-Anchor" href="#332-vector操作"></a> 3.3.2 vector操作</h3>
<ul>
<li>
<p>添加元素 – <code>push_back()</code></p>
<ul>
<li>
<blockquote>
<p>在定义vector对象的时候设定其大小就没什么必要了，事实上如果这么做性能可能更差</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>vector其他操作罗列</p>
<ul>
<li>
<p>注意<code>size()</code>同样返回<code>vector&lt;xxx&gt;::size_type</code>类型</p>
<blockquote>
<p>要使用<code>size_type</code>类型，需要首先指定它是由哪些类型定义的</p>
</blockquote>
</li>
</ul>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401111025007.png" alt="vector的其他操作" style="zoom:67%;" />
</li>
<li>
<p>只有当元素的值可比时，vector对象才能被比较：元素个数相等，对应位置的元素也相等</p>
</li>
</ul>
<h3 id="333-迭代器"><a class="markdownIt-Anchor" href="#333-迭代器"></a> 3.3.3 迭代器</h3>
<ul>
<li>
<p>用法</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401111524526.png" alt="迭代器运算符" style="zoom:67%;" />
<blockquote>
<p>在for循环中使用<code>!=</code>，原因是c++程序员更愿意使用迭代器而非下标。并非所有的容器的迭代器都定义了<code>&lt;</code>等，但都定义了<code>==</code>和<code>!=</code></p>
</blockquote>
</li>
<li>
<p>迭代器的类型 – <code>iterator</code>和<code>const_iterator</code>（只读）</p>
<ul>
<li>如果迭代器对象是一个常量，则只能用const_iterator</li>
<li>不是常量，则都能用</li>
</ul>
</li>
<li>
<p>begin和end、cbegin和cend</p>
<ul>
<li>
<p>它们返回的具体类型由对象是否是常量决定，如是常量返回const_iterator，否则返回iterator</p>
</li>
<li>
<p>如果只需读取，而不写入，可使用<code>cbegin</code>和<code>cend</code>，返回const_iterator</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.<span class="built_in">begin</span>();        <span class="comment">// vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.<span class="built_in">begin</span>();        <span class="comment">// vector&lt;int&gt;::const_iterator</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it3 = v.<span class="built_in">cbegin</span>();         <span class="comment">// vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>使vector迭代器失效的操作：</p>
<ul>
<li>在范围for循环中向vector对象添加元素</li>
<li>任何一种可能改变vector对象的操作，如push_back</li>
</ul>
</li>
<li>
<p>运算<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401111547255.png" alt="vector和string迭代器支持的运算" style="zoom:67%;" /></p>
<ul>
<li>迭代器相减的结果的类型：<code>difference_type</code>的带符号整型数</li>
</ul>
</li>
</ul>
<h2 id="34-数组"><a class="markdownIt-Anchor" href="#34-数组"></a> 3.4 数组</h2>
<h3 id="341-定义和初始化数组"><a class="markdownIt-Anchor" href="#341-定义和初始化数组"></a> 3.4.1 定义和初始化数组</h3>
<ul>
<li>
<p>定义</p>
<ul>
<li>编译的时候维度必须是已知的，维度必须是一个常量表达式（<code>constexpr</code>）</li>
<li>和内置类型的变量一样，如果在<strong>函数内部定义</strong>了某种内置类型的数组，那么<strong>默认初始化会令数组含有未定义的值</strong></li>
<li>不许用auto指定数组；</li>
<li>不存在引用的数组</li>
</ul>
</li>
<li>
<p>初始化</p>
<ul>
<li>
<p>显式地初始化数组</p>
<ul>
<li>
<p>列表初始化时，可不写维度，编译器会自动推测</p>
</li>
<li>
<p>指明维度后，初始值数量不应超过维度大小</p>
</li>
</ul>
</li>
<li>
<p>字符数组的特殊性 – 注意字符串结尾的空字符也会被拷贝到数组中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a3[] = <span class="string">&quot;c++&quot;</span>;  <span class="comment">// 维度为4</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="type">char</span> a3[] = &#123;<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>数组不允许拷贝和赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> a2[] = a;     <span class="comment">// 错误</span></span><br><span class="line">a2 = a;            <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>复杂的数组声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*parray)[<span class="number">10</span>] = &amp;arr;</span><br></pre></td></tr></table></figure>
<p>从数组名开始，由内向外，由右向左 --&gt;parray是一个指针，指向大小为10的数组，数组中包含int对象</p>
</li>
</ul>
</li>
<li>
<p>在使用数组下标时，通常将其定义为<code>size_t</code>类型，它是一种无符号整型，定义于<code>cstddef</code>中</p>
</li>
<li>
<p>两个特殊性质</p>
<ul>
<li>不允许拷贝数组</li>
<li>使用数组时通常会将其转化成指针</li>
</ul>
</li>
</ul>
<h3 id="342-指针和数组"><a class="markdownIt-Anchor" href="#342-指针和数组"></a> 3.4.2 指针和数组</h3>
<ul>
<li>
<p>数组名是指向数组首元素的指针</p>
<ul>
<li>
<p><code>auto</code>推断得到的类型是<strong>指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;  <span class="comment">// auto == int *</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用<code>decltype</code>时，返回的类型是<strong>数组</strong>  &lt;-- 与auto区分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">ia3[<span class="number">1</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>“迭代器”</p>
<ul>
<li>
<p>获取数组的“尾后迭代器” &lt;–不能对尾后指针进行解引用或者递增</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *e = &amp;arr[<span class="comment">/*元素个数*/</span>];</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>然而这种方法极易出错，c++11在<code>iterator</code>头文件中定义了两个函数<code>begin</code>和<code>end</code>，它们分别返回头指针和尾指针，用法如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *begin = <span class="built_in">begin</span>(ia);    <span class="comment">// 正确的使用形式是将数组作为它们的参数</span></span><br><span class="line"><span class="type">int</span> *end = <span class="built_in">end</span>(ia);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>两个指向同一数组不同元素的指针相减得到它们之间的距离，类型为<code>ptrdiff_t</code>，定义于<code>cstddef</code>,为带符号类型。[（对比3.3.3节-运算-两个迭代器相减的结果类型）](#3.3.3 迭代器)</p>
</li>
<li>
<p>与vector与string等标准库下标运算仅支持无符号数不同，数组的下标运算（内置下标运算）支持负数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = &amp;a[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> j = *(p+<span class="number">1</span>);  <span class="comment">// j = a[3]</span></span><br><span class="line"><span class="type">int</span> k = p[<span class="number">-2</span>];  <span class="comment">//k = a[0]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="343-多维数组"><a class="markdownIt-Anchor" href="#343-多维数组"></a> 3.4.3 多维数组</h3>
<blockquote>
<p>严格来说，c++没有多维数组，所说多维数组其实是数组的数组。谨记这一点，对今后理解和使用多维数组大有裨益。</p>
</blockquote>
<ul>
<li>
<p><code>int arr[3][4]</code>: 大小为3的数组，每个元素是含有4个整数的数组</p>
</li>
<li>
<p>初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">                &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------</span></span><br><span class="line"><span class="comment">//初始化每行首元素</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">4</span>&#125;,&#123;<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//不等于</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">4</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>下标和多维数组  略</p>
</li>
<li>
<p>范围for处理多维数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; row :ia)&#123;  &lt;--注意此处一定为 引用，原因如下所述</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> col :row)&#123;</span><br><span class="line">        cout&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>auto会将<a href="#3.4.2-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84">数组自动转成指针</a> （3.4.2节-<code>auto</code>推断得到…），row的类型就成了<code>int *</code>，怎么可能再进行内层循环呢？</p>
</li>
<li>
<p>指针和多维数组</p>
<ul>
<li>
<p>多维数组名 ：指向第一个内层数组的指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = <span class="built_in">begin</span>(ia); p!=<span class="built_in">end</span>(ia); p++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> q = <span class="built_in">begin</span>(*p); q != <span class="built_in">end</span>(*p); q++)&#123;</span><br><span class="line">        <span class="comment">/*...*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401121552247.png" style="zoom: 67%;" />
</li>
<li>
<p>参考资料</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiang_bolin/article/details/130448488">数组大小可省略的定义 – 努力学习游泳的鱼</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="344-与旧代码接口"><a class="markdownIt-Anchor" href="#344-与旧代码接口"></a> 3.4.4 与旧代码接口</h3>
<ul>
<li>
<p>C风格字符串</p>
<ul>
<li>c++程序中最好不要使用<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401121142358.png" alt="c风格字符串操作函数列举" /></li>
<li>传入上述函数的指针<strong>必须指向以空字符串作为结束</strong>的数组</li>
</ul>
</li>
<li>
<p>string和c风格字符串</p>
<ul>
<li>任何出现字符串字面值的地方都可以用  以空字符结束的字符数组  替代
<ul>
<li>允许用…来初始化string对象或为string对象赋值</li>
<li>允许作为加法运算中的一员（P111）</li>
</ul>
</li>
<li>但是，不能反过来用string对象直接初始化指向字符数组的指针，
<ul>
<li><code>string.c_str()</code>返回一个指向以空字符结束的字符数组的指针（char  *），数组存放的数据恰好与string对象一样；</li>
<li>但如果后续操作改变string，之前返回的字符数组将会失效</li>
</ul>
</li>
</ul>
</li>
<li>
<p>使用数组初始化vector</p>
<ul>
<li>
<p>允许使用数组来初始化vector对象，只需指明首元素地址和<strong>尾后</strong>地址</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec1</span><span class="params">(begin(arr),end(arr))</span></span>;    <span class="comment">//&#123;0,1,2,3,4,5&#125;</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec2</span><span class="params">(arr+<span class="number">1</span>,arr+<span class="number">3</span>)</span></span>;            <span class="comment">//&#123;1,2&#125;  &lt;--不包含rr[3]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="四-表达式"><a class="markdownIt-Anchor" href="#四-表达式"></a> 四 表达式</h1>
<h2 id="41-基础"><a class="markdownIt-Anchor" href="#41-基础"></a> 4.1 基础</h2>
<ul>
<li>
<p>小整数类型（bool、char、short等）通常会被提升成较大的整数类型，主要是int</p>
</li>
<li>
<p>运算符重载时，运算对象的个数、运算符的优先级和结合律都是无法改变的</p>
</li>
<li>
<p>左值和右值 &lt;-- 有些迷惑（P121，2024/1/13）❓</p>
<ul>
<li>
<p>左值表示一个占据<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020">内存</a>中可识别位置的一个对象，更进一步地，可以对左值取地址</p>
</li>
<li>
<p>判断右值的一个简单方法就是能不能对变量或者表达式取地址，如果不能，他就是右值</p>
</li>
<li>
<p>参考文献</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45425093/article/details/120310405">左值与右值 – 不摆烂的zzz</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p>求值顺序</p>
<ul>
<li>
<p>对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。</p>
</li>
<li>
<p>求值顺序与优先级和结合律无关（P123底部）  &lt;–拿不准的时候用括号来强制符合要求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如，int i = f()+g()*h()+j()</span><br><span class="line">这些函数的调用顺序没有明确的规定，如果它们互不相关，则无妨。如果其中某几个函数影响同一个对象，则将会产生未定义行为</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这4种运算符明确规定了运算对象的求值顺序：<code>&amp;&amp;</code>, <code>||</code>, <code>?:</code>, <code>,</code></p>
</li>
<li>
<p>例外情况：当  改变运算对象的子表达式本身  就是  另一个子表达式的运算对象  ，则没有什么影响：如<code>*++iter</code>，递增运算先发生（改变运算对象的子表达式）,解引用后发生。</p>
</li>
</ul>
</li>
</ul>
<h2 id="42-运算符"><a class="markdownIt-Anchor" href="#42-运算符"></a> 4.2 运算符</h2>
<p>本节运算符表都是按照优先级顺序将其分组，同优先级按照从左到右的顺序。</p>
<h3 id="421-算术运算符"><a class="markdownIt-Anchor" href="#421-算术运算符"></a> 4.2.1 算术运算符</h3>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401131600803.png" alt="算术运算符" style="zoom:67%;" />
<ul>
<li>算术对象和求值结果都是<strong>右值</strong></li>
<li>小整数的对象被提升成较大整数</li>
<li>一元正号、加法、减法运算符都能作用于指针</li>
<li>一元正（负）号，（负数将运算对象值取负后）返回对象值的一个（提升后的）副本</li>
<li>c++11规定<strong>商一律向0取整</strong></li>
<li><code>%</code>返回两个<strong>整数</strong>相除所得的余数</li>
<li><strong>如果<code>m%n!=0</code>,结果符号与m相同</strong></li>
</ul>
<h3 id="422-逻辑和关系运算符"><a class="markdownIt-Anchor" href="#422-逻辑和关系运算符"></a> 4.2.2 逻辑和关系运算符</h3>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401131603212.png" alt="逻辑和关系运算符表" style="zoom:67%;" />
<ul>
<li>关系运算符作用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型。</li>
<li>返回值都是布尔类型，运算结果和求值对象都是<strong>右值</strong></li>
<li>因为关系运算法的求值结果是布尔类型，所以将几个关系运算符连写在一起会产生意想不到的效果</li>
</ul>
<h3 id="423-赋值运算符"><a class="markdownIt-Anchor" href="#423-赋值运算符"></a> 4.2.3 赋值运算符</h3>
<ul>
<li>赋值运算符的左侧运算对象必须是一个<strong>可修改</strong>的<strong>左值</strong></li>
<li>右侧运算对象将转换成左侧运算对象的类型</li>
</ul>
<h3 id="424-递增-递减运算符"><a class="markdownIt-Anchor" href="#424-递增-递减运算符"></a> 4.2.4 递增、递减运算符</h3>
<ul>
<li>
<p><code>++</code>、<code>--</code>运算符必须作用于左值运算对象，前置版本将对象本身作为左值返回，后置版本将对象原始值的副本作为右值返回</p>
</li>
<li>
<blockquote>
<p>除非必须，否则不用递增递减运算符的后置版本  &lt;-- 额外增加开销（P132）</p>
</blockquote>
</li>
<li>
<p>如果一个子表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话，运算对象的求值顺序就很关键了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P133</span></span><br><span class="line">*beg = <span class="built_in">toupper</span>(*beg++);  <span class="comment">// 未定义行为</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="425-成员访问运算符"><a class="markdownIt-Anchor" href="#425-成员访问运算符"></a> 4.2.5 成员访问运算符</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;mem;</span><br><span class="line">(*ptr).men;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上<code>()</code>：<code>(*ptr).men</code></p>
</li>
<li>
<blockquote>
<p>箭头运算符作用于一个指针类型的对象，结果是一个左值。点运算符分成两种情况：如果成员所属的对象是左值，那么结果是左值；反之，如果成员所属的对象是右值，那么结果是右值。</p>
</blockquote>
</li>
</ul>
<h3 id="426-条件运算符"><a class="markdownIt-Anchor" href="#426-条件运算符"></a> 4.2.6 条件运算符</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition ? expr1 : expr2;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>当条件运算符的两个表达式都是左值或者能转换成同一类左值类型时，运算结果是左值，否者，运算结果是右值。</p>
</li>
<li>
<p>可嵌套，最好别超过2到3层，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond1?expr1:cond2?expr2:expr3;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>满足右结合律，右边的条件运算构成了靠左边条件运算的分支。上述代码实际为例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond1 ? expr1  :   (cond2?expr2:expr3)  <span class="comment">// &lt;--从右边开始结合，括号中的是分支</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>条件运算符的优先级非常低，当一条长表达式中嵌套了条件运算子表达式时，通常需要在其两端加上括号</p>
</li>
</ul>
<h3 id="427-位运算符"><a class="markdownIt-Anchor" href="#427-位运算符"></a> 4.2.7 位运算符</h3>
<ul>
<li>
<p>位运算符整数类型的运算对象，并且把运算对象看成二进制位的集和</p>
</li>
<li>
<p>如果运算对象是“小整型”，则它的值将会被自动提升为较大的整数类型。 —— <strong>先提升，再对提升后的整体进行位运算</strong></p>
</li>
<li>
<p>不同机器对于符号位的处理各不相同，因此建议位运算符<strong>仅用于处理无符号类型</strong></p>
</li>
</ul>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401141127468.png" alt="位运算符（左结合律）" style="zoom:67%;" />
<ul>
<li>
<p>移位运算符</p>
<ul>
<li>
<p><code>&lt;&lt;</code>、<code>&gt;&gt;</code>的右侧的运算符一定不能为负，并且值严格小于结果的位数</p>
</li>
<li>
<p>满足左结合律</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;hi&quot;</span>&lt;&lt;<span class="string">&quot;three&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">( (cout&lt;&lt;<span class="string">&quot;hi&quot;</span>) &lt;&lt; <span class="string">&quot;three&quot;</span> ) &lt;&lt;endl;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401141128465.png" alt="位移运算符" style="zoom:67%;" /></p>
</li>
</ul>
</li>
<li>
<p>位求反运算符  略</p>
</li>
<li>
<p>位与、位或、位异或</p>
<ul>
<li>异或 ：不同出1，相同处0</li>
</ul>
</li>
</ul>
<h3 id="428-sizeof运算符"><a class="markdownIt-Anchor" href="#428-sizeof运算符"></a> 4.2.8 sizeof运算符</h3>
<ul>
<li>
<p><strong><code>sizeof</code>返回一条表达式或一个类型名字所占的字节数</strong>，满足右结合律，得到<code>size_t</code>类型的常量表达式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span> (type);  <span class="comment">// sizeof (类型名)</span></span><br><span class="line"><span class="keyword">sizeof</span> expr;    <span class="comment">// sizeof 表达式  &lt;-- 不实际计算表达式的值，意味着即使是无效指针依然安全</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>c++11新标准允许使用作用域运算符来获取类成员大小</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> Sale_data::revenue;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>常见的sizeof运算结果</p>
<ul>
<li>
<p>char或类型为char的表达式，结果为1</p>
</li>
<li>
<p>引用类型，结果为被引用对象所占空间的大小</p>
</li>
<li>
<p>指针，指针本身所占空间的大小</p>
</li>
<li>
<p>解引用指针，指针指向的对象所占空间的大小，指针不需要有效</p>
</li>
<li>
<p>数组，整个数组所占的大小；等价于对数组中所有元素各执行一次sizeof并求和</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;...&#125; <span class="comment">// 一个很多元素的数组</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> sz = <span class="built_in">sizeof</span>(ia) / <span class="built_in">sizeof</span>(*ia); <span class="comment">// 返回ia数组的元素的数量</span></span><br><span class="line"><span class="type">int</span> arr2[sz];   <span class="comment">// sizeof返回一个常量表达式，所有可以用于声明数组的维度</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>string和vector，只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。&lt;-- 什么意思？没看懂</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">int</span>)&lt;&lt;endl; <span class="comment">// 4</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;  	<span class="comment">// 10个5，10个int大小按理来说应该是40个字节</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ia : a) &#123;</span><br><span class="line">        cout &lt;&lt; ia ;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;  <span class="comment">// 却是32？          &lt;-- 不懂</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="429-逗号运算符"><a class="markdownIt-Anchor" href="#429-逗号运算符"></a> 4.2.9 逗号运算符</h3>
<ul>
<li>
<p>首先对左侧的表达式求值，然后将结果丢弃。<strong>真正的运算结果是右侧表达式的值</strong>，如果右侧运算对象是左值，那么最终的求值结果也是左值</p>
</li>
<li>
<p>一般用于for循环，例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::size_type cnt = ivec.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::size_type ix = <span class="number">0</span>; ix != ivec.<span class="built_in">size</span>(); ++ix, --cnt)&#123;</span><br><span class="line">    ivec[ix] = cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="43-类型转换"><a class="markdownIt-Anchor" href="#43-类型转换"></a> 4.3 类型转换</h2>
<p>如果两种类型可相互转换，则它们是关联的。</p>
<h3 id="431-隐式转换"><a class="markdownIt-Anchor" href="#431-隐式转换"></a> 4.3.1 隐式转换</h3>
<ul>
<li>
<p>算术转换<br />
运算符的运算对象将转换至最宽的类型</p>
<ul>
<li>
<p>整型提升</p>
<ul>
<li>小整数类型提升成较大的整数类型：bool、char、signed char、unsigned char、short、unsigned short 所有可能的值都能存在int里，则提升为int，否则为unsigned int</li>
<li>较大的char（wchar_t, char16_t, char32_t）提升成int、unsigned int、long、unsigned  long、long long和 unsigned long long 中最小的一种类型</li>
</ul>
</li>
<li>
<p>无符号类型的运算对象</p>
<ul>
<li>
<p>注意有符号和无符号的混用带来的意外后果</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401141601280.png" style="zoom: 50%;" />
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数组转换成指针</p>
<ul>
<li>在大多数情况下，数组名自动转化成数组首元素的指针</li>
<li>当数组名被用作<code>decltype关键字、取地址符、sizeof、typeid、用一个引用来初始化数组</code>时，上述转化不会发生</li>
</ul>
</li>
<li>
<p>指针的转换</p>
<ul>
<li>0、nullptr能转化成任意指针类型</li>
<li>任意非常量指针能转换成void *</li>
<li>任意对象指针能转化成const void *</li>
<li>有继承关系的类型间</li>
</ul>
</li>
<li>
<p>转换成bool</p>
<ul>
<li>0:false 否则true</li>
</ul>
</li>
<li>
<p>转换成常量</p>
<ul>
<li>
<p>允许将指向非常量类型的指针（引用）转化成指向相应的常量类型的指针（引用）</p>
</li>
<li>
<p>不能反过来，因为这样试图删掉底层const</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = i;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>类类型定义的转换  （P144）</p>
<ul>
<li>类类型能定义由编译器自动执行的转换</li>
<li>每次只能执行一种类类型的转换</li>
</ul>
</li>
</ul>
<h3 id="432-显式转换"><a class="markdownIt-Anchor" href="#432-显式转换"></a> 4.3.2 显式转换</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast-<span class="built_in">name</span>&lt;type&gt;(expression)</span><br></pre></td></tr></table></figure>
<p>type：要转换的类型，expression：要转换的值；如果type是引用类型，则结果是左值</p>
<p>cast-name包括：static_cast、dynamic_cast、const_cast和reinterpret_cast</p>
<ul>
<li>
<p>static_cast    &lt;-- 最常用</p>
<ul>
<li>
<p>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast</p>
</li>
<li>
<p>当需要把一个较大的算术类型赋给较小的类型时，利用static_cast可关闭“精度损失”的警告信息</p>
</li>
<li>
<p>利用static_cast找回void *指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *p = &amp;d;</span><br><span class="line"><span class="type">double</span> * dp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span> *&gt;(p);  <span class="comment">//确保等号两边类型一样，否则产生未定义行为</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>const_cast</p>
<ul>
<li>
<p><strong>只能改变对象的底层const</strong>，<strong>仅用于进行去除 const 属性</strong>，它也是四个强制类型转换运算符中<strong>唯一能够去除 const 属性的运算符</strong>。</p>
</li>
<li>
<p>要注意可能发生的未定义后果</p>
</li>
<li>
<p>[常用于有重载函数的上下文](#6.4 重载)  &lt;-- 比如？</p>
</li>
<li>
<p>用法举例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*例1*/</span>       <span class="comment">//（P145,改）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* pc = &amp;a;   <span class="comment">// 底层const</span></span><br><span class="line">cout &lt;&lt; *pc &lt;&lt; endl; <span class="comment">//0</span></span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(pc); </span><br><span class="line">*p = <span class="number">5</span>;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例2*/</span>      <span class="comment">// 参考文献[1]</span></span><br><span class="line"><span class="comment">//const_cast只针对指针、引用、this指针 （只能改变对象的底层const）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* k = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;n);<span class="comment">//指针</span></span><br><span class="line">    *k = <span class="number">123</span>;</span><br><span class="line">    cout &lt;&lt; *k &lt;&lt; endl;  <span class="comment">//123</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp; kRef = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(n);<span class="comment">//引用</span></span><br><span class="line">    kRef = <span class="number">456</span>;</span><br><span class="line">    cout &lt;&lt; kRef &lt;&lt; endl;  <span class="comment">//456</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例3*/</span>    <span class="comment">// 参考文献[1]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CTest</span>() : <span class="built_in">m_nTest</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">//常成员函数，不能修改成员变量的值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> nTest)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">//void* p = this;</span></span><br><span class="line">        <span class="comment">//m_nTest = nTest;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//m_nTest = nTest; 错误</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//&lt;CTest* const&gt;指针地址不可改变，(this)代表常成员函数的this指针</span></span><br><span class="line">        <span class="comment">//const_cast去除CTest*前面的const</span></span><br><span class="line">        <span class="built_in">const_cast</span>&lt;CTest* <span class="type">const</span>&gt;(<span class="keyword">this</span>)-&gt;m_nTest = nTest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_nTest;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CTest t;</span><br><span class="line">    t.<span class="built_in">foo</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>参考</p>
<ul>
<li>[1] <a target="_blank" rel="noopener" href="https://blog.csdn.net/Dasis/article/details/121343011">C++新特性06_强制转换运算符_const_cast - 十月旧城</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p>reinterpret_cast</p>
<ul>
<li>
<p>通常为运算对象的位模式提供较低层次上的重新解释</p>
</li>
<li>
<p>非常有风险</p>
<blockquote>
<p>本质上依赖于机器，想要安全地使用必须对涉及的类型和编译器实现转换的过程都非常了解</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>dynamic_cast （19章介绍）</p>
</li>
</ul>
<h2 id="44-运算符优先级表"><a class="markdownIt-Anchor" href="#44-运算符优先级表"></a> 4.4 运算符优先级表</h2>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401131535739.png" alt="运算符优先级表" /></p>
<h1 id="五-语句"><a class="markdownIt-Anchor" href="#五-语句"></a> 五 语句</h1>
<h2 id="51-简单语句"><a class="markdownIt-Anchor" href="#51-简单语句"></a> 5.1 简单语句</h2>
<ul>
<li>
<p>空语句 – 没有什么用，但是需要注意对循环的影响</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;  <span class="comment">//&lt;--空语句，真么用也没有</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;;  <span class="comment">// &lt;-- 不会报错，就是多了一条空语句 :)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="52-作用域"><a class="markdownIt-Anchor" href="#52-作用域"></a> 5.2 作用域</h2>
<p>略</p>
<h2 id="53-条件语句"><a class="markdownIt-Anchor" href="#53-条件语句"></a> 5.3 条件语句</h2>
<h3 id="531-ifelse"><a class="markdownIt-Anchor" href="#531-ifelse"></a> 5.3.1 if…else</h3>
<ul>
<li>注意花括号</li>
<li>悬垂else
<ul>
<li>我们怎么知道给定的else和那个if相匹配？   这个问题被称为悬垂else</li>
<li>c++规定，与离它最近的尚未匹配的if匹配，从而消除程序的二义性</li>
</ul>
</li>
</ul>
<h3 id="532-switchcase"><a class="markdownIt-Anchor" href="#532-switchcase"></a> 5.3.2 switch…case</h3>
<ul>
<li>
<p>case标签必须是整型常量表达式</p>
</li>
<li>
<p>switch的默认动作是从某个匹配成功的case开始，顺序执行其下的所有case，直到遇到break。最好在每个case中都添加break，以避免不必要的问题。虽然在某些情况下，我们确实希望多个case共享同一组操作而不写break，此种情况最好加一段注释以说明。</p>
</li>
<li>
<p>最好添加default，声明我们已经考虑了默认情况，即使现在什么都没有做。</p>
<ul>
<li>标签不应该孤零零地出现，它后面必须跟上一条语句或者另外一个 case标签。如果switch 结构以一个空的 default 标签作为结束则该default 标签后面必须跟上一条空语句或一个空块。  &lt;-- （P163，没怎么懂在说什么）</li>
</ul>
</li>
<li>
<p>switch内部的变量定义</p>
<ul>
<li>
<blockquote>
<p>在C++11的标准下，【变量定义】操作在编译阶段就会执行分配内存，而涉及【变量初始化】操作的语句则必须等到程序运行时才会调用执行。</p>
</blockquote>
</li>
<li>
<blockquote>
<p><strong>因此对于<code>switch</code>语句的使用，如果确实有需要在内部定义变量的场景，最好的方法就是在编程的时候，将整个<code>switch</code>语句中都用到的变量在<code>switch</code>外定义好，到了<code>switch</code>内部，则可以针对某个<code>case</code>需要单独使用某些变量的情况，用<code>&#123;&#125;</code>作用域符号来明确此<code>case</code>语句的作用域</strong></p>
</blockquote>
</li>
<li>
<p>参考文献</p>
<ul>
<li>[1] <a target="_blank" rel="noopener" href="https://blog.csdn.net/LvzJason/article/details/123445116">switch case内部的变量定义问题 - John Chen1223</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="54-迭代语句"><a class="markdownIt-Anchor" href="#54-迭代语句"></a> 5.4 迭代语句</h2>
<h3 id="541-while"><a class="markdownIt-Anchor" href="#541-while"></a> 5.4.1 while</h3>
<p>略</p>
<h3 id="542-for"><a class="markdownIt-Anchor" href="#542-for"></a> 5.4.2 for</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(init-statemen; condition; expression)&#123; statement; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只要condition为真，就执行一次statement，如果为false，一次也不执行</li>
<li>init-statemen可以定义多个变量，但只能有一条声明语句，因此意味着所有变量的基础类型必须相同</li>
<li>init-statemen 、condition、 expression都可以省略（P167）</li>
</ul>
<h3 id="543-dowhile"><a class="markdownIt-Anchor" href="#543-dowhile"></a> 5.4.3 do…while</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125;<span class="keyword">while</span>(condition);  <span class="comment">//&lt;--最后还有个分号</span></span><br></pre></td></tr></table></figure>
<ul>
<li>condition不能为空</li>
<li>condition使用的变量不能定义在循环体之外</li>
<li>不允许在condition部分定义变量</li>
</ul>
<h2 id="55-跳转语句"><a class="markdownIt-Anchor" href="#55-跳转语句"></a> 5.5 跳转语句</h2>
<ul>
<li>
<p>break</p>
<ul>
<li>终止最近的<code>while</code>，<code>do...while</code>，<code>for</code>，<code>switch</code>，并从这些语句之后的第一条语句开始执行;</li>
</ul>
</li>
<li>
<p>continue</p>
<ul>
<li>
<p><code>while</code>，<code>do...while</code>，<code>for</code>可用</p>
</li>
<li>
<p>终止最近的循环中的当前迭代  并立即开始下一次迭代</p>
</li>
</ul>
</li>
<li>
<p>goto</p>
</li>
</ul>
<h2 id="56-异常处理"><a class="markdownIt-Anchor" href="#56-异常处理"></a> 5.6 异常处理</h2>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401151047619.png" alt="image-20240115104749450" style="zoom:67%;" />
<h3 id="561-异常类"><a class="markdownIt-Anchor" href="#561-异常类"></a> 5.6.1 异常类</h3>
<p>c++标准库定义了一组类，分别在4个头文件中：</p>
<ul>
<li>exception
<ul>
<li>定义exception，只报告异常的发生，不提供任何额外信息</li>
</ul>
</li>
<li>stdexcept
<ul>
<li>定义了几种常用的异常，下图列出</li>
</ul>
</li>
<li>new
<ul>
<li><code>bad_alloc</code>（12章）</li>
</ul>
</li>
<li>type_info
<ul>
<li><code>bad_cast</code>（19章）</li>
</ul>
</li>
</ul>
<p>其中，<code>exception</code>、<code>bad_alloc</code>、<code>bad_cast</code>只能默认初始化，不允许提供初值。反之，其余的异常类必须提供string或c风格字符串以初始化。</p>
<p>异常类只有一个名为<code>what()</code>的成员函数，没有任何参数，返回初始化异常类时用到string（c风格）字符串。对于默认初始化的异常类，返回内容由编译器决定。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401151426222.png" alt="image-20240115142614063" style="zoom:67%;" />
<h3 id="562-抛出异常"><a class="markdownIt-Anchor" href="#562-抛出异常"></a> 5.6.2 抛出异常</h3>
<p>用<code>throw</code>关键字抛出一个异常后，会直接跳转到对应的<code>catch</code>块，节选5.6.4中示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_isbn != item.m_isbn)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;data must refer to same isbn.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_sales_volume + item.m_sales_volume;</span><br></pre></td></tr></table></figure>
<h3 id="563-处理异常"><a class="markdownIt-Anchor" href="#563-处理异常"></a> 5.6.3 处理异常</h3>
<p><code>try...catch</code>接住throw抛出的异常并处理，语法如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//正常逻辑</span></span><br><span class="line">    <span class="comment">//抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="comment">/*（可能未命名的）异常声明1*/</span>) &#123;</span><br><span class="line">    <span class="comment">//异常处理1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="comment">/*（可能未命名的）异常声明2*/</span>) &#123;</span><br><span class="line">    <span class="comment">//异常处理2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。</p>
<ul>
<li>
<p>函数在寻找  异常处理代码  的过程中  退出（P175）</p>
<blockquote>
<p>在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个 try语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能调用了包含又一个 try 语句块的新函数，以此类推。</p>
<p>寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的 catch 子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的 catch 子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路逐层回退，直到找到适当类型的 catch 子句为止。</p>
<p>如果最终还是没能找到任何匹配的 catch 子句，程序转到名为<code>terminate</code> 的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。对于那些没有任何 try语句块定义的异常，也按照类似的方式处理：毕竟，没有 try语句块也就意味着没有匹配的catch 子句。如果一段程序没有 try 语句块且发生了异常系统会调用terminate函数并终止当前程序的执行。</p>
</blockquote>
</li>
</ul>
<h3 id="564-示例"><a class="markdownIt-Anchor" href="#564-示例"></a> 5.6.4 示例</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_item</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_item</span>(string isbn, <span class="type">int</span> sales_volume)</span><br><span class="line">        :m_isbn&#123; isbn &#125;, m_sales_volume&#123; sales_volume &#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_isbn; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">saleVolume</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_sales_volume; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>+(Sales_item item) &#123;</span><br><span class="line">        <span class="comment">// 使用异常处理将相加的代码和与用户交互的代码分离</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_isbn != item.m_isbn)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;data must refer to same isbn.&quot;</span>);  <span class="comment">//跳转到catch (runtime_error err) &#123;行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_sales_volume + item.m_sales_volume;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (runtime_error err) &#123;</span><br><span class="line">            cout &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_isbn;</span><br><span class="line">    <span class="type">int</span> m_sales_volume; <span class="comment">//销售额</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Sales_item <span class="title">item1</span><span class="params">(<span class="string">&quot;1-2-3&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Sales_item <span class="title">item2</span><span class="params">(<span class="string">&quot;1-2-3&quot;</span>, <span class="number">11</span>)</span></span>;</span><br><span class="line">    <span class="function">Sales_item <span class="title">item3</span><span class="params">(<span class="string">&quot;4-5-6&quot;</span>, <span class="number">12</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res1 = item1 + item2;</span><br><span class="line">    cout &lt;&lt; res1 &lt;&lt; endl;<span class="comment">//21</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res2 = item1 + item3;</span><br><span class="line">    cout &lt;&lt; res2 &lt;&lt; endl;<span class="comment">//失败并输出-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="六-函数"><a class="markdownIt-Anchor" href="#六-函数"></a> 六 函数</h1>
<h2 id="61-基础"><a class="markdownIt-Anchor" href="#61-基础"></a> 6.1 基础</h2>
<ul>
<li>函数最外层的作用于中的局部变量也不能使用和函数形参一样的名字。（P184顶部，不理解）</li>
<li>函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针</li>
<li>函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，函数声明也被称为函数原型</li>
<li>局部静态对象：在局部变量前加<code>static</code>，第一次经过该对象定义语句的时候初始化，并且直到程序终止才销毁，在此期间即使对象所在的函数结束也不会对它有影响。</li>
</ul>
<h2 id="62-参数传递"><a class="markdownIt-Anchor" href="#62-参数传递"></a> 6.2 参数传递</h2>
<h3 id="621-参数传递的方式"><a class="markdownIt-Anchor" href="#621-参数传递的方式"></a> 6.2.1 参数传递的方式</h3>
<ul>
<li>值传递</li>
<li>指针传递
<ul>
<li>其实是一种形式的值传递</li>
<li>在c++中，建议用引用类型的形参代替指针</li>
</ul>
</li>
<li>引用传递
<ul>
<li>当函数无须修改引用形参的值时最好使用常量引用</li>
<li>使用引用形参返回额外的信息</li>
</ul>
</li>
</ul>
<h3 id="622-const形参和实参"><a class="markdownIt-Anchor" href="#622-const形参和实参"></a> 6.2.2  const形参和实参</h3>
<ul>
<li>
<p>顶层const被忽略</p>
<ul>
<li>
<p>当形参有顶层const时，形参的顶层const被忽略，传给他常量对象或非常量对象都是可以的</p>
</li>
<li>
<p><strong>因为顶层const被忽略掉了，所以下述的两个func是一样的，不能[重载](#6.4 重载)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i; &#125; <span class="comment">// 函数“int func(const int)”已有主体</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>指针或引用参与const</p>
<ul>
<li>
<p>遵循“任何可能引发修改const值的操作都是非法的”</p>
</li>
<li>
<p>P191，略</p>
</li>
</ul>
</li>
<li>
<p>尽量使用常量引用</p>
<ul>
<li>
<p>把函数不会改变的形参定义成普通的引用是一种比较常见的错误，</p>
<ul>
<li>
<p>会给函数调用者“函数可以修改它们实参值的误导”</p>
</li>
<li>
<p>极大限制函数所能接收的实参类型（<strong>我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参</strong>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*例1*/</span></span><br><span class="line"><span class="function">string <span class="title">func</span><span class="params">(<span class="type">const</span> string&amp;i)</span></span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="string">&quot;a&quot;</span>) &lt;&lt; endl;  <span class="comment">// a</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例2*/</span></span><br><span class="line"><span class="function">string <span class="title">func</span><span class="params">( string&amp;i)</span></span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//无法用 &quot;const char [2]&quot; 类型的值初始化 &quot;std::string &amp;&quot; 类型的引用(非常量限定)</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="string">&quot;a&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>参考文献</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39827640/article/details/129431021">函数原型、函数签名、函数定义、函数参数传递方式 – 凶猛的瘦子</a></li>
</ul>
<h3 id="623-数组形参"><a class="markdownIt-Anchor" href="#623-数组形参"></a> 6.2.3 数组形参</h3>
<ul>
<li>
<p>因为不能拷贝数组，我们无法以值传递的方式使用数组参数；又因数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</p>
</li>
<li>
<p>三种等价的数组传参方式，数组大小对函数调用无影响</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>; <span class="comment">// 10表示我们期望，实际上不一定</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>数组以指针传参，函数不知道大小，有三种常用管理方式管理指针形参：</p>
<ul>
<li>
<p>使用  结束标记  指定数组长度</p>
<ul>
<li>使用  类似c风格字符串数组的结束标记  标记数组结束的位置</li>
</ul>
</li>
<li>
<p>使用标准库规范</p>
<ul>
<li>
<p>使用begin和end函数，传递首元素和尾后元素的指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>*beg, <span class="type">const</span> <span class="type">int</span>*end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(beg != end)</span><br><span class="line">        cout&lt;&lt;*beg++&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////调用</span></span><br><span class="line"><span class="type">int</span> j[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">begin</span>(j),<span class="built_in">end</span>(j));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>显式传递一个表示数组大小的形参 – 旧式风格</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *ia, <span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////调用</span></span><br><span class="line"><span class="type">int</span> j[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">func</span>(j, <span class="built_in">end</span>(j) - <span class="built_in">begin</span>(j) );</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>数组引用形参</p>
<ul>
<li>
<p>形参是数组的引用，维度是类型的一部分</p>
</li>
<li>
<p>下例中，<code>(&amp;arr)</code>括号必不可少，否则 <code>int &amp;arr[10]</code>是将arr声明成了引用的数组</p>
</li>
<li>
<p>下例中，[10]不可少，因为数组的大小是构成数组的一部分，只能将函数作用于大小为10的数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>传递多维数组</p>
<ul>
<li>
<p>多维数组是数组的数组，又因为将数组传递进函数的时候，传入的是指向第一个元素的指针。所以将多维数组传入函数，传入的是指向第一个数组（即多维数组的第一个元素）的指针。函数声明可以写为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形参matrix看起来是一个二维数组，实际上是指向含有10个整数的数组的指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> matrix[][<span class="number">10</span>],<span class="type">int</span> rowSize)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//matrix是一个指针，指向10个整数的数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> (*matrix)[<span class="number">10</span>], <span class="type">int</span> rowSize)</span></span>&#123;&#125;  <span class="comment">//int (*matrix)[10] 小括号不可少，否则是10个指针构成的数组</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>main处理命令行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="624-可变形参"><a class="markdownIt-Anchor" href="#624-可变形参"></a> 6.2.4 可变形参</h3>
<p>可变形参用于编写可处理不同数量实参的函数，主要有三种方法：</p>
<ul>
<li>
<p><code>initializer_list</code></p>
<ul>
<li>
<p>要求所有实参<strong>类型相同</strong></p>
</li>
<li>
<p>其中的对象<strong>永远是常量</strong>，无法改变其中的元素值</p>
</li>
<li>
<p>如果向其中传递的是一个序列，则必须放在花括号中</p>
</li>
<li>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*声明*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(ErrorCode e, initializer_list&lt;string&gt; il)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;e.<span class="built_in">msg</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;msg : il)</span><br><span class="line">        cout&lt;&lt;msg&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用*/</span></span><br><span class="line"><span class="built_in">error_msg</span>(<span class="built_in">ErrorCode</span>(<span class="number">0</span>), &#123;<span class="string">&quot;functionX&quot;</span>,<span class="string">&quot;okay&quot;</span>&#125; ); </span><br></pre></td></tr></table></figure>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401171100692.png" alt="image-20240117110037435" style="zoom:67%;" />
</li>
</ul>
</li>
<li>
<p>可变参数模板  （16章）</p>
<ul>
<li>实参类型不同</li>
</ul>
</li>
<li>
<p>省略符</p>
<ul>
<li>
<p><code>varargs</code>c标准库功能</p>
</li>
<li>
<p>省略符只能出现在形参列表的最后一个位置</p>
</li>
<li>
<p>仅用于c和c++通用的类型，大多数类类型的对象在传递给省略符形参时都无法正确拷贝</p>
</li>
<li>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(parm_list, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="63-返回类型和return"><a class="markdownIt-Anchor" href="#63-返回类型和return"></a> 6.3 返回类型和return</h2>
<h3 id="631-有返回值的函数"><a class="markdownIt-Anchor" href="#631-有返回值的函数"></a> 6.3.1 有返回值的函数</h3>
<ul>
<li>
<p>在含有return语句的循环后面也有一条return语句</p>
</li>
<li>
<p>不要返回  对局部对象的引用  或  指向局部变量的指针，局部变量在函数完成后已经被释放</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在vs2022上测试，该程序能正常编译和运行，</span></span><br><span class="line"><span class="comment">* 但是运行结果不对，</span></span><br><span class="line"><span class="comment">* 显然意味着这种错误不容易被发现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">const</span> string&amp; <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!a.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;empty&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">test</span>() &lt;&lt; endl;  <span class="comment">// 期望输出a，实际上输出空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>引用返回左值</p>
<ul>
<li>
<p>调用一个返回引用的函数得到左值，其他返回类型得到右值</p>
</li>
<li>
<p>我们能为返回类型是非常量引用的函数的结果赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>&amp; <span class="title">get_val</span><span class="params">(string &amp;str, string::size_type ix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str[ix];  <span class="comment">// 返回对 str[ix]的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;a test&quot;</span>;</span><br><span class="line">    <span class="built_in">get_val</span>(s, <span class="number">0</span>) = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>可返回列表初始化，<code>return &#123;&quot;funcX&quot;,&quot;okay&quot;&#125;</code></p>
</li>
<li>
<p>main函数的返回值</p>
<ul>
<li>
<p><code>cstdlib</code>中定义了两个预处理变量，表示成功或者失败</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> EXIT_FALLURE;</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>递归</p>
<ul>
<li>在递归函数中，一定有某条路径是不包含递归调用的，否则将一直递归循环，直至内存耗尽</li>
</ul>
</li>
</ul>
<h3 id="632-数组指针"><a class="markdownIt-Anchor" href="#632-数组指针"></a> 6.3.2 数组指针</h3>
<p>数组不能被拷贝，所以函数不能返回数组，不过函数可以返回数组的指针或引用。定义一个返回数组的指针或引用的函数有如下几种方法：</p>
<ul>
<li>
<p>使用类型别名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*两个等价的定义类型别名的方法*/</span></span><br><span class="line"><span class="comment">//arrT是一个类型别名，它表示的类型是含有10个整数的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> arrT[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">using</span> arrT = <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用*/</span></span><br><span class="line"><span class="function">arrT *<span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>普通方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">func</span>(<span class="type">int</span> i))[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401171607017.png" alt="202401171607017" /></p>
</li>
<li>
<p>尾置返回类型</p>
<ul>
<li>
<p>c++11新标准可使用 ，将返回类型放在<code>-&gt;</code>后，并在原来写返回值类型的地方放个auto</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>;  <span class="comment">// 返回一个指针，指向放10个int数据的数组</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>decltype</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> odd[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> even[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(odd) *<span class="built_in">arrPtr</span>(<span class="type">int</span> i)&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%<span class="number">2</span>) ? &amp;odd : &amp;even;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>decltype 并不负责把数组类型转换成对应的指针，所以decltype 的结果（即<code>int[]</code>）是个数组，要想表示 arrPtr 返回指针还必须在函数声明时加一个<code>*</code>符号。</p>
</li>
</ul>
<h2 id="64-重载"><a class="markdownIt-Anchor" href="#64-重载"></a> 6.4 重载</h2>
<ul>
<li>如果<strong>同一作用域内</strong>的几个<strong>函数名字相同但形参列表不同</strong>，称之为函数重载（overloaded）</li>
<li>重载和const形参
<ul>
<li>[顶层const不影响传入的对象，有无顶层const不能构成重载](#6.2.2  const形参和实参)</li>
<li>底层const会实现重载：
<ul>
<li>指向const的指针（引用）传递给const形参</li>
<li>对于非常量，编译器会优先选择非常量版本的函数 （6.6-最佳匹配-实参类型的转换）</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4.3.2-%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2">重载和const_cast</a>
<ul>
<li>const_cast在重载函数的情境中最有用 – 保障了安全性<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401181007150.png" alt="image-20240118100745867" /></li>
</ul>
</li>
<li>重载与作用域
<ul>
<li>不要把函数声明置于局部作用域内</li>
</ul>
</li>
</ul>
<h2 id="65-特殊用途语言特性"><a class="markdownIt-Anchor" href="#65-特殊用途语言特性"></a> 6.5 特殊用途语言特性</h2>
<h3 id="651-默认实参"><a class="markdownIt-Anchor" href="#651-默认实参"></a> 6.5.1 默认实参</h3>
<ul>
<li>
<p>一旦某个形参被赋予了默认值，其后所有形参都必须有默认值</p>
</li>
<li>
<p>默认实参负责填补函数调用缺少的尾部实参</p>
</li>
<li>
<p>合理设置形参顺序，将经常使用默认值的形参放在后面</p>
</li>
<li>
<p>函数后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz,sz,<span class="type">char</span>=<span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz,sz,<span class="type">char</span>= <span class="string">&#x27;*&#x27;</span>)</span></span>; <span class="comment">//错误，重复声明</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = <span class="number">24</span>, sz = <span class="number">80</span>, <span class="type">char</span>)</span></span>;<span class="comment">// 正确，添加默认形参</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>默认实参初始值</p>
<ul>
<li>
<p>局部变量不能作为默认实参，用作默认实参初始值的  表达式的值   必须声明在函数之外</p>
</li>
<li>
<p>只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sz wd = <span class="number">80</span>;</span><br><span class="line"><span class="type">char</span> def = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = ht(), sz = wd, <span class="type">char</span> = def)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string window = <span class="built_in">screen</span>(); <span class="comment">//screen(ht(), 80, &#x27; &#x27; );</span></span><br><span class="line">    </span><br><span class="line">    def = <span class="string">&#x27;*&#x27;</span>;   <span class="comment">// 将传递这个更新过的  全局变量的  值</span></span><br><span class="line">    sz wd = <span class="number">100</span>;  <span class="comment">//局部变量与默认实参没有任何关系</span></span><br><span class="line">    window = <span class="built_in">screen</span>(); <span class="comment">//screen(ht(), 80, &#x27;*&#x27;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="652-内联函数"><a class="markdownIt-Anchor" href="#652-内联函数"></a> 6.5.2 内联函数</h3>
<ul>
<li>
<p><code>inline</code></p>
</li>
<li>
<p>对编译器的建议，</p>
</li>
<li>
<p>加速程序</p>
</li>
</ul>
<h3 id="653-constexpr函数"><a class="markdownIt-Anchor" href="#653-constexpr函数"></a> 6.5.3 constexpr函数</h3>
<ul>
<li>
<p>能用于常量表达式的函数</p>
</li>
<li>
<p><strong>函数的返回类型及所有形参的类型都得是字面值类型，函数体中必须有且只有一条return语句</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>初始化任务时，编译器会把constexpr函数的调用替换成其结果值，函数被隐式地指定为内联函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="built_in">new_sz</span>()];</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>constexpr函数中也可以包含其他语句，只要这些语句在运行时不执行任何操作（空语句、typedef、using）  &lt;-- 唯一可执行的语句就是return</p>
</li>
<li>
<p>允许返回非常量：当实参是是一个常量表达式时，返回常量表达式，反之则不然：   &lt;-- <strong>constexpr函数不一定返回常量表达式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">scale</span><span class="params">(<span class="type">size_t</span> cnt)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">new_sz</span>() * cnt ;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="built_in">scale</span>(<span class="number">2</span>)]; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> arr[<span class="built_in">scale</span>(i)]; <span class="comment">//错误，返回的不是常量表达式，无法初始化数组</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="654-调试帮助"><a class="markdownIt-Anchor" href="#654-调试帮助"></a> 6.5.4 调试帮助</h3>
<ul>
<li>
<p><code>assert(expr)</code> – <code>#include &lt;cassert&gt;</code></p>
<ul>
<li>expr为假，输出信息并终止，为真，什么也不做。即expr为不可能情况</li>
</ul>
</li>
<li>
<p>NDEBUG预处理变量</p>
<ul>
<li>
<p>针对<code>assert()</code>：定义NDEBUG能避免检查各种条件所需的运行时开销，当然此时根本就不会执行运行时检查。因此，<strong>assert 应该仅用于验证那些确实不可能发生的事情</strong>。我们可以把assert当成调试程序的一种辅助手段，但是<strong>不能用它替代真正的运行时逻辑检查，也不能替代程序本身应该包含的错误检查</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*例1*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">assert</span>(i &gt; <span class="number">6</span>);  <span class="comment">// Assertion failed: i &gt; 6, file ... line 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例2  NDEBUG要写在整个程序的开头，否则没有用*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">assert</span>(i &gt; <span class="number">6</span>);  <span class="comment">// 失效</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例3  NDEBUG要写在整个程序的开头，否则没有用*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">assert</span>(i &gt; <span class="number">6</span>);  <span class="comment">// Assertion failed: i &gt; 6,file ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>针对<code>#ifndef ...#endif</code></p>
<ul>
<li>如果定义了NDEBUG，<code>#ifndef ...#endif</code>之间的代码将被忽略</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#define NDEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>补充，预处理器定义的几个  用于调试程序的  变量</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__func__</code></td>
<td>const char 的一个静态数组，存放<strong>函数的名字</strong></td>
</tr>
<tr>
<td><code>__FILE__</code></td>
<td>存放<strong>文件名</strong>的字符串字面值</td>
</tr>
<tr>
<td><code>__LINE__</code></td>
<td>存放<strong>当前行号</strong>的整型字面值</td>
</tr>
<tr>
<td><code>__TIME__</code></td>
<td>存放文件<strong>编译时间</strong>的字符串字面值</td>
</tr>
<tr>
<td><code>__DATE__</code></td>
<td>存放文件<strong>编译日期</strong>的字符串字面值</td>
</tr>
</tbody>
</table>
<ul>
<li>示例</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line">std::cout&lt;&lt;__func__</span><br><span class="line">    &lt;&lt;<span class="string">&quot;in file: &quot;</span>&lt;&lt;__FILE__</span><br><span class="line">    &lt;&lt;<span class="string">&quot;line &quot;</span>&lt;&lt;__LINE__;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​</p>
<h2 id="66-函数匹配"><a class="markdownIt-Anchor" href="#66-函数匹配"></a> 6.6 函数匹配</h2>
<ul>
<li>
<p>候选函数</p>
<ul>
<li>与被调用的函数同名</li>
<li>其声明在调用的可见</li>
</ul>
</li>
<li>
<p>可行函数 – 从候选函数中选出能被这组实参调用的函数</p>
<ul>
<li>实参数量相等，类型相同</li>
</ul>
</li>
<li>
<p>最佳匹配</p>
<ul>
<li>
<p>单个参数：实参类型与形参类型越接近，它们匹配得越好</p>
</li>
<li>
<p>多个参数：如果有且只有一个函数满足下列条件，则匹配成功。如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用的信息。</p>
<ul>
<li>该函数每个实参的匹配都不劣于其他可行函数需要的匹配。</li>
<li>至少有一个实参的匹配优于其他可行函数提供的匹配。</li>
</ul>
</li>
<li>
<p>实参类型的转换 （P219）</p>
<ul>
<li>
<p>编译器将实参类型到形参类型的转换划分成几个等级：<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401181617249.png" alt="image-20240118161700062" style="zoom:67%;" /></p>
</li>
<li>
<p>在设计良好的系统中函数很少会含有与下列例子相似的形参：（P219底部-220）</p>
<ul>
<li>假设有两个函数，一个接受 int、另一个接受short，则只有当调用提供的是 short 类型的值时才会选择 short 版本的函数。有时候，即使实参是一个很小的整数值，也会直接将它提升成int 类型。</li>
<li>所有算术类型转换的级别都一样。例如，从int 向unsigned int 的转换并不比从int向 double的转换级别高。当存在两种可能的算数类型转换时，调用具有二义性。</li>
</ul>
</li>
<li>
<p>重载忽略顶层const，因此顶层const不能用于重载；而底层const可重载：如果重载函数的区别在于它们的引用类型的形参是否引用了 const（或者指针类型的形参是否指向const），则当调用发生时编译器<strong>通过实参是否是常量来决定选择哪个函数</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">lookup</span>(a); <span class="comment">// 调用 lookup( string &amp;);</span></span><br><span class="line"><span class="built_in">lookup</span>(b); <span class="comment">// 调用 lookup(const string &amp;);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="67-函数指针"><a class="markdownIt-Anchor" href="#67-函数指针"></a> 6.7 函数指针</h2>
<h3 id="671-函数指针是什么"><a class="markdownIt-Anchor" href="#671-函数指针是什么"></a> 6.7.1 函数指针是什么？</h3>
<ul>
<li>
<p>函数指针指向的是函数而非对象</p>
</li>
<li>
<p>函数指针指向某种特定类型。函数的类型由它的返回类型和形参列表共同决定，与函数名无关</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型</span></span><br><span class="line"><span class="built_in">bool</span>(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向函数的指针</span></span><br><span class="line"><span class="built_in">bool</span> (*ptr)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span><br><span class="line"><span class="comment">/*ptr是一个指针，指向参数是（const string &amp;, const string &amp;）的函数，返回bool类型*/</span></span><br><span class="line"><span class="comment">/*（*ptr）的括号不可少，否则ptr变成了一个返回 bool* 类型的函数*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="672-如何使用"><a class="markdownIt-Anchor" href="#672-如何使用"></a> 6.7.2 如何使用</h3>
<ul>
<li>当我们把函数名作为一个值使用时，该函数自动转换成指针</li>
<li>还能指向函数的指针调用该函数，而无须提前解引用指针</li>
<li>不同类型的函数指针间不存在转换</li>
<li>可用nullptr或0初始化指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="comment">/* 指向函数的指针 */</span></span><br><span class="line"><span class="built_in">bool</span> (*ptr)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);</span><br><span class="line"><span class="comment">/*声明的同时定义*/</span></span><br><span class="line"><span class="built_in">bool</span> (*ptr)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;) = lengthCompare;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 */</span></span><br><span class="line">ptr = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">/* 赋值 */</span></span><br><span class="line">ptr = lengthCompare; </span><br><span class="line"><span class="comment">// 等价于 </span></span><br><span class="line">ptr = &amp;lengthCompare;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用 */</span></span><br><span class="line"><span class="type">bool</span> b = <span class="built_in">ptr</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="type">bool</span> b = (*ptr)(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="type">bool</span> b = <span class="built_in">lengthCompare</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="673-重载函数的指针"><a class="markdownIt-Anchor" href="#673-重载函数的指针"></a> 6.7.3 重载函数的指针</h3>
<ul>
<li>编译器通过指针类型决定选用哪个函数</li>
<li>指针类型必须与重载函数中的某一个<strong>精确匹配</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载的func函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向func函数的指针</span></span><br><span class="line"><span class="built_in">void</span> (*ptr)(<span class="type">unsigned</span> <span class="type">int</span>) = func; <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">void</span> (*ptr)(<span class="type">int</span>) = func; <span class="comment">// 错误，没有一个重载的func与该形参列表匹配</span></span><br><span class="line"><span class="built_in">double</span> (*ptr)(<span class="type">unsigned</span> <span class="type">int</span>) = func; <span class="comment">// 错误，没有一个重载的func与该返回类型匹配</span></span><br></pre></td></tr></table></figure>
<h3 id="674-函数指针作形参"><a class="markdownIt-Anchor" href="#674-函数指针作形参"></a> 6.7.4 函数指针作形参</h3>
<ul>
<li>
<p><a href="#6.2.3-%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82">和数组类型</a>（6.2.3节），形参可以是指向函数的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形参看起来是函数类型，实际上确实当成指针使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">bool</span> pf(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以直接把函数作为实参使用，他会被自动转换为指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">useBigger</span>(s1,s2,lengthCompare); <span class="comment">// 函数名即指向函数的指针</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如上，直接使用函数指针类型显得冗长，使用类型别名和decltype简化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数类型*/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">bool</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="keyword">using</span> Func = <span class="built_in">bool</span>(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指向函数的指针*/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncPtr)</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="keyword">using</span> FuncPtr = <span class="built_in">bool</span>(*)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncPtr</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*用简化的函数类型声明useBigger*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, Func)</span></span>; <span class="comment">// 编译器自动地将Func表示的函数类型转换成指针</span></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, FuncPtr)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="675-返回指向函数的指针"><a class="markdownIt-Anchor" href="#675-返回指向函数的指针"></a> 6.7.5 返回指向函数的指针</h3>
<ul>
<li>
<p>与形参不同，编译器不会自动地将函数返回类型当成对应的指针类型处理，因此<strong>我们必须显式地将返回类型指定为指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//四个等价</span></span><br><span class="line"><span class="function">FuncPtr <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, FuncPtr)</span></span>;</span><br><span class="line"><span class="function">Func *<span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, FuncPtr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, FuncPtr)</span> -&gt; <span class="title">bool</span><span class="params">(*)</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;<span class="comment">//尾置返回类型 </span></span><br><span class="line"><span class="built_in">bool</span> (* <span class="built_in">useBigger</span>(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, FuncPtr) ) (<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);</span><br><span class="line"><span class="comment">/*解释：先看括号里的，useBigger有形参列表，是一个函数；其前面有*，是一个指针；指向一个bool(const string &amp;, const string &amp;)的函数类型*/</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将auto和decltype用于函数指针类型</p>
<ul>
<li>
<p>牢记将decltype作用于某个函数，它返回函数类型而非指针类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string::size_type <span class="title">sumlength</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function">string::size_type <span class="title">largerlength</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(sumlength) *<span class="built_in">getFunc</span>(<span class="type">const</span> string &amp;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="七-类"><a class="markdownIt-Anchor" href="#七-类"></a> 七 类</h1>
<h2 id="71-定义抽象数据类型"><a class="markdownIt-Anchor" href="#71-定义抽象数据类型"></a> 7.1 定义抽象数据类型</h2>
<h3 id="711-关于类的基础知识"><a class="markdownIt-Anchor" href="#711-关于类的基础知识"></a> 7.1.1 关于类的基础知识</h3>
<p>（P228~P235）主要讲述了“类”的基础知识。</p>
<p>一、</p>
<p>首先说明了类是什么：</p>
<ul>
<li>类的基本思想是<strong>数据抽象</strong> (data abstraction)和<strong>封装</strong>(encapsulation)。数据抽象是一种依赖于<strong>接口</strong>(interface)和**实现 **(implementation)分离的编程(以及设计)技术。</li>
<li>类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。</li>
<li>封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。</li>
</ul>
<p>二、</p>
<p>通过设计Sales_data类，讲述了数据成员及成员函数。并提出了如下建议：</p>
<blockquote>
<p>在一些简单的应用程序中，类的用户和类的设计者常常是同一个人。尽管如此，还是最好把角色区分开来。<strong>当我们设计类的接口时，应该考虑如何才能使得类易于使用；而当我们使用类时，不应该顾及类的实现机理。</strong></p>
</blockquote>
<p>三、</p>
<p>接着通过成员函数引入<code>this</code>指针，该指针是类的成员函数额外的隐式参数，指向调用它的那个对象。有如下代码，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Sale_data定义于P230中间</span></span><br><span class="line">Sales_data total;</span><br><span class="line">total.<span class="built_in">isbn</span>();  <span class="comment">// total调用了成员函数isbn()</span></span><br></pre></td></tr></table></figure>
<p>实际上，编译器将该调用重写成如下形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::<span class="built_in">isbn</span>(&amp;total);</span><br></pre></td></tr></table></figure>
<ul>
<li>任何对类成员的直接访问都被看做this的隐式引用；</li>
<li>任何自定义名为this的参数或变量的行为都是非法的；</li>
<li><code>this</code>是一个常量指针，不允许修改<code>this</code>中保存的地址。</li>
</ul>
<p>成员函数在紧随参数列表之后，可以有const，用以修改隐式this指针的类型。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bookNo; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>默认的情况下，this是指向非常量版本的常量指针，所以不能把this绑定到常量对象上，这使得我们<strong>不能在一个常量对象上调用普通的成员函数</strong>。C++允许在成员函数<strong>紧随参数列表后，添加const关键字，使得this变成一个指向常量的常量指针</strong>。如此，该成员函数被称为常量成员函数，<strong>常量成员函数不能改变调用它的对象的内容</strong>。</p>
</li>
<li>
<blockquote>
<p>常量对象，及常量对象的引用或指针都只能调用常量成员函数。</p>
</blockquote>
</li>
</ul>
<p>四、</p>
<p>关于成员变量声明于成员函数之后，成员函数却能读取到成员变量，书中作出如下解释：</p>
<p>编译器分两步处理类：</p>
<ul>
<li>首先编译成员的声明</li>
<li>然后才轮到成员函数体(如果有的话)。</li>
</ul>
<p>因此，成员函数可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p>
<p>五、</p>
<p>之后，</p>
<ul>
<li>
<p>P232提及如何在类外部定义成员函数；</p>
</li>
<li>
<p>P233介绍了如何定义一个返回this对象的函数，通过<code>*this</code>以获得执行该函数的对象。</p>
</li>
<li>
<p>P234在“定义类相关的非成员函数”一节中，提到了如下几个关键点：</p>
<ul>
<li>
<p>一些辅助函数，尽管定义的操作从概念上来说属于类的接口的组成部分，但它们实际上并不属于类本身。<strong>这些函数也应与类声明(而非定义)在同一个头文件内</strong>。这样，用户使用接口的任何部分都只需要引入一个文件。</p>
</li>
<li>
<p><code>istream</code>、<code>ostream</code>等<strong>io类属于不能被拷贝的类型</strong>，因此，我们<strong>只能通过引用来传递它们</strong>。又因为<strong>读写操作会改变流的内容，所以两个函数接受的都是普通引用</strong>，而非对常量的引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, Sales_data &amp;item)</span></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    is&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">write</span><span class="params">(ostream &amp;os, Sales_data &amp;item)</span></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    os&lt;&lt;item.<span class="built_in">isbn</span>(); <span class="comment">//注意没有endl()等控制格式</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>执行<strong>输出任务的函数应该尽量减少对格式的控制</strong>，将格式控制交给用户</p>
</li>
<li>
<p>默认情况下，拷贝类的对象其实拷贝的是对象的数据成员（没有拷贝成员函数，不同的类对象共用成员函数，并用this控制（侯捷高级面向对象课程））</p>
</li>
</ul>
</li>
</ul>
<h3 id="712-构造函数"><a class="markdownIt-Anchor" href="#712-构造函数"></a> 7.1.2 构造函数</h3>
<h4 id="一-构造函数不能被声明成const"><a class="markdownIt-Anchor" href="#一-构造函数不能被声明成const"></a> 一、<strong>构造函数不能被声明成const</strong>。</h4>
<p>当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才真正取得“常量”属性–&gt;因此，<strong>构造函数在const对象的构造过程中可以向其写值</strong></p>
<h4 id="二-编译器合成的默认构造函数将按如下规则初始化类的数据成员"><a class="markdownIt-Anchor" href="#二-编译器合成的默认构造函数将按如下规则初始化类的数据成员"></a> 二、（编译器）合成的默认构造函数将按如下规则初始化类的数据成员：</h4>
<ul>
<li>如果存在类内初始值。则用它来初始化成员</li>
<li>否则，默认初始化</li>
</ul>
<p>（P262 默认构造函数的作用）</p>
<ul>
<li>
<p>类必须包含一个默认构造函数以便在下述情况下使用。</p>
</li>
<li>
<p>在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。</p>
</li>
<li>
<p>当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况下发生:</p>
<ul>
<li>当我们在块作用域内不使用任何初始值定义一个非静态变量(参见2.2.1节，第39页)或者数组时(参见3.5.1节，第101页)。</li>
<li>当一个类本身含有类类型的成员且使用合成的默认构造函数时(参见7.1.4 节，第235页)。</li>
<li>当类类型的成员没有在构造函数初始值列表中显式地初始化时(参见7.1.4 节，第237页)。</li>
</ul>
</li>
<li>
<p>值初始化在以下情况下发生:</p>
<ul>
<li>在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时 (参见3.5.1节，第 101页)。</li>
<li>当我们不使用初始值定义一个局部静态变量时(参见6.1.1节，第185页)。</li>
<li>当我们通过书写形如 T()的表达式显式地请求值初始化时，其中T是类型名(vector 的一个构造函数只接受一个实参用于说明 vector 大小(参见3.3.1节第88页)，它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化).</li>
</ul>
</li>
</ul>
<h4 id="三-某些类不能依赖于默认构造函数"><a class="markdownIt-Anchor" href="#三-某些类不能依赖于默认构造函数"></a> 三、某些类不能依赖于默认构造函数：</h4>
<ul>
<li>类内已经显式声明了构造函数</li>
<li><strong>类中包含内置类型（int等）或复合类型（如数组、指针），如执行默认构造，则他们的值将是未定义的。只有当这些值被赋予了初始值（7.3.4），才可使用默认构造</strong></li>
<li>类中包含一个其他类型的成员，其这个成员的类型没有默认构造，则编译器也无法对当前类执行默认构造</li>
</ul>
<h4 id="四-构造函数的几种方式"><a class="markdownIt-Anchor" href="#四-构造函数的几种方式"></a> 四、构造函数的几种方式</h4>
<ul>
<li>
<p><code>=default</code></p>
<p>在c++11新标准中，可以在参数列表后面写<code>=default</code>来要求编译器生成默认构造函数。注意要为内置类型或复合类型数据成员提供初始值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>构造函数列表初始化<br />
当某个数据成员被构造函数初始值化列表忽略时，它将以与合成的默认构造函数相同的方式隐式初始化（此时要求有类内初始值），</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> string &amp;s,<span class="type">double</span> p) : <span class="built_in">bookNo</span>(s),<span class="built_in">revenue</span>(p) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在类外部定义构造函数</p>
</li>
</ul>
<h4 id="五-拷贝-赋值和析构"><a class="markdownIt-Anchor" href="#五-拷贝-赋值和析构"></a> 五、拷贝、赋值和析构</h4>
<blockquote>
<p>尽管编译器能替我们合成拷贝、赋值和销毁的操作，但是必须要清楚的一点是，对于某些类来说合成的版本无法正常工作。特别是，<strong>当类需要分配类对象之外的资源时，合成的版本常常会失效。管理动态内存的类通常不能依赖于上述操作的合成版本</strong>。</p>
</blockquote>
<h3 id="713-构造函数再探"><a class="markdownIt-Anchor" href="#713-构造函数再探"></a> 7.1.3 构造函数再探</h3>
<blockquote>
<p>本节应是   书本P257页开始7.5   的内容，为了笔记结构的简洁，放到   笔记7.1.2构造函数   之后。</p>
</blockquote>
<h4 id="一-关于列表初始"><a class="markdownIt-Anchor" href="#一-关于列表初始"></a> 一、关于列表初始</h4>
<ul>
<li>
<p>使用<em>列表初始化</em>和<em>在构造函数体内通过拷贝赋值的方式初始化</em>，看似一样，但有时必须使用列表初始化且必不可少：<strong>如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过列表初始化为这些成员变量提供初始值。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstRef</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*正确*/</span></span><br><span class="line"><span class="built_in">ConstRef</span>(<span class="type">int</span> ii):<span class="built_in">i</span>(ii),<span class="built_in">ci</span>(ii),<span class="built_in">ri</span>(i)&#123;&#125;</span><br><span class="line"><span class="comment">/*引发错误*/</span></span><br><span class="line">    <span class="built_in">ConstRef</span>(<span class="type">int</span> ii)&#123;</span><br><span class="line">        i = ii;</span><br><span class="line">        ci = ii;  <span class="comment">//错误，不能给const赋值</span></span><br><span class="line">        ri = i;   <span class="comment">//错误，引用未被初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ci; </span><br><span class="line">    <span class="type">int</span> &amp;ri;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>列表初始化的初始化顺序问题 – 成员列表初始化的顺序与它们在类定义中的出现顺序一致：</p>
<blockquote>
<p>构造函数初始值列表只说明用于初始化成员的值，而<strong>不限定初始化的具体执行顺序</strong>。<strong>成员列表初始化的顺序与它们在类定义中的出现顺序一致</strong>：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。一般来说，初始化的顺序没什么特别要求。<strong>不过一个成员用另一个成员来初始化，那么这两个成员的初始化顺序就很关键了。最好令构造函数初始值的顺序与成员声明的顺序保存一致，如果可能的话，尽量避免使用某些成员初始化其他成员。</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*例1*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConstRef</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*正确*/</span></span><br><span class="line">    <span class="built_in">ConstRef</span>(<span class="type">int</span> ii) :<span class="built_in">j</span>(ii),<span class="built_in">i</span>(j) &#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;i = &quot;</span>&lt;&lt; i &lt;&lt; <span class="string">&quot;, j = &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 终端输出：i = -858993460, j = 1 </span></span><br><span class="line">        <span class="comment">// 出错，因为根据声明的顺序，先初始化i，而此时j还是未定义状态</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例2*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConstRef</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*正确*/</span></span><br><span class="line">    <span class="built_in">ConstRef</span>(<span class="type">int</span> ii) :<span class="built_in">j</span>(ii),<span class="built_in">i</span>(j) &#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;i = &quot;</span>&lt;&lt; i &lt;&lt; <span class="string">&quot;, j = &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 终端输出：i = 1, j = 1</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 声明顺序与列表初始化顺序匹配</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果为一个构造函数的所有参数都提供了默认实参，则其实际上也成为了默认构造函数。</p>
</li>
</ul>
<h4 id="二-委托构造"><a class="markdownIt-Anchor" href="#二-委托构造"></a> 二、委托构造</h4>
<ul>
<li>概念：一个委托构造函数   使用它所属类的其他构造函数    执行自身初始化过程。（将自身的（一些或全部）职责委托给了其他构造函数）</li>
<li>当一个构造函数委托给另一个构造函数时，受委托的构造函数的列表初始化和函数体被依次执行，然后才轮到委托者的函数体。</li>
<li>示例</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> unint = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line">    <span class="comment">//非委托构造使用对应的实参初始化成员</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(string s, unint cnt, <span class="type">double</span> price)</span><br><span class="line">        :<span class="built_in">bookNo</span>(s), <span class="built_in">sold</span>(cnt), <span class="built_in">rev</span>(cnt* price) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托构造</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() :<span class="built_in">Sales_data</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(string s) :<span class="built_in">Sales_data</span>(s, <span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(istream&amp; is) :<span class="built_in">Sales_data</span>() &#123; <span class="built_in">read</span>(is, *<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(istream&amp; is, Sales_data)</span> </span>&#123;<span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string bookNo;</span><br><span class="line">    unint sold;</span><br><span class="line">    <span class="type">double</span> rev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="三-隐式类型转换"><a class="markdownIt-Anchor" href="#三-隐式类型转换"></a> 三、隐式类型转换</h4>
<ul>
<li>
<p>如果一个类的<strong>构造函数只接受一个参数</strong>，则有<strong>从  该参数类型  到   该类类型  的隐式转换</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> uint = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(string s, uint cnt, <span class="type">double</span> p)</span><br><span class="line">        :<span class="built_in">m_isbn</span>(s), <span class="built_in">m_cnt</span>(cnt), <span class="built_in">m_price</span>(p) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(string s) :<span class="built_in">m_isbn</span>(s) &#123;  &#125; <span class="comment">// 1.string 可隐式转换为 Sales_data</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(Sales_data sd)</span> </span>&#123; <span class="comment">// 3. &lt;-- string转换为Sales_data后带入</span></span><br><span class="line">        <span class="keyword">if</span> (sd.m_isbn != <span class="keyword">this</span>-&gt;m_isbn)</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;isbn is not same.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_cnt += sd.m_cnt;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_isbn = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    uint m_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> m_price = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Sales_data <span class="title">item</span><span class="params">(<span class="string">&quot;978-7-121-15535-2&quot;</span>)</span></span>; <span class="comment">// 直接初始化</span></span><br><span class="line">    <span class="comment">//也可拷贝初始化</span></span><br><span class="line">    <span class="comment">//Sales_data item = string(&quot;978-7-121-15535-2&quot;);</span></span><br><span class="line">    </span><br><span class="line">    string isbn = <span class="string">&quot;978-7-121-15535-2&quot;</span>;</span><br><span class="line">    item.<span class="built_in">combine</span>(isbn); <span class="comment">// 2.正确，string 隐式转换为 Sales_data类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>但是，这种类型转换只允许一步完成，下面这种分开是不允许的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Sales_data <span class="title">item</span><span class="params">(<span class="string">&quot;978-7-121-15535-2&quot;</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="comment">/*错误*/</span></span><br><span class="line">    item.<span class="built_in">combine</span>(<span class="string">&quot;978-7-121-15535-2&quot;</span>); </span><br><span class="line">    <span class="comment">//编译器先向字符串常量转化为string；再将该string临时变量转换成Sales_data</span></span><br><span class="line">    <span class="comment">//两步转换导致隐式转换失败</span></span><br><span class="line">    <span class="comment">//编译器报错: 不存在从 &quot;const char [18]&quot; 转换到 &quot;Sales_data&quot; 的适当构造函数    </span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*正确*/</span></span><br><span class="line">    item.<span class="built_in">combine</span>(<span class="built_in">string</span>(<span class="string">&quot;978-7-121-15535-2&quot;</span>));</span><br><span class="line">    <span class="comment">//或</span></span><br><span class="line">    item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(<span class="string">&quot;978-7-121-15535-2&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>利用<code>explicit</code>关键字抑制单参数构造函数的隐式类型转换</p>
<ul>
<li>
<p><strong>关键字 <code>explicit</code>只对一个实参的构造函数有效</strong>。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为<code>explicit</code> 的。</p>
</li>
<li>
<p><strong>只能在类内声明</strong>构造函数时使用explicit 关键字，在<strong>类外部定义时不应重复</strong></p>
</li>
<li>
<p>使用了<code>explicit</code>关键字的构造函数只能以直接初始化的形式使用，不再支持拷贝形式的初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(string s)</span> :m_isbn(s) &#123;</span>  &#125; <span class="comment">// 禁止隐式转换</span></span><br><span class="line">&#125;;</span><br><span class="line">string isbn = <span class="string">&quot;978-7-121-15535-2&quot;</span>;</span><br><span class="line"><span class="function">Sales_data <span class="title">item1</span><span class="params">(isbn)</span></span>; <span class="comment">// 正确</span></span><br><span class="line">Sales_data item2 = isbn; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line">item1.<span class="built_in">combine</span>(isbn); <span class="comment">// 错误，隐式转化为explicit禁止了</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可是我们非要类型转换怎么办？可以显式类型转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">item1.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(isbn)); <span class="comment">// 错误，隐式转化为explicit禁止了</span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">item1.<span class="built_in">combine</span>(<span class="built_in">static_cast</span>&lt;Sales_data&gt;(isbn));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>标准库中含有显式构造（explicit）的类</p>
<ul>
<li>接受一个单参数的const char*的string构造函数(参见3.21节，第76页)不是explicit的。</li>
<li>接受一个容量参数的 vector 构造函数(参见3.3.1节，第87页)是explicit 的。</li>
</ul>
</li>
</ul>
<h2 id="72-控制访问和封装"><a class="markdownIt-Anchor" href="#72-控制访问和封装"></a> 7.2 控制访问和封装</h2>
<h3 id="721-访问说明符"><a class="markdownIt-Anchor" href="#721-访问说明符"></a> 7.2.1 访问说明符</h3>
<ul>
<li>public</li>
<li>private</li>
<li>protected</li>
</ul>
<h3 id="722-class与struct"><a class="markdownIt-Anchor" href="#722-class与struct"></a> 7.2.2 class与struct</h3>
<ul>
<li>class默认private</li>
<li>struct默认public</li>
</ul>
<h3 id="733-友元"><a class="markdownIt-Anchor" href="#733-友元"></a> 7.3.3 友元</h3>
<h4 id="一-友元函数"><a class="markdownIt-Anchor" href="#一-友元函数"></a> 一、友元函数</h4>
<ul>
<li>当类的数据成员被设为private，非成员函数（所谓辅助函数）就无法访问到它们了。为解决这个问题，可将这些非成员函数设为友元<code>friend</code>;</li>
<li>友元生命只能定义在类的内部，但是在类内出现的具体位置不限。友元不是类的成员，也不受它所在区域访问控制级别的约束。不过，一般来说，最好在类开始或结束的位置集中声明友元。</li>
<li>友元的声明仅仅指定了访问权限，而非通常意义上的函数声明，所以必须在友元声明之外再专门对函数进行一次声明。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales</span> data&#123;</span><br><span class="line">    <span class="comment">//为Salesdata的非成员函数所做的友元声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;，<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//其他成员及访问说明符与之前一致  </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Salesdata接口的非成员组成部分的声明</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales data&amp;，<span class="type">const</span> Sales datas)</span></span>;  <span class="comment">//类的非成员函数声明</span></span><br></pre></td></tr></table></figure>
<h4 id="二-友元类"><a class="markdownIt-Anchor" href="#二-友元类"></a> 二、友元类</h4>
<p>书本P250~P252对友元进行了补充，介绍了类与类之间的友元关系。</p>
<p>1.类作友元</p>
<ul>
<li>
<p>友元类的成员函数可以访问此类的所有成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Window_mgr</span>; <span class="comment">// Window_mgr的成员函数可以访问Screen的所有成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>友元关系不具有传递性。Window_mgr的友元与Screen没有关系。</p>
</li>
</ul>
<p>2.类的成员函数作友元</p>
<ul>
<li>
<p>当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIdx)</span></span>; <span class="comment">// Window_mgr的成员函数可以访问Screen的所有成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>想要某个成员函数作为友元，必须仔细组织程序结构，以满足声明和定义的彼此依赖关系：</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401221042529.png" alt="image-20240122104212361" style="zoom:67%;" />
</li>
<li>
<p>尽管重载函数名字相同，但它们是不同的函数，友元声明要分别声明。</p>
</li>
</ul>
<p>3.友元声明和作用域</p>
<ul>
<li>
<p>要理解：友元声明的作用是设定访问权限，其本身并不是普通意义上的声明。（必须在别处书写真正的声明。）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 即使在此处定义，也要在类的外部提供声明</span></span><br><span class="line">    <span class="built_in">X</span>() &#123; <span class="built_in">f</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void f(); //在此处定义，本例类的构造函数会报“f找不到标识符”</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="73-类的其他特性"><a class="markdownIt-Anchor" href="#73-类的其他特性"></a> 7.3 类的其他特性</h2>
<h3 id="731-在类中定义类型成员"><a class="markdownIt-Anchor" href="#731-在类中定义类型成员"></a> 7.3.1 在类中定义类型成员</h3>
<ul>
<li>类还可以自定义某种类型在类中的别名，该别名同样存在访问权限。</li>
<li>与不同成员不用关注定义的顺序不同，定义类型的成员必须先定义后使用。因此类型成员通常出现在类开始的地方；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 在类中定义类型成员 */</span></span><br><span class="line">    <span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line">    <span class="comment">//等价</span></span><br><span class="line">    <span class="comment">//using pos = string::size_type;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width = <span class="number">0</span>; <span class="comment">// 默认初始值</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如何在类外使用？*/</span></span><br><span class="line">Screen::pos myPos;</span><br></pre></td></tr></table></figure>
<h3 id="732-令成员做inline函数"><a class="markdownIt-Anchor" href="#732-令成员做inline函数"></a> 7.3.2 令成员做inline函数</h3>
<ul>
<li>
<p>最好在类外部定义的地方说明inline，以使类更容易理解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Screen &amp;<span class="title">move</span><span class="params">(pos r, pos c)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function">Screen &amp;<span class="title">Screen::move</span><span class="params">(pos r, pos c)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>inline成员函数也应与相应的类定义在同一个头文件中</p>
</li>
</ul>
<h3 id="733-可变数据成员-mutable"><a class="markdownIt-Anchor" href="#733-可变数据成员-mutable"></a> 7.3.3 可变数据成员 – <code>mutable</code></h3>
<ul>
<li>可以通过向类的某个变量声明中加入<code>mutable</code>关键字，达到即使是在一个const成员函数内也能修改该成员变量的目的。</li>
<li><strong>可变数据成员永远不会是const，任何时候都能被修改</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="type">const</span> </span>&#123; ++access_ctr; &#125; <span class="comment">//access_ctr用于记录成员函数被调用了多少次</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">size_t</span> access_ctr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="734-类数据成员的初始值"><a class="markdownIt-Anchor" href="#734-类数据成员的初始值"></a> 7.3.4 类数据成员的初始值</h3>
<ul>
<li>希望自己设计的类一开始就被一个默认初始化，最好的方式就是<strong>将默认值声明成类内初始值</strong></li>
<li>当我们提供一个类内初始值时，必须以等号或者花括号表示</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span>&#123;    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Screen&gt; screens&#123;<span class="built_in">Screen</span>(<span class="number">24</span>,<span class="number">80</span>,<span class="string">&#x27; &#x27;</span>)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="735-️成员函数利用引用返回this"><a class="markdownIt-Anchor" href="#735-️成员函数利用引用返回this"></a> 7.3.5 ⭐️成员函数利用引用返回*this</h3>
<h4 id="一-可将一系列操作连接成一条表达式"><a class="markdownIt-Anchor" href="#一-可将一系列操作连接成一条表达式"></a> 一、可将一系列操作连接成一条表达式</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::move</span><span class="params">(pos r, pos c)</span></span>&#123;  <span class="comment">// &lt;-- 返回*this的引用</span></span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::set</span><span class="params">(<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，返回引用的函数是左值的，意味着上述函数返回的是对象本身而非副本。将this对象作为左值返回，可以把一系列操作连接成一条表达式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Screen myScreen;</span><br><span class="line">myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>).<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>);  <span class="comment">// 一系列操作连接成一条表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line">myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">myScreen.<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>反之，如果返回的非引用（Screen &amp;）而是值传递（Screen），则调用<code>set()</code>只是改变副本，而不能改变myScreen的值，连续调用将会失败。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scream tmp = myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">tmp.<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>对比实验如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line">    <span class="built_in">Screen</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值为引用的版本    &lt;-- 正确的版本</span></span><br><span class="line">    <span class="function">Screen&amp; <span class="title">move</span><span class="params">(pos r, pos c)</span></span>;</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">set</span><span class="params">(<span class="type">char</span> ch)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载返回值非引用的版本，noRefer是用于重载的参数，无实际意义</span></span><br><span class="line">    <span class="function">Screen <span class="title">move</span><span class="params">(pos r, pos c, string noRefer)</span></span>;</span><br><span class="line">    <span class="function">Screen <span class="title">set</span><span class="params">(<span class="type">char</span> ch, string noRefer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; m_r &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; m_c &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; m_ch &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos m_r = <span class="number">0</span>, m_c = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> m_ch = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 返回值为引用的版本</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen&amp; <span class="title">Screen::move</span><span class="params">(pos r, pos c)</span> </span>&#123;  </span><br><span class="line">    m_r = r;</span><br><span class="line">    m_c = c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen&amp; <span class="title">Screen::set</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">    m_ch = ch;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载返回值非引用的版本，noRefer是用于重载的参数，无实际意义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen <span class="title">Screen::move</span><span class="params">(pos r, pos c, string noRef)</span> </span>&#123;</span><br><span class="line">    m_r = r;</span><br><span class="line">    m_c = c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen <span class="title">Screen::set</span><span class="params">(<span class="type">char</span> ch, string noRef)</span> </span>&#123;</span><br><span class="line">    m_ch = ch;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Screen myScreen1,myScreen2;</span><br><span class="line">    myScreen1.<span class="built_in">print</span>(); <span class="comment">//0,0,</span></span><br><span class="line"></span><br><span class="line">    myScreen1.<span class="built_in">move</span>(<span class="number">4</span>, <span class="number">0</span>).<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    myScreen1.<span class="built_in">print</span>(); <span class="comment">//4,0,#</span></span><br><span class="line"></span><br><span class="line">    myScreen2.<span class="built_in">move</span>(<span class="number">4</span>, <span class="number">0</span>, <span class="string">&quot;noRef&quot;</span>).<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>, <span class="string">&quot;noRef&quot;</span>); <span class="comment">// set失败，作用于了myScreen的副本</span></span><br><span class="line">    myScreen2.<span class="built_in">print</span>(); <span class="comment">//4,0,</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二-const成员函数的重载和this指针的返回"><a class="markdownIt-Anchor" href="#二-const成员函数的重载和this指针的返回"></a> 二、const成员函数的重载和*this指针的返回</h4>
<ul>
<li>重载多个const成员函数如何选择？下图1</li>
<li>从const成员函数返回*this：一个const成员函数如果以引用形式返回this，返回类型将是常量引用，下图2。</li>
<li>this指针的隐式传递，下图3</li>
</ul>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401212100323.png" alt="image-20240121210058172" style="zoom:67%;" />
<h3 id="736-类类型"><a class="markdownIt-Anchor" href="#736-类类型"></a> 7.3.6 类类型</h3>
<ul>
<li>
<p>只声明而未定义的类被称作前向声明；</p>
</li>
<li>
<p>在类定义之后，声明之前被称为不完全类型；</p>
</li>
<li>
<p>不完全类型用于有限的场景：</p>
<ul>
<li>
<p>可以定义指向这种类型的指针或引用</p>
</li>
<li>
<p>可以声明（但不可定义）以不完全类型作为参数或者返回类型的函数</p>
</li>
</ul>
</li>
<li>
<p>我们创建类的对象之前，该类必须被定义过</p>
</li>
<li>
<p>一种例外情况：（此处没有读懂，但是知道该用法）<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401212228151.png" alt="image-20240121222858971" /></p>
</li>
</ul>
<h2 id="74-类的其他形式"><a class="markdownIt-Anchor" href="#74-类的其他形式"></a> 7.4 类的其他形式</h2>
<h3 id="741-聚合类"><a class="markdownIt-Anchor" href="#741-聚合类"></a> 7.4.1 聚合类</h3>
<ul>
<li>
<p>用户可以直接访问其成员，且具有特殊初始化语法</p>
</li>
<li>
<p>满足如下条件：</p>
<ul>
<li>所有成员都是 public的。</li>
<li>没有定义任何构造函数。</li>
<li>没有类内初始值</li>
<li>没有基类，也没有 virtual函数</li>
</ul>
</li>
<li>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span>&#123;</span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    string s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>初始化 – 顺序必须与生命顺序一致</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data val&#123;<span class="number">0</span>,<span class="string">&quot;anna&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="742-constexpr类"><a class="markdownIt-Anchor" href="#742-constexpr类"></a> 7.4.2 constexpr类</h3>
<ul>
<li>对于聚合类，如果数据成员都是字面值类型，则为字面值常量类</li>
<li>对于普通的类，满足：
<ul>
<li>数据成员都必须是字面值类型</li>
<li>类必须至少含有一个 constexpr 构造函数。</li>
<li>如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式(笔记2.5.4）；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。</li>
<li>类必须使用析构函数的默认定义，该成员负责销毁类的对象(书7.1.5节，第239页)。</li>
</ul>
</li>
</ul>
<p>关于constexpr构造函数</p>
<ul>
<li>尽管构造函数不能是 const 的，但是字面值常量类的构造函数可以是 constexpr函数。</li>
<li>事实上，<strong>一个字面值常量类必须至少提供一个constexpr 构造函数</strong>。</li>
<li>constexpr构造函数的形式：
<ul>
<li>法一：<code>=default</code></li>
<li>法二：既符合构造函数的要求（无返回语句），又符合constexpr函数的要求。 &lt;-- constexpr构造函数体一般是空的。</li>
</ul>
</li>
<li>constexpr构造函数必须初始化所有数据成员。初始值  或者使用constexpr 构造函数 ，或者是一条常量表达式。</li>
<li>constexpr 构造函数用于生成constexpr 对象以及 constexpr 函数的参数或返回类型。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Debug</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">bool</span> b = <span class="literal">true</span>)</span> : hw(b),io(b),other(b) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">bool</span> h,<span class="type">bool</span> i, <span class="type">bool</span> o)</span> : hw(h),io(i),other(o) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*constexpr */</span><span class="function"><span class="type">bool</span> <span class="title">any</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> hw || io || other; &#125; </span><br><span class="line">    <span class="comment">//在vs2022上须指定为const成员函数，否则：</span></span><br><span class="line">    <span class="comment">//“bool Debug::any(void)”: 不能将“this”指针从“const Debug”转换为“Debug &amp;”</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_io</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123; io = b; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_hw</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123; hw = b; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_other</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123; hw = b; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> hw;</span><br><span class="line">    <span class="type">bool</span> io;</span><br><span class="line">    <span class="type">bool</span> other;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*调用*/</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> Debug <span class="title">io_sub</span><span class="params">(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (io_sub.<span class="built_in">any</span>()) <span class="comment">// if(true)</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;print appropriate error messages&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> Debug <span class="title">prod</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (prod.<span class="built_in">any</span>())  <span class="comment">// if(false)</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;print anerror message&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="75-类的作用域"><a class="markdownIt-Anchor" href="#75-类的作用域"></a> 7.5 类的作用域</h2>
<h3 id="751-类名的作用范围"><a class="markdownIt-Anchor" href="#751-类名的作用范围"></a> 7.5.1 <code>类名::</code>的作用范围</h3>
<p>本节从书本P253开始，首先简述了如何通过类访问其中的成员变量、成员函数和typedef的类型别名。</p>
<p>接着，讲述了<code>类名::</code>的作用范围，即其后的所有东西，包括函数名、参数列表和函数体。而其之前的返回值类型不包含在其中，如果返回值类名在此类中定义，也要用<code>类名::</code>额外声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 在类中定义类型成员 */</span></span><br><span class="line">    <span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line">    <span class="comment">//等价</span></span><br><span class="line">    <span class="comment">//using pos = string::size_type;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">pos <span class="title">clear</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width = <span class="number">0</span>; <span class="comment">// 默认初始值</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用*/</span></span><br><span class="line"><span class="comment">// Screen::clear中的 `Screen::`不作用于pos，pos需要额外声明其所属类</span></span><br><span class="line"><span class="function">Screen::pos <span class="title">Screen::clear</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="752-名字查找"><a class="markdownIt-Anchor" href="#752-名字查找"></a> 7.5.2 名字查找</h3>
<ul>
<li>
<p>类成员声明的名字查找，考虑下述代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line">string bal;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> bal;&#125; <span class="comment">//1.</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//typedef double Money; //2.错误，Money不可重复定义</span></span><br><span class="line">    Money bal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>编译器处理完类中的全部声明后，才会处理成员函数的定义。</strong></p>
</li>
<li>
<p>在注释1处，编译器没有找到  在Account中  使用Money前  出现的声明，接着到Account外层作用域寻找，找到了Money。</p>
</li>
<li>
<p>另一方面，成员函数<code>balance()</code>的函数体在整个类全部可见（声明）后才被处理（函数定义），因此返回成员变量bal，而非外层的string的bal。</p>
</li>
<li>
<p>在注释2处，</p>
<blockquote>
<p>一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。</p>
<p><strong>建议将类型名的定义放在类开始处，这样保证所有使用该类的成员都出现在类名定义之后。</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>成员函数中使用的名字的查找方式：<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401232246190.png" alt="image-20240123224641037" style="zoom:67%;" /></p>
<ul>
<li>
<p>成员变量名和成员函数参数名重名，降低了代码的阅读性。</p>
<blockquote>
<p><strong>建议不要将成员名字作为参数或其他局部变量使用</strong>，如下述代码例3所示。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> height;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line">    <span class="comment">/*********** 例1 *************/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(pos height)</span></span>&#123;</span><br><span class="line">        cursor = width * height;  <span class="comment">// height是参数声明</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*****************************/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>,width = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将例1替换成例2*/</span></span><br><span class="line"><span class="comment">/*********** 例2 *************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(pos height)</span></span>&#123;</span><br><span class="line">    cursor = width * <span class="keyword">this</span>-&gt;height; <span class="comment">//类成员height</span></span><br><span class="line">    <span class="comment">//等价</span></span><br><span class="line">    cursor = width * Screen::height;  <span class="comment">//类成员height</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将例1替换成例3*/</span></span><br><span class="line"><span class="comment">/*********** 例3 建议的写法*************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(pos ht)</span></span>&#123;</span><br><span class="line">    cursor = width * height;  <span class="comment">// 类成员height</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将例1替换成例4*/</span></span><br><span class="line"><span class="comment">/*********** 例4 *************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(pos height)</span></span>&#123;</span><br><span class="line">    cursor = width * ::height; <span class="comment">// 全局的那个int height;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****************************/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>在文件中名字的出现处进行解析</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> height;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(pos)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>,width = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Screen::pos <span class="title">verify</span><span class="params">(Screen::pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(pos var)</span></span>&#123;</span><br><span class="line">    height = <span class="built_in">verify</span>(var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然函数<code>verify()</code>在类Screen定义之后，但出现在了成员函数<code>func()</code>定义之前的全局作用域，所以可被正常使用。（参见：成员函数中使用的名字的查找方式第3点：如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。）</p>
</li>
</ul>
<h2 id="76-类的静态成员"><a class="markdownIt-Anchor" href="#76-类的静态成员"></a> 7.6 类的静态成员</h2>
<h3 id="761-基础"><a class="markdownIt-Anchor" href="#761-基础"></a> 7.6.1 基础</h3>
<ul>
<li>在成员声明前加上<code>static</code>关键字声明静态成员。静态成员直接与类关联，而不是与类的对象关联。</li>
<li>静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。只会存在一个静态数据，被所有对象共享。</li>
<li>静态成员函数不与任何对象绑定，不包含this指针，不能声明为const成员函数。</li>
</ul>
<h3 id="762-定义静态成员"><a class="markdownIt-Anchor" href="#762-定义静态成员"></a> 7.6.2 定义静态成员</h3>
<ul>
<li>因为静态成员不属于类的任何一个对象，因此不能用类的构造函数初始化。</li>
<li>一般来说，**不能再类内初始化静态成员，必须在类外部定义和初始化每个静态成员。**除了笔记7.6.3的情况。</li>
<li>一旦定义，将存在于整个程序的生命周期。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Account</span>();</span><br><span class="line">    ~<span class="built_in">Account</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i; <span class="comment">/*= 0;//错误,带有类内初始值设定项的成员必须为常量*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Account::i = <span class="number">0</span>; <span class="comment">// 类外定义和初始化</span></span><br></pre></td></tr></table></figure>
<h3 id="763-静态成员的类内初始化"><a class="markdownIt-Anchor" href="#763-静态成员的类内初始化"></a> 7.6.3 静态成员的类内初始化</h3>
<p>笔记7.6.2说：“不能再类内初始化静态成员，必须在类外部定义和初始化每个静态成员。”但是，有一种例外。</p>
<p>我们可以为静态成员提供<strong>const 整数类型</strong>的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr(参见 7.5.6 节，第267 页)。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适合于常量表达式的地方。例如，我们可以用一个初始化了的静态数据成员指定数组成员的维度:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> period = <span class="number">30</span>;</span><br><span class="line">    <span class="type">double</span> daily_tbl[period];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带初始值的定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> Account::period; </span><br></pre></td></tr></table></figure>
<p>书中提到了两种情况，说明<code>static constexpr</code>是否需要重复定义：</p>
<ul>
<li>仅用静态常量表达式替换它的值，如定义数组维度，则不用重复定义（也可以多此一举地定义）</li>
<li>当需要将其传递为一个接收该类型的函数时，则需要重复定义。</li>
</ul>
<p>**为省去麻烦，干脆不论上述何种情况，都在类外重新<em>不带初始值</em>地定义一下该成员。**如上述代码最后一行所示。</p>
<h3 id="764-能使用静态成员而不能使用普通成员变量的场景"><a class="markdownIt-Anchor" href="#764-能使用静态成员而不能使用普通成员变量的场景"></a> 7.6.4 能使用静态成员，而不能使用普通成员变量的场景</h3>
<h4 id="一-静态数据成员可以是不完全类型"><a class="markdownIt-Anchor" href="#一-静态数据成员可以是不完全类型"></a> 一、静态数据成员可以是不完全类型</h4>
<p>有关不完全类型见<em>书P250–类的声明</em>和<a href="#7.3.6-%E7%B1%BB%E7%B1%BB%E5%9E%8B"><em>笔记7.3.6 类类型</em></a></p>
<ul>
<li>特别的，静态数据成员的类型可以就是它所属的类型，而非静态成员变量只能声明它所属的类的指针或引用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Bar mem1;    <span class="comment">//正确，静态成员可以是不完全类型</span></span><br><span class="line">    Bar *men2;            <span class="comment">//正确，指针成员可以是不完全类型</span></span><br><span class="line">    Bar mem3;             <span class="comment">// 错误，数据成员必须是完整类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="二-可以使用静态成员作默认实参而普通成员不行"><a class="markdownIt-Anchor" href="#二-可以使用静态成员作默认实参而普通成员不行"></a> 二、可以使用静态成员作默认实参，而普通成员不行</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//静态成员作默认实参</span></span><br><span class="line">    <span class="function">Screen&amp; <span class="title">clear</span><span class="params">(<span class="type">char</span> = bg)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> bg;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> Screen::bg = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 类外定义static数据成员</span></span><br><span class="line"></span><br><span class="line"><span class="function">Screen&amp; <span class="title">Screen::clear</span><span class="params">(<span class="type">char</span> s)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Screen a;</span><br><span class="line">    a.<span class="built_in">clear</span>(); <span class="comment">// 使用默认实参bg，终端输出   a</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align="center"><h1>------标准库------</h1></div>
<h1 id="八-标准库的io操作"><a class="markdownIt-Anchor" href="#八-标准库的io操作"></a> 八 标准库的IO操作</h1>
<h2 id="81-io类"><a class="markdownIt-Anchor" href="#81-io类"></a> 8.1 IO类</h2>
<h3 id="811-io库类型和头文件"><a class="markdownIt-Anchor" href="#811-io库类型和头文件"></a> 8.1.1 IO库类型和头文件</h3>
<ul>
<li>标准库给出的IO类型如下图所示；其中，以“w”开头的版本是为了支持宽字符语言，标准库定义了一组类型和对象来操纵<code>wchar_t</code>类型的数据。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401242153870.png" alt="image-20240124215309669" /></p>
<h3 id="812-io对象无拷贝或赋值"><a class="markdownIt-Anchor" href="#812-io对象无拷贝或赋值"></a> 8.1.2 IO对象无拷贝或赋值</h3>
<ul>
<li>IO对象不能拷贝或者赋值
<ul>
<li>不能拷贝io对象，因此我们不能将形参或返回值类型设置为流类型，而<strong>常以引用方式传递</strong></li>
<li>读写一个io对象会改变其状态，因此传递和返回的引用不能是<code>const</code></li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ofstream out1,out2;</span><br><span class="line">out1 = out2;            <span class="comment">//错误，不能对流对象赋值</span></span><br><span class="line"><span class="function">ofstream <span class="title">print</span><span class="params">(ofstream)</span></span>;    <span class="comment">//错误，不能初始化ofstream参数</span></span><br><span class="line">out1 = <span class="built_in">print</span>(out2);        <span class="comment">//错误，不能拷贝流对象（不能将形参设置为流对象）</span></span><br></pre></td></tr></table></figure>
<h3 id="813-io状态"><a class="markdownIt-Anchor" href="#813-io状态"></a> 8.1.3  IO状态</h3>
<ul>
<li>条件状态表</li>
</ul>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401242233996.png" alt="202401242233996" style="zoom:67%;" />
<ul>
<li>
<p>判断一个流是否处于良好状态的最简单的方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin&gt;&gt;word)&#123;</span><br><span class="line">    <span class="comment">//读取成功的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>IO 库定义了一个与机器无关的 <code>iostate</code>类型，该类型应<strong>作为一个位集合来使用</strong>。有4个iostate类型的constexpr值（<code>badbit</code>,<code>failbit</code>,<code>eofbit</code>,<code>goodbit</code>），表示特定的位模式，这些值可以与位运算符一起使用来一次性检测或设置多个标志位：</p>
<ul>
<li><code>badbit</code> 表示系统级错误，如不可恢复的读写错误。通常情况下，一旦 <code>badbit</code>被置位，流就无法再使用了。</li>
<li><code>failbit</code> 被置位于发生可恢复错误后，如期望读取数值却读取一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。</li>
<li>如果到达文件结束位置，<code>eofbit</code>和 <code>failbit</code> 都会被置位。</li>
<li><code>goodbit</code> 的值为0，表示流未发生错误。如果<code>badbit</code>、<code>failbit</code>和<code>eofbit</code>任一个被置位，则检测流状态的条件会失败。</li>
</ul>
</li>
<li>
<p>为检测流的状态，IO库提供了一组函数。其中，<code>good()</code>和<code>fail()</code>是确定流的总体状态的方法。下面列出两种使用方法：</p>
<ul>
<li>
<p>状态管理：保存流的状态并恢复</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> old_state = cin.<span class="built_in">rdstate</span>();</span><br><span class="line">cin.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">proess_func</span>(cin);</span><br><span class="line">cin.<span class="built_in">setstate</span>(old_state);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将failbit和badbit复位，但保持eofbit不变：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">clear</span>(cin.<span class="built_in">rdstate</span>() &amp; ~cin.failbit &amp; ~cin.badbit);</span><br></pre></td></tr></table></figure>
<p>过程如下图所示<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401251044101.png" alt="image-20240125104415847" /></p>
</li>
</ul>
</li>
</ul>
<h3 id="814-缓冲区"><a class="markdownIt-Anchor" href="#814-缓冲区"></a> 8.1.4 缓冲区</h3>
<ul>
<li>
<p>导致缓冲区刷新的原因</p>
<ul>
<li>
<p>程序正常结束，作为main函数<code>return</code>操作的一部分，缓冲刷新被执行。</p>
</li>
<li>
<p>缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。</p>
</li>
<li>
<p>我们可以使用操纵符如<code>endl</code>(参见1.2节，第6页)来显式刷新缓冲区。</p>
</li>
<li>
<p>在每个输出操作之后，我们可以用操纵符<code>unitbuf</code>设置流的内部状态，来清空缓冲区。默认情况下，对<code>cerr</code> 是设置<code>unitbuf</code>的，因此写到<code>cerr</code>的内容都是立即刷新的。</p>
</li>
<li>
<p>一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，<code>cin</code>和 <code>cerr</code> 都关联到 <code>cout</code>。因此，读<code>cin</code>或写<code>cerr</code>都会导致<code>cout</code>的缓冲区被刷新。</p>
</li>
</ul>
</li>
<li>
<p>刷新缓冲区的几种方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">&quot;hi&quot;</span>&lt;&lt;endl;    <span class="comment">//附加一个换行符，然后刷新缓冲区</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;hi&quot;</span>&lt;&lt;flush;    <span class="comment">//不附加任何字符，刷新缓冲区</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;hi&quot;</span>&lt;&lt;end;    <span class="comment">//附加一个空字符，然后刷新缓冲区</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;unitbuf;</span><br><span class="line"><span class="comment">//任何输出都立即刷新，无缓冲</span></span><br><span class="line">......;<span class="comment">// 一些操作</span></span><br><span class="line">cout&lt;&lt;nounitbuf; <span class="comment">// 回到正常的缓冲模式</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>书中提到的一个注意事项：</p>
<blockquote>
<p>警告：如果程序崩溃，输出缓冲区不会被刷新</p>
<p>如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩溃后，它所输出的数据很可能停留在输出缓冲区中等待打印。</p>
<p>当调试一个已经崩溃的程序时，需要确认那些你认为已经输出的数据确实已经刷新了。否则，可能将大量时间浪费在追踪代码为什么没有执行上，而实际上代码已经执行了，只是程序崩溃后缓冲区没有被刷新，输出数据被挂起没有打印而已。</p>
<p><strong>程序员常常在调试添加打印语句。这类语句应该保证一直刷新流。否则，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。</strong></p>
</blockquote>
</li>
</ul>
<h3 id="815-关联输入流和输出流"><a class="markdownIt-Anchor" href="#815-关联输入流和输出流"></a> 8.1.5 关联输入流和输出流</h3>
<ul>
<li>
<p>当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将cin和cout关联，因此<code>cin &gt;&gt;ival</code>将会导致cout的缓冲区被刷新。</p>
</li>
<li>
<p>利用<code>iostream::tie()</code>函数，既可以将一个istream对象关联到另一个ostream上，也可以将一个ostream关联到另一个ostream上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">tie</span>(&amp;cout); <span class="comment">// 标准库中，cin与cout关联</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//old_tie指向旧的关联</span></span><br><span class="line">ostream *old_tie = cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);<span class="comment">//cin不再与任何流关联（即解除关联）</span></span><br><span class="line"></span><br><span class="line">cin.<span class="built_in">tie</span>(&amp;cerr); <span class="comment">// 将cin与cerr关联，读取cin会导致cerr的刷新</span></span><br><span class="line"></span><br><span class="line">cin.<span class="built_in">tie</span>(old_tie); <span class="comment">// 恢复之前的关联</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="82-iostream"><a class="markdownIt-Anchor" href="#82-iostream"></a> 8.2 iostream</h2>
<p>书本第5页（略）</p>
<h2 id="83-fstream文件流"><a class="markdownIt-Anchor" href="#83-fstream文件流"></a> 8.3 fstream（文件流）</h2>
<h3 id="831-fstream的特有操作"><a class="markdownIt-Anchor" href="#831-fstream的特有操作"></a> 8.3.1 fstream的特有操作</h3>
<ul>
<li>fstream继承与iostream，除了可以使用iostream的操作外，还有其特有的操作，如下所示：<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401242237156.png" alt="image-20240124223730897" style="zoom:67%;" />
<ul>
<li>**在要求使用基类类型对象的地方，我们可以用继承类型的对象来替代。**因为fstream（和sstream）继承于iostream，所以接受iostream的引用（或指针）参数的函数，可以用对用的fstream（或sstream）类型来调用。</li>
<li>通过构造函数打开文件的，会自动调用<code>open()</code>和<code>close()</code> （自动构造和析构）。通过<code>open()</code>打开文件，则必须在结束是手动书写<code>close()</code>。</li>
<li>对一个已经打开的文件流调用<code>open()</code>会失败，并导致<code>failbit</code>被置位。必须先关闭（<code>close()</code>）已经关联的文件，再打开新文件。</li>
</ul>
</li>
</ul>
<h3 id="832-文件模式"><a class="markdownIt-Anchor" href="#832-文件模式"></a> 8.3.2 文件模式</h3>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401242235255.png" alt="image-20240124223522104" style="zoom:67%;" />
<ul>
<li>
<p>默认模式</p>
<ul>
<li>ifstream：in模式</li>
<li>ofstream：out模式</li>
<li>fstream：in+out模式</li>
</ul>
</li>
<li>
<p>一些注意事项</p>
<ul>
<li>以<code>out</code>模式打开文件会将文件清空，除非同时显式指定<code>app</code>或<code>in</code>。</li>
<li>只有当<code>out</code>也被设定时才可设定<code>trunc</code></li>
<li>每次调用<code>open()</code>都要（显式或隐式地）重新设置文件模式。</li>
<li>只可以对<code>ofstream</code>或<code>fstream</code>设置<code>out</code></li>
<li>只可以对<code>ifstream</code>或<code>fstream</code>设置<code>in</code></li>
<li>只要<code>trunc</code>没被设定，就可以设定<code>app</code> 模式。在 <code>app</code>模式下，即使没有显式指定<code>out</code> 模式，文件也总是以输出方式被打开。</li>
<li><code>ate</code>和<code>binary</code>模式可用于任何类型的文件流对象，且可以与其他任何文件模式组合使用。</li>
</ul>
</li>
</ul>
<h2 id="84-sstreamstring流"><a class="markdownIt-Anchor" href="#84-sstreamstring流"></a> 8.4 sstream（string流）</h2>
<ul>
<li>
<p>和fstream同样继承与ostream，既可以使用iostream的操作，也有其特有操作：<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401251631905.png" alt="image-20240125163147587" /></p>
</li>
<li>
<p><code>strm.str(s)</code>会清空strm中原有的数据，示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ostringstream nums;</span><br><span class="line">    vector&lt;string&gt; nums_vec&#123;<span class="string">&quot;123&quot;</span>,<span class="string">&quot;456&quot;</span>,<span class="string">&quot;789&quot;</span>,<span class="string">&quot;101112&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> num : nums_vec) &#123;</span><br><span class="line">        nums &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; nums.<span class="built_in">str</span>() &lt;&lt; endl; <span class="comment">//123 456 789 101112</span></span><br><span class="line"></span><br><span class="line">    nums.<span class="built_in">str</span>(<span class="built_in">string</span>(<span class="string">&quot;888&quot;</span>)); <span class="comment">// 清空了string流中原有的数据</span></span><br><span class="line">    cout &lt;&lt; nums.<span class="built_in">str</span>() &lt;&lt; endl; <span class="comment">//888</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="841-istringstream"><a class="markdownIt-Anchor" href="#841-istringstream"></a> 8.4.1 istringstream</h3>
<ul>
<li>何时使用？
<ul>
<li>当我们对整行文本进行处理，并同时需要处理行内的单个单词时。</li>
</ul>
</li>
<li>示例</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PersonInfo</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    vector&lt;string&gt; phones;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string line, phone;</span><br><span class="line">    vector&lt;PersonInfo&gt; people;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件中的所有数据存入people:vector&lt;PersonInfo&gt;中</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line)) &#123;</span><br><span class="line">        PersonInfo info;</span><br><span class="line">        <span class="function">istringstream <span class="title">record</span><span class="params">(line)</span></span>;</span><br><span class="line">        record &gt;&gt; info.name;</span><br><span class="line">        <span class="keyword">while</span> (record &gt;&gt; phone)</span><br><span class="line">        &#123;</span><br><span class="line">            info.phones.<span class="built_in">push_back</span>(phone);</span><br><span class="line">        &#125;</span><br><span class="line">        people.<span class="built_in">push_back</span>(info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐人验证号码是否有效</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;entry : people)</span><br><span class="line">    &#123;</span><br><span class="line">        ostringstream formated, badNums;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;phone :entry.phones)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">valid</span>(phone)) &#123; <span class="comment">// 省略判断电话是否有效的代码</span></span><br><span class="line">                badNums &lt;&lt; phone &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                formated &lt;&lt; format(phone) &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//省略格式化电话号码的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (badNums.<span class="built_in">str</span>().<span class="built_in">empty</span>())</span><br><span class="line">            cout &lt;&lt; entry.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; formated.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;input error: &quot;</span> &lt;&lt; entry.name </span><br><span class="line">            &lt;&lt; <span class="string">&quot; invalid numbers(s) &quot;</span>&lt;&lt; badNums.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="842-ostringstream"><a class="markdownIt-Anchor" href="#842-ostringstream"></a> 8.4.2 ostringstream</h3>
<ul>
<li>
<p>何时使用？我们想逐步构造输出的内容，希望放在最后一起打印。（此构造非构造函数的构造，不要过分解读））</p>
</li>
<li>
<p>接着8.4.1节的代码，示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逐人验证号码是否有效</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;entry : people)</span><br><span class="line">&#123;</span><br><span class="line">    ostringstream formated, badNums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;phone :entry.phones)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">valid</span>(phone)) &#123; <span class="comment">// 省略判断电话是否有效的代码</span></span><br><span class="line">            badNums &lt;&lt; phone &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            formated &lt;&lt; format(phone) &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//省略格式化电话号码的代码        </span></span><br><span class="line">            <span class="comment">/*注意此处 ↑。</span></span><br><span class="line"><span class="comment">            使用标准的输出运算符`&lt;&lt;`向这些对象写入数据，</span></span><br><span class="line"><span class="comment">            但这些“写入”操作实际上转换为 `string`操作，</span></span><br><span class="line"><span class="comment">            分别向` formatted`和`badNums`中的`string `对象添加字符。*/</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (badNums.<span class="built_in">str</span>().<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; entry.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; formated.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;input error: &quot;</span> &lt;&lt; entry.name </span><br><span class="line">        &lt;&lt; <span class="string">&quot; invalid numbers(s) &quot;</span>&lt;&lt; badNums.<span class="built_in">str</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>程序最有趣的部分是对字符串流 <code>formatted</code>和<code>badNums</code>的使用。我们使用标准的输出运算符<code>&lt;&lt;</code>向这些对象写入数据，但这些“写入”操作实际上转换为 <code>string</code>操作，分别向<code>formatted</code>和<code>badNums</code>中的<code>string</code>对象添加字符。</p>
</blockquote>
</li>
</ul>
<h3 id="843-本节完整的示例代码"><a class="markdownIt-Anchor" href="#843-本节完整的示例代码"></a> 8.4.3 本节完整的示例代码</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件中的数据 */</span></span><br><span class="line"><span class="comment">//morgan 2015552368 8625550123</span></span><br><span class="line"><span class="comment">//drew 9735550130l</span></span><br><span class="line"><span class="comment">//ee 6095550132 2015550175 8005550000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PersonInfo</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    vector&lt;string&gt; phones;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string line, phone;</span><br><span class="line">    vector&lt;PersonInfo&gt; people;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件中的所有数据存入people:vector&lt;PersonInfo&gt;中</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line)) &#123;</span><br><span class="line">        PersonInfo info;</span><br><span class="line">        <span class="function">istringstream <span class="title">record</span><span class="params">(line)</span></span>;</span><br><span class="line">        record &gt;&gt; info.name;</span><br><span class="line">        <span class="keyword">while</span> (record &gt;&gt; phone)</span><br><span class="line">        &#123;</span><br><span class="line">            info.phones.<span class="built_in">push_back</span>(phone);</span><br><span class="line">        &#125;</span><br><span class="line">        people.<span class="built_in">push_back</span>(info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐人验证号码是否有效</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;entry : people)</span><br><span class="line">    &#123;</span><br><span class="line">        ostringstream formated, badNums;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;phone :entry.phones)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">valid</span>(phone)) &#123; <span class="comment">// 省略判断电话是否有效的代码</span></span><br><span class="line">                badNums &lt;&lt; phone &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                formated &lt;&lt; format(phone) &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//省略格式化电话号码的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (badNums.<span class="built_in">str</span>().<span class="built_in">empty</span>())</span><br><span class="line">            cout &lt;&lt; entry.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; formated.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;input error: &quot;</span> &lt;&lt; entry.name </span><br><span class="line">            &lt;&lt; <span class="string">&quot; invalid numbers(s) &quot;</span>&lt;&lt; badNums.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="九-顺序容器"><a class="markdownIt-Anchor" href="#九-顺序容器"></a> 九 顺序容器</h1>
<h2 id="91-概述"><a class="markdownIt-Anchor" href="#91-概述"></a> 9.1 概述</h2>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401260921334.png" alt="image-20240126092125836" /></p>
<ul>
<li><code>forward_list</code>没有<code>size</code>操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其他容器而言，<code>size</code>保证的是一个快速的常量时间的操作。</li>
</ul>
<h3 id="911-选用顺序容器的原则"><a class="markdownIt-Anchor" href="#911-选用顺序容器的原则"></a> 9.1.1 选用顺序容器的原则</h3>
<ul>
<li>首选<code>vector</code></li>
<li>很多小元素，且空间开销重要 --&gt; 不要使用<code>list</code>或<code>forward_list</code></li>
<li>要求随机访问 --&gt; <code>vector</code>或<code>deque</code></li>
<li>中间插入和删除 --&gt; <code>list</code>或<code>forward_list</code></li>
<li>头尾插入和删除，但不在中间插入和删除 --&gt; <code>deque</code></li>
<li>如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则
<ul>
<li>首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向 <code>vector</code> 追加数据，然后再调用标准库的<code>sort</code>函数，来重排容器中的元素，从而避免在中间位置添加元素。</li>
<li>如果必须在中间位置插入元素，考虑在输入阶段使用<code>list</code>，一旦输入完成，将<code>list</code>中的内容拷贝到一个 <code>vector</code> 中。</li>
</ul>
</li>
<li>如果程序既需要随机访问元素，又需要在容器中间位置插入元素，则取决于在<code>list</code>或<code>forward_list</code> 中访问元素与 <code>vector</code>或<code>deque</code>中插入/删除元素的相对性能，一般来说，应用中占主导地位的操作(执行的访问操作更多还是插入/删除更多)决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了）。</li>
</ul>
<blockquote>
<p>如果你不确定应该使用哪种容器，那么可以在程序中只使用 <code>vector</code>和<code>list</code>公共的操作：迭代器，而不是使用下标，以避免随机访问。这样，在必要时选择使用<code>vector</code>或<code>list</code>都很方便。</p>
</blockquote>
<h2 id="92-容器库概览"><a class="markdownIt-Anchor" href="#92-容器库概览"></a> 9.2 容器库概览</h2>
<blockquote>
<p>对于容器类型的操作，有些适用于所有容器；有些仅针对顺序或关联或无序；有些适用于个别容器。</p>
<p>本节介绍适用于所用容器的操作。</p>
<p>本章剩余部分则聚焦顺序容器的操作。</p>
</blockquote>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401260943509.png" alt="202401260943509" /></p>
<blockquote>
<p>虽然我们可以在容器中保存几乎任何类型，但某些容器操作对元素类型有其自己的特殊要求。我们可以为不支持特定操作需求的类型定义容器，但这种情况下就只能使用那些没有特殊要求的容器操作了。有如下示例。</p>
</blockquote>
<p>顺序容器的  接受容器大小的  构造函数版本，要求其中元素的类型必须能够被默认初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NoDefault：a Type With No Default Constructor</span></span><br><span class="line"><span class="function">vector&lt;NoDefault&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>,init)</span></span>;  <span class="comment">// 正确，提供了元素初始化器</span></span><br><span class="line"><span class="function">vector&lt;NoDefault&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;        <span class="comment">// 错误，需要元素初始化</span></span><br></pre></td></tr></table></figure>
<h3 id="921-迭代器"><a class="markdownIt-Anchor" href="#921-迭代器"></a> 9.2.1 迭代器</h3>
<p>在书P296~P299，介绍了容器的迭代器。书中首先说，与容器一样，迭代器有着公共的接口，不同容器的迭代器都执行着类似的操作。 <strong>并特别指出，<code>forward_list</code>的迭代器不支持<code>--</code> 。</strong></p>
<p>接着介绍了迭代器的左闭右开区间：<code>[ begin , end )</code>，以及利用该特性对容器中元素进行访问的操作。特别提到<strong>需要保证在合法的范围内解引用begin</strong>。</p>
<p>然后提到了类型成员，特别提到了<strong>反向迭代器</strong>，与正向迭代器相比，各种操作的含义都发生了颠倒。比如，<code>++</code>会得到上一个元素；<code>rbegin</code>和<code>rend</code>会获得尾元素和首元素之前位置的迭代器。<a href="#10.4.3-%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8">笔记10.4.3介绍</a></p>
<p>提到容器相关的类型别名在书16章介绍。</p>
<p>P298，书9.2.3节begin和end成员 中提到：</p>
<ul>
<li>
<p>迭代器中（begin，cbegin，rbegin，crbegin，end，cend，rend，crend），不以<code>c</code>开头的版本都是重载过的。</p>
</li>
<li>
<p>可以将一个普通版本的<code>iterator</code>转化为对应的<code>const_iterator</code>，反之则不然。</p>
</li>
<li>
<p>当<code>auto</code>与<code>begin</code>或<code>end</code>结合使用时，获得的选代器类型依赖于容器类型，与我们想要如何使用迭代器毫不相干。但以<code>c</code>开头的版本还是可以获得 <code>const_iterator</code> 的而不管容器的类型是什么。示例如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it7 = a.<span class="built_in">begin</span>();    <span class="comment">// 仅当a是const时，it7是const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it8 = a.<span class="built_in">cbegin</span>();    <span class="comment">// it8是const_iterator</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当不需要写访问时，应使用 <code>cbegin</code> 和<code>cend</code>。</p>
</blockquote>
</li>
</ul>
<p><a href="#10.4-%E5%86%8D%E6%8E%A2%E8%BF%AD%E4%BB%A3%E5%99%A8">笔记10.4 再探迭代器</a>将对迭代器的内容进行拓展。</p>
<h3 id="922-容器定义和初始化"><a class="markdownIt-Anchor" href="#922-容器定义和初始化"></a> 9.2.2 容器定义和初始化</h3>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401261224291.png" alt="image-20240126122404847" style="zoom:67%;" />
<h4 id="一-拷贝初始化"><a class="markdownIt-Anchor" href="#一-拷贝初始化"></a> 一、拷贝初始化</h4>
<p>将一个新容器创建为另一个容器的拷贝的方法有两种：</p>
<ul>
<li>
<p>直接拷贝整个容器</p>
<ul>
<li>
<p><strong>要求两个容器的类型及其元素类型必须匹配</strong></p>
</li>
<li>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; authors = &#123;<span class="string">&quot;Milton&quot;</span>,<span class="string">&quot;Shakespeare&quot;</span>,<span class="string">&quot;Austen&quot;</span>&#125;; <span class="comment">// 列表初始化</span></span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">list2</span><span class="params">(authors)</span></span>;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line">list&lt;string&gt; list2 = authors;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">list3</span><span class="params">(authors)</span></span>; <span class="comment">//错误，容器的类型不匹配</span></span><br><span class="line"><span class="function">list&lt;<span class="type">char</span> *&gt; <span class="title">list4</span><span class="params">(authors)</span></span>; <span class="comment">//错误，元素的类型不匹配</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>拷贝由  迭代器对  指定的元素范围</p>
<ul>
<li>
<p><strong>不要求容器的类型相同，也不要求元素的类型相同</strong>。只要能将要拷贝的元素转换为要初始化的容器的元素类型即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">const</span> <span class="type">char</span> *&gt; authors = &#123;<span class="string">&quot;Milton&quot;</span>,<span class="string">&quot;Shakespeare&quot;</span>,<span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line"><span class="function">forward_list&lt;string&gt; <span class="title">words</span><span class="params">(authors.begin(), authors.end())</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>array不适用</p>
</li>
</ul>
</li>
</ul>
<h4 id="二-列表初始化"><a class="markdownIt-Anchor" href="#二-列表初始化"></a> 二、列表初始化</h4>
<p>略</p>
<h4 id="三-顺序容器独有指定容器大小来初始化"><a class="markdownIt-Anchor" href="#三-顺序容器独有指定容器大小来初始化"></a> 三、顺序容器独有：指定容器大小来初始化</h4>
<ul>
<li>
<p>只有顺序容器的构造函数才接受大小参数，关联容器并不支持。</p>
</li>
<li>
<p>如果元素类型是内置类型或者是具有默认构造函数的类类型，可以只为构造函数提供一个容器大小参数。**如果元素类型没有默认构造函数，除了大小参数外，还必须指定一个显式的元素初始值。**举个例子，创建一个Test类，并将其默认构造函数删除，编译器报错如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">/*删除了默认构造函数，成员变量a无法执行默认初始化。</span></span><br><span class="line"><span class="comment">    * 当创建10个Test类型的vector的时候，找不到默认构造函数，编译器报错如下：</span></span><br><span class="line"><span class="comment">    * 错误  C2280  “Test::Test(void)”: 尝试引用已删除的函数    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;Test&gt; <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不指定大小的容器中，元素可以没有构造函数。如上面提到的拷贝初始化、列表初始化等。</p>
</li>
</ul>
<h4 id="四-array的固定大小"><a class="markdownIt-Anchor" href="#四-array的固定大小"></a> 四、array的固定大小</h4>
<ul>
<li>
<p><strong>大小也是类型的一部分</strong>，必须同时指定元素类型和大小。</p>
</li>
<li>
<p>和其他容器不同，默认构造的array是非空的。其包含了指定数量的被默认初始化后的元素（因此元素类型一定要有默认初始化）。</p>
</li>
<li>
<p>值得注意的是，虽然<strong>不能对内置数组类型进行拷贝或者对象赋值</strong>，但<strong>array没有该限制</strong>。<code>array&lt;&gt;</code>在拷贝赋值的时候，注意元素类型和数量要一样。内置数组拷贝赋值和<code>array</code>容器拷贝赋值对比如下：<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401261613618.png" alt="202401261613618" /></p>
</li>
</ul>
<h3 id="923-赋值和swap"><a class="markdownIt-Anchor" href="#923-赋值和swap"></a> 9.2.3 赋值和swap</h3>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401261224557.png" alt="image-20240126122444107" style="zoom:67%;" />
<ul>
<li>
<p>上表中列出的，<strong>与赋值有关的运算符</strong>可用于所有容器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1=c2;</span><br><span class="line">c1=&#123;a,b&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>由于右边运算对象的大小可能与左边运算对象的大小不同，<strong>因此array类型不支持assign，也不允许用花括号值列表进行赋值</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>,10&gt; a1 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">array&lt;<span class="type">int</span>,10&gt; a2 = &#123;<span class="number">0</span>&#125;; <span class="comment">// 10个0</span></span><br><span class="line"></span><br><span class="line">a2 = a1; <span class="comment">//正确</span></span><br><span class="line">a2 = &#123;<span class="number">0</span>&#125;; <span class="comment">//错误，不能用花括号值列表给array赋值</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assign()</code></p>
<ul>
<li>
<p>仅顺序容器</p>
</li>
<li>
<p>允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;string&gt; names;</span><br><span class="line">    vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; old_style;</span><br><span class="line">    </span><br><span class="line">    names = old_style; <span class="comment">// 错误,容器类型不匹配</span></span><br><span class="line">    </span><br><span class="line">    names.<span class="built_in">assign</span>(old_style.<span class="built_in">begin</span>(), old_style.<span class="built_in">end</span>()); <span class="comment">// 自动进行了类型转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>由于其旧元素被替代，因此传递给assign的迭代器不能指向调用assign的容器。以下是ChatGPT给出的例子，人为制造一个错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; originalList = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 试图在循环中使用迭代器来调用 assign</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = originalList.<span class="built_in">begin</span>(); it != originalList.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="comment">// 尝试在循环中调用 assign，传递迭代器指向原始列表</span></span><br><span class="line">        originalList.<span class="built_in">assign</span>(it, it);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里迭代器已经失效，因为 assign 改变了容器的大小</span></span><br><span class="line">        <span class="comment">// 这可能导致未定义的行为或程序崩溃</span></span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; std::endl;  <span class="comment">// 试图访问失效的迭代器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>swap()</code></p>
<ul>
<li>交换两个相同类型的容器内容。</li>
<li>除<code>array</code>外，<code>swap</code>不对任何元素进行拷贝、删除或插入操作，只交换两个容器的内部数据结构，因此速度非常快。而对<code>array</code>则会真正交换它们的元素。</li>
<li>除<code>string</code>外，指向容器的迭代器、引用和指针，在<code>swap</code>操作后都不会失效，仍指向<code>swap</code>操作前所指向的那些元素。但是这些元素已经属于不同的容器了。</li>
<li>统一使用非成员版本的<code>swap()</code>是个好习惯。</li>
</ul>
</li>
</ul>
<h3 id="924-容器大小"><a class="markdownIt-Anchor" href="#924-容器大小"></a> 9.2.4 容器大小</h3>
<ul>
<li><code>size()</code>：返回元素数目。<strong><code>forward_list</code>不支持<code>size()</code></strong></li>
<li><code>empty()</code>：容器是否为空</li>
<li><code>max_size()</code>：返回一个大于或等于该类型<strong>容器所能容纳的最大元素数</strong>的值。</li>
</ul>
<h3 id="925-关系运算"><a class="markdownIt-Anchor" href="#925-关系运算"></a> 9.2.5 关系运算</h3>
<ul>
<li>每个容器类型都支持相等运算符（==和!=）</li>
<li>除无序关联容器外都支持关系运算符（&gt; 、&gt;=、 &lt; 、&lt;=）</li>
<li>比较的对象必须有相同的容器类型和相同的元素类型。</li>
<li>用于比较的元素类型必须重载了（定义了）关系运算符</li>
<li>比较规则类似string，如下：<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401261757615.png" alt="image-20240126175704307" style="zoom:67%;" /></li>
</ul>
<h2 id="93-顺序容器的特有操作"><a class="markdownIt-Anchor" href="#93-顺序容器的特有操作"></a> 9.3 顺序容器的特有操作</h2>
<h3 id="931-插入元素"><a class="markdownIt-Anchor" href="#931-插入元素"></a> 9.3.1 插入元素</h3>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401261226532.png" alt="202401261226532" style="zoom: 67%;" />
<h4 id="一-push_back"><a class="markdownIt-Anchor" href="#一-push_back"></a> 一、push_back</h4>
<ul>
<li>
<p>除<code>array</code>和<code>forward_list</code>外，每个顺序容器（包括string）都支持<code>push_back</code>。</p>
</li>
<li>
<p>push_back是将对象<strong>拷贝</strong>，</p>
<blockquote>
<p>关键概念:容器元素是拷贝<br />
当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。</p>
</blockquote>
</li>
</ul>
<h4 id="二-push_front"><a class="markdownIt-Anchor" href="#二-push_front"></a> 二、push_front</h4>
<ul>
<li><code>list</code>、<code>forward_list</code>、<code>deque</code>还支持<code>push_front</code></li>
</ul>
<h4 id="三-insert"><a class="markdownIt-Anchor" href="#三-insert"></a> 三、insert</h4>
<ul>
<li>
<p><code>vector</code>、<code>deque</code>、<code>list</code>、<code>string</code>都支持<code>insert</code>。（注：<code>forward_list</code>为特殊版本，于forward_list专题介绍）</p>
</li>
<li>
<p>每个insert都接受一个迭代器作为其第一参数，表示将某个（些）额外的元素添加到这个迭代器所指向的元素之<strong>前</strong>。 &lt;–注意，是之前插入</p>
</li>
<li>
<p>虽然某些容器（如vector）不支持push_front 操作，但它们对于 insert 操作并无类似的限制（插入开始位置）。因此我们可以将元素插入到容器的开始位置，而不必担心容器是否支持push_front :</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; vec_str = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// vector不支持push_front,但是可以通过insert插入新的首元素，但是可能很耗时</span></span><br><span class="line">    vec_str.<span class="built_in">insert</span>(vec_str.<span class="built_in">begin</span>(), <span class="string">&quot;hello&quot;</span>);  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;word : vec_str)</span><br><span class="line">        cout&lt;&lt;word&lt;&lt;<span class="string">&quot; &quot;</span>;  <span class="comment">// hello a b c</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>一、插入特定元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">insert</span>(p,t);    <span class="comment">//对容器c，向p位置之前插入元素t</span></span><br></pre></td></tr></table></figure>
<p>二、插入范围内元素</p>
<ul>
<li>
<p><code>c.insert(p,n,t)</code> ：对容器c，向p位置之前插入n个元素t</p>
</li>
<li>
<p><code>c.insert(p,b,e)</code>：对容器c，向p位置之前插入一对迭代器，<strong>特别说明，这对迭代器不能指向  调用insert的容器对象（此处为c）  的元素</strong></p>
</li>
<li>
<p><code>c.insert(p,il)</code>：对容器c，向p位置之前插入初始化列表il</p>
</li>
</ul>
<p>本节的三种插入方式，返回<strong>指向第一个新加入元素的迭代器</strong>。如果插入为空，则将insert的第一个参数返回。</p>
<p>通过使用该返回值，可以在容器中一个特定的位置反复插入元素。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;string&gt; lst;</span><br><span class="line">    string word;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> iter = lst.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;word)</span><br><span class="line">        <span class="comment">//等价于调用push_front</span></span><br><span class="line">        iter = lst.<span class="built_in">insert</span>(iter,word);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三、</p>
<p><code>emplace_front</code>、<code>emplace</code>、<code>emplace_back</code>与<code>push_front</code>、<code>insert</code>、<code>push_back</code>对应。</p>
<p>push_xxx和insert，将元素类型的<strong>对象拷贝到容器</strong>中；</p>
<p>emplace_xxx则是<strong>将参数传递给元素类型的构造函数，以在容器管理的内存空间中直接构造元素</strong>。传递给emplace函数的参数必须元素类型的构造函数相匹配。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, Sales_data sd);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> uint = <span class="type">unsigned</span> ;</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(string isbn, uint cnt, <span class="type">double</span> price)</span><br><span class="line">            :<span class="built_in">m_isbn</span>(isbn),<span class="built_in">m_cnt</span>(cnt),<span class="built_in">m_price</span>(price)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_isbn;</span><br><span class="line">    uint m_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> m_price = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, Sales_data sd)&#123;</span><br><span class="line">    os&lt;&lt;sd.m_isbn&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;sd.m_cnt&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;sd.m_price;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Sales_data&gt; vec;</span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="string">&quot;123&quot;</span>,<span class="number">25</span>,<span class="number">15.99</span>);<span class="comment">//直接在容器的内存空间中创建对象</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">Sales_data</span>(<span class="string">&quot;456&quot;</span>,<span class="number">15</span>,<span class="number">36.2</span>)); <span class="comment">// 创建元素的临时对象，并将其拷贝到容器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; sales_data : vec)</span><br><span class="line">        cout&lt;&lt;sales_data&lt;&lt;endl;</span><br><span class="line">        <span class="comment">/* 终端输出：</span></span><br><span class="line"><span class="comment">        123 25 15.99</span></span><br><span class="line"><span class="comment">        456 15 36.2</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="932-访问元素"><a class="markdownIt-Anchor" href="#932-访问元素"></a> 9.3.2 访问元素</h3>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401271500480.png" alt="image-20240127150051109" /></p>
<ul>
<li><code>at</code>和下标运算符只使用于<code>string、vector、deque、array</code></li>
<li><code>back</code>不适用<code>forward_list</code></li>
<li><code>back()</code> 、<code>front()</code>、 <code>at</code> 和<code>下标运算符</code>返回的都是<strong>引用</strong>。</li>
<li><code>at</code>相较于下标运算符较安全，越界抛出<code>out_of_range</code>的异常。</li>
</ul>
<p>因为返回的是引用，可通过访问元素的函数修改容器内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    vec.<span class="built_in">front</span>() = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> &amp;v1 = vec.<span class="built_in">back</span>();</span><br><span class="line">    v1 = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//理解auto的规则（笔记2.6.2）：</span></span><br><span class="line">    <span class="comment">// auto以引用对象的类型作为auto的类型</span></span><br><span class="line">    <span class="keyword">auto</span> v2 = vec.<span class="built_in">back</span>();    <span class="comment">//不是引用，是一个拷贝</span></span><br><span class="line">    v2 = <span class="number">0</span>; <span class="comment">//未能改变vec中的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; num : vec)</span><br><span class="line">        cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="933-删除元素"><a class="markdownIt-Anchor" href="#933-删除元素"></a> 9.3.3 删除元素</h3>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401271525056.png" alt="image-20240127152516619" /></p>
<ul>
<li>
<p><code>pop_front()</code>和<code>pop_back()</code>返回void，如果还需要弹出的元素值，要在弹出前保存。</p>
</li>
<li>
<p><code>erase(p)</code>返回p的下一个元素的迭代器</p>
</li>
<li>
<p><code>erase(b,e)</code>e指向<strong>要删除的最后一个元素的下一个位置</strong>，结束后b==e</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">vec.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line">vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>补充：forward_list没有pop_back()，如何删除尾元素？</p>
<p>在C++中，<code>std::forward_list</code>是单向链表，由于单向链表的特性，删除最后一个元素需要一些额外的考虑，因为它没有直接提供像<code>pop_back</code>这样的成员函数，而是需要从头开始遍历链表找到倒数第二个元素，然后将其<code>next</code>指针置为空。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* forward_list删除尾元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; myList = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果列表为空，无需进行任何操作</span></span><br><span class="line">    <span class="keyword">if</span> (!myList.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> current = myList.<span class="built_in">before_begin</span>(); <span class="comment">// 迭代器指向头之前的位置</span></span><br><span class="line">        <span class="keyword">auto</span> last = myList.<span class="built_in">begin</span>(); <span class="comment">// 迭代器指向头</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历找到倒数第二个元素</span></span><br><span class="line">        <span class="keyword">while</span> (std::<span class="built_in">next</span>(last) != myList.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            ++current;</span><br><span class="line">            ++last;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除最后一个元素</span></span><br><span class="line">        myList.<span class="built_in">erase_after</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出删除后的列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; value : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::next</code>是C++标准库中的一个函数模板，用于<strong>返回给定迭代器的下一个迭代器</strong>。该函数的定义位于头文件 <code>&lt;iterator&gt;</code> 中。下面是它的基本语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt &gt;</span></span><br><span class="line"><span class="function">InputIt <span class="title">next</span><span class="params">( InputIt it, <span class="keyword">typename</span> std::iterator_traits&lt;InputIt&gt;::difference_type n = <span class="number">1</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>it</code>：要获取下一个迭代器的起始迭代器。</li>
<li><code>n</code>：要移动的步数，默认为1。<br />
<code>std::next</code>在迭代器上执行递增操作，允许你在容器中向前移动指定数量的位置。这对于在算法中进行迭代器操作时非常有用。<br />
以下是一个简单的示例，演示如何使用<code>std::next</code>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::next 将迭代器向前移动两个位置</span></span><br><span class="line">    <span class="keyword">auto</span> advancedIt = std::<span class="built_in">next</span>(it, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original iterator value: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Advanced iterator value: &quot;</span> &lt;&lt; *advancedIt &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>std::next</code>被用来将迭代器 <code>it</code> 向前移动两个位置，产生一个新的迭代器 <code>advancedIt</code>。这样，你可以在容器中灵活地移动迭代器，而不必手动进行逐步增加。<br />
如果有其他问题或需要更详细的解释，请随时提出。</p>
<h3 id="934-改变容器大小"><a class="markdownIt-Anchor" href="#934-改变容器大小"></a> 9.3.4 改变容器大小</h3>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401271558280.png" alt="image-20240127155838890" /></p>
<ul>
<li>
<p>如果当前大小大于所要求的大小，容器后部的元素会被删除:如果当前大小小于新大小，会将新元素添加到容器后部:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">ilist</span><span class="params">(<span class="number">10</span>,<span class="number">42</span>)</span></span>;     <span class="comment">//10个int:每个的值都是42</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">15</span>);           <span class="comment">//将5个值为0的元素添加到 ilist 的末尾</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">25</span>,<span class="number">-1</span>);        <span class="comment">//将10个值为-1的元素添加到 ilist的末尾</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">5</span>);            <span class="comment">//从ilist末尾删除20个元素</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>resize 操作接受一个可选的元素值参数，用来初始化添加到容器中的元素。如果调用者未提供此参数，新元素进行值初始化。</p>
</li>
<li>
<p>如果容器保存的是<strong>类类型元素</strong>，且 resize 向容器添加新元素，则我们<strong>必须提供初始值，或者元素类型必须提供一个默认构造函数</strong>。</p>
</li>
</ul>
<h3 id="935-容器操作可能使迭代器失效"><a class="markdownIt-Anchor" href="#935-容器操作可能使迭代器失效"></a> 9.3.5 容器操作可能使迭代器失效</h3>
<h4 id="一-添加元素"><a class="markdownIt-Anchor" href="#一-添加元素"></a> 一、添加元素</h4>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401271611838.png" alt="image-20240127161124456" style="zoom:67%;" />
<h4 id="二-删除元素"><a class="markdownIt-Anchor" href="#二-删除元素"></a> 二、删除元素</h4>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401271615161.png" alt="image-20240127161526765" style="zoom:67%;" />
<h4 id="三-因此我们需要管理迭代器"><a class="markdownIt-Anchor" href="#三-因此我们需要管理迭代器"></a> 三、因此，我们需要管理迭代器</h4>
<blockquote>
<p>当你使用迭代器（或指向容器元素的引用或指针）时，最小化要求迭代器必须保持有效的程序片段是一个好的方法。</p>
<p>由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确地重新定位迭代器。这个建议对 vector、string和 deque尤为重要。</p>
</blockquote>
<p>有两个要求：</p>
<ul>
<li>
<p>添加/删除vector、string 或deque 元素的循环程序必须考虑迭代器、引用和指针可能失效的问题：</p>
<blockquote>
<p><strong>每次循环都更新迭代器、引用或指针</strong>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加/删除vector、string 或deque 元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。</span></span><br><span class="line"><span class="comment"> * 程序必须保证每个循环步中都更新迭代器、引用或指针。</span></span><br><span class="line"><span class="comment"> * 如果循环中调用的是insert()或erase()，那么更新迭代器很容易，因为这些操作都返回迭代器，我们可以用来更新:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(it!=vec.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="comment">//注意等号左侧，每步循环都更新了迭代器</span></span><br><span class="line">        <span class="keyword">if</span>(*it % <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//奇数</span></span><br><span class="line">            it = vec.<span class="built_in">insert</span>(it, *it);</span><br><span class="line">            it += <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 向前移动迭代器，跳过当前元素及插入到它之前的元素</span></span><br><span class="line">            <span class="comment">// insert()在it的前面插入新元素，并返回指向新插入元素的迭代器，所以+2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//偶数</span></span><br><span class="line">            it = vec.<span class="built_in">erase</span>(it);</span><br><span class="line">            <span class="comment">// 不必向前移动迭代器，erase()使it指向删除元素的下一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;num:vec)</span><br><span class="line">        cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>;  <span class="comment">// 1 1 3 3 5 5 7 7 9 9</span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>不要保存end返回的迭代器</strong></p>
<p>当添加/删除vector、string的元素，或在deque中首元素之外的任何位置添加/删除元素，原来的end返回的迭代器总是失效。</p>
<p>因此，如果在一个循环中插入/删除deque、string、vector中的元素，不要缓存end返回的迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 想要往每两个数中间插入42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> be = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//    auto en = vec.end(); /*insert后，end迭代器失效会引发死循环*/</span></span><br><span class="line"><span class="comment">//    while(be != en)&#123;  /*循环中，不要缓存尾后迭代器*/</span></span><br><span class="line">    <span class="keyword">while</span>(be != vec.<span class="built_in">end</span>())&#123; <span class="comment">/*应该在每次插入操作后重新调用end()*/</span></span><br><span class="line">        ++be;</span><br><span class="line">        be = vec.<span class="built_in">insert</span>(be,<span class="number">42</span>);</span><br><span class="line">        ++be;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;num:vec)</span><br><span class="line">        cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// 0 42 1 42 2 42 3 42 4 42 5 42 6 42 7 42 8 42 9 42</span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="94-vector对象是如何增长的"><a class="markdownIt-Anchor" href="#94-vector对象是如何增长的"></a> 9.4 vector对象是如何增长的？</h2>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401280912213.png" alt="image-20240128091159836" /></p>
<ul>
<li>resize和reserve
<ul>
<li>resize改变容器中元素的数目，而不是容器的容量，如不能减少预留的内存空间。</li>
<li>reserve仅影响vector/string预先分配多大的内存，并不改变容器中元素的数目</li>
</ul>
</li>
<li>capacity和size
<ul>
<li>size已经保存的元素数目</li>
<li>capacity表示在不分配新的内存的前提下，容器最多保存多少元素。</li>
</ul>
</li>
</ul>
<p>示例</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401280928465.png" alt="image-20240128092852165" /></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size = &quot;</span>&lt;&lt;ivec.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; | &quot;</span>&lt;&lt;<span class="string">&quot;capacity = &quot;</span>&lt;&lt;ivec.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// size = 0 | capacity = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; ++i)</span><br><span class="line">        ivec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size = &quot;</span>&lt;&lt;ivec.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; | &quot;</span>&lt;&lt;<span class="string">&quot;capacity = &quot;</span>&lt;&lt;ivec.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// size = 24 | capacity = 32</span></span><br><span class="line">    <span class="comment">// 存了24个元素，分配了可保存32个元素内存</span></span><br><span class="line"></span><br><span class="line">    ivec.<span class="built_in">reserve</span>(<span class="number">50</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size = &quot;</span>&lt;&lt;ivec.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; | &quot;</span>&lt;&lt;<span class="string">&quot;capacity = &quot;</span>&lt;&lt;ivec.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// size = 24 | capacity = 50、</span></span><br><span class="line">    <span class="comment">// reserve()将内存括展到了50，ivec内元素个数没变</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(ivec.<span class="built_in">size</span>()!=ivec.<span class="built_in">capacity</span>())</span><br><span class="line">        ivec.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="comment">//写满预分配的内存</span></span><br><span class="line">    ivec.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">// 在添加1位</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size = &quot;</span>&lt;&lt;ivec.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; | &quot;</span>&lt;&lt;<span class="string">&quot;capacity = &quot;</span>&lt;&lt;ivec.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// size = 51 | capacity = 100</span></span><br><span class="line">    <span class="comment">// 超出预分配的内存，ivec的内存两倍括展</span></span><br><span class="line"></span><br><span class="line">    ivec.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size = &quot;</span>&lt;&lt;ivec.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; | &quot;</span>&lt;&lt;<span class="string">&quot;capacity = &quot;</span>&lt;&lt;ivec.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// size = 51 | capacity = 51</span></span><br><span class="line">    <span class="comment">// 请求退还没有用过的内存（不一定采纳）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="95-forward_list专题"><a class="markdownIt-Anchor" href="#95-forward_list专题"></a> 9.5 forward_list专题</h2>
<p>原文《特殊的forward_list》操作</p>
<blockquote>
<p>当添加或删除一个元素时，删除或添加的元素之前的那个元素的后继会发生改变。为了添加或删除一个元素，我们需要访问其前驱，以便改变前驱的链接。但是，forward_list 是单向链表。在一个单向链表中，没有简单的方法来获取一个元素的前驱。</p>
<p>出于这个原因，在一个 forward list 中添加或删除元素的操作是通过改变给定元素之后的元素来完成的。这样，我们总是可以访问到被添加或删除操作所影响的元素。由于这些操作与其他容器上的操作的实现方式不同，forward_list 并未定义insert、emplace和erase，而是定义了名为insert_after、emplace_after和erase_after 的操作(参见表 9.8)。</p>
<p>例如，在我们的例子中，为了删除 elem3，应该用指向elem2的迭代器调用 <code>erase_after</code>。为了支持这些操作，forward_list还定义了<code>before_begin</code>，它返回一个<strong>首前迭代器</strong>。这个选代器允许我们在链表首元素之前并不存在的元素“之后”添加或删除元素(亦即在链表首元素之前添加删除元素)。</p>
</blockquote>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401272203790.png" alt="image-20240127220317328" /></p>
<p>示例：</p>
<p><strong>当向forward_list中添加或删除元素时，我们必须关注两个选代器：一个指向我们要处理的元素，另一个指向其前驱。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 知识点：</span></span><br><span class="line"><span class="comment"> * 当向forward_list中添加或删除元素时，我们必须关注两个选代器：</span></span><br><span class="line"><span class="comment"> * 一个指向我们要处理的元素，另一个指向其前驱。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例：删除forward_list中的奇数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    forward_list&lt;<span class="type">int</span>&gt; flist = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> prev = flist.<span class="built_in">before_begin</span>();<span class="comment">//首前迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> curr = flist.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(curr != flist.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(*curr%<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//奇数</span></span><br><span class="line">            curr = flist.<span class="built_in">erase_after</span>(prev);<span class="comment">//返回删除的元素的下一个位置的迭代器，并用其更新curr</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            prev = curr;</span><br><span class="line">            ++curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;num:flist)</span><br><span class="line">        cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>;  <span class="comment">//0 2 4 6 8</span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="96-string专题"><a class="markdownIt-Anchor" href="#96-string专题"></a> 9.6 string专题</h2>
<p>书P320《9.5 额外的string操作》</p>
<p>除了顺序容器的共同操作外，string还提供了一些额外的操作，如所述。</p>
<h3 id="961-string操作函数汇总"><a class="markdownIt-Anchor" href="#961-string操作函数汇总"></a> 9.6.1 string操作函数汇总</h3>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281520448.png" alt="202401281520448" style="zoom:67%;" />
<h3 id="962-构造string的子序列"><a class="markdownIt-Anchor" href="#962-构造string的子序列"></a> 9.6.2 构造string的子序列</h3>
<p>除了在[笔记3.2.1](#3.2.1 初始化)已经介绍过的构造函数方法，以及与其他顺序容器相同的构造函数外，string还支持另外3个构造函数。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281553783.png" alt="image-20240128155347371" /></p>
<p>当我们从一个const char*创建string时</p>
<ul>
<li>通常，指针指向的数组必须以空字符结尾，<strong>拷贝操作遇到空字符时停止</strong>。</li>
<li>如果我们还传递给构造函数一个计数值，数组就不必以空字符结尾。</li>
<li>如果我们未传递计数值且数组也未以空字符结尾，或者给定计数值大于数组大小，则构造函数的行为是未定义的。</li>
</ul>
<p>因此，const char *数组最好以空字符结尾。</p>
<p>当从string拷贝：</p>
<ul>
<li>开始位置要小于或等于size</li>
<li>计数值再大，最多拷贝到string结束的位置</li>
</ul>
<p>子字符串操作：</p>
<ul>
<li><code>str.substr(pos = 0, n = str.size() -pos);</code></li>
</ul>
<h3 id="962-改变string的其他方法"><a class="markdownIt-Anchor" href="#962-改变string的其他方法"></a> 9.6.2 改变string的其他方法</h3>
<p>联想：[3.4.4 与旧代码接口—c风格字符串](#3.4.4 与旧代码接口)</p>
<p>string类型支持顺序容器的赋值运算符以及assign、insert 和erase操作(表9.4；表9.7)外，还定义了额外的insert和erase版本。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281619598.png" alt="202401281619598" style="zoom:67%;" />
<ul>
<li>
<p>insert、erase、assign示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStr</span><span class="params">(string &amp;str)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;<span class="string">&quot; | size = &quot;</span>&lt;&lt;str.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;abcdefghij&quot;</span>;</span><br><span class="line">    <span class="built_in">printStr</span>(s);  <span class="comment">// abcdefghij | size = 10</span></span><br><span class="line"></span><br><span class="line">    string s1 = s;</span><br><span class="line">    s1.<span class="built_in">insert</span>(s1.<span class="built_in">size</span>(), <span class="number">5</span>, <span class="string">&#x27;!&#x27;</span>); <span class="comment">//末尾插入5个感叹号</span></span><br><span class="line">    <span class="built_in">printStr</span>(s1);  <span class="comment">// abcdefghij!!!!! | size = 15</span></span><br><span class="line"></span><br><span class="line">    string s2 = s;</span><br><span class="line">    s2.<span class="built_in">erase</span>(s.<span class="built_in">size</span>()<span class="number">-5</span><span class="comment">/*, 5*/</span>); <span class="comment">// 从s的倒数5个位置开始，删除最后5个字符</span></span><br><span class="line">    <span class="built_in">printStr</span>(s2); <span class="comment">// abcde | size = 5</span></span><br><span class="line"></span><br><span class="line">    string s3 = s;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *cp = <span class="string">&quot;stately, plump buck&quot;</span>;</span><br><span class="line">    s3.<span class="built_in">assign</span>(cp,<span class="number">2</span>); <span class="comment">// 用cp的前2个字符覆盖整个s</span></span><br><span class="line">    <span class="built_in">printStr</span>(s3); <span class="comment">// st | size = 2</span></span><br><span class="line"></span><br><span class="line">    string s4 = s;</span><br><span class="line">    s4.<span class="built_in">insert</span>(s.<span class="built_in">size</span>(), cp+<span class="number">7</span>);</span><br><span class="line">    <span class="comment">// 从cp向后移动7位所指向的元素开始，到cp结束之间的所有字符，插入到s的末尾(s.size())</span></span><br><span class="line">    <span class="built_in">printStr</span>(s4);  <span class="comment">// abcdefghij, plump buck | size = 22</span></span><br><span class="line"></span><br><span class="line">    string s5 = s;</span><br><span class="line">    string s5_ = <span class="string">&quot;,xyz&quot;</span>;</span><br><span class="line">    s5.<span class="built_in">insert</span>(<span class="number">0</span>,s5_); <span class="comment">//在s5的位置0处插入s5_</span></span><br><span class="line">    <span class="built_in">printStr</span>(s5);  <span class="comment">// ,xyzabcdefghij | size = 14</span></span><br><span class="line"></span><br><span class="line">    string s6 = s;</span><br><span class="line">    s6.<span class="built_in">insert</span>(<span class="number">0</span>,s5_,<span class="number">0</span>,s5_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 在s6[0]之前插入s5_中s5_[0]开始的s5_.size()个字符</span></span><br><span class="line">    <span class="built_in">printStr</span>(s6); <span class="comment">//,xyzabcdefghij | size = 14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>append、replace示例</p>
<ul>
<li><code>append(str)</code>：末尾追加str</li>
<li><code>replace(开始位置pos，删除几个元素n，在当前位置添加字符串str)</code> = erase+insert；<strong>删除的字符数n可以不等于添加的字符数量str</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStr</span><span class="params">(string &amp;str)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;<span class="string">&quot; | size = &quot;</span>&lt;&lt;str.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s&#123;<span class="string">&quot;c++ primer&quot;</span>&#125;;</span><br><span class="line">    s.<span class="built_in">append</span>(<span class="string">&quot; 4th Ed.&quot;</span>);</span><br><span class="line">    <span class="built_in">printStr</span>(s); <span class="comment">// c++ primer 4th Ed. | size = 18</span></span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">replace</span>(<span class="number">11</span>,<span class="number">3</span>,<span class="string">&quot;5th&quot;</span>);</span><br><span class="line">    <span class="built_in">printStr</span>(s);  <span class="comment">//c++ primer 5th Ed. | size = 18</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//replace时，删除的字符数和添加的字符数可以不相等</span></span><br><span class="line">    s.<span class="built_in">replace</span>(<span class="number">11</span>,<span class="number">3</span>,<span class="string">&quot;Fifth&quot;</span>);<span class="comment">// 删除3个字符，但增加5个字符</span></span><br><span class="line">    <span class="built_in">printStr</span>(s);  <span class="comment">// c++ primer Fifth Ed. | size = 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="963-string搜索操作"><a class="markdownIt-Anchor" href="#963-string搜索操作"></a> 9.6.3 string搜索操作</h3>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401282149718.png" alt="202401282149718" style="zoom:67%;" />
<ul>
<li>
<p>string类提供了6个搜索函数，每个函数都有4个重载版本。</p>
</li>
<li>
<p>搜索操作返回<code>string::size_type</code>值，表示匹配发生位置的下标。若搜索失败，返回<code>string::npos</code>的static成员。标准库将npos定义为const string::size_type类型，并初始化为-1。又由于npos是unsigned类型，此初始值意味着npos等于任何string最大的可能大小。</p>
</li>
<li>
<p>搜索操作大小写敏感</p>
</li>
<li>
<p>str.find_first_of(args)：返回str中第一个出现在args中的元素的下标</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str&#123;<span class="string">&quot;pi=3.14&quot;</span>&#125;;</span><br><span class="line">string nums&#123;<span class="string">&quot;+-.0123456789&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> pos = str.<span class="built_in">find_first_of</span>(nums);</span><br><span class="line"><span class="comment">//str中第一个出现在nums的元素的下标（即“pi=3.14”的‘3’的下标）</span></span><br><span class="line">cout&lt;&lt;pos&lt;&lt;endl;  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>find_last_of、find_first_not_of、find_last_not_of</p>
</li>
<li>
<p>逆向搜索：有从左向右搜索，也有从右向左搜索的函数</p>
</li>
<li>
<p>一个常见的设计模式：<br />
通过指定   从哪里搜索的可选参数   在字符串中循环地搜索   子字符串出现的所有位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">string::size_type pos=<span class="number">0</span>;</span><br><span class="line">string name&#123;<span class="string">&quot;bananabananabanana&quot;</span>&#125;;</span><br><span class="line">string nums&#123;<span class="string">&quot;hb&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>((pos=name.<span class="built_in">find_first_of</span>(nums,pos))!=string::npos)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;found number at idx: &quot;</span>&lt;&lt;pos</span><br><span class="line">        &lt;&lt;<span class="string">&quot;element is &quot;</span>&lt;&lt; name[pos]&lt;&lt;endl;</span><br><span class="line">    ++pos;  <span class="comment">//&lt;-- 必须，否则死循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">found number at idx: 0element is b</span></span><br><span class="line"><span class="comment">found number at idx: 6element is b</span></span><br><span class="line"><span class="comment">found number at idx: 12element is b</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="964-compare"><a class="markdownIt-Anchor" href="#964-compare"></a> 9.6.4 compare</h3>
<p>见笔记9.6.1汇总 表9.15</p>
<h3 id="965-数值转换"><a class="markdownIt-Anchor" href="#965-数值转换"></a> 9.6.5 数值转换</h3>
<p>书P327~P328</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281801235.png" alt="202401281801235" style="zoom:67%;" />
<ul>
<li>
<p>要转换为数值的string中，第一个空白字符必须是数值可能出现的字符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str&#123;<span class="string">&quot;pi = 3.14&quot;</span>&#125;;</span><br><span class="line"><span class="type">double</span> val = <span class="built_in">stod</span>(str.<span class="built_in">substr</span>(str.<span class="built_in">find_first_of</span>(<span class="string">&quot;+-.0123456789&quot;</span>)));</span><br><span class="line">cout&lt;&lt;val&lt;&lt;endl; <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果string不能转换为数值，表9.6中函数抛出<code>invalid_argument</code>异常</li>
<li>如果转换得到的数值无法用任何类型表示，抛出<code>out_of_range</code></li>
</ul>
</li>
<li>
<p>查找原则</p>
<blockquote>
<p>string 参数中<strong>第一个非空白符必须是符号(+ 或 -)或数字</strong>。它可以以0x 或0X开头来表示十六进制数。</p>
<p>对那些将字符串转换为浮点值的函数，string 参数也可以以小数点 (.)开头，并可以包含 e 或 E 来表示指数部分。</p>
<p>对于那些将字符串转换为整型值的函数，根据基数不同，string 参数可以包含字母字符，对应大于数字9的数。</p>
</blockquote>
</li>
</ul>
<h2 id="97-适配器"><a class="markdownIt-Anchor" href="#97-适配器"></a> 9.7  适配器</h2>
<p>（adaptor）</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281035812.png" alt="image-20240128103539423" /></p>
<h3 id="971-什么是适配器"><a class="markdownIt-Anchor" href="#971-什么是适配器"></a> 9.7.1 什么是适配器</h3>
<h3 id="972-定义一个适配器"><a class="markdownIt-Anchor" href="#972-定义一个适配器"></a> 9.7.2 定义一个适配器</h3>
<h4 id="一-每个适配器都定义两个构造函数"><a class="markdownIt-Anchor" href="#一-每个适配器都定义两个构造函数"></a> 一、每个适配器都定义两个构造函数</h4>
<ul>
<li>
<p><code>A a;</code>默认构造函数创建一个空对象</p>
</li>
<li>
<p><code>A a(c)</code>接受一个容器c的构造函数 ，<strong>拷贝容器c的元素来初始化适配器</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; deq;</span><br><span class="line">    <span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">stk</span><span class="params">(deq)</span></span>; <span class="comment">// 拷贝deq的元素到stk，以初始化stk</span></span><br><span class="line">    <span class="comment">// 其实隐藏了默认容器类型，等价于</span></span><br><span class="line">    stack&lt;<span class="type">int</span>,deque&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">stk</span>(deq);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="二-重载默认容器类型"><a class="markdownIt-Anchor" href="#二-重载默认容器类型"></a> 二、重载默认容器类型</h4>
<p>默认容器类型：</p>
<ul>
<li>stack和queue基于deque实现</li>
<li>priority_queue基于vector实现</li>
</ul>
<p>我们可以在创建一个适配器时，将一个命名的顺序容器作为第二个  类型  参数，来重载默认容器类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在vector的基础上实现空栈</span></span><br><span class="line">    stack&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; stk1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在vector的基础上实现，初始化时保存vec的拷贝</span></span><br><span class="line">    stack&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">stk2</span>(vec);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三-重载默认容器类型的限制"><a class="markdownIt-Anchor" href="#三-重载默认容器类型的限制"></a> 三、重载默认容器类型的限制</h4>
<p><code>stack</code>：可用于除了array和forward_list之外的任何容器类型（deque、list、vector）</p>
<p><code>queue</code>：只能用于list和deque之上，不能用于vector</p>
<p><code>priority_queue</code>只能用于vector和deque，不能用于list</p>
<h3 id="973-栈适配器"><a class="markdownIt-Anchor" href="#973-栈适配器"></a> 9.7.3 栈适配器</h3>
<p>参考资料</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/stack-class?view=msvc-170">stack类 —— Microsoft</a></li>
</ul>
<p>stack定义在stack头文件中</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281102757.png" alt="image-20240128110200371" /></p>
<p>用法示例（书P330）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        stk.<span class="built_in">push</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(i));</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然每个适配器都是基于底层容器的操作定义自己的操作，但我们只可以使用适配器的操作，而不可使用底层容器的操作。如，虽然stack基于deque实现，stack.push()基于deque.push_back()，但我们不能在一个stack上调用push_back()</p>
<h3 id="974-队列适配器"><a class="markdownIt-Anchor" href="#974-队列适配器"></a> 9.7.4 队列适配器</h3>
<p>参考资料</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/queue-class?view=msvc-170">queue类 —— Microsoft</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/priority-queue-class?view=msvc-170">priority_queue类 —— Microsoft</a></li>
</ul>
<p>queue和priority_queue定义在queue头文件中</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281122221.png" alt="202401281122221" /></p>
<p>queue（FIFO）</p>
<p>priority_queue:</p>
<blockquote>
<p>priority_queue 允许我们为队列中的元素建立优先级。新加入的元素会排在所有优先级比它低的已有元素之前。</p>
<p>饭店按照客人预定时间而不是到来时间的早晚来为他们安排座位，就是一个优先队列的例子。</p>
<p>默认情况下，标准库在元素类型上使用<code>&lt;</code>运算符来确定相对优先级。</p>
</blockquote>
<hr />
<p>对于表9.19有个疑问：表中第二行说，queue也可以用list或vector实现，是不是有有误？<br />
在《笔记9.6.2三、重载默认容器类型的限制（书P329最下面的一大段话）》中提到：<code>queue</code>：只能用于list和deque之上，不能用于vector。<br />
两者是不是冲突了？</p>
<p>不知道两句换描述的事物是不是不一样，但照我理解，两句话在说一个东西。</p>
<p>实际测试：</p>
<p>1.正确执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; deq&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    queue&lt;<span class="type">int</span>,deque&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">que1</span>(deq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!que1.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;que1.<span class="built_in">front</span>()&lt;&lt;endl;</span><br><span class="line">        que1.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.正常编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">que1</span>(vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.编译器报错：</p>
<blockquote>
<p>In template: no member named ‘pop_front’ in ‘std::vector<int>’</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">que1</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!que1.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;que1.<span class="built_in">front</span>()&lt;&lt;endl;</span><br><span class="line">        que1.<span class="built_in">pop</span>();   <span class="comment">// &lt;--在此处报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我认为，确实queue能用vector构造，但是当碰到处理（增删）首元素的情况，就会出错。所以不要用vector构造queue。</p>
<hr />
<h2 id="98-特例汇总"><a class="markdownIt-Anchor" href="#98-特例汇总"></a> 9.8 特例汇总</h2>
<h3 id="981-forward_list"><a class="markdownIt-Anchor" href="#981-forward_list"></a> 9.8.1 forward_list&lt;&gt;</h3>
<ul>
<li>没有<code>size</code>操作</li>
<li>不支持反向迭代器</li>
<li>不支持<code>--</code></li>
<li>不支持适配器（因为所有适配器都要求容器有添加、删除和访问尾元素的能力）</li>
</ul>
<p>单向链表对尾元素的处理很耗时，所以一般不支持<code>xxx_back()</code>操作，而是<code>xxx_after()</code>：</p>
<ul>
<li>不支持<code>push_back</code>和<code>emplace_back</code>，有自己专有的<code>insert</code>和<code>emplace</code></li>
<li>不支持<code>back()</code>获取尾元素的引用。</li>
<li>不支持<code>pop_back()</code></li>
<li>forward_list 并未定义insert、emplace和erase，而是定义了名为<code>insert_after</code>、<code>emplace_after</code>和<code>erase_after</code>的操作（见forward_list专题）</li>
</ul>
<h3 id="982-string"><a class="markdownIt-Anchor" href="#982-string"></a> 9.8.2 string</h3>
<ul>
<li>不支持<code>C c(n)</code>构造</li>
<li><code>swap</code>会导致<code>string</code>的迭代器、指针和引用失效。而其他容器不会。</li>
</ul>
<h3 id="983-array"><a class="markdownIt-Anchor" href="#983-array"></a> 9.8.3 array&lt;&gt;</h3>
<p>一、构造</p>
<ul>
<li><code>C c</code>默认构造的时候，c中的元素也会通过默认构造初始化。如果c是其他容器时，则为空。</li>
<li>不支持通过<code>C c(n,t)</code>、<code>C c(n)</code>构造容器。（n个值为t的元素）</li>
</ul>
<p>二、拷贝和赋值</p>
<ul>
<li>不支持<code>c = &#123;a,b,c,...&#125;</code></li>
<li>不支持<code>C c(b,e)</code>：b和e为迭代器的范围拷贝构造（见笔记9.2.2 一、拷贝初始化）</li>
<li><code>C c1=c2</code>两者必须是相同大小</li>
</ul>
<p>三、其他</p>
<ul>
<li>
<p>不支持添加/插入/删除元素的函数</p>
<ul>
<li>不支持笔记9.3.1中表9.5（如<code>push_back</code>）</li>
<li>不支持笔记9.3.3的所有操作</li>
</ul>
</li>
<li>
<p><code>swap</code>会真正交换<code>array</code>的元素值，而其他容器不会。</p>
</li>
<li>
<p>不支持<code>resize()</code></p>
</li>
<li>
<p>不支持适配器（因为所有适配器都要求容器有添加和删除元素的能力）</p>
</li>
</ul>
<h1 id="十-泛型算法"><a class="markdownIt-Anchor" href="#十-泛型算法"></a> 十 泛型算法</h1>
<h2 id="101-概述"><a class="markdownIt-Anchor" href="#101-概述"></a> 10.1 概述</h2>
<blockquote>
<p>关键概念：算法永远不会执行容器的操作（算法只所用于迭代器）</p>
<ul>
<li>
<p>泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。<strong>泛型算法运行于迭代器之上而不会执行容器操作</strong>的特性带来了一个令人惊讶但非常必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。</p>
</li>
<li>
<p>如我们将在书本10.4.1节(第358页)所看到的，标准库定义了一类特殊的<strong>迭代器，称为插入器(inserter)</strong>。与普通迭代器只能遍历所绑定的容器相比，插入器能做更多的事情。当给这类迭代器赋值时，它们会在底层的容器上执行插入操作。因此，当一个算法操作一个这样的迭代器时，迭代器可以完成向容器添加元素的效果，但算法自身永远不会做这样的操作。</p>
</li>
</ul>
</blockquote>
<ul>
<li>
<p>大多数算法定义在<code>algorithm</code>中，<code>numeric</code>也定义了一组数值泛型算法。</p>
</li>
<li>
<p>一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。</p>
</li>
<li>
<p>迭代器令算法不依赖于容器，但是算法依赖于容器的元素类型。（因为算法要对元素进行比较等操作）</p>
</li>
</ul>
<h2 id="102-初识泛型算法"><a class="markdownIt-Anchor" href="#102-初识泛型算法"></a> 10.2 初识泛型算法</h2>
<h3 id="1021-只读算法"><a class="markdownIt-Anchor" href="#1021-只读算法"></a> 10.2.1 只读算法</h3>
<ul>
<li>
<p><code>find</code>_<code>&lt;algorithm&gt;</code><br />
<code>fund(开始迭代器（指针）,结束迭代器（指针）,val)</code></p>
<ul>
<li>作用：在指定范围内<code>[开始迭代器，结束迭代器)</code>查找val值，找到了就返回   第一个   等于val的  元素的  迭代器，否则返回结束迭代器。</li>
</ul>
</li>
<li>
<p><code>count</code>_<code>&lt;algorithm&gt;</code></p>
<ul>
<li>作用：返回给定值在次序中出现的次数</li>
</ul>
</li>
<li>
<p><code>accumulate</code>_<code>&lt;numeric&gt;</code><br />
<code>sum = accumulate(vec.cbegin(),vec.cend(),0)</code></p>
<ul>
<li>
<p>作用：将范围内所有元素加到第三个参数上，返回最终的加法之和。</p>
</li>
<li>
<p>要求第三个参数重载过<code>+</code>。</p>
</li>
<li>
<p>第三个参数决定了函数中使用哪个类型重载的加法运算符，以及返回值类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string sum = <span class="built_in">accumulate</span>(str.<span class="built_in">cbegin</span>(),str.<span class="built_in">cend</span>(),<span class="built_in">string</span>(<span class="string">&quot;&quot;</span>)); <span class="comment">//正确</span></span><br><span class="line">string sum = <span class="built_in">accumulate</span>(str.<span class="built_in">cbegin</span>(),str.<span class="built_in">cend</span>(),<span class="string">&quot;&quot;</span>); <span class="comment">//错误，const char*没有重载过‘+’运算符</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>equal</code>_<code>&lt;algorithm&gt;</code><br />
<code>equal(roster1.cbegin(),roster1.cend(),roster2.cbegin());</code></p>
<ul>
<li>作用：用于确定两个序列是否保存相同的值。第三个参数是第二个序列的首元素的迭代器</li>
<li>基于假设：它假定第二序列至少与第一序列一样长<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401291125010.png" alt="image-20240129112533625" /><br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401291152804.png" alt="image-20240129115208359" /></li>
<li>由于equal利用迭代器完成操作，因此，我们可以通过调用<strong>equal来比较两个不同类型的容器中的元素，而且，元素类型也不必一样，只要我们能用<code>==</code>来比较两个元素类型即可</strong>。</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401291126731.png" alt="image-20240129112605375" /></p>
<h3 id="1022-写容器元素算法"><a class="markdownIt-Anchor" href="#1022-写容器元素算法"></a> 10.2.2 写容器元素算法</h3>
<ul>
<li>
<p><code>fill</code><br />
<code>fill(vec.begin(),vec.end(),val);</code></p>
<ul>
<li>作用：将范围内的每个元素重置为第三个参数</li>
</ul>
</li>
<li>
<p><code>fill_n</code><br />
<code>fill_n(起始位置迭代器,n,val)</code></p>
<ul>
<li>
<p>作用：从其实位置的迭代器开始，将n和元素替换为val</p>
</li>
<li>
<p>注意：<strong>不应在一个空容器上调用<code>fill_n</code>，或类似写元素的算法</strong>。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//灾难错误示例</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec; <span class="comment">//空vector</span></span><br><span class="line"><span class="comment">//修改了10个不存在的向量，引发未定义的结果</span></span><br><span class="line"><span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span>(), <span class="number">10</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>back_inserter</code>_<code>&lt;iterator&gt;</code>：“插入” 迭代器</p>
<ul>
<li>
<p>作用：接受一个指向容器的引用，返回一个与该容器绑定插入迭代器。</p>
</li>
<li>
<p>我们用此迭代器赋值时，<strong>赋值运算符会调用push_back</strong>。</p>
</li>
<li>
<p>常常使用back_inserter创建一个插入迭代器，作为<strong>算法的目的位置使用</strong></p>
</li>
<li>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 有bug</span></span><br><span class="line"><span class="comment"> * 重载&lt;&lt;，流式输出容器中的元素</span></span><br><span class="line"><span class="comment"> * @tparam T</span></span><br><span class="line"><span class="comment"> * @param os </span></span><br><span class="line"><span class="comment"> * @param ctor </span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os,T &amp;ctor)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;ele:ctor)&#123;</span><br><span class="line">        os&lt;&lt;ele;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*例1*/</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec; <span class="comment">//空容器</span></span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">back_inserter</span>(vec); <span class="comment">// 插入迭代器</span></span><br><span class="line">    *iter = <span class="number">24</span>; <span class="comment">//赋值运算符调用push_back</span></span><br><span class="line">    cout&lt;&lt;vec&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*例2*/</span></span><br><span class="line">    vec.<span class="built_in">clear</span>(); <span class="comment">//清空容器</span></span><br><span class="line">    <span class="comment">//常常使用back_inserter创建一个插入迭代器，作为算法的目的位置使用</span></span><br><span class="line">    <span class="built_in">fill_n</span>(<span class="built_in">back_inserter</span>(vec),<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;vec&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>copy</code><br />
<code>copy(源起始迭代器，源终止迭代器，目的序列的起始位置)</code></p>
<ul>
<li>
<p>传递给copy的目的序列至少要包含与输入序列一样多的元素</p>
</li>
<li>
<p>返回目的位置迭代器增值后的值。下例中为a2尾后位置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 有bug</span></span><br><span class="line"><span class="comment"> * 流式输出容器</span></span><br><span class="line"><span class="comment"> * @tparam T</span></span><br><span class="line"><span class="comment"> * @param os</span></span><br><span class="line"><span class="comment"> * @param ctor</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os,T &amp;ctor)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;ele:ctor)&#123;</span><br><span class="line">        os&lt;&lt;ele;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> a2[<span class="built_in">sizeof</span>(a1)/<span class="built_in">sizeof</span>(*a1)];</span><br><span class="line">    <span class="keyword">auto</span> re = <span class="built_in">copy</span>(<span class="built_in">begin</span>(a1), <span class="built_in">end</span>(a1),a2); <span class="comment">// re指向尾后</span></span><br><span class="line">    cout&lt;&lt;a2&lt;&lt;endl;  <span class="comment">// 123456789</span></span><br><span class="line">    cout&lt;&lt;*(re<span class="number">-1</span>)&lt;&lt;endl; <span class="comment">// 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>replace_copy</code><br />
<code>replace_copy(ilst.cbegin(), ilst.end(), back_inserter(ivec), 0, 42);</code><br />
将ilst（值不会改变）中的所有元素拷贝到ivec（可以是空列表）之后，并将ivec中的0替换为24</p>
<ul>
<li>对比replace是将原来的序列范围内的值替换</li>
</ul>
</li>
</ul>
<h3 id="1023-重排容器元素算法"><a class="markdownIt-Anchor" href="#1023-重排容器元素算法"></a> 10.2.3 重排容器元素算法</h3>
<ul>
<li><code>sort</code>：sort(序列开始位置迭代器，结束位置迭代器)</li>
<li><code>unique</code>：返回不重复区域之后一个位置的迭代器 = unique(序列开始位置迭代器，结束位置迭代器)</li>
</ul>
<p>书中的例子：排序一个由单词组成的vector，并删除重复的单词</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401291602660.png" alt="202401291602660" /></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printCtor</span><span class="params">(T &amp;ctor)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;ele:ctor)&#123;</span><br><span class="line">        cout&lt;&lt;ele&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;string&gt; vec&#123;<span class="string">&quot;the&quot;</span>,<span class="string">&quot;quick&quot;</span>,<span class="string">&quot;red&quot;</span>,<span class="string">&quot;fox&quot;</span>,<span class="string">&quot;jumps&quot;</span>,<span class="string">&quot;over&quot;</span>,<span class="string">&quot;the&quot;</span>,<span class="string">&quot;slow&quot;</span>,<span class="string">&quot;red&quot;</span>,<span class="string">&quot;turtle&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">printCtor</span>(vec);cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 输出：the quick red fox jumps over the slow red turtle</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*sort*/</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printCtor</span>(vec);cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 输出：fox jumps over quick red red slow the the turtle</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*unique 将重复项移动到末尾*/</span></span><br><span class="line">    <span class="comment">// iter指向不重复区域的下一个位置</span></span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">unique</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    vec.<span class="built_in">erase</span>(iter,vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printCtor</span>(vec);cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 输出：fox jumps over quick red slow the turtle</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="103-定制操作"><a class="markdownIt-Anchor" href="#103-定制操作"></a> 10.3 定制操作</h2>
<h3 id="1031-谓词"><a class="markdownIt-Anchor" href="#1031-谓词"></a> 10.3.1 谓词</h3>
<h4 id="一-通过谓词改变算法的默认行为"><a class="markdownIt-Anchor" href="#一-通过谓词改变算法的默认行为"></a> 一、通过“谓词”改变算法的默认行为</h4>
<p>“谓词”是一种可调用的表达式，其返回结果是一个能用作条件的值。</p>
<ul>
<li>一元谓词，只接受一个单一参数的谓词</li>
<li>二元谓词，接受两个参数的谓词</li>
</ul>
<p>接受谓词参数的算法对输入序列中的元素调用谓词，元素类型必须能转化为谓词的参数类型。</p>
<p>根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或两个参数。</p>
<h4 id="二-举例"><a class="markdownIt-Anchor" href="#二-举例"></a> 二、举例</h4>
<p>接受一个二元谓词参数的<code>sort()</code>，用谓词替换<code>&lt;</code>来比较元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isShorter</span><span class="params">(<span class="type">const</span> string s1, <span class="type">const</span> string s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), isShorter);</span><br><span class="line"></span><br><span class="line"><span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), isShorter);<span class="comment">//可保持等长元素间的字典顺序</span></span><br></pre></td></tr></table></figure>
<h4 id="三-补充"><a class="markdownIt-Anchor" href="#三-补充"></a> 三、补充</h4>
<p><code>find_if()</code>算法接受一对迭代器，表示一个范围。与<code>find()</code>不同的是，<code>find_if()</code>的第三个参数是一个谓词，find_if算法对输入序列中的每个元素调用给定的这个谓词，返回第一个使谓词返回非0值的元素，如果不存在这样的元素，则返回尾迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> sz = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>(), [sz](<span class="type">const</span> string &amp;s)&#123;<span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz ;&#125;);</span><br></pre></td></tr></table></figure>
<p><code>for_each()</code>接受一个可调用的对象，并对输入序列中的每个元素调用此对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>(), [](<span class="type">const</span> string &amp;s)&#123;cout&lt;&lt;s&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="1032-lambda"><a class="markdownIt-Anchor" href="#1032-lambda"></a> 10.3.2 lambda</h3>
<p>（很重要，放在二级标题）</p>
<h4 id="一-书写格式"><a class="markdownIt-Anchor" href="#一-书写格式"></a> 一、书写格式</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list) -&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = []&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;; <span class="comment">// 相当于空参数列表；自动推导返回类型。</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">f</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h4 id="二-参数"><a class="markdownIt-Anchor" href="#二-参数"></a> 二、参数</h4>
<p>lambda不能有默认参数  —&gt; 一个lambda调用的实参数目永远与形参数目相等。</p>
<h4 id="三-捕获列表"><a class="markdownIt-Anchor" href="#三-捕获列表"></a> 三、捕获列表</h4>
<h5 id="一-谁需要被捕获"><a class="markdownIt-Anchor" href="#一-谁需要被捕获"></a> 一、谁需要被捕获？</h5>
<p><strong>捕获列表只适用于局部非static变量，可以直接使用局部static变量和在它所在函数之外声明的名字。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>; <span class="comment">// 只有局部非static变量需要捕获</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [b]() &#123;cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c; &#125;;</span><br><span class="line">    <span class="comment">// f的类型  main::__l2::&lt;lambda_1&gt;</span></span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 1 2 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二-几种捕获方式"><a class="markdownIt-Anchor" href="#二-几种捕获方式"></a> 二、几种捕获方式</h5>
<p>1.值捕获</p>
<ul>
<li>
<p>采用值捕获的前提是变量可以拷贝</p>
</li>
<li>
<p>被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝。（与函数参数不同）</p>
</li>
<li>
<p>又由于 “ 被捕获的变量的值是在lambda创建时拷贝”，因此，随后对其修改不会影响到lambda内对应的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [v1]&#123;<span class="keyword">return</span> v1;&#125;;<span class="comment">// &lt;--值捕获</span></span><br><span class="line">    v1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = <span class="built_in">f</span>();<span class="comment">// j = 42;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2.引用捕获</p>
<p>下例为引用捕获示例与上述值捕获示例的对比</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;v1]&#123;<span class="keyword">return</span> v1;&#125;; <span class="comment">// &lt;--引用捕获</span></span><br><span class="line">    v1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = <span class="built_in">f</span>();<span class="comment">// j = 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lambda捕获的都是函数的局部变量，函数结束后，捕获的引用指向的局部变量已经消失。</p>
<ul>
<li>
<p>必须确保被引用的对象在lambda执行的时候是存在的。</p>
</li>
<li>
<p>函数不能返回一个包含引用捕获的lambda（因为局部变量已消失，和函数不能返回局部变量的引用/指针是一个道理）</p>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402021136952.png" alt="image-20240202113652567" /></p>
<p>3.隐式捕获</p>
<ul>
<li>当我们混合使用隐式捕获和显式捕获时，
<ul>
<li>必须以隐式捕获开头（原文：捕获列表的第一个元素必须是一个<code>&amp;</code>或<code>=</code>，以指定默认捕获方式）。</li>
<li>显式捕获的变量必须使用与隐式捕获不同的方式。</li>
</ul>
</li>
</ul>
<h5 id="三-捕获列表的书写方式汇总"><a class="markdownIt-Anchor" href="#三-捕获列表的书写方式汇总"></a> 三、捕获列表的书写方式汇总</h5>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402021052259.png" alt="image-20240202105221721" /></p>
<h5 id="四-可变lambdamutable"><a class="markdownIt-Anchor" href="#四-可变lambdamutable"></a> 四、可变lambda（mutable）</h5>
<ul>
<li>
<p>默认情况下，对于一个值被拷贝的变量，lambda 不会改变其值。但是，如果我们希望能改变个被捕获的变量的值，就必须在参数列表首加上关键字 mutable。</p>
</li>
<li>
<p>一个引用捕获的变量是否可以修改，依赖于此引用指向的是一个const还是一个非const</p>
</li>
<li>
<p>对于局部static变量和在它所在函数之外声明，不用mutable也可以在lambda中修改</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*如果我们希望能改变个被捕获的变量的值，就必须在参数列表首加上关键字 mutable。*/</span></span><br><span class="line"><span class="type">int</span> v1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [v1]() <span class="keyword">mutable</span> &#123;<span class="keyword">return</span> ++v1; &#125;;</span><br><span class="line"><span class="comment">// auto f = [v1]()  &#123; return ++v1; &#125;; //v1报错：表达式必须是可修改的左值（v1只读）</span></span><br><span class="line">cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl; <span class="comment">// 42 43</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*一个引用捕获的变量是否可以修改，依赖于此引用指向的是一个const还是一个非const*/</span></span><br><span class="line"><span class="keyword">auto</span> f1 = [&amp;v1]() &#123;<span class="keyword">return</span> ++v1; &#125;;</span><br><span class="line">cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">f1</span>() &lt;&lt; endl; <span class="comment">//43 43</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> v2 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//auto f2 = [&amp;v2] &#123;return ++v2; &#125;; //v2报错：表达式必须是可修改的左值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对于局部static变量和在它所在函数之外声明，不用mutable也可以在lambda中修改*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> v3 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> f3 = [] &#123;<span class="keyword">return</span> ++v3; &#125;;</span><br><span class="line">cout &lt;&lt; v3 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">f3</span>(); <span class="comment">// 2 2</span></span><br></pre></td></tr></table></figure>
<h4 id="四-指定lambda的返回类型"><a class="markdownIt-Anchor" href="#四-指定lambda的返回类型"></a> 四、指定lambda的返回类型</h4>
<ul>
<li>
<p>默认情况下，如果一个lambda体   除了单一return外   还包含了其他语句，则编译器假定lambda返回void。如果与本意不符，需要显式指明返回类型。</p>
</li>
<li>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lambda体内只有一条return语句，编译器自动推导返回类型</span></span><br><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi,<span class="built_in">begin</span>(), </span><br><span class="line">         [](<span class="type">int</span> i)&#123; <span class="keyword">return</span> i &lt; <span class="number">0</span> ? -i : i; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译错误：</span></span><br><span class="line"><span class="comment">//除了单一return外   还包含了其他语句，编译器推断为void，实际却返回int</span></span><br><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi,<span class="built_in">begin</span>(),[](<span class="type">int</span> i)&#123; </span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -i;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> i; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确写法：显式指定返回类型</span></span><br><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi,<span class="built_in">begin</span>(),[](<span class="type">int</span> i)-&gt;<span class="type">int</span>&#123;  <span class="comment">// 尾置返回类型</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -i;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> i; &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>补充：<code>transform()</code><br />
使用标准库 transform 算法和一个 lambda来将一个序列中的每个负数替换为其绝对值:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>()， vi.<span class="built_in">end</span>()， vi.<span class="built_in">begin</span>()，</span><br><span class="line">          [](<span class="type">int</span> i) &#123; <span class="keyword">return</span> i &lt; <span class="number">0</span> ?-i :i; &#125;);</span><br></pre></td></tr></table></figure>
<p>函数transform接受三个迭代器和一个可调用对象。前两个迭代器表示输入序列，第三个迭代器表示目的位置。算法对输入序列中每个元素调用可调用对象，并将结果写到目的位置。</p>
</li>
</ul>
<h4 id="五-参数绑定"><a class="markdownIt-Anchor" href="#五-参数绑定"></a> 五、参数绑定</h4>
<p><strong>一、引入</strong></p>
<p>之前我们写过的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> sz = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>(), [sz](<span class="type">const</span> string &amp;s)&#123;<span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz ;&#125;);</span><br></pre></td></tr></table></figure>
<p>如果好多地方使用同样的操作，或者操作需要很多语句才能完成，使用lambda不方便，需要使用函数。但是如何用接受两个参数的函数替换一元谓词？如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_sz</span><span class="params">(<span class="type">const</span> string &amp;s, string::size_type sz)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt; sz ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>(), <span class="comment">/*check_sz*/</span>); <span class="comment">// 如何用接受两个参数的函数替换一元谓词?</span></span><br></pre></td></tr></table></figure>
<p><strong>二、bind</strong></p>
<p>使用在库<code>functional</code>中的<code>bind()</code>。可以将其看做函数适配器（类比容器适配器），接受一个可调用对象，生成一个新的可调用对象来“适应”原本对象的参数列表。一般形式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = <span class="built_in">bind</span>(callable, arg_list);</span><br></pre></td></tr></table></figure>
<p><strong>当<em>调用newCallable</em>时，newCallable会调用<em>函数callable</em>，并向callable传递arg_list中的参数。</strong></p>
<p>其中，arg_list中可能会有<code>std::placeholders::_n</code>，为占位符。表示调用newCallable时，传入的参数应该填入callable形参列表的第n位。</p>
<p>举例，对于一中的例子，利用bind改写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_sz</span><span class="params">(<span class="type">const</span> string &amp;s, string::size_type sz)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt; sz ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> check6 = <span class="built_in">bind</span>(check_sz, std::placeholders::_1, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>(), check6); </span><br></pre></td></tr></table></figure>
<p>举例2：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namesapce std::placeholders;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_sz</span><span class="params">(<span class="type">const</span> string &amp;s, string::size_type sz)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt; sz ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> check6 = <span class="built_in">bind</span>(check_sz, _1, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">check6</span>(s); <span class="comment">// 相当于  check_sz(s,6);</span></span><br></pre></td></tr></table></figure>
<p>三、bind的参数</p>
<p>bind对参数的作用：</p>
<ul>
<li>
<p>绑定给定可调用对象中的参数（上文所述）</p>
</li>
<li>
<p>重新安排参数的顺序。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> g = <span class="built_in">bind</span>(func, a, b, _2, c, _1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">g</span>(X,Y);<span class="comment">//func(a,b,Y,c,X);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>四、绑定引用参数</p>
<p>我们希望传递一个引用给bind，而不是拷贝，用<code>ref()</code>或<code>cref()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">bind</span>(print, <span class="built_in">ref</span>(os), _1, <span class="string">&#x27; &#x27;</span>));</span><br></pre></td></tr></table></figure>
<h2 id="104-再探迭代器"><a class="markdownIt-Anchor" href="#104-再探迭代器"></a> 10.4 再探迭代器</h2>
<p><a href="#9.2.1-%E8%BF%AD%E4%BB%A3%E5%99%A8">笔记9.2.1迭代器基础</a></p>
<p>补充额外的迭代器：</p>
<ul>
<li>插入迭代器（insert iterator）：迭代器被绑定到一个容器上，可以用来向容器插入元素</li>
<li>流迭代器（stream iterator）：迭代器被绑定到输入/输出流上，用来遍历所关联的io</li>
<li>反向迭代器（reverse iterator）：迭代器向反方向移动（++/–方向相反）。除了forward_list外标准库容器都有反向迭代器</li>
<li>移动迭代器（move iterator）：这些迭代器不是拷贝其中的元素，而是移动它们。</li>
</ul>
<h3 id="1041-插入迭代器"><a class="markdownIt-Anchor" href="#1041-插入迭代器"></a> 10.4.1 插入迭代器</h3>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402031036331.png" alt="image-20240203103605570" style="zoom:67%;" />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">inserter</span>(nums,++nums.<span class="built_in">begin</span>()); <span class="comment">// inserter(容器，迭代器)；插入迭代器之前的位置</span></span><br><span class="line">it = <span class="number">12</span>;  <span class="comment">//等价*it或++it或it++ = 12，因为这三个存在但什么都不做，只返回it</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//0 12 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">int</span> ins_num = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">auto</span> iter = nums.<span class="built_in">insert</span>(++nums.<span class="built_in">begin</span>(), ins_num);</span><br><span class="line">++iter; <span class="comment">// &lt;--特别注意这里，iter又指回了原来的地方</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//0 12 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个值得注意的地方：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lst&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lst2, lst3;</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">begin</span>(), lst.<span class="built_in">end</span>(), <span class="built_in">front_inserter</span>(lst2));<span class="comment">//lst2=4 3 2 1</span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">begin</span>(), lst.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(lst3,lst3.<span class="built_in">begin</span>()));<span class="comment">//lst2=1 2 3 4</span></span><br></pre></td></tr></table></figure>
<p>原理如图所示：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402031140878.png" alt="image-20240203114013429" /></p>
<h3 id="1042-流迭代器"><a class="markdownIt-Anchor" href="#1042-流迭代器"></a> 10.4.2 流迭代器</h3>
<p>原文：iostream迭代器</p>
<blockquote>
<p>虽然iostream类型不是容器，但标准库定义了可以用于这些IO类型对象的选代器(参见8.1 节，第278页)。</p>
<p>istream_iterator (参见表10.3)读取输入流，ostream_iterator(参见表10.4节，第361页)向一个输出流写数据。</p>
<p>这些选代器将它们对应的流当作一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。</p>
</blockquote>
<h4 id="一-istream_iterator"><a class="markdownIt-Anchor" href="#一-istream_iterator"></a> 一、istream_iterator</h4>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402031523800.png" alt="image-20240203152334297" style="zoom:67%;" />
<p>用法示例：用一个istream_iterator从标准输入读取数据，存入一个vector的例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 写法1 */</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span> <span class="comment">/* 从cin读取int类型的数据 */</span>, eof<span class="comment">/*istream尾后迭代器*/</span></span>;</span><br><span class="line"><span class="keyword">while</span> (in_iter != eof)</span><br><span class="line">&#123;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(*in_iter++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写法2，等价于写法1*/</span></span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span>, eof</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(in_iter, eof)</span></span>; <span class="comment">// 从迭代器范围构造vec（用一对表示元素范围的迭代器构造vec）</span></span><br></pre></td></tr></table></figure>
<p>要求：</p>
<ul>
<li>必须指定迭代器将要读写的对象类型</li>
<li>该对象类型定义了<code>&gt;&gt;</code>来读取流</li>
<li>默认初始化迭代器，即创建了istream流的尾后迭代器</li>
</ul>
<p>特点：允许使用懒惰求值。  &lt;-- 没怎么看懂</p>
<blockquote>
<p>当我们将一个istream_iterator 绑定到一个流时，标准库<strong>并不保证迭代器立即从流读取数据</strong>。具体实现可以推迟从流中读取数据，<strong>直到我们使用迭代器时才真正读取</strong>。</p>
<p>标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取没什么差别。但是，如果我们创建了一个istream_iterator，没有使用就销毁了，或者我们正在从两个不同的对象同步读取同一个流，那么何时读取可能就很重要了。</p>
</blockquote>
<p>应用：用一对istream_iterator来调用accumulate</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in</span><span class="params">(cin)</span>, eof</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">accumulate</span>(in, eof, <span class="number">0</span>)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h4 id="二-ostream_iterator"><a class="markdownIt-Anchor" href="#二-ostream_iterator"></a> 二、ostream_iterator</h4>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402031523918.png" alt="image-20240203152310391" style="zoom:67%;" />
<p>用法示例：用ostream_iterator来输出  值的序列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 写法1 */</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_iter</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; n : vec)</span><br><span class="line">    *out_iter++ = n; <span class="comment">// 0 1 2 3 4 5 6</span></span><br><span class="line">    <span class="comment">// 等价</span></span><br><span class="line">    <span class="comment">// out_iter = n; // 不推荐，因为上面的写法更易阅读</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写法2 */</span></span><br><span class="line"><span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), out_iter);</span><br></pre></td></tr></table></figure>
<p>要求：</p>
<ul>
<li>要输出的类型   定义了<code>&lt;&lt;</code></li>
<li>第二个可选参数表示：在输出的每个元素后都会打印该字符（必须是c风格字符串——字符串字面常量或以空字符结尾的字符数组的指针）</li>
<li>ostream_iterator必须绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator</li>
</ul>
<p>应用：（书P362）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1043-反向迭代器"><a class="markdownIt-Anchor" href="#1043-反向迭代器"></a> 10.4.3 反向迭代器</h3>
<p><a href="#9.2.1-%E8%BF%AD%E4%BB%A3%E5%99%A8">返回笔记9.2.1</a></p>
<ul>
<li><code>rbegin(),rend(), crbegin(),crend()</code></li>
<li>forward_list和流迭代器不能创建反向迭代器</li>
<li>reverse_iterator的<code>base()</code>将反向迭代器转换为普通迭代器（在容器中正向移动）</li>
</ul>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402032113033.png" alt="image-20240203211300327" style="zoom:67%;" />
<p>应用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*例1*/</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()); <span class="comment">// 顺序</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">rbegin</span>(), vec.<span class="built_in">rend</span>()); <span class="comment">// 逆序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例2*/</span></span><br><span class="line"><span class="comment">//first,middle,last</span></span><br><span class="line"><span class="keyword">auto</span> comma = <span class="built_in">find</span>(line.<span class="built_in">cbegin</span>(), line.<span class="built_in">cend</span>(), <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">cout&lt;&lt;<span class="built_in">string</span>(line.<span class="built_in">cbegin</span>(), comma);<span class="comment">//first</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> rcomma = <span class="built_in">find</span>(line.<span class="built_in">crbegin</span>(), line.<span class="built_in">crend</span>(), <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">cout&lt;&lt;<span class="built_in">string</span>(line.<span class="built_in">crbegin</span>(), rcomma);<span class="comment">//tsal</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">string</span>(rcomma.<span class="built_in">base</span>(),line.<span class="built_in">cend</span>());<span class="comment">//last</span></span><br></pre></td></tr></table></figure>
<h2 id="105-泛型算法结构"><a class="markdownIt-Anchor" href="#105-泛型算法结构"></a> 10.5 泛型算法结构</h2>
<h3 id="1051-五类迭代器"><a class="markdownIt-Anchor" href="#1051-五类迭代器"></a> 10.5.1 五类迭代器</h3>
<p>任何算法最基本的特性是  它要求其迭代器提供哪些操作。</p>
<p>类似容器，迭代器也定义了一组公共操作。<strong>迭代器按其提供的操作分类，这些分类形成了一种层次，除了输出迭代器外，一个高层类别的迭代器支持低层类别迭代器的所有操作。</strong></p>
<p><strong>C++标准指明了泛型和数值算法的每个迭代器参数的最小类别（至少应该达到的类别）</strong>。例如，find 算法在个序列上进行一遍扫描，对元素进行只读操作，因此至少需要输入迭代器。对每个迭代器参数来说，<strong>其能力必须与规定的最小类别至少相当。向算法传递一个能力更差的迭代器会产生错误。</strong></p>
<p>迭代器提供的操作可以划分为5类。每个算法都会对   它的每个迭代器参数  指明  需要提供哪类迭代器。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402032150537.png" alt="image-20240203215001891" style="zoom:67%;" />
<p>迭代器类别简述：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402042051427.png" alt="202402042051427" /></p>
<h3 id="1052-算法形参模式"><a class="markdownIt-Anchor" href="#1052-算法形参模式"></a> 10.5.2 算法形参模式</h3>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402042108959.png" alt="image-20240204210849325" /></p>
<ul>
<li>dest
<ul>
<li>表示算法可以写入的目的位置迭代器</li>
<li>使用dest时，算法假定：按其需要写入的数据，不管写入多少元素都是安全的</li>
<li>如果dest是一个直接指向容器的迭代器，算法将输出数据写到容器中<strong>已存在的元素内</strong></li>
</ul>
</li>
<li>beg2
<ul>
<li><strong>接受单独beg2的算法   假定从beg2开始的序列   至少   与beg和end所表示的范围   一样大</strong></li>
</ul>
</li>
</ul>
<h3 id="1053-算法命名规范"><a class="markdownIt-Anchor" href="#1053-算法命名规范"></a> 10.5.3 算法命名规范</h3>
<ul>
<li>
<p>一些算法使用重载形式传递一个谓词</p>
</li>
<li>
<p>_if版本的算法</p>
<ul>
<li>
<p>接受一个元素值的算法通常有一个不同名的版本，接受一个谓词以替代元素值，这类接受谓词参数的算法都附加_if。</p>
</li>
<li>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(beg,end,val);<span class="comment">//查找范围内val第一次出现的位置</span></span><br><span class="line"><span class="built_in">find_if</span>(beg,end,pred);<span class="comment">//查找第一个令pred为真的元素的位置</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>_copy版本的算法</p>
<ul>
<li>
<p>默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个<code>_copy</code></p>
</li>
<li>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(begin,end); <span class="comment">// 反向输入范围中的序列</span></span><br><span class="line"><span class="built_in">reverse_copy</span>(begin,end,dest); <span class="comment">// 将元素按逆序拷贝到dest</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>一些算法同时提供_if和_copy，如<code>remove_if</code>和<code>remove_copy_if</code></p>
</li>
</ul>
<h2 id="106-特定容器算法"><a class="markdownIt-Anchor" href="#106-特定容器算法"></a> 10.6 特定容器算法</h2>
<ul>
<li>
<p><strong>对于<code>list</code>和<code>forward_list</code>，应该   优先使用成员函数版本的算法    而不是通用算法</strong><br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402042147204.png" alt="202402042147204" /></p>
</li>
<li>
<p>链表类型还定义了<code>splice</code>成员（链表特有，<code>splice</code>和<code>splice_after</code>）<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402042148050.png" alt="image-20240204214806386" /></p>
</li>
<li>
<p>链表特有的操作会改变容器</p>
<blockquote>
<p>多数链表特有的算法都与其通用版本很相似，但不完全相同。链表特有版本与通用版本间的一个至关重要的区别是<strong>链表版本  会  改变底层的容器</strong>。例如，remove 的链表版本会删除指定的元素。unique 的链表版本会删除第二个和后继的重复元素。</p>
<p>类似的，merge和splice 会销毁其参数。例如，通用版本的merge 将合并的序列写到一个给定的目的迭代器：两个输入序列是不变的。而链表版本的 merge 函数会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用 merge 的链表对象中。在merge 之后，来自两个链表中的元素仍然存在，但它们都已在同一个链表中。</p>
</blockquote>
</li>
</ul>
<h1 id="十一-关联容器"><a class="markdownIt-Anchor" href="#十一-关联容器"></a> 十一 关联容器</h1>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402050716864.png" alt="image-20240205071603483" /></p>
<ul>
<li>
<p>map &amp; set</p>
<ul>
<li>map中的元素是键值对</li>
<li>set每个元素只包含一个关键字</li>
</ul>
</li>
<li>
<p>8个容器见的不同体现在3个维度上</p>
<ul>
<li>
<p>map or set</p>
</li>
<li>
<p>要求不重复关键字 or 允许重复关键字 <code>multi</code></p>
</li>
<li>
<p>顺序存储 or 无序存储 <code>unordered</code></p>
<ul>
<li>
<p>有序存储会自动排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;string,string&gt; authors&#123;&#123;<span class="string">&quot;Alain&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Stanley&quot;</span>,<span class="string">&quot;c++Primer&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Alain&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Blain&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402052128072.png" alt="image-20240205212831668" /></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>也可以对一个关联容器进行列表初始化</p>
</li>
</ul>
<h2 id="111-简单使用关联容器"><a class="markdownIt-Anchor" href="#111-简单使用关联容器"></a> 11.1 简单使用关联容器</h2>
<ul>
<li>
<p>map</p>
<ul>
<li>
<p>map是键值对的集和</p>
</li>
<li>
<p>map通常被称为关联数组，可使用key而不是位置作为下标来查找val</p>
</li>
<li>
<p><code>map&lt;key的类型，val的类型&gt;</code>  --&gt; <strong>每个元素是一个<code>pair类型</code>，</strong><code>.first</code> 表示key，<code>.second</code>表示val</p>
</li>
</ul>
</li>
<li>
<p>set</p>
<ul>
<li>set就是关键字的简单集和。</li>
<li>值就是关键字</li>
</ul>
</li>
</ul>
<p>简单应用：单词计数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,<span class="type">size_t</span>&gt; word_cnt;</span><br><span class="line">set&lt;string&gt; exclude&#123;<span class="string">&quot;the&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;but&quot;</span>&#125;; <span class="comment">//忽略计数的单词</span></span><br><span class="line">string word;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;word)</span><br><span class="line">    <span class="keyword">if</span>(exclude.<span class="built_in">find</span>(word) == exclude.<span class="built_in">end</span>()) <span class="comment">// 没找到，返回尾后指针</span></span><br><span class="line">        ++word_cnt[word]; <span class="comment">// ++是将val加1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;w:word_cnt)&#123;</span><br><span class="line">    cout&lt;&lt;w.first&lt;&lt;<span class="string">&quot; occurs &quot;</span>&lt;&lt;w.second</span><br><span class="line">        &lt;&lt;((w.second&gt;<span class="number">1</span>)?<span class="string">&quot; times &quot;</span>:<span class="string">&quot; time &quot;</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="112-关联容器概述"><a class="markdownIt-Anchor" href="#112-关联容器概述"></a> 11.2 关联容器概述</h2>
<h3 id="1121-如何定义关联式容器"><a class="markdownIt-Anchor" href="#1121-如何定义关联式容器"></a> 11.2.1 如何定义关联式容器</h3>
<ul>
<li>除了不支持顺序容器的<code>push_back</code>等位置操作，以及构造函数和插入操作这些接受一个元素值和一个数量值的操作外，都支持[笔记9.2中表9.2](#9.2 容器库概览)的普通容器操作。</li>
<li>关联容器的迭代器都是双向的</li>
<li>初始化<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402050956853.png" alt="image-20240205095623403" /></li>
<li>初始化时，没有muti的关联容器会自动删除key重复的元素<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402050957004.png" alt="image-20240205095744626" /></li>
</ul>
<h3 id="1122-关键字类型的要求"><a class="markdownIt-Anchor" href="#1122-关键字类型的要求"></a> 11.2.2 关键字类型的要求</h3>
<ul>
<li>
<p>对于有序容器，关键字类型必须定义元素比较的方法。默认情况下标准库使用key类型的<code>&lt;</code>运算符来比较两个关键字。</p>
</li>
<li>
<p>key类型可以提供自己的操作来替代默认的<code>&lt;</code>，遵循<strong>严格弱序（小于等于）</strong><br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051032678.png" alt="image-20240205103238274" /></p>
</li>
<li>
<p>key如果没有自定义的<code>&lt;</code>运算符，也可使用关键字类型的比较函数，下例所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="type">const</span> Sales_data &amp;sd1, <span class="type">const</span> Sales_data &amp;sd2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sd1.<span class="built_in">isbn</span>() &lt; sd2.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义mutiset</span></span><br><span class="line"><span class="function">mutiset&lt;Sales_data, <span class="title">decltype</span><span class="params">(compareIsbn)</span> *&gt;  <span class="title">bookstore</span><span class="params">()</span></span>; <span class="comment">// decltype作用于函数时，返回函数类型而非指针类型，所以要另加*号</span></span><br></pre></td></tr></table></figure>
<ul>
<li>元素的操作类型（比较函数）也是容器类型的一部分</li>
<li>操作类型也仅仅只是类型，当创建容器时，才会以构造函数参数的形式提供真正的比较操作。</li>
</ul>
</li>
</ul>
<h3 id="1123-pair"><a class="markdownIt-Anchor" href="#1123-pair"></a> 11.2.3 pair</h3>
<ul>
<li>
<p><code>#include &lt;utility&gt;</code></p>
</li>
<li>
<p>pair上的操作<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402050959875.png" alt="image-20240205095922457" /></p>
</li>
<li>
<p>如何创建一个<code>pair</code>对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*写法1*/</span></span><br><span class="line">&#123;key,val&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写法2*/</span></span><br><span class="line"><span class="built_in">pair</span>&lt;key_type,val_type&gt;(key,val); </span><br><span class="line"></span><br><span class="line"><span class="comment">/*写法3*/</span></span><br><span class="line"><span class="built_in">make_pair</span>(key,val);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*隐式构造一个空的pair*/</span></span><br><span class="line"><span class="built_in">pair</span>&lt;key_type,val_type&gt;();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="113-关联容器操作"><a class="markdownIt-Anchor" href="#113-关联容器操作"></a> 11.3 关联容器操作</h2>
<h3 id="1131-获得关联容器中元素的类型-容器迭代器"><a class="markdownIt-Anchor" href="#1131-获得关联容器中元素的类型-容器迭代器"></a> 11.3.1 获得关联容器中元素的类型 &amp; 容器迭代器</h3>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051455057.png" alt="image-20240205145535666" /></p>
<ul>
<li>
<p>关键字是const的，不能随便改变一个元素的关键字</p>
<ul>
<li>
<p>1.类型别名<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051458429.png" alt="image-20240205145826046" /></p>
</li>
<li>
<p>2.不能改变map的key的值，因为是const的<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051500619.png" alt="image-20240205150018200" /></p>
</li>
<li>
<p>3.set的val就是key，同样是const的</p>
<blockquote>
<p>虽然set 类型同时定义了iterator和const_iterator类型，但两种类型<strong>都只允许只读访问 set 中的元素</strong>。</p>
<p>与不能改变一个map 元素的关键字一样，一个 <strong>set 中的关键字也是 const 的</strong>。</p>
</blockquote>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051501346.png" alt="image-20240205150123954" /></p>
</li>
</ul>
</li>
<li>
<p>同样可由<code>++迭代器</code>遍历关联容器</p>
</li>
<li>
<p>关联容器和算法</p>
<ul>
<li>通常不对关联容器使用泛型算法——关键字是const的</li>
<li>关联容器可用于只读容器的算法——不过建议使用成员函数</li>
<li>在实际编程中，如果我们真要对一个关联容器使用算法，要么是将它当作一个源序列，要么当作一个目的序列。</li>
</ul>
</li>
</ul>
<h3 id="1132-添加元素"><a class="markdownIt-Anchor" href="#1132-添加元素"></a> 11.3.2 添加元素</h3>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051515470.png" alt="image-20240205151520039" /></p>
<ul>
<li>
<p>非muti在构造时会自动忽略重复的项</p>
</li>
<li>
<p>对map进行insert，切记所需元素类型的pair</p>
</li>
<li>
<p>insert/emplace的返回值</p>
<ul>
<li>
<p>对于非muti，返回一个pair。first是一个指向插入的元素的迭代器。second是一个bool，指出   插入成功（true）  还是  已在容器中（false）</p>
</li>
<li>
<p>对于first，通常用auto代替，详细的结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,<span class="type">size_t</span>&gt; word_cnt;</span><br><span class="line">pair&lt;map&lt;string,<span class="type">size_t</span>&gt;::iterator, <span class="type">bool</span>&gt; ret = </span><br><span class="line">    word_cnt.<span class="built_in">insert</span>(&#123;word,<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>对muti，返回值为指向新元素的迭代器，没有bool</p>
<ul>
<li>应用：添加具有相同关键字的多个元素</li>
</ul>
</li>
</ul>
<h3 id="1133-删除元素"><a class="markdownIt-Anchor" href="#1133-删除元素"></a> 11.3.3 删除元素</h3>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051531873.png" alt="image-20240205153100464" /></p>
<h3 id="1134-map的下标操作"><a class="markdownIt-Anchor" href="#1134-map的下标操作"></a> 11.3.4 map的下标操作</h3>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051559437.png" alt="image-20240205155953031" /></p>
<ul>
<li>仅map和unordered_map支持下标操作</li>
<li>如果<strong>关键字不在map/unordered_map中，会创建该关键字</strong>。初始化顺序如下：<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051600520.png" alt="image-20240205160026146" style="zoom: 80%;" /></li>
<li>由于下标运算符可能插入一个新元素，所以只能对非const使用</li>
<li>解引用迭代器和下标操作所得到的值不同，前者为（value_type）,后者为（mapped_type）</li>
</ul>
<h3 id="1135-访问元素"><a class="markdownIt-Anchor" href="#1135-访问元素"></a> 11.3.5 访问元素</h3>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402052102580.png" alt="202402052102580" /></p>
<ul>
<li>
<p>只是为了判断特定元素在不在容器中，find是最佳选择，下标运算会有副作用</p>
</li>
<li>
<p><strong>muti</strong>容器中，具有<strong>相同关键字</strong>的多个元素<strong>相邻存储</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;string,string&gt; authors&#123;&#123;<span class="string">&quot;Alain&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Stanley&quot;</span>,<span class="string">&quot;c++Primer&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Alain&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Blain&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;&#125;;</span><br><span class="line">string author&#123;<span class="string">&quot;Alain&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> entries = authors.<span class="built_in">count</span>(author); <span class="comment">// 元素个数</span></span><br><span class="line"><span class="keyword">auto</span> iter = authors.<span class="built_in">find</span>(author);  <span class="comment">// 作者的第一本书</span></span><br><span class="line"><span class="keyword">while</span> (entries--)&#123;</span><br><span class="line">    cout&lt;&lt;iter-&gt;second&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// a b</span></span><br><span class="line">    ++iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>针对muti，lower_bound和upper_bound</p>
<ul>
<li>lower_bound返回的迭代器指向第一个具有给定关键字的元素</li>
<li>upper_bound返回的迭代器指向最后一个具有给定关键字的元素之后的位置</li>
<li>如果给定关键字不存在，则两个函数指向相同的位置——第一个安全的插入点（即能够保持容器顺序的插入位置）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价上例</span></span><br><span class="line">multimap&lt;string,string&gt; authors&#123;&#123;<span class="string">&quot;Alain&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Stanley&quot;</span>,<span class="string">&quot;c++Primer&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Alain&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Blain&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">string author&#123;<span class="string">&quot;Alain&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> beg = authors.<span class="built_in">lower_bound</span>(author),</span><br><span class="line">    end = authors.<span class="built_in">upper_bound</span>(author);</span><br><span class="line">    beg != end; ++beg)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;beg-&gt;second&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// a b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402052147283.png" alt="image-20240205214737877" /></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402052154316.png" alt="image-20240205215417909" /></p>
</li>
<li>
<p>equal_bound</p>
<ul>
<li>
<p>此函数接受一个关键字，返回一个选代器对pair。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素（相当于lower_bound），第二个迭代器指向最后一个匹配元素之后的位置(相当于upper_bound)。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置（同样类似lower_bound和upper_bound）。</p>
</li>
<li>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价上例</span></span><br><span class="line">multimap&lt;string,string&gt; authors&#123;&#123;<span class="string">&quot;Alain&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Stanley&quot;</span>,<span class="string">&quot;c++Primer&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Alain&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Blain&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">string author&#123;<span class="string">&quot;Alain&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pos = authors.<span class="built_in">equal_range</span>(author);</span><br><span class="line">    pos.first != pos.second; ++pos.first)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;pos.first-&gt;second&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// a b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="114-无序容器"><a class="markdownIt-Anchor" href="#114-无序容器"></a> 11.4 无序容器</h2>
<ul>
<li>
<p>通常可以用无序容器替换对应的有序容器，反之亦然。但是，由于元素未按顺序存储，一个使用无序容器的输出（通常）会与使用有序容器的版本不同。</p>
</li>
<li>
<p>管理桶</p>
<ul>
<li>
<p>无序容器的形式如下图所示<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402060925431.png" alt="image-20240206092547916" /></p>
</li>
<li>
<p>无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。</p>
<p>对于相同的参数，哈希函数必须总是产生相同的结果。理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但是，将不同关键字的元素映射到相同的桶也是允许的。当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在桶中搜索通常都是很快的操作。但是，如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作。</p>
</li>
<li>
<p>无序容器的管理操作<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402052211491.png" alt="image-20240205221101059" /></p>
</li>
</ul>
</li>
<li>
<p>无序容器对key类型的要求</p>
<ul>
<li>
<p>无序容器需要<code>==</code>来比较元素和<code>hash&lt;key_type&gt;</code>来生成每个元素的hash值</p>
</li>
<li>
<p>可以通过重载关键字类型的默认操作，类定义无序容器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(string isbn)</span>:m_isbn(std::move(isbn))&#123;</span>&#125;</span><br><span class="line">    <span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_isbn;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_isbn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">hasher</span><span class="params">(<span class="type">const</span> Sales_data &amp;sd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(sd.<span class="built_in">isbn</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">eqop</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() == rhs.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> sd_mutiset = unordered_set&lt;Sales_data, <span class="keyword">decltype</span>(hasher)*, <span class="keyword">decltype</span>(eqop)*&gt;;</span><br><span class="line">    <span class="function">sd_mutiset <span class="title">bookstore</span><span class="params">(<span class="number">42</span>, hasher, eqop)</span></span>;<span class="comment">//桶数目、哈希函数指针、相等性判断运算符指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果Sales_data中重载了==，可省略等号</span></span><br><span class="line">    <span class="function">unordered_set&lt;Foo,<span class="title">decltype</span><span class="params">(FooHash)</span>*&gt; <span class="title">fooSet</span><span class="params">(<span class="number">10</span>,FooFash)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="十二-动态内存"><a class="markdownIt-Anchor" href="#十二-动态内存"></a> 十二 动态内存</h1>
<h2 id="121-动态内存与智能指针"><a class="markdownIt-Anchor" href="#121-动态内存与智能指针"></a> 12.1 动态内存与智能指针</h2>
<p>使用动态内存的原因：</p>
<ul>
<li>程序不知道自己使用多少个对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在对个对象间共享数据</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402061053237.png" alt="image-20240206105347502" /></p>
<h3 id="1211-shared_ptr"><a class="markdownIt-Anchor" href="#1211-shared_ptr"></a> 12.1.1 shared_ptr</h3>
<ul>
<li>
<p><code>make_shared()</code></p>
<ul>
<li>
<p>最安全的分配和使用动态内存的方法.</p>
</li>
<li>
<p>返回一个<code>shared_ptr</code>，指向函数在动态内存中分配的对象</p>
</li>
<li>
<p><code>#include &lt;memery&gt;</code></p>
</li>
<li>
<p>类似<code>emplace</code>，<code>make_shared()</code>用其参数构造给定类型的对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; ptr = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>,<span class="string">&#x27;9&#x27;</span>);<span class="comment">// 9999999999</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>shared_ptr</code></p>
<ul>
<li>自动销毁所管理的对象，自动释放关联的内存（析构函数）</li>
<li>如果是容器中的元素，不用时记得用erase删除</li>
<li>如果多个对象共享底层数据（使用动态内存的原因），当某个对象被销毁时，我们不能单方面地销毁底层数据</li>
</ul>
</li>
</ul>
<h3 id="1212-new-delete"><a class="markdownIt-Anchor" href="#1212-new-delete"></a> 12.1.2 new &amp; delete</h3>
<p>（原文：12.1.2 直接管理内存）</p>
<ul>
<li>
<p>直接管理内存的类不能依赖类对象的拷贝、赋值和销毁操作的任何默认定义。（相对于智能指针容易出错）</p>
</li>
<li>
<p>初始化方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">//默认构造</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(); <span class="comment">// 值初始化</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>); <span class="comment">// 传统构造方式</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">5</span>&#125;;<span class="comment">//列表初始化</span></span><br><span class="line"></span><br><span class="line">string *p = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">&#x27;9&#x27;</span>);<span class="comment">//*p为&quot;9999999999&quot;,注意&#x27;9&#x27;是单引号的字符</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>值初始化</p>
<ul>
<li>
<p>对于自定义构造函数会执行默认构造函数，默认/值初始化没有差别；</p>
</li>
<li>
<p>而对于<strong>内置类型， 建议使用值初始化</strong>，而不是默认初始化 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p0 = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//默认初始化，*p0的值未定义</span></span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="built_in">int</span>();<span class="comment">//值初始化，*p1=0</span></span><br><span class="line"></span><br><span class="line">string *p2 = <span class="keyword">new</span> string;<span class="comment">//string有默认构造函数，*p=&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>同样，对于自定义类中的那些依赖于编译器合成的默认构造函数的内置类型成员，如果未在类内被初始化，那么它们的值也是未定义的。</p>
</li>
<li>
<p>如果提供了括号包围的初始化器，则可以用auto</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">auto</span>(obj);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>动态分配const对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const int *pci = new const int; //错误</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *pci = <span class="keyword">new</span> <span class="type">const</span> <span class="built_in">int</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="type">const</span> string *pcs = <span class="keyword">new</span> <span class="type">const</span> string; <span class="comment">// string有默认构造函数，隐式初始化</span></span><br></pre></td></tr></table></figure>
<ul>
<li>类似其他任何 const 对象，一个动态分配的 const 对象必须进行初始化。</li>
<li>对于一个定义了默认构造函数的类类型，其const 动态对象可以隐式初始化，而其他类型的对象就必须显式初始化。</li>
<li>由于分配的对象是 const 的，new 返回的指针是一个指向const的指针。</li>
</ul>
</li>
<li>
<p>内存耗尽，会抛出<code>bab_alloc</code>异常，可以通过定位new的方式阻止其抛出异常</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">new</span> (nothrow) <span class="built_in">int</span>(); <span class="comment">//如果分配失败，返回一个空指针，而不是抛出异常</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>delete<br />
（书本P409~P411）都是在讲delete的用法，并没有特别的知识。需要注意的地方有：</p>
<ul>
<li>
<p>delete销毁给定的指针指向的对象，并释放其内存</p>
</li>
<li>
<p>delete之后，指针变为空悬指针，最好将指针置为nullptr</p>
</li>
<li>
<p>delete指向数组的指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> *p = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> *p1 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//delete p1;//只会删除数组中的一个元素</span></span><br><span class="line"><span class="keyword">delete</span>[] p1; <span class="comment">//告诉编译器，将要删除的是数组</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="1213-shared_ptr-new"><a class="markdownIt-Anchor" href="#1213-shared_ptr-new"></a> 12.1.3 shared_ptr &amp; new</h3>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402061545630.png" alt="202402061545630" /></p>
<ul>
<li>
<p>可以使用new通过值初始化的方式构造智能指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>接受指针参数的智能指针构造函数时explicit的，<strong>不能使用隐式转换构造指针指针</strong>，有如下几种<strong>错误情况</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*例1*/</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);<span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例2*/</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//return new int(p); // 错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(p)); <span class="comment">// 正确，显式转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例3*/</span>    <span class="comment">// &lt;-- 不要混用普通指针和智能指针，推荐使用make_shared</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(shared_ptr&lt;<span class="type">int</span>&gt; ptr)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------</span></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="type">int</span> *x = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line"><span class="comment">//process(x); //错误,不可隐式转换</span></span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(x)); <span class="comment">// 错误。虽然合法，但x在process结束时会被释放</span></span><br><span class="line"><span class="type">int</span> j = *x; <span class="comment">//未定义行为，x已经被释放</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------</span></span><br><span class="line"><span class="comment">//正确的写法</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="built_in">process</span>(p); <span class="comment">// 引用计数+1</span></span><br><span class="line"><span class="type">int</span> i = *p; <span class="comment">//仍然存在</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不要混用普通指针和智能指针，推荐使用make_shared。</p>
<ul>
<li>当将一个 shared_ptr 绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr。一旦这样做了，我们就<strong>不应该再使用内置指针来访问 shared_ptr所指向的内存了</strong>。如上例3错误写法所示。</li>
<li>也<strong>不要使用get初始化另一个智能指针或为智能指针赋值</strong>——<code>get()</code>返回内置指针，如果delete了，指针指针就失效了。<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402062126441.png" alt="image-20240206212657982" /></li>
</ul>
</li>
<li>
<p><code>reset()</code>用一个新的指针赋予一个shared_ptr，常与<code>unique()</code>（注意：是shared_ptr的成员函数，不是unique_ptr&lt;&gt;）一起用，来控制多个shared_ptr共享的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; a,b;</span><br><span class="line"><span class="function">shared_ptr&lt;string&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;x&quot;</span>))</span></span>;</span><br><span class="line">a = p, b = p;</span><br><span class="line"><span class="keyword">if</span>(!p.<span class="built_in">unique</span>())</span><br><span class="line">    p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p));</span><br><span class="line">*p+=<span class="built_in">string</span>(<span class="string">&quot;y&quot;</span>);</span><br><span class="line">cout&lt;&lt;*p&lt;&lt;endl; <span class="comment">// xy</span></span><br><span class="line">cout&lt;&lt;*a&lt;&lt;endl;  <span class="comment">//x</span></span><br><span class="line">cout&lt;&lt;*b&lt;&lt;endl;  <span class="comment">//x</span></span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402061628874.png" alt="image-20240206162851438" /></p>
</li>
</ul>
<h3 id="1214-智能指针-异常"><a class="markdownIt-Anchor" href="#1214-智能指针-异常"></a> 12.1.4 智能指针 &amp; 异常</h3>
<ul>
<li>
<p>如果在new和delete之间发生了异常，且异常没有在函数内部被捕获，new的内存就永远无法释放了——使用智能指针就不会有这样的问题。</p>
</li>
<li>
<p>智能指针陷阱<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402062201953.png" alt="image-20240206220131426" /></p>
</li>
<li>
<p>shared_ptr额外的用法 ——释放哑类（没有析构函数的类）<br />
（书P416）<br />
利用<code>shared_ptr</code>并指定删除器（<code>deleter</code>），当<code>func()</code>退出时（即使由于异常而退出），哑类对象也会被正常关闭</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">destination</span>&#123;&#125;;<span class="comment">//目的ip</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">connection</span>&#123;&#125;; </span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destination *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnect</span><span class="params">(connection)</span></span>; <span class="comment">// 断开connect连接（析构）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除器（deleter）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">end_disconnect</span><span class="params">(connection *p <span class="comment">/*指向 shared_ptr尖括号中类型  的指针*/</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">disconnect</span>(*p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(destination &amp;d)</span></span>&#123;</span><br><span class="line">    connection c = <span class="built_in">connect</span>(&amp;d);</span><br><span class="line">    <span class="comment">// 如果我们在f()退出前没有调用disconnect，就无法关闭c了</span></span><br><span class="line">    <span class="comment">// 利用shared_ptr并指定删除器，当f()退出时（即使由于异常而退出），connection也会被正常关闭，如下:</span></span><br><span class="line">    <span class="function">shared_ptr&lt;connection&gt; <span class="title">p</span><span class="params">(&amp;c, end_disconnect)</span></span>; <span class="comment">// 第二个参数指定自定义的删除器（指向函数的指针）</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1215-unique_ptr"><a class="markdownIt-Anchor" href="#1215-unique_ptr"></a> 12.1.5 unique_ptr</h3>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402062227111.png" alt="image-20240206222750628" /></p>
<ul>
<li>
<p>独占、“拥有”</p>
</li>
<li>
<p>初始化unique_ptr必须采用直接初始化形式。</p>
</li>
<li>
<p>不支持普通拷贝和赋值。但是有个例外：可以拷贝或赋值一个将要被销毁的unique_ptr，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt; (<span class="keyword">new</span> <span class="built_in">int</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(p))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>虽然不能拷贝和赋值unique_ptr，但是可以通过调用release或reset将指针的所有权转移（非const）</p>
<ul>
<li>
<p><code>reset</code>（重置）就是将<code>std::unique_ptr</code>指向新的资源。由于<code>std::unique_ptr</code>就是最后一个指向当前资源的智能指针，因此，在重置前需要销毁回收当前的资源。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;p3&quot;</span>))</span></span>;</span><br><span class="line">p2.<span class="built_in">reset</span>(p3.<span class="built_in">release</span>()); </span><br><span class="line"><span class="comment">// reset释放p2原来的指向的内存，并令p2指向内存</span></span><br><span class="line"><span class="comment">// release返回p3当前指向的内存地址后，令p3 == nullptr</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>release</code>函数可以释放所有权，并返回指向<code>std::unique_ptr</code>所管理的资源的指针。</p>
<ul>
<li>注意：<strong><code>release</code>仅仅释放了所有权，并没有销毁回收所管理的资源</strong>。而回收内存资源的责任交还给了使用者。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*例1*/</span></span><br><span class="line">p2.<span class="built_in">release</span>(); <span class="comment">//错误，p2不会释放内存，并且我们丢失了指针</span></span><br><span class="line"><span class="keyword">auto</span> p = p2.<span class="built_in">release</span>(); <span class="comment">// 正确，但要记得手动  delete p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例2*/</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;p3&quot;</span>))</span></span>;</span><br><span class="line">string *pstr = p3.<span class="built_in">release</span>();</span><br><span class="line">cout&lt;&lt;*pstr; <span class="comment">//终端输出： p3</span></span><br><span class="line"><span class="keyword">delete</span> pstr;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>书中示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;p1&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>; <span class="comment">//**release只是将p1置空（p1==nullptr），并没有销毁原来指向的内存**</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;p3&quot;</span>))</span></span>;</span><br><span class="line">p2.<span class="built_in">reset</span>(p3.<span class="built_in">release</span>()); <span class="comment">// reset释放p2原来的指向的内存，并令p2指向内存</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>参考文献</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/475823415">Effective Modern C++(18): std::unique_ptr - 知乎 (zhihu.com)</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p>向unique_ptr传递删除器</p>
<ul>
<li>
<p>与shared_ptr不同，需要在<code>&lt;&gt;</code>指定删除器函数类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;objType,<span class="title">decltype</span><span class="params">(deleteFunc)</span>*&gt; <span class="title">n</span><span class="params">(<span class="keyword">new</span> ObjType, deleteFunc)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用unique_ptr重写shared_ptr网络连接的例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">destination</span>&#123;&#125;;<span class="comment">//目的ip</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">connection</span>&#123;&#125;; </span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destination *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnect</span><span class="params">(connection)</span></span>; <span class="comment">// 断开connect连接（析构）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除器（deleter）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">end_disconnect</span><span class="params">(connection *p <span class="comment">/*指向 shared_ptr尖括号中类型  的指针*/</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">disconnect</span>(*p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(destination &amp;d)</span></span>&#123;</span><br><span class="line">    connection c = <span class="built_in">connect</span>(&amp;d);</span><br><span class="line">    <span class="comment">// 如果我们在f()退出前没有调用disconnect，就无法关闭c了</span></span><br><span class="line">    <span class="comment">// 利用unique_ptr并指定删除器，当f()退出时（即使由于异常而退出），connection也会被正常关闭，如下:</span></span><br><span class="line">    <span class="function">unique_ptr&lt;connection,<span class="title">decltype</span><span class="params">(end_disconnect)</span>*&gt; <span class="title">p</span><span class="params">(&amp;c, end_disconnect)</span></span>; <span class="comment">// 第二个参数指定自定义的删除器（指向函数的指针）</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="1216-weak_ptr"><a class="markdownIt-Anchor" href="#1216-weak_ptr"></a> 12.1.6 weak_ptr</h3>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402062228056.png" alt="image-20240206222828563" /></p>
<ul>
<li>
<p>weak_ptr的主要特点</p>
<blockquote>
<p>weak_ptr(见表 12.5)是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个 weak_ptr 绑定到一个 shared_ptr 不会改变shared_ptr的引用计数。一旦最后一个指向对象的 shared_ptr 被销毁，对象就会被释放。即使有 weak_ptr 指向对象，对象也还是会被释放，因此，weak_ptr 的名字抓住了这种智能指针“弱”共享对象的特点。</p>
</blockquote>
</li>
<li>
<p>weak_ptr需要用shared_ptr初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt; (<span class="number">42</span>);</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>调用<code>lock()</code>以使用weak_ptr</p>
<ul>
<li>
<p>由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用<code>lock()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(shared_ptr&lt;<span class="type">int</span>&gt; np = wp.<span class="built_in">lock</span>())&#123;</span><br><span class="line">    <span class="comment">// lock检查weak_ptr指向的对象是否存在；</span></span><br><span class="line">    <span class="comment">// 如果存在，返回指向共享对象的shared_ptr</span></span><br><span class="line">    <span class="comment">// 否则返回空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="122-动态数组"><a class="markdownIt-Anchor" href="#122-动态数组"></a> 12.2 动态数组</h2>
<p>建议使用容器，而不是动态分配的数组</p>
<h3 id="1221-new-数组"><a class="markdownIt-Anchor" href="#1221-new-数组"></a> 12.2.1 new &amp; 数组</h3>
<h4 id="一-两种声明方法"><a class="markdownIt-Anchor" href="#一-两种声明方法"></a> 一、两种声明方法</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="comment">// 法1</span></span><br><span class="line"><span class="type">int</span> *pia = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">42</span>]; <span class="comment">// 必须指定大小，必须是整形，但不一定是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 法2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> arrT[<span class="number">42</span>];</span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> arrT ;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>分配一个数组会得到一个元素类型的指针，分配的内存不是数组类型。</p>
<ul>
<li>
<p>不能调用begin和end</p>
</li>
<li>
<p>不能使用范围for</p>
</li>
<li>
<p>原文</p>
<blockquote>
<p>分配一个数组会得到一个元素类型的指针</p>
<p>虽然我们通常称 new T[]分配的内存为“动态数组”，但这种叫法某种程度上有些误导。当用 new 分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。即使我们使用类型别名定义了一个数组类型，new 也不会分配一个数组类型的对象。在上例中，我们正在分配一个数组的事实甚至都是不可见的一一连[num]都没有。new 返回的是一个元素类型的指针。</p>
<p>由于分配的内存并不是一个数组类型，因此不能对动态数组调用 begin 或end(参见3.5.3 节，第106 页)。这些函数使用数组维度(回忆一下，维度是数组类型的一部分)来返回指向首元素和尾后元素的指针。出于相同的原因，也不能用范围 for 语句来处理所谓的)动态数组中的元素。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="二-初始化"><a class="markdownIt-Anchor" href="#二-初始化"></a> 二、初始化</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pia = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">42</span>];  <span class="comment">// 10个未初始化的int。内置类型未初始化，其中的值是未定义的</span></span><br><span class="line"><span class="type">int</span> *pia2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">42</span>]();</span><br><span class="line"><span class="type">int</span> *pia3 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">string *psa = <span class="keyword">new</span> string[<span class="number">10</span>];  <span class="comment">// 10个值初始化的空stirng，string中有默认构造函数</span></span><br><span class="line">string *psa2 = <span class="keyword">new</span> string[<span class="number">10</span>]();</span><br><span class="line">string *psa3 = <span class="keyword">new</span> string[<span class="number">10</span>]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>,<span class="built_in">string</span>(<span class="number">3</span>,<span class="string">&#x27;x&#x27;</span>)&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>如果，初始化器中数目大于指定的元素数，new失败，不会分配任何内存，抛出<code>bad_array_new_length</code>异常（<code>#include &lt;new&gt;</code>）</p>
</li>
<li>
<p>虽然我们可用空括号对数组中的元素进行值初始化，但不能在括号中给出初始化器。意味着不能用auto分配数组——笔记<a href="#12.1.2-new-&amp;-delete">12.1.2 new &amp; delete</a>节–&gt;值初始化–&gt;第4小点</p>
</li>
<li>
<p>动态分配一个空数组是合法的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[<span class="number">0</span>]; <span class="comment">// 错误，不能定义长度为0的数组</span></span><br><span class="line"><span class="type">char</span> *cp = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">0</span>]; <span class="comment">//正确，但cp不能解引用。可用于循环的比较操作，如下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*动态分配一个空数组，用于循环的比较操作*/</span></span><br><span class="line"><span class="type">size_t</span> n = <span class="built_in">get_size</span>();</span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[n];  <span class="comment">// n为0，算法依然成立</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> *q = p; q != p+n; ++q)&#123;</span><br><span class="line">    <span class="comment">/*处理数组*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="三-释放动态数组"><a class="markdownIt-Anchor" href="#三-释放动态数组"></a> 三、释放动态数组</h4>
<p>必须带有方括号，不论是那种初始化形式。例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pia2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">42</span>]();</span><br><span class="line"><span class="keyword">delete</span>[] pia2;</span><br></pre></td></tr></table></figure>
<h4 id="四-智能指针和动态数组"><a class="markdownIt-Anchor" href="#四-智能指针和动态数组"></a> 四、智能指针和动态数组</h4>
<ul>
<li>
<p>unique_ptr</p>
<ul>
<li>
<p>标准库提供了一个  管理new分配的数组的   unique_ptr版本，销毁时将自动调用<code>delete[]</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    unique_ptr&lt;int[]&gt; up = new int[10]; //No viable conversion from &#x27;int *&#x27; to &#x27;unique_ptr&lt;int[]&gt;&#x27;</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> p = up.<span class="built_in">release</span>(); <span class="comment">// 书P425说的是销毁其*指针*，而不是说销毁指针指向的元素</span></span><br><span class="line">cout&lt;&lt;*p; <span class="comment">//终端输出： 1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>也可以使用下标运算符，但不支持  点和箭头  运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)&#123;</span><br><span class="line">    up[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>unique_ptr管理数组的方式汇总<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402071759152.png" alt="image-20240207175919576" /></p>
</li>
</ul>
</li>
<li>
<p>shared_ptr</p>
<p>shared_ptr不直接支持动态管理数组，需要我们：1）提供删除器；2）使用<code>get()</code>获取数组首元素指针，以访问数组中的元素。</p>
<ul>
<li>
<p>提供删除器（否则，shared_ptr将用delete销毁其所指向的对象）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span> *p)&#123; <span class="keyword">delete</span>[] p; &#125;)</span></span>;</span><br><span class="line">sp.<span class="built_in">reset</span>();<span class="comment">// 将调用我们提供的删除器</span></span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402071812706.png" alt="202402071812706" /></p>
</li>
<li>
<p>使用<code>get()</code>获取数组首元素指针，以访问数组中的元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)&#123;</span><br><span class="line">    *(sp.<span class="built_in">get</span>() + i) = i; <span class="comment">// 使用get()获得内置指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="1222-allocator类"><a class="markdownIt-Anchor" href="#1222-allocator类"></a> 12.2.2 allocator类</h3>
<ul>
<li><code>#include &lt;memory&gt;</code></li>
<li>目的：先分配内存，在需要的时候再在该内存创建对象。（区别于new等同时分配内存和创建对象）</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402072147044.png" alt="image-20240207214733502" /></p>
<ul>
<li>
<p>基础用法示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">    allocator&lt;string&gt; alloc; <span class="comment">// 可以分配string内存的allocator对象</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> p = alloc.<span class="built_in">allocate</span>(n); <span class="comment">// 分配5个未初始化的string的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> q = p; <span class="comment">// q指向构造元素之后的位置</span></span><br><span class="line">    <span class="comment">// construct(指向当前要填充位置的指针，...构造函数所需的参数...)</span></span><br><span class="line">    alloc.<span class="built_in">construct</span>(q++); <span class="comment">// *q为空字符串</span></span><br><span class="line">    alloc.<span class="built_in">construct</span>(q++,<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>); <span class="comment">//*q为&quot;cccccccccc&quot;</span></span><br><span class="line">    alloc.<span class="built_in">construct</span>(q++,<span class="string">&quot;hi&quot;</span>); <span class="comment">// *q为&quot;hi&quot;</span></span><br><span class="line"><span class="comment">//  cout&lt;&lt;*q&lt;&lt;endl;//灾难：q指向未构造的内存，不能在未构造的情况下使用原始内存</span></span><br><span class="line">    cout&lt;&lt;*(q<span class="number">-1</span>)&lt;&lt;endl; <span class="comment">//hi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当我们用完对象后，必须对每个构造的元素调用destroy()销毁</span></span><br><span class="line">    <span class="keyword">while</span> (q != p)</span><br><span class="line">        alloc.<span class="built_in">destroy</span>(--q); <span class="comment">// 只能对真正构造了的元素调用destory</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一旦元素销毁，就可以用该内存保存其他的string元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序结束，释放alloc申请的内存（要先对所有元素destory）</span></span><br><span class="line">    alloc.<span class="built_in">deallocate</span>(p,n); <span class="comment">// p必须指向由allocate分配的内存，n必须等于allocate分配的大小</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>拷贝和填充未初始化的内存<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402072209158.png" alt="image-20240207220937592" /></p>
<ul>
<li>
<p>书中例子：作为一个例子，假定有一个 int 的 vector，希望将其内容拷贝到动态内存中。我们将分配一块比 vector 中元素所占用空间大一倍的动态内存，然后将原 vector 中的元素拷贝到前一半空间，对后一半空间用一个给定值进行填充:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    allocator&lt;<span class="type">int</span>&gt; alloc;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> p = alloc.<span class="built_in">allocate</span>(v.<span class="built_in">size</span>() * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> q = <span class="built_in">uninitialized_copy</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(), p);</span><br><span class="line">    <span class="comment">// p:第三个参数**必须指向未构造的内存**</span></span><br><span class="line">    <span class="comment">// q:指向最后一个构造的元素之后的位置</span></span><br><span class="line"></span><br><span class="line">    q = <span class="built_in">uninitialized_fill_n</span>(q,v.<span class="built_in">size</span>(), <span class="number">42</span>);</span><br><span class="line">    <span class="comment">// 在目的指针（q）指向的内存中创建给定数目（v.size()）个对象，用给定的值（42）对他们进行初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p!=q)&#123;</span><br><span class="line">        cout&lt;&lt;*(--q)&lt;&lt;<span class="string">&quot; &quot;</span>;  <span class="comment">//输出： 42 42 42 42 42 4 3 2 1 0</span></span><br><span class="line">        alloc.<span class="built_in">destroy</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alloc.<span class="built_in">deallocate</span>(q,v.<span class="built_in">size</span>()*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="跳过的书中例子的记录"><a class="markdownIt-Anchor" href="#跳过的书中例子的记录"></a> 跳过的书中例子的记录</h2>
<p>P391 一个单词转换的map</p>
<p>P404 ~ P406 StrBlob类<br />
P420底部 ~ P422 核查指针类 —— 为StrBlob定义一个伴随指针类</p>
<p>P432 ~ P435 文本查询类的定义</p>
<div align="center"><h1>------类设计者工具------</h1></div>
<h1 id="十三-拷贝控制"><a class="markdownIt-Anchor" href="#十三-拷贝控制"></a> 十三 拷贝控制</h1>
<blockquote>
<p>拷贝构造、拷贝赋值和析构  ：big three  —— 侯捷《面向对象高级编程》</p>
</blockquote>
<p>13.1,13.2：拷贝</p>
<p>13.4：移动</p>
<h2 id="131-拷贝-赋值和析构"><a class="markdownIt-Anchor" href="#131-拷贝-赋值和析构"></a> 13.1 拷贝、赋值和析构</h2>
<h3 id="1311-拷贝构造"><a class="markdownIt-Anchor" href="#1311-拷贝构造"></a> 13.1.1 拷贝构造</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(); <span class="comment">//默认构造</span></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;); <span class="comment">// 拷贝构造</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数必须是自身类型的<strong>引用</strong>，且几乎总是一个const，且额外参数都有默认值</li>
<li>不应该是<code>explicit</code></li>
<li>static成员不被拷贝（拷贝每个非static成员）</li>
</ul>
<h4 id="一拷贝初始化"><a class="markdownIt-Anchor" href="#一拷贝初始化"></a> 一：拷贝初始化</h4>
<p><strong>拷贝初始化依靠拷贝构造函数或移动构造函数来完成。——<a href="#13433-%E5%90%88%E6%88%90%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C">左值拷贝，右值移动</a></strong></p>
<p>拷贝初始化的发生条件：</p>
<ul>
<li>
<p><code>=</code></p>
</li>
<li>
<p>作为实参  传递给一个非引用的形参</p>
</li>
<li>
<p>返回类型为非引用的函数  返回一个对象</p>
</li>
<li>
<p>列表初始化一个数组的元素或一个聚合类中的成员</p>
</li>
<li>
<p>标准库容器调用insert或push等</p>
</li>
</ul>
<h4 id="二拷贝初始化的限制"><a class="markdownIt-Anchor" href="#二拷贝初始化的限制"></a> 二：拷贝初始化的限制</h4>
<p>总结：主要是针对<code>explicit</code>的限制，拷贝构造不可隐式转化，可直接构造为临时对象再使用   --&gt;  当传递一个实参或从函数返回一个值时，不可隐式使用explicit，需要像<code>示例2</code>最后一行一样使用。</p>
<p>参考：</p>
<p>[1] <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/copy_initialization">Copy-initialization</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/gqtcgq/p/7189888.html">C++复制初始化的限制 —— 对[1]的翻译 </a></p>
<p>相比于直接初始化，复制初始化有更加严格的限制。</p>
<p>1：<strong>在复制初始化时，不能使用声明为explicit的构造函数进行的隐式转换。而直接初始化则是允许的：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Exp</span> &#123; <span class="function"><span class="keyword">explicit</span> <span class="title">Exp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span> </span>&#123;&#125; &#125;; <span class="comment">// not convertible from const char*</span></span><br><span class="line"><span class="function">Exp <span class="title">e1</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;  <span class="comment">// OK</span></span><br><span class="line">Exp e2 = <span class="string">&quot;abc&quot;</span>; <span class="comment">// Error, copy-initialization does not consider explicit constructor</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Imp</span> &#123; <span class="built_in">Imp</span>(<span class="type">const</span> <span class="type">char</span>*) &#123;&#125; &#125;; <span class="comment">// convertible from const char*</span></span><br><span class="line"><span class="function">Imp <span class="title">i1</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;  <span class="comment">// OK</span></span><br><span class="line">Imp i2 = <span class="string">&quot;abc&quot;</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Exp类中的构造函数声明为了explicit，因此，复制初始化Exp e2 = &quot;abc&quot;将会发生编译错误：error: conversion from ‘const char [4]’ to non-scalar type ‘Exp’ requested.</p>
</li>
<li>
<p>Imp类中的构造函数没有声明为explicit，因此，可以用字符串”abc”进行直接初始化或复制初始化Imp的对象。</p>
</li>
</ul>
<p>2：<strong>在复制初始化中，使用隐式转换时，必须是从初始化器（=右边的表达式）可以直接转换为被初始化对象，而不是间接的。在直接初始化中，可以使用从初始化器到构造函数参数的隐式转换。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123; <span class="built_in">S</span>(std::string) &#123;&#125; &#125;; <span class="comment">// implicitly convertible from std::string</span></span><br><span class="line"> </span><br><span class="line"><span class="function">S <span class="title">s1</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>; <span class="comment">// OK: conversion from const char[4] to std::string</span></span><br><span class="line">S s2 = <span class="string">&quot;abc&quot;</span>; <span class="comment">// Error: no conversion from const char[4] to S</span></span><br><span class="line">S s3 = std::<span class="built_in">string</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">// OK: conversion from std::string to S</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>类S有一个接受std::string参数的构造函数，因此，可以使用”const char*”直接初始化S的对象s1。这里的转换序列是：const char* à std::string à struct S；</p>
</li>
<li>
<p>复制初始化中，则不允许这种转换，因为它不是直接转换，而是间接转换，因此，s2的初始化就会发生编译错误；</p>
</li>
<li>
<p>复制初始化中，可以使用直接隐式转换，因此，可以使用std::string的对象，初始化s3。</p>
</li>
</ul>
<h4 id="三编译器可以绕过拷贝构造函数"><a class="markdownIt-Anchor" href="#三编译器可以绕过拷贝构造函数"></a> 三：编译器可以绕过拷贝构造函数</h4>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/uangyy/p/5516935.html">参考文献</a></p>
<p>C++ primer P442 P447:在拷贝初始化过程中，编译器可以跳过拷贝构造函数，直接创建对象。即，编译器允许将下面的代码</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string null_book = <span class="string">&quot;999&quot;</span>;　　<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>改写为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">null_book</span><span class="params">(<span class="string">&quot;999&quot;</span>)</span></span>;　　<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>由于string的构造函数不是一个explicit的，所以说string类型允许从const char* 到string的隐式转换。</p>
<p>在行1中，首先将&quot;999&quot;隐式转化为一个string的临时对象，然后应该调用string的拷贝构造函数对null_book初始化。即</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">temp_str</span><span class="params">(<span class="string">&quot;999&quot;</span>)</span></span>;</span><br><span class="line">string null_book = temp_str;    <span class="comment">//或者 string null_book(temp_str);</span></span><br></pre></td></tr></table></figure>
<p><strong>在这里编译器会进行优化，跳过拷贝构造函数直接创建对象，使临时变量直接成为所要创建的对象</strong>。</p>
<p>类似的下面代码也会跳过拷贝构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="built_in">string</span>();</span><br></pre></td></tr></table></figure>
<p>但是在这种情况下，拷贝构造函数必须是public的，否则编译会不通过。可能是因为如果拷贝构造函数是private的话，编译器会理解为不能够使用拷贝构造函数，进而不会进行这种优化。</p>
<h3 id="1312-拷贝赋值"><a class="markdownIt-Anchor" href="#1312-拷贝赋值"></a> 13.1.2 拷贝赋值</h3>
<ul>
<li>在类中重载<code>=</code>运算符，必须是成员函数</li>
<li>通常应该<strong>返回指向其左侧运算对象的引用</strong></li>
<li>标准库通常要求保存在容器中的类型要具有赋值运算符</li>
<li>将右侧的非static成员赋予左侧（xxx除外）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo &amp;f)&#123;</span><br><span class="line">        <span class="comment">//this-&gt;xxx = f.xxx;</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：将于<a href="#132-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86">笔记13.2</a>详细说明</p>
<ul>
<li>拷贝赋值运算符与往常一样执行类似拷贝构造函数和析构函数的工作。即，它必须递增右侧运算对象的引用计数(即，拷贝构造函数的工作)，并递减左侧运算对象的引用计数，在必要时释放使用的内存(即，析构函数的工作)。</li>
<li>必须处理自赋值（自己赋值给自己）</li>
</ul>
<h3 id="1313-析构函数"><a class="markdownIt-Anchor" href="#1313-析构函数"></a> 13.1.3 析构函数</h3>
<h4 id="13131-什么时候需要析构函数"><a class="markdownIt-Anchor" href="#13131-什么时候需要析构函数"></a> 13.1.3.1 什么时候需要析构函数</h4>
<blockquote>
<p>什么时候需要析构函数？一般是成员通过new动态申请了内存的时候。（管理类外资源的类）</p>
<p>因为：隐式销毁一个内置指针类型的成员不会delete它所指向的对象。</p>
</blockquote>
<h4 id="13132-什么时候调用析构函数"><a class="markdownIt-Anchor" href="#13132-什么时候调用析构函数"></a> 13.1.3.2 什么时候调用析构函数？</h4>
<p>变量在离开其作用域时被销毁。</p>
<ul>
<li>当一个对象被销毁时，其成员被销毁</li>
<li>容器（包括数组）被销毁时，其元素被销毁</li>
<li>对于动态分配的对象,当对指向它的指针应用delete运算符时被销毁(参见12.1.2节，第409页)。</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁</li>
</ul>
<p>析构函数调用过程（P446）</p>
<p>如同构造函数有一个初始化部分和一个函数体，析构函数也有一个函数体和一个析构部分。</p>
<ul>
<li>在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。</li>
<li>在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。</li>
</ul>
<blockquote>
<p><strong>要认识到析构函数体自身并不直接销毁成员是非常重要的：成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。</strong></p>
</blockquote>
<h4 id="13133-三五法则"><a class="markdownIt-Anchor" href="#13133-三五法则"></a> 13.1.3.3 三/五法则</h4>
<p><strong>需要析构函数的类也需要拷贝构造和拷贝赋值</strong></p>
<p><strong>需要拷贝构造的类也需要拷贝赋值，反之亦然。但不必然要求析构函数。</strong></p>
<h3 id="1314-控制是否使用默认合成函数"><a class="markdownIt-Anchor" href="#1314-控制是否使用默认合成函数"></a> 13.1.4 控制是否使用默认（合成）函数</h3>
<h4 id="13141-default-delete"><a class="markdownIt-Anchor" href="#13141-default-delete"></a> 13.1.4.1 <code>=default</code> &amp; <code>=delete</code></h4>
<ul>
<li>
<p>显式地要求编译器使用默认版本：<code>=default</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;  <span class="comment">// 类内 = default将被声明为内联</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> Sales_data &amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Sales_data &amp;);</span><br><span class="line">    ~<span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>=(<span class="type">const</span> Sales_data &amp;) = <span class="keyword">default</span>; <span class="comment">// 这样写就不是内联</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>阻止拷贝：<code>=delete</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">noCopy</span>&#123;</span><br><span class="line">    <span class="built_in">noCopy</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">noCopy</span>(<span class="type">const</span> noCopy &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    noCopy &amp; <span class="keyword">operator</span>=(<span class="type">const</span> noCopy &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">noCopy</span>() = <span class="keyword">default</span>; <span class="comment">//析构函数不能是=delete，否则会导致一系列问题</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>何时阻止拷贝？例如：iostream类阻止了拷贝，以避免多个对象读取或写入相同的io缓冲</li>
<li><code>=delete</code>必须出现在函数第一次声明的时候</li>
<li>可以对任何函数<code>=delete</code>：用于引导函数匹配过程。<strong>（析构函数除外)</strong></li>
<li>对上一点的补充：<strong>析构函数不能是<code>=delete</code></strong>，否则
<ul>
<li>1)无法定义该类型的变量或临时对象；且如果它被包含进另一个类，则导致外层的类也不能定义变量或临时对象</li>
<li>2)无法释放指向该类型的动态分配到指针（可以new但不能delete）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="13142-何时合成的拷贝控制成员被定义为删除"><a class="markdownIt-Anchor" href="#13142-何时合成的拷贝控制成员被定义为删除"></a> 13.1.4.2 何时合成的拷贝控制成员被定义为删除</h4>
<p>（P450）❓有点乱</p>
<ul>
<li>如果<strong>类的某个成员的析构函数是删除的或不可访问的</strong>(例如，是 private 的),则类的合成析构函数被定义为删除的。</li>
<li>如果<strong>类的某个成员的拷贝构造函数是删除的或不可访问的</strong>，则类的合成拷贝构造函数被定义为删除的。如果<strong>类的某个成员的析构函数是删除的或不可访问</strong>的，则类合成的拷贝构造函数也被定义为删除的。</li>
<li>如果<strong>类的某个成员的拷贝赋值运算符是删除的或不可访问的,或是类有一个const的或引用成员</strong>，则类的合成拷贝赋值运算符被定义为删除的。</li>
<li>如果<strong>类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器(参见2.6.1节，第65页)，或是类有一个 const 成员，它没有类内初始化器且其类型未显式定义默认构造函数</strong>，则该类的默认构造函数被定义为删除的。</li>
</ul>
<p>总结：<strong>本质上，如果一个类中，存在某个数据成员不能默认构造、拷贝、赋值或销毁，则该类对应的成员函数将被定义为删除（=delete）。</strong></p>
<ul>
<li>类中存在引用成员或无法默认构造的const成员类，编译器不会合成<em>默认构造函数</em>。</li>
<li>类中存在引用成员或无法默认构造的const成员类，编译器不会合成<em>拷贝赋值运算符</em>。</li>
</ul>
<h4 id="13143-private拷贝控制"><a class="markdownIt-Anchor" href="#13143-private拷贝控制"></a> 13.1.4.3 private拷贝控制</h4>
<p>没有<code>=delete</code>前（c++11前），通过声明（但不定义）private的拷贝构造和拷贝赋值，可以阻止任何拷贝该类对象的企图。</p>
<ul>
<li>private：试图拷贝对象的用户代码将在编译阶段被标记为错误</li>
<li>不定义：成员函数或友元函数中的拷贝操作将会导致链接错误</li>
</ul>
<h2 id="132-拷贝控制和资源管理"><a class="markdownIt-Anchor" href="#132-拷贝控制和资源管理"></a> 13.2 拷贝控制和资源管理</h2>
<p>管理类外资源的类有两种拷贝方式：（a）拷贝指针指向的对象；（b）拷贝指针本身。</p>
<h3 id="1321-行为像值的类拷贝指针指向的对象"><a class="markdownIt-Anchor" href="#1321-行为像值的类拷贝指针指向的对象"></a> 13.2.1 行为像值的类——拷贝指针指向的对象</h3>
<p>一</p>
<ul>
<li>定义一个拷贝构造函数，完成string 的拷贝，而不是拷贝指针</li>
<li>定义一个析构函数来释放string</li>
<li>定义一个拷贝赋值运算符来释放对象当前的 string，并从右侧运算对象拷贝string</li>
</ul>
<p>二</p>
<p>其中，尤其需要<strong>注意拷贝赋值的写法</strong>：</p>
<ul>
<li>
<p>拷贝赋值运算符组合了类似拷贝构造函数和析构函数的工作：</p>
<ul>
<li>
<p>赋值运算符左侧：销毁左侧运算对象的资源——（析构函数的构造）</p>
</li>
<li>
<p>赋值运算符右侧：从右侧运算对象拷贝数据到左侧运算对象——（拷贝构造的工作）</p>
</li>
</ul>
</li>
<li>
<p>必须处理自赋值</p>
</li>
<li>
<p>需要异常安全——当异常发生时，能将左侧运算对象置于一个有意义的状态</p>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402201501741.png" alt="202402201501741" /></p>
<p>三</p>
<p>示例如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> string&amp; s = <span class="built_in">string</span>()) :</span><br><span class="line">        <span class="built_in">ps</span>(<span class="keyword">new</span> <span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>) &#123;&#125; <span class="comment">// 构造</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr&amp; p) :</span><br><span class="line">        <span class="built_in">ps</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p.ps)), <span class="built_in">i</span>(p.i) &#123;&#125;  <span class="comment">// 拷贝构造</span></span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp; p); <span class="comment">// &lt;-特别需要注意拷贝赋值</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">HasPtr</span>() &#123; <span class="keyword">delete</span> ps; &#125;  <span class="comment">//析构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string* ps;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span>(*p.ps); <span class="comment">// 现将数据保存在额外的空间中，避免因自赋值而将自身销毁</span></span><br><span class="line">    <span class="keyword">delete</span> ps; <span class="comment">// 先释放当前对象指针指向的空间</span></span><br><span class="line">    ps = newp; <span class="comment">// 后从右侧对象拷贝数据</span></span><br><span class="line">    i = p.i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*错误案例*/</span></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*如果有如下情况，ps将会指向无效内存：</span></span><br><span class="line"><span class="comment">    * HasPtr a；</span></span><br><span class="line"><span class="comment">    * a = a;</span></span><br><span class="line"><span class="comment">    * 调用operator=时，先将a.ps销毁了，又让a.ps指向了已经被销毁的空间，而产生未定义行为</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    ps = <span class="keyword">new</span> <span class="built_in">string</span>(*(p.ps));</span><br><span class="line">    i = p.i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1322-行为像指针的类拷贝指针本身"><a class="markdownIt-Anchor" href="#1322-行为像指针的类拷贝指针本身"></a> 13.2.2 行为像指针的类——拷贝指针本身</h3>
<p>同样要注意拷贝赋值的写法：</p>
<ul>
<li>
<p>拷贝赋值运算符组合了类似拷贝构造函数和析构函数的工作：</p>
<ul>
<li>
<p>需要递增右侧运算对象的引用计数（拷贝构造）</p>
</li>
<li>
<p>递减左侧运算对象的引用计数，并在必要时释放资源（析构）</p>
</li>
</ul>
</li>
<li>
<p>处理自赋值</p>
</li>
<li>
<p>异常安全</p>
</li>
</ul>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> string&amp; s = <span class="built_in">string</span>()) :</span><br><span class="line">        <span class="built_in">ps</span>(<span class="keyword">new</span> <span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>) ,<span class="built_in">use</span>(<span class="keyword">new</span> <span class="built_in">size_t</span>(i))&#123;&#125; <span class="comment">//构造</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr&amp; p) :</span><br><span class="line">        <span class="built_in">ps</span>(p.ps), <span class="built_in">i</span>(p.i), <span class="built_in">use</span>(p.use) &#123; ++*use; &#125; <span class="comment">// 拷贝构造</span></span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp; p); <span class="comment">// 拷贝赋值</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">HasPtr</span>() &#123; </span><br><span class="line">        <span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123; <span class="comment">// 如果引用计数变为0，则释放内存</span></span><br><span class="line">            <span class="keyword">delete</span> ps;</span><br><span class="line">            <span class="keyword">delete</span> use;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string* ps;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span>* use; <span class="comment">// 引用计数器，保存在动态内存中</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    ++*p.use; <span class="comment">// 递增右侧运算对象的引用计数，可以避免自赋值被销毁：当=两边相同时，在递减之前，计数器已经被递增过了</span></span><br><span class="line">    <span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123; <span class="comment">// 递减左对象的引用计数</span></span><br><span class="line">        <span class="keyword">delete</span> ps;</span><br><span class="line">        <span class="keyword">delete</span> use;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;ps = p.ps;</span><br><span class="line">    <span class="keyword">this</span>-&gt;i = p.i;</span><br><span class="line">    <span class="keyword">this</span>-&gt;use = p.use;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1323-交换操作"><a class="markdownIt-Anchor" href="#1323-交换操作"></a> 13.2.3 交换操作</h3>
<blockquote>
<p>与拷贝控制成员不同，swap并不是必要的。但是，对于分配了资源的类，定义swap可能是一种很重要的优化手段。</p>
</blockquote>
<h4 id="一编写自定义swap"><a class="markdownIt-Anchor" href="#一编写自定义swap"></a> 一：编写自定义<code>swap</code></h4>
<p>两个类型交换的传统做法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HasPtr tmp = v1;</span><br><span class="line">v1 = v2;</span><br><span class="line">v2 = tmp;</span><br></pre></td></tr></table></figure>
<p>可通过重载<code>swap</code>的默认行为，实现两个自定义类的交换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;, HasPtr &amp;)</span></span>; <span class="comment">// 定义为友元以访问类的private成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;l, HasPtr &amp;r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(l.ps, r.ps); <span class="comment">// 交换指针</span></span><br><span class="line">    <span class="built_in">swap</span>(l.i,r.i); <span class="comment">// 交换int成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用HasPtr定义的<code>swap</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(Foo &amp;, Foo &amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HasPtr h;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Foo &amp;r, Foo &amp;l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(r.h, l.h); <span class="comment">// 自定义版本的swap优先级高于std::swap, 此处会调用类中重载的版本</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换Foo的其他成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议使用<code>using std::swap</code>的写法：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402201622418.png" alt="image-20240220162159834" /></p>
<h4 id="二在赋值构造中使用swap"><a class="markdownIt-Anchor" href="#二在赋值构造中使用swap"></a> 二：在赋值构造中使用<code>swap</code></h4>
<p>拷贝交换技术：将左侧运算对象与右侧运算对象的一个副本进行交换。</p>
<p>优势：自动处理了自赋值情况  且  天然异常安全。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HasPtr &amp; HasPtr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr rhs)&#123; <span class="comment">// &lt;-注意：参数以值方式传递</span></span><br><span class="line">    <span class="built_in">swap</span>(*<span class="keyword">this</span>,rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// rhs被销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="133-两个例子"><a class="markdownIt-Anchor" href="#133-两个例子"></a> 13.3 两个例子</h2>
<h3 id="1331-拷贝控制示例"><a class="markdownIt-Anchor" href="#1331-拷贝控制示例"></a> 13.3.1 拷贝控制示例</h3>
<p>Message.hpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Folder.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Folder</span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(Message&amp; l, Message&amp; r)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Message</span><span class="params">(<span class="type">const</span> string str = <span class="string">&quot;&quot;</span>)</span></span></span><br><span class="line"><span class="function">        :contents(str) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Message</span>(<span class="type">const</span> Message&amp;);<span class="comment">//拷贝构造</span></span><br><span class="line">    Message&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Message&amp;);</span><br><span class="line">    ~<span class="built_in">Message</span>() &#123; <span class="built_in">remove_from_folders</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从给定folder中添加/删除本message</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">(Folder&amp; f)</span> </span>&#123; <span class="keyword">this</span>-&gt;folders.<span class="built_in">insert</span>(&amp;f); f.<span class="built_in">addMsg</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Folder&amp; f)</span> </span>&#123; <span class="keyword">this</span>-&gt;folders.<span class="built_in">erase</span>(&amp;f); f.<span class="built_in">remMsg</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    string contents;</span><br><span class="line">    set&lt;Folder*&gt; folders; <span class="comment">// 包含本message的folder</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_to_folders</span><span class="params">(<span class="type">const</span> Message&amp;m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将本message添加到指向m的folder中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> f : m.folders) &#123;</span><br><span class="line">            f-&gt;<span class="built_in">addMsg</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove_from_folders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> f : <span class="keyword">this</span>-&gt;folders) &#123;</span><br><span class="line">            f-&gt;<span class="built_in">remMsg</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Message::<span class="built_in">Message</span>(<span class="type">const</span> Message&amp;m)</span><br><span class="line">    :<span class="built_in">contents</span>(m.contents), <span class="built_in">folders</span>(m.folders)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">add_to_folders</span>(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Message&amp; Message::<span class="keyword">operator</span>=(<span class="type">const</span> Message&amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">remove_from_folders</span>();</span><br><span class="line">    contents = r.contents;</span><br><span class="line">    folders = r.folders;</span><br><span class="line">    <span class="built_in">add_to_folders</span>(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Message&amp; l, Message&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将每个消息的指针从它（原来）所在的Folder中删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f: l.folders)</span><br><span class="line">        f-&gt;<span class="built_in">remMsg</span>(&amp;l);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : r.folders)</span><br><span class="line">        f-&gt;<span class="built_in">remMsg</span>(&amp;r);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(l.folders, r.folders); <span class="comment">// 交换set</span></span><br><span class="line">    <span class="built_in">swap</span>(l.contents, r.contents); <span class="comment">// 交换string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将每个Message的指针添加到它的（新）Folder中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1332-动态内存管理类"><a class="markdownIt-Anchor" href="#1332-动态内存管理类"></a> 13.3.2 动态内存管理类</h3>
<p>StrVec类</p>
<h2 id="134-️对象移动"><a class="markdownIt-Anchor" href="#134-️对象移动"></a> 13.4 ⭐️对象移动</h2>
<p>（书P470）</p>
<p>为何使用移动？</p>
<ul>
<li>
<p>**提升性能。**在某些情况下，对象拷贝后机立即被销毁了，在这种情况下，移动而非拷贝对象会大幅度提升性能。</p>
</li>
<li>
<p><strong>不能被共享的资源（io类或unique_ptr），不可被拷贝但可以移动。</strong></p>
<blockquote>
<p>在旧 C++标准中，没有直接的方法移动对象。因此，即使不必拷贝对象的情况下，我们也不得不拷贝。如果对象较大，或者是对象本身要求分配内存空间(如 string)，进行不必要的拷贝代价非常高。类似的，在旧版本的标准库中，容器中所保存的类必须是可拷贝的。但在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能被移动即可。</p>
</blockquote>
</li>
</ul>
<h3 id="1341-什么是右值引用"><a class="markdownIt-Anchor" href="#1341-什么是右值引用"></a> 13.4.1 什么是右值引用</h3>
<h4 id="一-左值和右值"><a class="markdownIt-Anchor" href="#一-左值和右值"></a> 一、左值和右值</h4>
<p>左值：表示一个对象的身份，通常<strong>可以被取地址</strong>。</p>
<ul>
<li>左值引用的作用对象：不能将左值引用绑定到要求转换的表达式、字面值常量、返回右值的表达式。</li>
</ul>
<p>右值：表示一个对象的值，通常<strong>无法取地址</strong>。</p>
<ul>
<li>右值引用的作用对象：不能将右值引用直接绑定到左值，如必须要绑定，则要先用<code>std::move</code>将左值转换成右值，再右值引用。</li>
</ul>
<p>左值和右值的对比：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/1708483132022.png" alt="20240221103743320" /></p>
<h4 id="二-右值引用"><a class="markdownIt-Anchor" href="#二-右值引用"></a> 二、右值引用</h4>
<p>右值引用就是<strong>必须绑定到右值</strong>的引用，通过<code>&amp;&amp;</code>表示。</p>
<p>右值引用的一个重要性质：只能绑定到一个将要销毁的对象上，从而将一个右值引用的资源“移动”到另一个对象上。</p>
<p>示例</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402211708483950.png" alt="image-20240221105229193" style="zoom:80%;" />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp;&amp; rr1 = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span>&amp;&amp; rr2 = std::<span class="built_in">move</span>(rr1);</span><br><span class="line">    cout &lt;&lt; rr2 &lt;&lt; endl; <span class="comment">// 42</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>&amp;&amp; rr3 = <span class="number">42</span>;</span><br><span class="line">    cout &lt;&lt; rr3 &lt;&lt; endl; <span class="comment">// 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1342-stdmove"><a class="markdownIt-Anchor" href="#1342-stdmove"></a> 13.4.2 <code>std::move()</code></h3>
<ul>
<li>通过<code>std::move</code>将左值转化为右值（原文：使用std::move获得绑定到左值上的右值引用）
<ul>
<li><strong>move的作用是<font color='red'>偷取（窃取）</font>其他变量里的资源变为自己的（是资源所有权的变更，而不是拷贝资源）</strong>，如内存、线程等等，而不必自己再从0获取。很显然这样可以节约一些程序开销。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr1 = <span class="number">42</span>; <span class="comment">// 正确，字面值常量是右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = rr1; <span class="comment">// 错误，rr1是左值，右值引用只能绑定右值。（变量（rr1）可以看做没有运算符的表达式，而表达式都是左值）</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr1); <span class="comment">// 正确，使用std::move获得绑定到左值上的右值引用（我的理解：将左值转化为右值）</span></span><br><span class="line"><span class="comment">//之后，可以销毁rr1的源对象，也可以赋予它新值，但是不可再使用rr1源对象的值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>#include &lt;utility&gt;</code></p>
</li>
<li>
<p>我们可以销毁一个移后源对象（此处指rr1），也可以赋予它新值，但不能使用一个移后源对象的值。</p>
<blockquote>
<p>move 调用告诉编译器:我们有一个左值，但我们希望像一个右值一样处理它。我们必须认识到，调用 move 就意味着承诺：**除了对 rr1 赋值或销它外，我们将不再使用它。**在调用move之后，我们不能对移后源对象的值做任何假设。</p>
</blockquote>
<blockquote>
<p>移动操作还必须<strong>保证源对象可以安全地为其赋予新值</strong>或者可以安全地使用而不依赖其当前值。</p>
<p>另一方面，<strong>移动操作对移后源对象中留下的值没有任何要求。因此，我们不可对其值进行假设，我们的程序也不应依赖于移后源对象中的数据。</strong></p>
</blockquote>
</li>
<li>
<p>使用move 的代码<strong>应该使用 std::move而不是move</strong>（不提供using声明）。这样做可以避免潜在的名字冲突。</p>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402221708579013.png" alt="image-20240222131649580" /></p>
<hr />
<h3 id="1343-自定义类中的移动构造和移动赋值"><a class="markdownIt-Anchor" href="#1343-自定义类中的移动构造和移动赋值"></a> 13.4.3 自定义类中的移动构造和移动赋值</h3>
<p>对于移动构造和移动赋值：</p>
<ul>
<li>
<p>从给定对象窃取资源而不是拷贝资源，<strong>不新分配任何内存</strong></p>
</li>
<li>
<p><strong>必须在声明和定义中都标记为<code>noexcept</code></strong>，通知标准库不抛出任何异常（为什么需要noexcpt，书P474，❓）</p>
</li>
<li>
<p><strong>源对象的所有指针置为<code>nullptr</code></strong>，确保移后源对象处于一个可析构的状态（必须确保移后源对象被销毁是无害的）</p>
</li>
<li>
<p><strong>后续程序不应依赖移后源对象中的数据</strong></p>
</li>
</ul>
<h4 id="13431-移动构造"><a class="markdownIt-Anchor" href="#13431-移动构造"></a> 13.4.3.1 移动构造</h4>
<p>模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*移动构造函数*/</span></span><br><span class="line">    <span class="built_in">StrVec</span>(StrVec&amp;&amp; s) <span class="keyword">noexcept</span> <span class="comment">// 移动操作不应抛出任何异常</span></span><br><span class="line">        <span class="comment">//成员初始化器接管s中的资源</span></span><br><span class="line">        :<span class="built_in">elements</span>(s.elements),<span class="built_in">first_free</span>(s.first_free),<span class="built_in">cap</span>(s.cap) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 源对象的指针全都要置空，确保移后源对象处于一个可析构的状态</span></span><br><span class="line">        s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string* elements;</span><br><span class="line">    string* first_free;</span><br><span class="line">    string* cap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数须是该类型的右值引用，额外参数必须有默认值。（类似拷贝构造）</li>
</ul>
<h4 id="13432-移动赋值"><a class="markdownIt-Anchor" href="#13432-移动赋值"></a> 13.4.3.2 移动赋值</h4>
<p>类似拷贝赋值：</p>
<ul>
<li>析构函数+移动构造</li>
<li>必须正确处理自赋值</li>
</ul>
<p>模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*拷贝赋值*/</span></span><br><span class="line">    StrVec&amp; <span class="keyword">operator</span>=(StrVec&amp;&amp; s) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">//if语句检测自赋值：对于“=”两端相同的资源，避免在使用右侧运算对象之前就释放了左侧对象（避免将自身释放）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s) &#123;  <span class="comment">// s是左值，取地址</span></span><br><span class="line">            <span class="comment">/*this-&gt;*/</span><span class="built_in">free</span>(); <span class="comment">// 释放左侧运算对象所使用的内存</span></span><br><span class="line">            elements = s.elements;</span><br><span class="line">            first_free = s.first_free;</span><br><span class="line">            cap = s.cap;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将s置于可析构状态</span></span><br><span class="line">            s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>; <span class="comment">// 源对象的指针全都要置空</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string* elements;</span><br><span class="line">    string* first_free;</span><br><span class="line">    string* cap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="13433-合成的移动操作"><a class="markdownIt-Anchor" href="#13433-合成的移动操作"></a> 13.4.3.3 合成的移动操作</h4>
<p>何时会生成合成移动操作？</p>
<ul>
<li>只有当一个类
<ul>
<li><strong>没有定义任何自己版本的拷贝控制成员</strong>，</li>
<li><strong>且它的所有数据成员都能移动构造或移动赋值时</strong>，编译器才会为它合成移动构造函数或移动赋值运算符。</li>
</ul>
</li>
</ul>
<p>何时移动操作被定义为删除？(P476 )</p>
<ul>
<li>与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是:
<ul>
<li><strong>有类成员定义了自己的拷贝构造函数且未定义移动构造函数，</strong></li>
<li><strong>或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数</strong>。移动赋值运算符的情况类似。</li>
</ul>
</li>
<li>如果<strong>有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的</strong>，则类的移动构造函数或移动赋值运算符被定义为删除的。</li>
<li>类似拷贝构造函数，<strong>如果类的析构函数被定义为删除的或不可访问的</strong>，则类的移动构造函数被定义为删除的。</li>
<li>类似拷贝赋值运算符，如果<strong>有类成员是 const 的或是引用</strong>，则类的移动赋值运算符被定义为删除的。</li>
</ul>
<p>移动操作和合成拷贝之间的关系：</p>
<ul>
<li>
<p>如果<strong>类定义了一个移动构造函数和（或）一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为<em>删除</em></strong>。</p>
<ul>
<li>因此，定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。</li>
</ul>
</li>
</ul>
<p><strong>移动右值，拷贝左值，但如果没有移动构造函数，右值也将被拷贝。</strong>  --&gt;拷贝也是一种形式的“移动”，并且几乎是安全的。</p>
<ul>
<li>
<p>移动右值，拷贝左值：一个类既有拷贝构造，又有移动构造，编译器会实现最优匹配</p>
</li>
<li>
<p>如果没有移动构造函数，右值也将被拷贝。此种情况，即使通过<code>std::move</code>也会调用拷贝构造</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo &amp;); <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="comment">//未定义移动构造</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo x;</span><br><span class="line"><span class="function">Foo <span class="title">y</span><span class="params">(x)</span></span>; <span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="function">Foo <span class="title">z</span><span class="params">(std::move(x))</span></span>; <span class="comment">// 拷贝构造，因为没有定义移动构造；此处会将 Foo&amp;&amp; 隐式转化为 const Foo&amp;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="13434-三五法则"><a class="markdownIt-Anchor" href="#13434-三五法则"></a> 13.4.3.4 三/五法则</h4>
<blockquote>
<p>所有五个拷贝控制成员应该看作一个整体：</p>
<p>**一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。**如前所述，某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作(参见13.1.4 节，第447页)。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。</p>
</blockquote>
<h4 id="1345-基于拷贝并交换技术的赋值运算符"><a class="markdownIt-Anchor" href="#1345-基于拷贝并交换技术的赋值运算符"></a> 13.4.5 （基于）拷贝并交换（技术的）赋值运算符</h4>
<p>即，<strong>添加了移动构造函数之后，类中使用拷贝并交换技术的重载赋值运算符既是拷贝赋值，也是移动赋值。具体是那种赋值方式依赖于<code>operator=()</code>的实参类型：拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——移动右值，拷贝左值。如此，一个operator=函数就实现了拷贝赋值和移动赋值两种功能。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 添加移动构造</span></span><br><span class="line">    <span class="built_in">HasPtr</span>(HasPtr &amp;&amp;p)<span class="keyword">noexcept</span>:<span class="built_in">ps</span>(p.ps),<span class="built_in">i</span>(p.i)&#123;p.ps=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">// 赋值运算符既是拷贝赋值，也是移动赋值</span></span><br><span class="line">    HasPtr &amp;<span class="keyword">operator</span>=(HasPtr rhs)&#123; </span><br><span class="line">        <span class="built_in">swap</span>(*<span class="keyword">this</span>,rhs); <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>参考书中的论述：</p>
<p>值得注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁掉原对象，因此你只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法。</p>
<p>联想：operator=的作用包括构造+析构——对左对象析构并将右对象拷贝（移动）到左对象。</p>
<hr />
<h3 id="1344-移动迭代器"><a class="markdownIt-Anchor" href="#1344-移动迭代器"></a> 13.4.4 移动迭代器</h3>
<ul>
<li>
<p><strong>解引用移动迭代器生成右值引用</strong></p>
</li>
<li>
<p>调用<code>make_move_iterator()</code>将一个迭代器转为移动迭代器：<code>make_move_iterator(begin())</code></p>
</li>
<li>
<p>移动迭代器支持正常的迭代器操作，我们可以将一对移动迭代器传递给算法。</p>
</li>
<li>
<p>值得注意的是：</p>
<blockquote>
<p>值得注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁掉原对象，因此你<strong>只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法</strong>。</p>
</blockquote>
</li>
</ul>
<h2 id="135-右值引用和成员函数"><a class="markdownIt-Anchor" href="#135-右值引用和成员函数"></a> 13.5 右值引用和成员函数</h2>
<h3 id="1351-重载拷贝版本和移动版本"><a class="markdownIt-Anchor" href="#1351-重载拷贝版本和移动版本"></a> 13.5.1 重载拷贝版本和移动版本</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> string&amp;s)</span></span>&#123; <span class="comment">// 拷贝：绑定到int</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        alloc.<span class="built_in">construct</span>(first_free++, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(string &amp;&amp;s)</span></span>&#123;     <span class="comment">// 移动：只能绑定到类型为int的可修改的右值 </span></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">       alloc.<span class="built_in">construct</span>(first_free++, std::<span class="built_in">move</span>(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------使用StrVec</span></span><br><span class="line">StrVec vec;</span><br><span class="line">string s = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">vec.<span class="built_in">push_back</span>(s); <span class="comment">// 调用拷贝的版本</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="string">&quot;done&quot;</span>); <span class="comment">//调用移动的版本：临时对象/常量调用右值的版本</span></span><br></pre></td></tr></table></figure>
<ul>
<li>区分拷贝和移动的重载函数通常由一个版本接受一个<code>const T&amp;</code>，而另一个版本接受一个<code>T&amp;&amp;</code></li>
</ul>
<h3 id="1352-引用限定符"><a class="markdownIt-Anchor" href="#1352-引用限定符"></a> 13.5.2 引用限定符</h3>
<p>对一个右值进行赋值居然是成立的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;a&quot;</span>, s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">s1 + s2 = <span class="string">&quot;c&quot;</span>; <span class="comment">// 对s1和s2的连接结果赋值</span></span><br></pre></td></tr></table></figure>
<p>在新标准下可以阻止这一情况的发生：<strong>在参数列表后放置一个引用限定符</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class Foo&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Foo &amp;) &amp;;<span class="comment">//只能向可修改的左值赋值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>引用限定符可以是<code>&amp;</code>或<code>&amp;&amp;</code>，指出this可以指向一个左值或一个右值；</p>
</li>
<li>
<p>只能<strong>用于非static</strong>成员函数（类似const）</p>
</li>
<li>
<p>必须<strong>同时出现在函数的声明和定义</strong>中</p>
</li>
<li>
<p>可以与<code>const</code>连用，<strong>引用限定符必须在const之后</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">someM</span><span class="params">()</span> <span class="type">const</span> &amp;</span>; <span class="comment">// 必须注意const和&amp;的顺序</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果一个成员函数有引用限定符，则具有相同参数列表的所有参数版本都必须加引用限定符。（相同参数列表的重载版本要么都加，要么都不加引用限定符）</p>
<blockquote>
<p>就像一个成员函数可以根据是否有 const 来区分其重载版本一样(书：参见7.3.2节第247页)，引用限定符也可以区分重载版本。而且，我们可以综合引用限定符和 const 来区分一个成员函数的重载版本。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">puiblic:</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;&amp;</span>;</span><br><span class="line">    <span class="comment">//Foo sorted() const; // 错误</span></span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="type">const</span> &amp;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">(<span class="type">int</span> *)</span></span>;</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">(<span class="type">int</span> *)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------编译器会根据调用sorted的对象的左值/右值属性来确定使用哪个sorted版本</span></span><br><span class="line"><span class="built_in">retVal</span>().<span class="built_in">sorted</span>(); <span class="comment">// retVal()是右值，调用&amp;&amp;版本</span></span><br><span class="line"><span class="built_in">retFoo</span>().<span class="built_in">sorted</span>(); <span class="comment">// retFoo()是左值，调用const &amp;版本</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="十四-重载运算与类型转换"><a class="markdownIt-Anchor" href="#十四-重载运算与类型转换"></a> 十四 重载运算与类型转换</h1>
<h2 id="141-基本概念"><a class="markdownIt-Anchor" href="#141-基本概念"></a> 14.1 基本概念</h2>
<ul>
<li>
<p>除了重载的函数调用运算符<code>operator()</code>外，其他重载运算符<strong>不能含有默认实参</strong>。</p>
</li>
<li>
<p>对于一个运算符函数来说，它或是类的成员，或至少含有一个类类型的参数。–&gt;当运算符作用于内置类型（如int）的运算对象，我们无法改变该运算符的含义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:不能为int重定义内置的运算符</span></span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以直接调用重载的运算符函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,等价</span></span><br><span class="line">data1+data2;</span><br><span class="line"><span class="keyword">operator</span>+(data1, data2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2,等价</span></span><br><span class="line">data1+=data2;</span><br><span class="line">data1.<span class="keyword">operator</span>+=(data2);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通常情况下，可以重载却不应重载：逗号、取地址、逻辑与/或（原因：重载版本无法保留求值顺序和/或短路求值属性，导致运算符不符合用户习惯）<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403131710318400.png" alt="image-20240313162557121" /></p>
</li>
<li>
<p>何时使用运算符重载？</p>
<ul>
<li>只有当操作的含义对于用户来说清晰明了时才可以重载运算符。如果用户对运算符可能有多种理解，重载运算符将产生二义性。</li>
</ul>
</li>
<li>
<p>使用与内置类型一致的含义：</p>
<ul>
<li>有<code>operator==</code>，也应有<code>operator!=</code>；有<code>operator&lt;</code>，也应有其他关系运算符。</li>
<li>有算符运算符或为运算符，最好也提供复合运算符。如有<code>operator+</code>，也应有<code>operator+=</code>，并用<code>+=</code>（复合）来实现<code>+</code>（算数）。</li>
<li>重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容：
<ul>
<li>逻辑运算符和关系运算符应该返回 bool，</li>
<li>算术运算符应该返回一个类类型的值，</li>
<li>赋值运算符和复合赋值运算符则应该<strong>返回左侧运算对象的一个引用</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>作为成员还是非成员?<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403141710401943.png" alt="image-20240314153519440" /></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如</span></span><br><span class="line">string s = <span class="string">&quot;w&quot;</span>;</span><br><span class="line">string t = s+<span class="string">&quot;hi&quot;</span>; <span class="comment">// 等价s.operator+(&quot;hi&quot;);</span></span><br><span class="line">string u = <span class="string">&quot;hi&quot;</span>+s; <span class="comment">// 如果+是string的成员，则产生错误</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于<code>对称性</code>的解释：如<code>+</code>，a+b==b+a  --&gt;对称性</p>
<p>因为标准库中，string将<code>+</code>定义成了普通的非成员函数，所以&quot;hi&quot;+s等价于operator+(“hi”,s)。</p>
<p>和任何其他函数调用一样，每个实参都能被转换成形参类型。唯一的要求是至少有一个运算对象是类类型，并且两个运算对象都能准确无误地转换成string。</p>
</blockquote>
</li>
</ul>
<h2 id="142-输入和输出运算符"><a class="markdownIt-Anchor" href="#142-输入和输出运算符"></a> 14.2 输入和输出运算符</h2>
<p><strong>非成员</strong></p>
<h3 id="1421-operator"><a class="markdownIt-Anchor" href="#1421-operator"></a> 14.2.1 operator&lt;&lt;</h3>
<ul>
<li>
<p>例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream&amp;os, <span class="type">const</span> Sales_data &amp;item)&#123;</span><br><span class="line">    os&lt;&lt;item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">        &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>operator&lt;&lt;</code>应尽量减少格式化操作，更不应打印换行符。</p>
</li>
<li>
<p><code>operator&lt;&lt;</code>必须是非成员函数，又因需要读写非公成员，一般设置为友元。</p>
</li>
</ul>
<h3 id="1422-operator"><a class="markdownIt-Anchor" href="#1422-operator"></a> 14.2.2 operator&gt;&gt;</h3>
<ul>
<li>
<p>例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Sales_data &amp;item)&#123;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">    is&gt;&gt;item.bookNo&gt;&gt;item.units_sold&gt;&gt;price;</span><br><span class="line">    <span class="keyword">if</span>(is) <span class="comment">// 检查输入是否成功</span></span><br><span class="line">        item.revenue = item.units_sold * price;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 输入失败，对象被赋予默认状态</span></span><br><span class="line">        <span class="comment">// 当读取操作发生错误时，</span></span><br><span class="line">        item = <span class="built_in">Sales_data</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>operator&gt;&gt;</code>必须处理输入可能失败的情况。利用<code>if(is)</code>检查是否输入成功。</p>
<ul>
<li>当流含有错误类型的数据时，读取操作可能失败：如输入的是int，读取的对象要求string</li>
<li>当读取到达文件尾 或 遇到输入流的其他错误</li>
</ul>
</li>
<li>
<p><code>operator&gt;&gt;</code>也应该设置流的条件状态以标识出失败信息：</p>
<ul>
<li>通常情况下，只需设置<code>failbit</code></li>
<li>除此之外，设置<code>eofbit</code>表示文件耗尽，<code>badbit</code>表示流被破坏等</li>
</ul>
</li>
</ul>
<h2 id="143-算数和关系运算符"><a class="markdownIt-Anchor" href="#143-算数和关系运算符"></a> 14.3 算数和关系运算符</h2>
<ul>
<li>通常情况下，我们把算数和关系运算符定义成<strong>非成员</strong>函数以允许左侧或右侧的运算对象进行转换</li>
<li>形参一般为常量的引用，<code>const Sales_data &amp;lhs</code></li>
</ul>
<h3 id="1431-算数运算符"><a class="markdownIt-Anchor" href="#1431-算数运算符"></a> 14.3.1 算数运算符</h3>
<ul>
<li>最有效的方式是使用复合赋值来定义算数运算符，<code>+=</code> --&gt; <code>+</code></li>
</ul>
<h3 id="1432-相等运算符"><a class="markdownIt-Anchor" href="#1432-相等运算符"></a> 14.3.2 相等运算符</h3>
<ul>
<li>相等运算符和不相等运算符中的一个应该把工作委托给另一个</li>
</ul>
<h3 id="1433-关系运算符"><a class="markdownIt-Anchor" href="#1433-关系运算符"></a> 14.3.3 关系运算符</h3>
<ul>
<li>因为关联容器和一些算法要用到小于运算符，所以定义<code>operator&lt;</code>会比较有用</li>
<li>如果存在唯一一种逻辑可靠的<code>&lt;</code>定义，则应该考虑为这个类定义<code>&lt;</code>运算符；顺序关系应与关联容器中对关键字的要求一致。</li>
<li>如果该类同时包含<code>==</code>，则当且仅当<code>&lt;</code>的定义和<code>==</code>产生的结果一致时才定义<code>&lt;</code>运算符；特别是，如果两个对象时<code>!=</code>的，那么一个对象应该<code>&lt;</code>另外一个。（解释：P498-14.3.2-（第5段）尽管……）</li>
</ul>
<h2 id="144-赋值运算符"><a class="markdownIt-Anchor" href="#144-赋值运算符"></a> 14.4 赋值运算符</h2>
<ul>
<li>
<p>赋值运算符必须定义成<strong>类的成员</strong>，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。</p>
</li>
<li>
<p>赋值，除了移动赋值和拷贝赋值，还可接受元素列表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v;</span><br><span class="line">v = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StrVec &amp;<span class="keyword">operator</span>=(std::initializer_list&lt;std::string&gt; il)&#123;</span><br><span class="line">        <span class="keyword">auto</span> data = <span class="built_in">alloc_n_copy</span>(il.<span class="built_in">begin</span>(), il.<span class="built_in">end</span>()); <span class="comment">// 分配空间并拷贝元素</span></span><br><span class="line">        <span class="comment">/*this-&gt;*/</span><span class="built_in">free</span>(); <span class="comment">// 释放当前对象的内存</span></span><br><span class="line">        elements = data.first; <span class="comment">// 更新数据成员使其指向新的空间</span></span><br><span class="line">        first_free = cap = data.second;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>赋值运算符必须释放当前内存，在创建新内存。</li>
<li>此处不同的是，不必检查自我赋值</li>
</ul>
</li>
<li>
<p>复合赋值运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sales_data &amp;Sales_data::<span class="keyword">operator</span>+=(<span class="type">const</span> Sales_data &amp;rhs)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="145下标运算符"><a class="markdownIt-Anchor" href="#145下标运算符"></a> 14.5下标运算符</h2>
<ul>
<li>
<p><code>operator[]</code>必须是<strong>成员函数</strong></p>
</li>
<li>
<p>通常返回访问元素的引用</p>
</li>
<li>
<p>通常同时定义常量版本和非常量版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> elements[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> std::string&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> elements[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; elements-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string elements[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StrVec svec;</span><br><span class="line">    <span class="type">const</span> StrVec&amp; cvec = svec;</span><br><span class="line">    <span class="keyword">if</span> (svec.<span class="built_in">size</span>() &amp;&amp; svec[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        svec[<span class="number">0</span>] = <span class="string">&quot;zero&quot;</span>;</span><br><span class="line">        <span class="comment">//cvec[0] = &quot;zero&quot;;//没有与这些操作数匹配的&quot;=&quot;运算符.操作数类型为:  const std::string = const char [5]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="146-递增递减运算符"><a class="markdownIt-Anchor" href="#146-递增递减运算符"></a> 14.6 递增递减运算符</h2>
<ul>
<li>
<p>建议是<strong>类的成员</strong></p>
</li>
<li>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlobPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 前置 */</span></span><br><span class="line">    <span class="comment">// 如果显示调用则：p.operator++();</span></span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>++(); <span class="comment">// 返回递增或递减后对象的**引用**</span></span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 后置 */</span></span><br><span class="line">    <span class="comment">// 后置版本接受一个额外的（不被使用的）int类型的形参，该形参仅用于重载(用于区分前置和后置)</span></span><br><span class="line">    <span class="comment">// 如果显示调用则：p.operator++(0);</span></span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>++(<span class="type">int</span>); <span class="comment">// 应该返回对象的原值，返回的形式是一个**值**而非引用</span></span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>--(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">check</span>(curr, <span class="string">&quot;increment past end of StrBlobPtr.&quot;</span>);</span><br><span class="line">    <span class="comment">// check的作用：</span></span><br><span class="line">    <span class="comment">// 1-检查StrBlobPtr是否有效</span></span><br><span class="line">    <span class="comment">// 2-索引值是否有效  --&gt;curr已经到达vector末尾，则抛出异常</span></span><br><span class="line">    </span><br><span class="line">    ++curr;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">    --curr;</span><br><span class="line">    <span class="built_in">check</span>(curr, <span class="string">&quot;decrement past begin of StrBlobPtr.&quot;</span>);</span><br><span class="line">    <span class="comment">// curr如果已经是0，`--`后将是一个表示无效下标的非常大的正数值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="147-成员访问运算符"><a class="markdownIt-Anchor" href="#147-成员访问运算符"></a> 14.7 成员访问运算符</h2>
<ul>
<li>
<p>常用语迭代器类及智能指针类</p>
</li>
<li>
<p>箭头运算符(<code>-&gt;</code>)必须是<strong>类的成员</strong>，解引用运算符(<code>*</code>)通常是类的成员。</p>
</li>
<li>
<p>这两个函数都是const函数，返回非const的引用或指针</p>
</li>
<li>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlobPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 成员访问运算符 */</span></span><br><span class="line">    std::string&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">check</span>(curr, <span class="string">&quot;dereference past end.&quot;</span>); <span class="comment">// 检查curr是否在合法范围内</span></span><br><span class="line">        <span class="keyword">return</span> (*p)[curr];  <span class="comment">// *p为对象所指的vector</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// 将实际工作交于operator*(),返回解引用结果的地址</span></span><br><span class="line">        <span class="keyword">return</span> &amp;<span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对箭头运算符返回值有限定，只能用于获取成员。</p>
<blockquote>
<p>重载的箭头运算符必须返回类的指针 或 自定义了箭头运算符的某个类的对象</p>
</blockquote>
<p>对于<code>point-&gt;mem</code>，只能有两种含义，具体取决于<code>point</code>的类型：</p>
<ul>
<li>
<p>如果<code>point</code>是一个指针类型，那么<code>point-&gt;mem</code>等价于<code>(*point).mem</code>，表示访问指针<code>point</code>指向的对象的<code>mem</code>成员。</p>
</li>
<li>
<p>如果<code>point</code>是一个类类型的对象，并且该类重载了<code>operator-&gt;</code>，那么<code>point-&gt;mem</code>会调用<code>point.operator-&gt;()</code>来获取一个指针，然后再访问该指针的<code>mem</code>成员。</p>
</li>
</ul>
<p>这样的机制允许类型设计者为其类对象提供类似于指针的接口，使得使用这些对象时能够有类似直接使用指针一样的语法和方便性。</p>
</li>
</ul>
<h2 id="148-函数调用运算符"><a class="markdownIt-Anchor" href="#148-函数调用运算符"></a> 14.8 函数调用运算符</h2>
<h3 id="1481-基础"><a class="markdownIt-Anchor" href="#1481-基础"></a> 14.8.1 基础</h3>
<ul>
<li>
<p>必须是<strong>成员函数</strong></p>
</li>
<li>
<p>函数对象：对象的行为像函数一样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">absInt</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt; <span class="number">0</span> ? -val : val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">-42</span>;</span><br><span class="line">    absInt absObj;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">absObj</span>(i);</span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; std::endl; <span class="comment">// 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>函数对象常常作为泛型算法的实参</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrintString</span>(ostream&amp; o = cout, <span class="type">char</span> c = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        :<span class="built_in">os</span>(o), <span class="built_in">step</span>(c) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp; s)</span><span class="type">const</span> </span>&#123; os &lt;&lt; s &lt;&lt; step; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ostream&amp; os;</span><br><span class="line">    <span class="type">char</span> step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本用法</span></span><br><span class="line">    string s = <span class="string">&quot;s&quot;</span>;</span><br><span class="line">    PrintString priterner;</span><br><span class="line">    <span class="built_in">priterner</span>(s); <span class="comment">// s</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数对象常常作为泛型算法的实参</span></span><br><span class="line">    vector&lt;string&gt; vs&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">    for_each(vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>(), <span class="built_in">PrintString</span>(cerr,<span class="string">&quot;\n&quot;</span>)); <span class="comment">// a b c</span></span><br><span class="line">    <span class="comment">// 首次时，PrintString()创建临时对象；</span></span><br><span class="line">    <span class="comment">// 之后for_each()的内部代码会调用这个对象（此时运行operator()）以排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1482-lambda表达式与operator"><a class="markdownIt-Anchor" href="#1482-lambda表达式与operator"></a> 14.8.2 lambda表达式与operator()</h3>
<p>一、无捕获行为的lambda</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>();&#125;</span><br><span class="line"><span class="comment">// 等价</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShorterString</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        <span class="comment">//默认情况下lambda不能改变它捕获的变量。</span></span></span><br><span class="line"><span class="function">        <span class="comment">//因此在默认情况下，由lambda产生的类当中的函数调用运算符是一个const成员函数。</span></span></span><br><span class="line"><span class="function">        <span class="comment">//如果lambda被声明为可变的，则调用运算符就不是const的了。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*于是有*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stable_short</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b)</span><br><span class="line">             &#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>();&#125;);</span><br><span class="line"><span class="comment">// 等价</span></span><br><span class="line"><span class="built_in">stable_short</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),<span class="built_in">ShorterString</span>());</span><br><span class="line"><span class="comment">//第三个实参是新构建的Shorterstring对象，当stable_sort内部的代码每次比较两个string时就会“调用”这一对象，</span></span><br><span class="line"><span class="comment">//此时该对象将调用运算符的函数体，判断第一个string的大小小于第二个时返回 true。</span></span><br></pre></td></tr></table></figure>
<p>二、有捕获行为的lambda</p>
<blockquote>
<p>如我们所知，当一个lambda 表达式<strong>通过引用捕获变量时</strong>，将由程序负责确保lambda执行时引用所引的对象确实存在(参见10.3.3节，第350页)。因此，编译器可以直接使用该引用而<strong>无须</strong>在lambda产生的类中将其存储为数据成员。</p>
<p>相反，<strong>通过值捕获</strong>的变量被拷贝到lambda中(参见10.3.3节，第350页)。因此，这种<strong>lambda产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。</strong></p>
</blockquote>
<p>如，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">        [sz](<span class="type">const</span> string&amp; a) &#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz; &#125;);</span><br></pre></td></tr></table></figure>
<p>lambda将产生如下类，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SizeComp</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SizeComp</span>(std::<span class="type">size_t</span> n) :<span class="built_in">sz</span>(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp; s)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> sz;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda表达式产生的类不含默认构造函数、赋值运算符及默认析构函数;</span></span><br><span class="line"><span class="comment">//它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定</span></span><br></pre></td></tr></table></figure>
<p>则find_if等价于，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),<span class="built_in">SizeComp</span>(sz));</span><br></pre></td></tr></table></figure>
<h3 id="1483-标准库定义的函数对象"><a class="markdownIt-Anchor" href="#1483-标准库定义的函数对象"></a> 14.8.3 标准库定义的函数对象</h3>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403171710648132.png" alt="image-20240317120201949" /></p>
<ul>
<li>
<p>标准库（<code>#include &lt;functional&gt;</code>）定义了一组表示算数运算、关系运算符和逻辑运算符的类，每个类分别定义了执行命名操作的调用运算符。</p>
</li>
<li>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;<span class="type">int</span>&gt; intAdd;</span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">intAdd</span>(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//sum=30</span></span><br><span class="line"></span><br><span class="line">negate&lt;<span class="type">int</span>&gt; intNeg; <span class="comment">// 取反</span></span><br><span class="line"><span class="type">int</span> neg = <span class="built_in">intNeg</span>(<span class="number">-10</span>); <span class="comment">// neg = 10</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在算法中使用标准库函数</p>
<ul>
<li>
<p>表示运算符的函数对象类常用来替换算法中的默认运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认使用operator&lt;将序列升序，可做如下更改使其降序排列</span></span><br><span class="line"><span class="built_in">sort</span>(svec.<span class="built_in">begin</span>(), svec.<span class="built_in">end</span>(), greater&lt;string&gt;); <span class="comment">// 大于比较运算</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>标准库规定其函数对于指针同样使用</p>
<ul>
<li>
<p>首先对于顺序容器，我们之前曾经介绍过比较两个无关指针将产生未定义的行为(书：参见3.5.3节，第107页)，然而我们可能会<strong>希望通过比较指针的内存地址来排序指针的vector</strong>。直接这么做将产生未定义的行为，因此我们可以使用一个标准库函数对象来实现该目的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string*&gt; nameTab;</span><br><span class="line"><span class="comment">// 错误，nameTab中的指针彼此没有关联，&lt;将产生未定义行为</span></span><br><span class="line"><span class="built_in">sort</span>(nameTab.<span class="built_in">begin</span>(), nameTab.<span class="built_in">end</span>(),</span><br><span class="line">    [](string* a, string* b) &#123;<span class="keyword">return</span> a &lt; b; &#125;); <span class="comment">// 妄图通过比较内存地址，类排序vector，将不会成功</span></span><br><span class="line"><span class="comment">// 正确,标准库规定指针的less是定义良好的</span></span><br><span class="line"><span class="built_in">sort</span>(nameTab.<span class="built_in">begin</span>(), nameTab.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;string*&gt;());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>其次，关联容器可以直接排序指针，而无需显式地声明。</p>
<blockquote>
<p>关联容器使用 <code>less&lt;key_type&gt;</code>对元素排序，因此我们可以定义一个指针的set或者在map中 使用指针作为关键值而无须直接声明less。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1484-可调用对象与function"><a class="markdownIt-Anchor" href="#1484-可调用对象与function"></a> 14.8.4 可调用对象与function</h3>
<ul>
<li>
<p>C++语言中有几种可调用的对象：函数、函数指针、lambda表达式(书：参见10.3.2节，第 346页)、bind 创建的对象(书：参见10.3.4节，第354页)以及重载了函数调用运算符的类。</p>
</li>
<li>
<p>不同的类型可能具有相同的调用方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如下可调用对象</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;<span class="keyword">return</span> i+j;&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="type">int</span> i, <span class="type">int</span> j)&#123;<span class="keyword">return</span> i%j; &#125;;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">divide</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i/j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具有相同的调用形式</span></span><br><span class="line"><span class="built_in">int</span>(<span class="type">int</span>, <span class="type">int</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用<code>map</code>创建<em>函数表</em>用于存储可调用这些对象的“指针”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>(*)(<span class="type">int</span>, <span class="type">int</span>)&gt; binops;</span><br><span class="line">binops.<span class="built_in">insert</span>(&#123;<span class="string">&quot;+&quot;</span>,add&#125;); <span class="comment">// &#123;&quot;+&quot;,add&#125;:pair</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是不能将mod和divide存入binops</span></span><br><span class="line"><span class="comment">// 问题在于mod是个lambda表达式，而每个lambda有其自己的类型，该类型与存储在binops中的值的类型不匹配</span></span><br><span class="line"><span class="comment">// 如何才能将mod和divide存入binops呢？使用function&lt;T&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用<code>function&lt;T&gt;</code></p>
<ul>
<li>
<p><code>#include &lt;functional&gt;</code><br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403171710654733.png" alt="image-20240317135208426" /></p>
</li>
<li>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i + j; &#125;</span><br><span class="line"><span class="comment">// 2.lambda</span></span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="type">int</span> i, <span class="type">int</span> j) &#123;<span class="keyword">return</span> i % j; &#125;;</span><br><span class="line"><span class="comment">// 3.可调用对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">divide</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i / j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = add; <span class="comment">// 函数指针</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f2 = <span class="built_in">divide</span>(); <span class="comment">// 函数对象类的对象</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f3 = mod; <span class="comment">// lambda</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f1</span>(<span class="number">4</span>, <span class="number">2</span>) &lt;&lt; endl; <span class="comment">// 6</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f2</span>(<span class="number">4</span>, <span class="number">2</span>) &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f3</span>(<span class="number">4</span>, <span class="number">2</span>) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建map函数表</span></span><br><span class="line">    map&lt;string, function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; binops = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;+&quot;</span>,add&#125;,                  <span class="comment">// 函数指针</span></span><br><span class="line">        &#123;<span class="string">&quot;-&quot;</span>,std::<span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;()&#125;,    <span class="comment">// 标准库中的函数对象</span></span><br><span class="line">        &#123;<span class="string">&quot;/&quot;</span>,<span class="built_in">divide</span>()&#125;,             <span class="comment">// 用户定义的函数对象</span></span><br><span class="line">        &#123;<span class="string">&quot;*&quot;</span>,[](<span class="type">int</span> i, <span class="type">int</span> j) &#123;<span class="keyword">return</span> i * j; &#125;&#125;, <span class="comment">// 未命名的lambda</span></span><br><span class="line">        &#123;<span class="string">&quot;%&quot;</span>,mod&#125; <span class="comment">// 命名的lambda</span></span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; binops[<span class="string">&quot;+&quot;</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 15</span></span><br><span class="line">    cout &lt;&lt; binops[<span class="string">&quot;-&quot;</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line">    cout &lt;&lt; binops[<span class="string">&quot;/&quot;</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">    cout &lt;&lt; binops[<span class="string">&quot;*&quot;</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 50</span></span><br><span class="line">    cout &lt;&lt; binops[<span class="string">&quot;%&quot;</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>但是我们不能不能直接将重载的函数名置于<code>function&lt;T&gt;</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;<span class="keyword">return</span> i+j;&#125;</span><br><span class="line"><span class="comment">// 2.重载add</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">map&lt;string, function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; binops;</span><br><span class="line">binops.<span class="built_in">insert</span>(&#123;<span class="string">&quot;+&quot;</span>,add&#125;); <span class="comment">// 错误：哪一个add？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种方法解决该二义性问题</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>将函数指针传入function，而不是直接传入重载的函数的名字</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>) = add;</span><br><span class="line">binops.<span class="built_in">insert</span>(&#123;<span class="string">&quot;+&quot;</span>,fp&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用lambda消除二义性</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binops.<span class="built_in">insert</span>(&#123;<span class="string">&quot;+&quot;</span>,[](<span class="type">int</span> i, <span class="type">int</span> j)&#123; <span class="keyword">return</span> <span class="built_in">add</span>(a,b);&#125;&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="149-重载-类型转换与运算符"><a class="markdownIt-Anchor" href="#149-重载-类型转换与运算符"></a> 14.9 重载、类型转换与运算符</h2>
<h3 id="1491-类型转换运算符"><a class="markdownIt-Anchor" href="#1491-类型转换运算符"></a> 14.9.1 类型转换运算符</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>type可以是void之外的任意类型；</li>
<li>type不允许转换成数组或者函数类型，但允许转换成指针（包括数组指针及函数指针）或引用类型。</li>
<li>type也是该函数的返回类型</li>
<li>没有显式返回类型，type()中也不能写形参</li>
<li>必须定义成类的<strong>成员函数</strong></li>
<li>一般定义成const（类型转换通常不改变转换对象的内容）</li>
</ul>
<p>举例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="type">int</span> i = <span class="number">0</span>):<span class="built_in">val</span>(i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;<span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Bad SmallInt value.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SmallInt si;</span><br><span class="line">    si = <span class="number">4</span>; <span class="comment">// 4被隐式转换为SmallInt，然后调用SmallInt::operator=</span></span><br><span class="line">    si + <span class="number">3</span>; <span class="comment">// si被隐式转化为int，后执行整数加法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，隐式转换有时会带来一些问题(书P515底~516顶)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//operator bool()引发的问题</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">cin &lt;&lt; i;</span><br></pre></td></tr></table></figure>
<p>上述代码的解释：cin没有定义&lt;&lt;，这段代码本应报错。然而，cin中使用了operator bool()，将cin隐式转化成了bool，bool又被提升为了int，并被作为内置左移运算符的左侧运算对象。最终，提升后的bool（0或1）被左移了42个位置。</p>
<p>因此在必要的时候，需要用<code>explicit</code>禁用隐式转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="type">int</span> i = <span class="number">0</span>):<span class="built_in">val</span>(i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;<span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Bad SmallInt value.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SmallInt si;</span><br><span class="line">    si = <span class="number">4</span>; <span class="comment">// 4被隐式转换为SmallInt，然后调用SmallInt::operator=</span></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(si) + <span class="number">3</span>; <span class="comment">// si被显式转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意，在下列情况（表达式被用作条件时），显式类型转换将被隐式地执行：</p>
<ul>
<li>if、while、do的条件部分</li>
<li>for语句头的条件表达式</li>
<li>？ ：的条件表达式</li>
<li>！，||，&amp;&amp;</li>
</ul>
<p>对于上文因为operator bool()引发的问题，将其定义为explicit后，只有在条件中，才会隐式转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(std::cin &gt;&gt; value)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>对于此过程的解释：while 语句的条件执行输入运算符，它负责将数据读入到 value 并返回cin。为了对条件求值，cin被istream operator bool类型转换函数隐式地执行了转换。如果cin的条件状态是 good(参见8.1.2 节，第280 页)，则该函数返回为真；否则该函数返回为假。</p>
<blockquote>
<p>bool 的类型转换通常用在条件部分，因此<strong>operator bool一般定义成explicit</strong></p>
</blockquote>
<h3 id="1492-避免有二义性的类型转换"><a class="markdownIt-Anchor" href="#1492-避免有二义性的类型转换"></a> 14.9.2 避免有二义性的类型转换</h3>
<p>（❓有些难以理解）</p>
<ul>
<li>
<p>不要在两个类之间构建相同的类型转换，反例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> B&amp;);  <span class="comment">// 以B为参数的构造函数，B-&gt;A</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//类型转换运算符，B-&gt;A</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">(<span class="type">const</span> A&amp;)</span></span>;</span><br><span class="line">B b;</span><br><span class="line">A a = <span class="built_in">f</span>(b); <span class="comment">// 二义性错误，不知道调用f(B::operator A())还是f(A::A(const B&amp;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如何解决上述问题？</span></span><br><span class="line"><span class="comment">//显式调用类型转换运算符 或 转换构造函数</span></span><br><span class="line">A a1 = <span class="built_in">f</span>(b.<span class="keyword">operator</span> <span class="built_in">A</span>());</span><br><span class="line">A a2 = <span class="built_in">f</span>(<span class="built_in">A</span>(b));</span><br><span class="line"><span class="comment">//注意，不可用强制类型转换，因为其本身也会碰到二义性问题</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>二义性与转换目标为内置类型的多重类型转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">// 最好不要创建两个转换源都是算数类型的类型转换，反例：</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>  = <span class="number">0</span>);    </span><br><span class="line">    <span class="built_in">A</span>(<span class="type">double</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最好不要创建两个转换对象都是算数类型的类型转换，反例：</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="keyword">operator</span> <span class="type">double</span> <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">long</span> <span class="type">double</span>)</span></span>;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">f2</span>(a); <span class="comment">// 二义性错误：f(A::operator int())还是f(A::operator double()) ?</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> lg;</span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(lg)</span></span>; <span class="comment">//二义性错误：A::A(int)还是A::A(double) ?</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> s = <span class="number">42</span>;</span><br><span class="line"><span class="function">A <span class="title">a3</span><span class="params">(s)</span></span>; <span class="comment">// 使用A::A(int),把short提升为int的优先级 大于 short提升为double</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>总结</p>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403181710750203.png" alt="image-20240318162313244" /></p>
<ul>
<li>
<p>重载函数与转换构造函数</p>
<ul>
<li>
<p>调用重载函数时，如果多个类型转换都提供了同一种可行的匹配，则这些类型转换优先级一样（书：这些类型转换一样好）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个转换构造函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    <span class="built_in">D</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载的manip()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">const</span> D&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">manip</span>(<span class="number">10</span>); <span class="comment">// 二义性错误，manip(C(10))还是manip(D(10));</span></span><br><span class="line"><span class="built_in">manip</span>(<span class="built_in">C</span>(<span class="number">10</span>)); <span class="comment">// 正确，需要显式声明</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重载函数与用户定义的类型转换<br />
同时，这种情况也不会考虑任何可能出现的优先级</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="built_in">E</span>(<span class="type">double</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载的manip()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip2</span><span class="params">(<span class="type">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip2</span><span class="params">(<span class="type">const</span> E&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">manip2</span>(<span class="number">10</span>); <span class="comment">// 二义性错误，manip(C(10))还是manip(E(double(10))) ?</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>只有当重载函数能<strong>通过同一个类型</strong>转换函数得到匹配时，我们才会考虑其中的类型转换（❓同一类型转换指？原文书P520中间）</p>
</li>
</ul>
<blockquote>
<p>如果在调用重载函数时我们需要使用构造函数或者强制类型转换来改变实参的类型，则这通常意味着程序的设计存在不足。</p>
</blockquote>
</li>
</ul>
<h3 id="1493-函数匹配与重载的运算符"><a class="markdownIt-Anchor" href="#1493-函数匹配与重载的运算符"></a> 14.9.3 函数匹配与重载的运算符</h3>
<ul>
<li>
<p>当在表达式中使用重载的运算符时，无法判断在使用的是成员函数还是非成员函数，他们都在候选函数集中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a + b 可能是</span></span><br><span class="line">a.<span class="keyword">operator</span>+(b);</span><br><span class="line"><span class="keyword">operator</span>+(a,b);</span><br></pre></td></tr></table></figure>
<p>对比：调用一个命名函数时，具有该名字的成员函数和非成员函数不会彼此重载，因为他们的调用语法是不同的。</p>
</li>
<li>
<p>如果我们对<strong>同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符</strong>，则将会遇到重载运算符与内置运算符的二义性问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> SmallInt <span class="keyword">operator</span>+(<span class="type">const</span> SmallInt&amp;, <span class="type">const</span> SmallInt&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="type">int</span> = <span class="number">0</span>) &#123;&#125;; <span class="comment">// int -&gt; SmallInt</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125; <span class="comment">// SmallInt -&gt; int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SmallInt s1, s2;</span><br><span class="line"></span><br><span class="line">SmallInt s3 = s1 + s2; <span class="comment">// 正确，使用重载的operator+</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = s3 + <span class="number">0</span>; <span class="comment">// 二义性错误</span></span><br><span class="line"><span class="comment">// 我们可以把0转换成SmallInt，然后使用SmallInt的+;</span></span><br><span class="line"><span class="comment">// 或者把s3转换成int，然后对于两个int 执行内置的加法运算。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="十五-面向对象程序设计"><a class="markdownIt-Anchor" href="#十五-面向对象程序设计"></a> 十五 面向对象程序设计</h1>
<h2 id="151-oop概述"><a class="markdownIt-Anchor" href="#151-oop概述"></a> 15.1 OOP：概述</h2>
<p>oop核心思想：数据抽象、继承、动态绑定。（或者说：封装、继承、多态）</p>
<ul>
<li>
<p>数据抽象：类的接口与实现分离</p>
</li>
<li>
<p>继承</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span> n)</span> <span class="type">const</span></span>; <span class="comment">// 虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote&#123;  <span class="comment">// public继承，我们完全可以把Bulk_quote的对象当成Quote的对象来用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span> n)</span> <span class="type">const</span> <span class="keyword">override</span></span>; <span class="comment">// 重写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>动态绑定（或者说运行时绑定）</p>
<ul>
<li>函数的运行版本由实参决定</li>
<li>当我们使用基类的<strong>引用、指针</strong>调用一个<strong>虚函数</strong>时，将引发动态绑定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">print_total</span><span class="params">(<span class="type">const</span> Quote&amp; item, <span class="type">size_t</span> n)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> ret = item.<span class="built_in">net_price</span>(n);</span><br><span class="line">    <span class="comment">// 当item是Quote类型时调用Quote::net_price()</span></span><br><span class="line">    <span class="comment">// 当item是Bulk_quote类型时调用Bulk_quote::net_price()</span></span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;isbn: &quot;</span>&lt;&lt;item.<span class="built_in">isbn</span>()</span><br><span class="line">        &lt;&lt;<span class="string">&quot; sold: &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; total due: &quot;</span>&lt;&lt;ret&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="152-定义基类和派生类"><a class="markdownIt-Anchor" href="#152-定义基类和派生类"></a> 15.2 定义基类和派生类</h2>
<h3 id="1521-定义基类"><a class="markdownIt-Anchor" href="#1521-定义基类"></a> 15.2.1 定义基类</h3>
<ul>
<li>
<p><strong>基类通常都会定义一个虚析构函数</strong>，即使该函数不执行任何实际操作也是如此。</p>
</li>
<li>
<p>任何构造函数之外的非静态函数，都可以是虚构函数</p>
</li>
<li>
<p><strong>virtul只能出现在类内的声明语句之前</strong>，而不能用于类外部的函数定义</p>
</li>
</ul>
<h3 id="1522-定义派生类"><a class="markdownIt-Anchor" href="#1522-定义派生类"></a> 15.2.2 定义派生类</h3>
<ul>
<li>
<p><strong>继承列表</strong>中，访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见。</p>
<blockquote>
<p>如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。此外，我们能将公有派生类型的对象绑定到基类的引用或指针上。因为我们在派生列表中使用了public，所以 Bulk_quote的接口隐式地包含 isbn 函数，同时在任何需要 Quote的引用或指针的地方我们都能使用Bulkquote的对象。</p>
</blockquote>
</li>
</ul>
<p>派生类中的虚函数</p>
<ul>
<li>
<p><strong>覆盖虚函数</strong>：如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员,派生类会直接继承其在基类中的版本。</p>
</li>
<li>
<p><strong>override</strong>的位置：写在声明语句最后。</p>
<blockquote>
<p>在形参列表后面、或者在const成员函数的 const 关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字override。</p>
</blockquote>
</li>
</ul>
<p>派生类对象及派生类向基类的类型转换</p>
<ul>
<li>
<p>因为在派生类对象中含有与其基类对应的组成部分，所以我们<strong>能把派生类的对象当成基类对象来使用</strong>，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403192013939.png" alt="image-20240319201317821" /></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Quote item; <span class="comment">// 基类对象</span></span><br><span class="line">Bulk_quote bulk; <span class="comment">// 子类对象</span></span><br><span class="line">Quote *p = &amp;item;  <span class="comment">// p指向Quote对象</span></span><br><span class="line"></span><br><span class="line">p = &amp;bulk; <span class="comment">// p指向bulk的Quote部分</span></span><br><span class="line">Quote &amp;r = bulk; <span class="comment">// p绑定到bulk的Quote部分</span></span><br><span class="line"><span class="comment">// 以上两个转换被称为  派生类到基类的转换  --&gt; 继承的关键所在</span></span><br></pre></td></tr></table></figure>
<p>这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方;同样的，我们也可以把派生类对象的指针用在需要基类指针的地方。</p>
</li>
</ul>
<p>在派生类中构造基类</p>
<ul>
<li>
<p>每个类控制它自己的成员初始化过程</p>
<blockquote>
<p>尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp; book, <span class="type">double</span> p, std::<span class="type">size_t</span> qty, <span class="type">double</span> disc)</span><br><span class="line">        :<span class="built_in">Quote</span>(book, p) <span class="comment">/* 通过初始化列表将实参传递给基类构造函数,否则基类部分会执行默认初始化 */</span></span><br><span class="line">            , <span class="built_in">min_qty</span>(qty), <span class="built_in">discount</span>(disc)&#123;&#125; </span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    std::<span class="type">size_t</span> min_qty;</span><br><span class="line">    <span class="type">double</span> discount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在派生类中使用基类成员</p>
<ul>
<li>
<p>对于派生类，访问自己的成员和访问基类成员的方式一样。</p>
<blockquote>
<p><strong>派生类的作用域嵌套在基类的作用域之内</strong>。因此，对于派生类的一个成员来说，它使用派生类成员的方式与使用基类成员的方式没什么不同。</p>
</blockquote>
</li>
<li>
<p>然而，即使访问方式一样，也不能直接初始化基类的成员。</p>
<blockquote>
<p>必须明确一点:<strong>每个类负责定义各自的接口</strong>。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。 因此，**派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。**和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</p>
</blockquote>
</li>
</ul>
<p>继承与静态成员</p>
<p>❓</p>
<p>派生类的声明</p>
<ul>
<li>
<p>派生类的声明中包含类名但不得包含其派生列表。</p>
</li>
<li>
<p>派生列表及与定义有关的其他细节必须与类的主题一起出现。</p>
</li>
<li>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote; <span class="comment">// 错误，派生列表不能出现在这里</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span>; <span class="comment">// 正确，声明派生类的正确方式</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>被用作基类的类</p>
<ul>
<li>
<p>如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。 – &gt; 一个类不能派生其本身</p>
</li>
<li>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>; <span class="comment">// 声明但未定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote&#123;&#125;; <span class="comment">// 错误，必须被定义Quote</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>防止继承的发生</p>
<ul>
<li>
<p>在类名后面加<code>final</code>，以阻止继承</p>
</li>
<li>
<p>在函数后面加<code>final</code>，任何尝试覆盖该函数的操作都将引发错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span>:B&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D3</span> :D2&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>;  <span class="comment">//错误，D2已经声明为final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1523-类型转换与继承"><a class="markdownIt-Anchor" href="#1523-类型转换与继承"></a> 15.2.3 类型转换与继承</h3>
<p>派生类 --&gt; 基类的隐式转换</p>
<ul>
<li>
<p>我们可以将基类的指针或引用绑定到派生类对象上。</p>
</li>
<li>
<p>当使用基类的**引用(或指针)**时，实际上我们并不清楚该引用(或指针)所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象（动态类型）。</p>
</li>
<li>
<p>区分静态类型和动态类型</p>
<ul>
<li>
<p>静态类型：字面上要求的类型</p>
</li>
<li>
<p>动态类型：多态、动态绑定的类型</p>
</li>
</ul>
</li>
<li>
<p>如果表达式既不是引用也不是指针，则其动态类型 == 静态类型。</p>
</li>
</ul>
<p>但是不存在  基类  --&gt; 派生类的隐式转换</p>
<ul>
<li>
<p>因为  这样有可能会访问  基类中本不存在的对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Quote base;</span><br><span class="line">Bulk_quote * bulkP = &amp;base; <span class="comment">// 错误，不能将基类转化为派生类</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>即使一个基类指针或引用绑定在一个派生类对象上，也不能执行基类向派生类的转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *itemP = &amp;bulk; <span class="comment">// 正确，动态类型是Bulk_quote</span></span><br><span class="line">Bulk_qoute *bulk = itemP; <span class="comment">// 错误，不能将基类转换成派生类（除非使用强制转换static_cast）</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对象之间不存在类型转换（能转换，但是会丢失派生类中，基类没有的数据）</p>
<ul>
<li>
<p>具体表述：派生类向基类的自动类型<strong>转换只对指针或引用有效</strong>，在派生类类型和基类类型之间不存在这样的转换。</p>
</li>
<li>
<p>原因：当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生部分被忽略掉（切掉）了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line"><span class="function">Quote <span class="title">item</span><span class="params">(bulk)</span></span>;  <span class="comment">// 使用Quote::Quote(const Quote&amp;)，只能构造派生类中的基类部分</span></span><br><span class="line">item = bulk;  <span class="comment">// 使用Quote::operator=(const Quote&amp;),只能处理基类中自己的成员</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="153-虚函数"><a class="markdownIt-Anchor" href="#153-虚函数"></a> 15.3 虚函数</h2>
<ul>
<li>
<p>我们<strong>必须为每一个虚函数提供定义，而不管他是否被用到</strong></p>
</li>
<li>
<p>对虚函数的调用可能在运行时才会被解析</p>
<ul>
<li>动态绑定只有当我们通过指针或引用调用虚函数时才会发生</li>
<li>当通过普通类型（非指针非引用）的表达式调用虚函数，不会发生动态绑定，只会运行静态类型的函数</li>
<li>note<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403231430309.png" alt="image-20240323143031094" /></li>
</ul>
</li>
<li>
<p>派生类中的虚函数</p>
<ul>
<li>也是虚函数</li>
<li>函数类型与基类一致（返回值类型、形参类型）。但是有一个例外情况：<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403231444209.png" alt="image-20240323144408065" /></li>
</ul>
</li>
<li>
<p>final和override说明符</p>
<ul>
<li>使用<code>override</code>标记了某个函数，但该函数并没有覆盖已经存在的虚函数，编译器将报错</li>
<li>在类名后面加<code>final</code>，以阻止继承</li>
<li>在函数后面加<code>final</code>，任何尝试覆盖该函数的操作都将引发错误</li>
</ul>
</li>
<li>
<p>虚函数和默认实参</p>
<ul>
<li>
<p>如果虚函数使用了默认实参，则基类和派生类中定义的默认实参最好一致。</p>
<blockquote>
<p>和其他函数一样，虚函数也可以拥有默认实参(参见6.5.1节，第211页)。如果某次函数调用使用了默认实参，则该<strong>实参值由本次调用的静态类型决定。</strong></p>
<p><strong>换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此</strong>。此时，传入派生类函数的将是基类函数定义的默认实参。如果派生类函数依赖不同的实参，则程序结果将与我们的预期不符。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>回避虚函数机制</p>
<ul>
<li>
<p>在某些情况下，希望虚函数的调用不要动态绑定：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> undiscounted = baseP-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>); <span class="comment">// &#x27;Quote::&#x27;指明调用Quote的net_price(),而不管baseP的动态类型到底是什么</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>什么情况下使用呢？通常是  当一个派生类的虚函数   调用  它覆盖的基类的虚函数版本  时。如果没有作用域运算符，将会被解析为派生类自身的调用，将导致无限递归。</p>
</li>
</ul>
</li>
</ul>
<h2 id="154-抽象基类"><a class="markdownIt-Anchor" href="#154-抽象基类"></a> 15.4 抽象基类</h2>
<ul>
<li>
<p>一个纯虚函数无须定义，在结尾处加上<code>=0</code></p>
</li>
<li>
<p>含有纯虚函数的类是抽象基类</p>
<ul>
<li>不能创建抽象基类的对象</li>
<li>不重写纯虚函数的派生类也是抽象基类</li>
</ul>
</li>
<li>
<p>派生类构造函数只能初始化它的直接基类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Disc</span> : <span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Disc</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Disc</span>(<span class="type">const</span> string &amp;book, <span class="type">double</span> price, <span class="type">size_t</span> qty, <span class="type">double</span> disc)</span><br><span class="line">        :<span class="built_in">Quote</span>(book, price), <span class="built_in">quantity</span>(qty), <span class="built_in">discount</span>(disc)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(<span class="type">size_t</span>)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">size_t</span> quantity = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Disc&#123;</span><br><span class="line">    <span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Bulk_quote</span>(<span class="type">const</span> string &amp;book, <span class="type">double</span> price, <span class="type">size_t</span> qty, <span class="type">double</span> disc)</span><br><span class="line">        :<span class="built_in">Disc</span>(book, price, qty, disc)&#123;&#125;  <span class="comment">// &lt;-- 初始化它的直接基类,而不是初始化Quote</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(<span class="type">size_t</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如前所述，每个类各自控制其对象的初始化过程。因此，即使Bulk_quote没有自己的数据成员，它也仍然需要像原来一样提供一个接受四个参数的构造函数。该构造函数将它的实参传递给Disc_quote的构造函数，随后Disc_quote的构造函数继续调用Quote的构造函数。Quote的构造函数首先初始化bulk的bookNo和price 成员，当Quote的构造函数结束后，开始运行Disc_quote的构造函数并初始化 quantity 和discount成员，最后运行Bulk_quote的构造函数，该函数无须执行实际的初始化或其他工作。</p>
</blockquote>
</li>
</ul>
<h2 id="155-访问控制与继承"><a class="markdownIt-Anchor" href="#155-访问控制与继承"></a> 15.5 访问控制与继承</h2>
<ul>
<li>
<p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/107709327">C++之访问控制与继承</a></li>
</ul>
</li>
<li>
<p>C++中的public、protect、private三个关键字既可以用于<strong>访问控制</strong>，也可以用于控制<strong>继承</strong>方式。</p>
<ul>
<li>
<p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/107709327">C++之访问控制与继承</a></li>
</ul>
</li>
<li>
<p>访问控制<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251657214.png" alt="image-20240325165736001" /></p>
<p>大致解释就是：</p>
<ol>
<li>首先类本身对于自己的所有成员肯定是有访问权限的，无论是public、protect还是private</li>
<li>类的实例化对象只对类的public成员有访问权限</li>
<li>protect相比private成员的特别之处在于，protect对于派生类是可访问（或可见）的，而private成员在派生类中不可见。</li>
</ol>
<p>对于第三点，换句话说就是，只有父类的public、protect成员可以被子类继承，private成员子类压根是看不到的。至于父类的public、protect成员继承到子类后，是什么样子，这还要看下面的继承方式了。</p>
</li>
<li>
<p>控制继承方式（继承方式的作用不影响派生类对基类的访问，而是影响派生类的用户——见派生说明符）<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251658982.png" alt="image-20240325165814776" /></p>
</li>
</ul>
</li>
<li>
<p>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问权限。</p>
<ul>
<li>
<p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/37051531/answer/70303204">C++派生类的成员或友员只能通过派生类对象来访问基类的受保护成员? - 晶龙的回答 - 知乎</a></li>
</ul>
</li>
<li>
<p>理解下面代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line">    Base baseObject;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">11</span>;             <span class="comment">// target object is self (kind of Derived)</span></span><br><span class="line">        baseObject.a = <span class="number">12</span>;  <span class="comment">// target object is kind of Base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意在Derived 的 foo() 的方法里，第一句是可以编译通过的，第二句不行，会报错</p>
<p>这正是因为，第一句</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 11</span><br></pre></td></tr></table></figure>
<p>操作的对象是Derived类型，因此他可以看到从Base继承下来的protected a成员</p>
<p>相对，第二句</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baseObject.a = 12</span><br></pre></td></tr></table></figure>
<p>是不行的，因为他的操作对象明确地是一个与自身self无关的另一个Base类型对象，其a成员是不可见的。</p>
</li>
<li>
<p>例2</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">clas Sneaky : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="comment">//正确，派生类的成员和友元 访问 派生类对象中的基类部分 的受保护成员</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span></span>&#123;</span><br><span class="line">        s.j = </span><br><span class="line">        s.prot_mem = <span class="comment">// 派生类对象中的基类部分</span></span><br><span class="line">        <span class="number">0</span>;&#125;;</span><br><span class="line">    <span class="comment">//错误，操作对象明确地是一个与Sneaky自身无关的另一个Base类型对象</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span></span>&#123;b.prot_mem = <span class="number">0</span>;&#125;;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>综之，<strong>派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员；对于普通的基类对象中的成员不具有特殊的访问权限。</strong> &lt;–其实很好理解，感觉书上写复杂了。</p>
</li>
</ul>
</li>
<li>
<p>派生说明符</p>
<ul>
<li>不影响派生类成员（及友元）访问其直接基类</li>
<li>作用是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限</li>
</ul>
</li>
<li>
<p>派生类向基类转换的可访问性<br />
派生类向基类的转换 --&gt; 基类的指针（引用）指向派生类的对象</p>
<ul>
<li>
<p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://t.csdnimg.cn/lQ6hs">C++ 派生类向基类转换的可访问性——CSDN</a></li>
</ul>
</li>
<li>
<p>书中原文</p>
<p>派生类向基类到转换是否可访问由使用该转换到代码决定，同时派生类到派生访问说明符也会有影响。假定D继承自B：</p>
<ul>
<li>
<p><strong>只有当D公有继承B时，<u>用户代码</u>才能使用派生类向基类到转换</strong>；如果D继承B的方式时受保护的或者私有的，则用户代码不能使用该转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _COUT(str) std::cout&lt;&lt;str&lt;&lt;<span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _COUTL(str) std::cout&lt;&lt;str&lt;&lt;std::endl;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _COUTL(<span class="string">&quot;我是A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _COUTL(<span class="string">&quot;我是B 继承A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">private</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _COUTL(<span class="string">&quot;我是C 继承A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *p;</span><br><span class="line">    B b;</span><br><span class="line">    C c;</span><br><span class="line">    </span><br><span class="line">    p = &amp;b;</span><br><span class="line">    p = &amp;c;<span class="comment">// error:Cannot cast &#x27;C&#x27; to its private base class &#x27;A&#x27;</span></span><br><span class="line">    p-&gt;<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>不论D以什么方式继承B，D的成员函数和友员函数都能使用派生类向基类的转换</strong>；派生类向其直接基类的类型转换对于派生类的成员和友员而言永远是可访问的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(D &amp;d)</span></span>&#123;</span><br><span class="line">        B b = d; <span class="comment">// 派生类向基类的转换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">friendFunction</span><span class="params">(D &amp;d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        B b = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>:<span class="keyword">protected</span> B&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(E &amp;e)</span></span>&#123;</span><br><span class="line">        B b = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">friendFunction</span><span class="params">(E &amp;e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        B b = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span>:<span class="keyword">private</span> B&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(F &amp;f)</span></span>&#123;</span><br><span class="line">        B b = f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">friendFunction</span><span class="params">(F &amp;f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        B b = f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果D继承B 的方式是公有的或者受保护的，则D的派生类的成员和友员可以使用D向B 的类型转换；反之，如果D继承B 的方式时私有的，则不能使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>tips：对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>不考虑继承的话，我们可以认为一个类有两种不同的用户:普通用户和类的实现者.</p>
<p>其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有(接口)成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有(实现)部分。<br />
如果进一步考虑继承的话就会出现第三种用户，即派生类。基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。<br />
和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组：一组可供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据;对于后者应该声明为私有的。</p>
</blockquote>
<ul>
<li>友元和继承</li>
</ul>
<h2 id="156-继承中的类作用域"><a class="markdownIt-Anchor" href="#156-继承中的类作用域"></a> 15.6 继承中的类作用域</h2>
<h2 id="157-构造函数和拷贝控制"><a class="markdownIt-Anchor" href="#157-构造函数和拷贝控制"></a> 15.7 构造函数和拷贝控制</h2>
<h2 id="158-容器和继承"><a class="markdownIt-Anchor" href="#158-容器和继承"></a> 15.8 容器和继承</h2>
<h1 id="十六-模板与泛型编程"><a class="markdownIt-Anchor" href="#十六-模板与泛型编程"></a> 十六 模板与泛型编程</h1>
<div align="center"><h1>------高级主题------</h1></div>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2024/01/25/hexo%E4%BB%A3%E7%A0%81%E5%9D%97%E7%BC%A9%E8%BF%9B%E9%97%AE%E9%A2%98/">hexo在butterfly/next主题下代码块缩进问题</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2024/01/03/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">git基本操作</a></div></section></div>




  <div class="related-wrap md-text" id="comments">
    <section class='header cmt-title cap theme'>
      <p>快来参与讨论吧~</p>

    </section>
    <section class='body cmt-body twikoo'>
      

<div id="twikoo_container"><svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg></div>
    </section>
  </div>



<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">He Zexian</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.27.0">Stellar 1.27.0</a> 主题创建。<br />
本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。<br />
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="4" onerror="localStorage.setItem('modelId','4')" style="display:none;"><script src="https://www.hekeke.top/live2d-widget-master/autoload.js"></script></p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text"> 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text"> 参考资料</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">------C++ 基础------</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 二 变量和基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 2.1 基本内置类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#211-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text"> 2.1.1 变量类型的大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#212-%E7%AC%A6%E5%8F%B7"><span class="toc-text"> 2.1.2 符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#213%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96"><span class="toc-text"> 2.1.3类型转化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F"><span class="toc-text"> 2.2 字面值常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%8F%98%E9%87%8F"><span class="toc-text"> 2.3 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#231-%E4%BA%86%E8%A7%A3%E5%8F%98%E9%87%8F"><span class="toc-text"> 2.3.1 了解变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#232-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text"> 2.3.2 作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 2.4 复合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#241-%E5%BC%95%E7%94%A8"><span class="toc-text"> 2.4.1 引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#242-%E6%8C%87%E9%92%88"><span class="toc-text"> 2.4.2 指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-const"><span class="toc-text"> 2.5 const</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#251-%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span class="toc-text"> 2.5.1 常量引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#252-%E6%8C%87%E9%92%88%E5%92%8Cconst"><span class="toc-text"> 2.5.2 指针和const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#253-%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const"><span class="toc-text"> 2.5.3 顶层const和底层const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#254-%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cconstexpr"><span class="toc-text"> 2.5.4 常量表达式和constexpr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 2.6 处理类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#261-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-text"> 2.6.1 类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#262-auto"><span class="toc-text"> 2.6.2 auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#263-decltype"><span class="toc-text"> 2.6.3 decltype</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-text"> 三 字符串、向量和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-using"><span class="toc-text"> 3.1 using</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-string"><span class="toc-text"> 3.2 string</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#321-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text"> 3.2.1 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#322-string%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text"> 3.2.2 string对象的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#323-%E5%A4%84%E7%90%86string%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-text"> 3.2.3 处理string对象中的字符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-vector"><span class="toc-text"> 3.3 vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#331-%E5%88%9D%E5%A7%8B%E5%8C%96vector%E5%AF%B9%E8%B1%A1"><span class="toc-text"> 3.3.1 初始化vector对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#332-vector%E6%93%8D%E4%BD%9C"><span class="toc-text"> 3.3.2 vector操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#333-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text"> 3.3.3 迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E6%95%B0%E7%BB%84"><span class="toc-text"> 3.4 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#341-%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="toc-text"> 3.4.1 定义和初始化数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#342-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-text"> 3.4.2 指针和数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#343-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text"> 3.4.3 多维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#344-%E4%B8%8E%E6%97%A7%E4%BB%A3%E7%A0%81%E6%8E%A5%E5%8F%A3"><span class="toc-text"> 3.4.4 与旧代码接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text"> 四 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E5%9F%BA%E7%A1%80"><span class="toc-text"> 4.1 基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 4.2 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#421-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 4.2.1 算术运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#422-%E9%80%BB%E8%BE%91%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 4.2.2 逻辑和关系运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#423-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 4.2.3 赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#424-%E9%80%92%E5%A2%9E-%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 4.2.4 递增、递减运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#425-%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 4.2.5 成员访问运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#426-%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 4.2.6 条件运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#427-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 4.2.7 位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#428-sizeof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 4.2.8 sizeof运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#429-%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 4.2.9 逗号运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 4.3 类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#431-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 4.3.1 隐式转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#432-%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 4.3.2 显式转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8"><span class="toc-text"> 4.4 运算符优先级表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-%E8%AF%AD%E5%8F%A5"><span class="toc-text"> 五 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E7%AE%80%E5%8D%95%E8%AF%AD%E5%8F%A5"><span class="toc-text"> 5.1 简单语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text"> 5.2 作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text"> 5.3 条件语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#531-ifelse"><span class="toc-text"> 5.3.1 if…else</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#532-switchcase"><span class="toc-text"> 5.3.2 switch…case</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E8%BF%AD%E4%BB%A3%E8%AF%AD%E5%8F%A5"><span class="toc-text"> 5.4 迭代语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#541-while"><span class="toc-text"> 5.4.1 while</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#542-for"><span class="toc-text"> 5.4.2 for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#543-dowhile"><span class="toc-text"> 5.4.3 do…while</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5"><span class="toc-text"> 5.5 跳转语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text"> 5.6 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#561-%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-text"> 5.6.1 异常类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#562-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-text"> 5.6.2 抛出异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#563-%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-text"> 5.6.3 处理异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#564-%E7%A4%BA%E4%BE%8B"><span class="toc-text"> 5.6.4 示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-%E5%87%BD%E6%95%B0"><span class="toc-text"> 六 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E5%9F%BA%E7%A1%80"><span class="toc-text"> 6.1 基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text"> 6.2 参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#621-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text"> 6.2.1 参数传递的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#622-const%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="toc-text"> 6.2.2  const形参和实参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#623-%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82"><span class="toc-text"> 6.2.3 数组形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#624-%E5%8F%AF%E5%8F%98%E5%BD%A2%E5%8F%82"><span class="toc-text"> 6.2.4 可变形参</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%92%8Creturn"><span class="toc-text"> 6.3 返回类型和return</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#631-%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text"> 6.3.1 有返回值的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#632-%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-text"> 6.3.2 数组指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E9%87%8D%E8%BD%BD"><span class="toc-text"> 6.4 重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-text"> 6.5 特殊用途语言特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#651-%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="toc-text"> 6.5.1 默认实参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#652-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-text"> 6.5.2 内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#653-constexpr%E5%87%BD%E6%95%B0"><span class="toc-text"> 6.5.3 constexpr函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#654-%E8%B0%83%E8%AF%95%E5%B8%AE%E5%8A%A9"><span class="toc-text"> 6.5.4 调试帮助</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="toc-text"> 6.6 函数匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text"> 6.7 函数指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#671-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text"> 6.7.1 函数指针是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#672-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-text"> 6.7.2 如何使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#673-%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-text"> 6.7.3 重载函数的指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#674-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%BD%9C%E5%BD%A2%E5%8F%82"><span class="toc-text"> 6.7.4 函数指针作形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#675-%E8%BF%94%E5%9B%9E%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-text"> 6.7.5 返回指向函数的指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83-%E7%B1%BB"><span class="toc-text"> 七 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#71-%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 7.1 定义抽象数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#711-%E5%85%B3%E4%BA%8E%E7%B1%BB%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text"> 7.1.1 关于类的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#712-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text"> 7.1.2 构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%A3%B0%E6%98%8E%E6%88%90const"><span class="toc-text"> 一、构造函数不能被声明成const。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-%E7%BC%96%E8%AF%91%E5%99%A8%E5%90%88%E6%88%90%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%B0%86%E6%8C%89%E5%A6%82%E4%B8%8B%E8%A7%84%E5%88%99%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B1%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-text"> 二、（编译器）合成的默认构造函数将按如下规则初始化类的数据成员：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-%E6%9F%90%E4%BA%9B%E7%B1%BB%E4%B8%8D%E8%83%BD%E4%BE%9D%E8%B5%96%E4%BA%8E%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text"> 三、某些类不能依赖于默认构造函数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text"> 四、构造函数的几种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94-%E6%8B%B7%E8%B4%9D-%E8%B5%8B%E5%80%BC%E5%92%8C%E6%9E%90%E6%9E%84"><span class="toc-text"> 五、拷贝、赋值和析构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#713-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%86%8D%E6%8E%A2"><span class="toc-text"> 7.1.3 构造函数再探</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%E5%85%B3%E4%BA%8E%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B"><span class="toc-text"> 一、关于列表初始</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0"><span class="toc-text"> 二、委托构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 三、隐式类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E6%8E%A7%E5%88%B6%E8%AE%BF%E9%97%AE%E5%92%8C%E5%B0%81%E8%A3%85"><span class="toc-text"> 7.2 控制访问和封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#721-%E8%AE%BF%E9%97%AE%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-text"> 7.2.1 访问说明符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#722-class%E4%B8%8Estruct"><span class="toc-text"> 7.2.2 class与struct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#733-%E5%8F%8B%E5%85%83"><span class="toc-text"> 7.3.3 友元</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-text"> 一、友元函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-text"> 二、友元类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="toc-text"> 7.3 类的其他特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#731-%E5%9C%A8%E7%B1%BB%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98"><span class="toc-text"> 7.3.1 在类中定义类型成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#732-%E4%BB%A4%E6%88%90%E5%91%98%E5%81%9Ainline%E5%87%BD%E6%95%B0"><span class="toc-text"> 7.3.2 令成员做inline函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#733-%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98-mutable"><span class="toc-text"> 7.3.3 可变数据成员 – mutable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#734-%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-text"> 7.3.4 类数据成员的初始值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#735-%EF%B8%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9Ethis"><span class="toc-text"> 7.3.5 ⭐️成员函数利用引用返回*this</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%E5%8F%AF%E5%B0%86%E4%B8%80%E7%B3%BB%E5%88%97%E6%93%8D%E4%BD%9C%E8%BF%9E%E6%8E%A5%E6%88%90%E4%B8%80%E6%9D%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text"> 一、可将一系列操作连接成一条表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8Cthis%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%94%E5%9B%9E"><span class="toc-text"> 二、const成员函数的重载和*this指针的返回</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#736-%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 7.3.6 类类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E5%BD%A2%E5%BC%8F"><span class="toc-text"> 7.4 类的其他形式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#741-%E8%81%9A%E5%90%88%E7%B1%BB"><span class="toc-text"> 7.4.1 聚合类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#742-constexpr%E7%B1%BB"><span class="toc-text"> 7.4.2 constexpr类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text"> 7.5 类的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#751-%E7%B1%BB%E5%90%8D%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-text"> 7.5.1 类名::的作用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#752-%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE"><span class="toc-text"> 7.5.2 名字查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text"> 7.6 类的静态成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#761-%E5%9F%BA%E7%A1%80"><span class="toc-text"> 7.6.1 基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#762-%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text"> 7.6.2 定义静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#763-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB%E5%86%85%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text"> 7.6.3 静态成员的类内初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#764-%E8%83%BD%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E8%80%8C%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text"> 7.6.4 能使用静态成员，而不能使用普通成员变量的场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%8F%AF%E4%BB%A5%E6%98%AF%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 一、静态数据成员可以是不完全类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%BD%9C%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82%E8%80%8C%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E4%B8%8D%E8%A1%8C"><span class="toc-text"> 二、可以使用静态成员作默认实参，而普通成员不行</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">------标准库------</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB-%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84io%E6%93%8D%E4%BD%9C"><span class="toc-text"> 八 标准库的IO操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#81-io%E7%B1%BB"><span class="toc-text"> 8.1 IO类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#811-io%E5%BA%93%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text"> 8.1.1 IO库类型和头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#812-io%E5%AF%B9%E8%B1%A1%E6%97%A0%E6%8B%B7%E8%B4%9D%E6%88%96%E8%B5%8B%E5%80%BC"><span class="toc-text"> 8.1.2 IO对象无拷贝或赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#813-io%E7%8A%B6%E6%80%81"><span class="toc-text"> 8.1.3  IO状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#814-%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text"> 8.1.4 缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#815-%E5%85%B3%E8%81%94%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8C%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text"> 8.1.5 关联输入流和输出流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82-iostream"><span class="toc-text"> 8.2 iostream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83-fstream%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-text"> 8.3 fstream（文件流）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#831-fstream%E7%9A%84%E7%89%B9%E6%9C%89%E6%93%8D%E4%BD%9C"><span class="toc-text"> 8.3.1 fstream的特有操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#832-%E6%96%87%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-text"> 8.3.2 文件模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-sstreamstring%E6%B5%81"><span class="toc-text"> 8.4 sstream（string流）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#841-istringstream"><span class="toc-text"> 8.4.1 istringstream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#842-ostringstream"><span class="toc-text"> 8.4.2 ostringstream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#843-%E6%9C%AC%E8%8A%82%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text"> 8.4.3 本节完整的示例代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-text"> 九 顺序容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#91-%E6%A6%82%E8%BF%B0"><span class="toc-text"> 9.1 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#911-%E9%80%89%E7%94%A8%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-text"> 9.1.1 选用顺序容器的原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-%E5%AE%B9%E5%99%A8%E5%BA%93%E6%A6%82%E8%A7%88"><span class="toc-text"> 9.2 容器库概览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#921-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text"> 9.2.1 迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#922-%E5%AE%B9%E5%99%A8%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text"> 9.2.2 容器定义和初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text"> 一、拷贝初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text"> 二、列表初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%8B%AC%E6%9C%89%E6%8C%87%E5%AE%9A%E5%AE%B9%E5%99%A8%E5%A4%A7%E5%B0%8F%E6%9D%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text"> 三、顺序容器独有：指定容器大小来初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B-array%E7%9A%84%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F"><span class="toc-text"> 四、array的固定大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#923-%E8%B5%8B%E5%80%BC%E5%92%8Cswap"><span class="toc-text"> 9.2.3 赋值和swap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#924-%E5%AE%B9%E5%99%A8%E5%A4%A7%E5%B0%8F"><span class="toc-text"> 9.2.4 容器大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#925-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97"><span class="toc-text"> 9.2.5 关系运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%9A%84%E7%89%B9%E6%9C%89%E6%93%8D%E4%BD%9C"><span class="toc-text"> 9.3 顺序容器的特有操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#931-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="toc-text"> 9.3.1 插入元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-push_back"><span class="toc-text"> 一、push_back</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-push_front"><span class="toc-text"> 二、push_front</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-insert"><span class="toc-text"> 三、insert</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#932-%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-text"> 9.3.2 访问元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#933-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text"> 9.3.3 删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#934-%E6%94%B9%E5%8F%98%E5%AE%B9%E5%99%A8%E5%A4%A7%E5%B0%8F"><span class="toc-text"> 9.3.4 改变容器大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#935-%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%83%BD%E4%BD%BF%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="toc-text"> 9.3.5 容器操作可能使迭代器失效</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-text"> 一、添加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text"> 二、删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-%E5%9B%A0%E6%AD%A4%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E7%AE%A1%E7%90%86%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text"> 三、因此，我们需要管理迭代器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94-vector%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%A2%9E%E9%95%BF%E7%9A%84"><span class="toc-text"> 9.4 vector对象是如何增长的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#95-forward_list%E4%B8%93%E9%A2%98"><span class="toc-text"> 9.5 forward_list专题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96-string%E4%B8%93%E9%A2%98"><span class="toc-text"> 9.6 string专题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#961-string%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB"><span class="toc-text"> 9.6.1 string操作函数汇总</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#962-%E6%9E%84%E9%80%A0string%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text"> 9.6.2 构造string的子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#962-%E6%94%B9%E5%8F%98string%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-text"> 9.6.2 改变string的其他方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#963-string%E6%90%9C%E7%B4%A2%E6%93%8D%E4%BD%9C"><span class="toc-text"> 9.6.3 string搜索操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#964-compare"><span class="toc-text"> 9.6.4 compare</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#965-%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 9.6.5 数值转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#97-%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text"> 9.7  适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#971-%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text"> 9.7.1 什么是适配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#972-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text"> 9.7.2 定义一个适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%E6%AF%8F%E4%B8%AA%E9%80%82%E9%85%8D%E5%99%A8%E9%83%BD%E5%AE%9A%E4%B9%89%E4%B8%A4%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text"> 一、每个适配器都定义两个构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-%E9%87%8D%E8%BD%BD%E9%BB%98%E8%AE%A4%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 二、重载默认容器类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-%E9%87%8D%E8%BD%BD%E9%BB%98%E8%AE%A4%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-text"> 三、重载默认容器类型的限制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#973-%E6%A0%88%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text"> 9.7.3 栈适配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#974-%E9%98%9F%E5%88%97%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text"> 9.7.4 队列适配器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-%E7%89%B9%E4%BE%8B%E6%B1%87%E6%80%BB"><span class="toc-text"> 9.8 特例汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#981-forward_list"><span class="toc-text"> 9.8.1 forward_list&lt;&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#982-string"><span class="toc-text"> 9.8.2 string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#983-array"><span class="toc-text"> 9.8.3 array&lt;&gt;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="toc-text"> 十 泛型算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E6%A6%82%E8%BF%B0"><span class="toc-text"> 10.1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-%E5%88%9D%E8%AF%86%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="toc-text"> 10.2 初识泛型算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1021-%E5%8F%AA%E8%AF%BB%E7%AE%97%E6%B3%95"><span class="toc-text"> 10.2.1 只读算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1022-%E5%86%99%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E7%AE%97%E6%B3%95"><span class="toc-text"> 10.2.2 写容器元素算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1023-%E9%87%8D%E6%8E%92%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E7%AE%97%E6%B3%95"><span class="toc-text"> 10.2.3 重排容器元素算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#103-%E5%AE%9A%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="toc-text"> 10.3 定制操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1031-%E8%B0%93%E8%AF%8D"><span class="toc-text"> 10.3.1 谓词</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%E9%80%9A%E8%BF%87%E8%B0%93%E8%AF%8D%E6%94%B9%E5%8F%98%E7%AE%97%E6%B3%95%E7%9A%84%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="toc-text"> 一、通过“谓词”改变算法的默认行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-%E4%B8%BE%E4%BE%8B"><span class="toc-text"> 二、举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-%E8%A1%A5%E5%85%85"><span class="toc-text"> 三、补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1032-lambda"><span class="toc-text"> 10.3.2 lambda</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%E4%B9%A6%E5%86%99%E6%A0%BC%E5%BC%8F"><span class="toc-text"> 一、书写格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-%E5%8F%82%E6%95%B0"><span class="toc-text"> 二、参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8"><span class="toc-text"> 三、捕获列表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80-%E8%B0%81%E9%9C%80%E8%A6%81%E8%A2%AB%E6%8D%95%E8%8E%B7"><span class="toc-text"> 一、谁需要被捕获？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C-%E5%87%A0%E7%A7%8D%E6%8D%95%E8%8E%B7%E6%96%B9%E5%BC%8F"><span class="toc-text"> 二、几种捕获方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8%E7%9A%84%E4%B9%A6%E5%86%99%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BB"><span class="toc-text"> 三、捕获列表的书写方式汇总</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B-%E5%8F%AF%E5%8F%98lambdamutable"><span class="toc-text"> 四、可变lambda（mutable）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B-%E6%8C%87%E5%AE%9Alambda%E7%9A%84%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 四、指定lambda的返回类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="toc-text"> 五、参数绑定</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E5%86%8D%E6%8E%A2%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text"> 10.4 再探迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1041-%E6%8F%92%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text"> 10.4.1 插入迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1042-%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text"> 10.4.2 流迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-istream_iterator"><span class="toc-text"> 一、istream_iterator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-ostream_iterator"><span class="toc-text"> 二、ostream_iterator</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1043-%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text"> 10.4.3 反向迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-text"> 10.5 泛型算法结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1051-%E4%BA%94%E7%B1%BB%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text"> 10.5.1 五类迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1052-%E7%AE%97%E6%B3%95%E5%BD%A2%E5%8F%82%E6%A8%A1%E5%BC%8F"><span class="toc-text"> 10.5.2 算法形参模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1053-%E7%AE%97%E6%B3%95%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-text"> 10.5.3 算法命名规范</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#106-%E7%89%B9%E5%AE%9A%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95"><span class="toc-text"> 10.6 特定容器算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-text"> 十一 关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#111-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-text"> 11.1 简单使用关联容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#112-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-text"> 11.2 关联容器概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1121-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-text"> 11.2.1 如何定义关联式容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1122-%E5%85%B3%E9%94%AE%E5%AD%97%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-text"> 11.2.2 关键字类型的要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1123-pair"><span class="toc-text"> 11.2.3 pair</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#113-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-text"> 11.3 关联容器操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1131-%E8%8E%B7%E5%BE%97%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E7%B1%BB%E5%9E%8B-%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text"> 11.3.1 获得关联容器中元素的类型 &amp; 容器迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1132-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-text"> 11.3.2 添加元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1133-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text"> 11.3.3 删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1134-map%E7%9A%84%E4%B8%8B%E6%A0%87%E6%93%8D%E4%BD%9C"><span class="toc-text"> 11.3.4 map的下标操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1135-%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="toc-text"> 11.3.5 访问元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114-%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-text"> 11.4 无序容器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="toc-text"> 十二 动态内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#121-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text"> 12.1 动态内存与智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1211-shared_ptr"><span class="toc-text"> 12.1.1 shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1212-new-delete"><span class="toc-text"> 12.1.2 new &amp; delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1213-shared_ptr-new"><span class="toc-text"> 12.1.3 shared_ptr &amp; new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1214-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E5%BC%82%E5%B8%B8"><span class="toc-text"> 12.1.4 智能指针 &amp; 异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1215-unique_ptr"><span class="toc-text"> 12.1.5 unique_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1216-weak_ptr"><span class="toc-text"> 12.1.6 weak_ptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-text"> 12.2 动态数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1221-new-%E6%95%B0%E7%BB%84"><span class="toc-text"> 12.2.1 new &amp; 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%E4%B8%A4%E7%A7%8D%E5%A3%B0%E6%98%8E%E6%96%B9%E6%B3%95"><span class="toc-text"> 一、两种声明方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text"> 二、初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-%E9%87%8A%E6%94%BE%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-text"> 三、释放动态数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-text"> 四、智能指针和动态数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1222-allocator%E7%B1%BB"><span class="toc-text"> 12.2.2 allocator类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%BF%87%E7%9A%84%E4%B9%A6%E4%B8%AD%E4%BE%8B%E5%AD%90%E7%9A%84%E8%AE%B0%E5%BD%95"><span class="toc-text"> 跳过的书中例子的记录</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">------类设计者工具------</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="toc-text"> 十三 拷贝控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#131-%E6%8B%B7%E8%B4%9D-%E8%B5%8B%E5%80%BC%E5%92%8C%E6%9E%90%E6%9E%84"><span class="toc-text"> 13.1 拷贝、赋值和析构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1311-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0"><span class="toc-text"> 13.1.1 拷贝构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text"> 一：拷贝初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-text"> 二：拷贝初始化的限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%AF%E4%BB%A5%E7%BB%95%E8%BF%87%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text"> 三：编译器可以绕过拷贝构造函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1312-%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC"><span class="toc-text"> 13.1.2 拷贝赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1313-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text"> 13.1.3 析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13131-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text"> 13.1.3.1 什么时候需要析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13132-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%B0%83%E7%94%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text"> 13.1.3.2 什么时候调用析构函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13133-%E4%B8%89%E4%BA%94%E6%B3%95%E5%88%99"><span class="toc-text"> 13.1.3.3 三&#x2F;五法则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1314-%E6%8E%A7%E5%88%B6%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E5%90%88%E6%88%90%E5%87%BD%E6%95%B0"><span class="toc-text"> 13.1.4 控制是否使用默认（合成）函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13141-default-delete"><span class="toc-text"> 13.1.4.1 &#x3D;default &amp; &#x3D;delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13142-%E4%BD%95%E6%97%B6%E5%90%88%E6%88%90%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98%E8%A2%AB%E5%AE%9A%E4%B9%89%E4%B8%BA%E5%88%A0%E9%99%A4"><span class="toc-text"> 13.1.4.2 何时合成的拷贝控制成员被定义为删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13143-private%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="toc-text"> 13.1.4.3 private拷贝控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#132-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-text"> 13.2 拷贝控制和资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1321-%E8%A1%8C%E4%B8%BA%E5%83%8F%E5%80%BC%E7%9A%84%E7%B1%BB%E6%8B%B7%E8%B4%9D%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text"> 13.2.1 行为像值的类——拷贝指针指向的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1322-%E8%A1%8C%E4%B8%BA%E5%83%8F%E6%8C%87%E9%92%88%E7%9A%84%E7%B1%BB%E6%8B%B7%E8%B4%9D%E6%8C%87%E9%92%88%E6%9C%AC%E8%BA%AB"><span class="toc-text"> 13.2.2 行为像指针的类——拷贝指针本身</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1323-%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="toc-text"> 13.2.3 交换操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89swap"><span class="toc-text"> 一：编写自定义swap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%9C%A8%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0%E4%B8%AD%E4%BD%BF%E7%94%A8swap"><span class="toc-text"> 二：在赋值构造中使用swap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#133-%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-text"> 13.3 两个例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1331-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E7%A4%BA%E4%BE%8B"><span class="toc-text"> 13.3.1 拷贝控制示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1332-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B1%BB"><span class="toc-text"> 13.3.2 动态内存管理类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#134-%EF%B8%8F%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8"><span class="toc-text"> 13.4 ⭐️对象移动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1341-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text"> 13.4.1 什么是右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="toc-text"> 一、左值和右值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text"> 二、右值引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1342-stdmove"><span class="toc-text"> 13.4.2 std::move()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1343-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC"><span class="toc-text"> 13.4.3 自定义类中的移动构造和移动赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13431-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0"><span class="toc-text"> 13.4.3.1 移动构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13432-%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC"><span class="toc-text"> 13.4.3.2 移动赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13433-%E5%90%88%E6%88%90%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C"><span class="toc-text"> 13.4.3.3 合成的移动操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13434-%E4%B8%89%E4%BA%94%E6%B3%95%E5%88%99"><span class="toc-text"> 13.4.3.4 三&#x2F;五法则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1345-%E5%9F%BA%E4%BA%8E%E6%8B%B7%E8%B4%9D%E5%B9%B6%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%E7%9A%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 13.4.5 （基于）拷贝并交换（技术的）赋值运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1344-%E7%A7%BB%E5%8A%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text"> 13.4.4 移动迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#135-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text"> 13.5 右值引用和成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1351-%E9%87%8D%E8%BD%BD%E6%8B%B7%E8%B4%9D%E7%89%88%E6%9C%AC%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%89%88%E6%9C%AC"><span class="toc-text"> 13.5.1 重载拷贝版本和移动版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1352-%E5%BC%95%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-text"> 13.5.2 引用限定符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 十四 重载运算与类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#141-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text"> 14.1 基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 14.2 输入和输出运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1421-operator"><span class="toc-text"> 14.2.1 operator&lt;&lt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1422-operator"><span class="toc-text"> 14.2.2 operator&gt;&gt;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#143-%E7%AE%97%E6%95%B0%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 14.3 算数和关系运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1431-%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 14.3.1 算数运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1432-%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 14.3.2 相等运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1433-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 14.3.3 关系运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#144-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 14.4 赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#145%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 14.5下标运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#146-%E9%80%92%E5%A2%9E%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 14.6 递增递减运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#147-%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 14.7 成员访问运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#148-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 14.8 函数调用运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1481-%E5%9F%BA%E7%A1%80"><span class="toc-text"> 14.8.1 基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1482-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8Eoperator"><span class="toc-text"> 14.8.2 lambda表达式与operator()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1483-%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text"> 14.8.3 标准库定义的函数对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1484-%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%B8%8Efunction"><span class="toc-text"> 14.8.4 可调用对象与function</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#149-%E9%87%8D%E8%BD%BD-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 14.9 重载、类型转换与运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1491-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 14.9.1 类型转换运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1492-%E9%81%BF%E5%85%8D%E6%9C%89%E4%BA%8C%E4%B9%89%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 14.9.2 避免有二义性的类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1493-%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text"> 14.9.3 函数匹配与重载的运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%94-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-text"> 十五 面向对象程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#151-oop%E6%A6%82%E8%BF%B0"><span class="toc-text"> 15.1 OOP：概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#152-%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-text"> 15.2 定义基类和派生类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1521-%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB"><span class="toc-text"> 15.2.1 定义基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1522-%E5%AE%9A%E4%B9%89%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-text"> 15.2.2 定义派生类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1523-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-text"> 15.2.3 类型转换与继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#153-%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text"> 15.3 虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#154-%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-text"> 15.4 抽象基类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#155-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-text"> 15.5 访问控制与继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#156-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text"> 15.6 继承中的类作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#157-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="toc-text"> 15.7 构造函数和拷贝控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#158-%E5%AE%B9%E5%99%A8%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-text"> 15.8 容器和继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%85%AD-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-text"> 十六 模板与泛型编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">------高级主题------</span></a></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js`,
    marked: `https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.27.0" async></script>

<!-- optional -->

  <script>
    function load_twikoo() {
        if (!document.querySelectorAll("#twikoo_container")[0]) return;
        utils.js('https://gcore.jsdelivr.net/npm/twikoo@1.6.8/dist/twikoo.all.min.js', {defer: true}).then(function () {
            const el = document.getElementById("twikoo_container");
            var path = el.getAttribute('comment_id');
            if (!path) {
                path = decodeURI(window.location.pathname);
            }
            twikoo.init(Object.assign({"js":"https://gcore.jsdelivr.net/npm/twikoo@1.6.8/dist/twikoo.all.min.js","envId":"https://hezexian-blogcommentsystem.hf.space"}, {
                el: '#twikoo_container',
                path: path,
            }));
        });
    }

    window.addEventListener('DOMContentLoaded', (event) => {
        load_twikoo();
    });
</script>



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"></script><script defer src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css`,
    js: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || null
        }
      });
    })
  }
</script><script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          loop: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
<script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
<script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"onload="renderMathInElement(document.body);"></script>
<script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/mermaid@v9/dist/mermaid.min.js"></script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    var mermaid_config = {
      startOnLoad: true,
      theme:
        "" == "auto" &&
          window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "neutral",
      logLevel: 3,
      themeVariables: {
        darkMode: true
      },
      flowchart: {
        useMaxWidth: false,
        htmlLabels: true,
        curve: "linear"
      },
      gantt: {
        axisFormat: "%Y/%m/%d"
      },
      sequence: {
        actorMargin: 50
      }
    }
    mermaid.initialize(mermaid_config);
  });
</script><script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
