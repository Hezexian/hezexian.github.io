<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>郭天祥51单片机第二版</title>
      <link href="/2024/03/26/%E9%83%AD%E5%A4%A9%E7%A5%A551%E5%8D%95%E7%89%87%E6%9C%BA%E7%AC%AC%E4%BA%8C%E7%89%88/"/>
      <url>/2024/03/26/%E9%83%AD%E5%A4%A9%E7%A5%A551%E5%8D%95%E7%89%87%E6%9C%BA%E7%AC%AC%E4%BA%8C%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="1-点亮第一个LED"><a href="#1-点亮第一个LED" class="headerlink" title="1 点亮第一个LED"></a>1 点亮第一个LED</h1><h2 id="1-1-两种电平类型"><a href="#1-1-两种电平类型" class="headerlink" title="1.1 两种电平类型"></a>1.1 两种电平类型</h2><div class="table-container"><table><thead><tr><th>电平类型</th><th>高</th><th>低</th></tr></thead><tbody><tr><td>TTL</td><td>+5V</td><td>0V</td></tr><tr><td>RS232</td><td>-12V</td><td>+12V</td></tr></tbody></table></div><p>TTL  &lt;——&gt;RS232，使用电平转换芯片max232</p><h2 id="1-2-了解二、八、十、十六进制及其转换"><a href="#1-2-了解二、八、十、十六进制及其转换" class="headerlink" title="1.2 了解二、八、十、十六进制及其转换"></a>1.2 了解二、八、十、十六进制及其转换</h2><p>略</p><h2 id="1-3-逻辑电路"><a href="#1-3-逻辑电路" class="headerlink" title="1.3 逻辑电路"></a>1.3 逻辑电路</h2><ul><li>参考<ul><li><a href="https://zhuanlan.zhihu.com/p/604162902">《图灵完备 Turing Complete》游戏攻略保姆级详解 更新中… - 知乎 (zhihu.com)</a></li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:left"></th><th>备注</th></tr></thead><tbody><tr><td style="text-align:center">非</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:center">与</td><td style="text-align:left">均1出1</td><td></td></tr><tr><td style="text-align:center">与非</td><td style="text-align:left">均1出0</td><td>即将 “与” 取  非</td></tr><tr><td style="text-align:center">或</td><td style="text-align:left">均0出0</td><td></td></tr><tr><td style="text-align:center">或非</td><td style="text-align:left">均0出1</td><td></td></tr><tr><td style="text-align:center">异或</td><td style="text-align:left">不同出1</td><td></td></tr><tr><td style="text-align:center">同或</td><td style="text-align:left">相同出1</td></tr></tbody></table></div><h2 id="1-4-关于的说明"><a href="#1-4-关于的说明" class="headerlink" title="1.4 关于的说明"></a>1.4 关于<reg52.h>的说明</h2><ul><li><p>作用：定义特殊功能寄存器和位寄存器</p></li><li><p>类型说明</p><p>| 声明类型 | 说明                   |<br>| ———— | ——————————— |<br>| sfr      | 特殊功能寄存器声明     |<br>| sfr16    | 16位特殊功能寄存器声明 |<br>| sbit     | 特殊功能位声明         |<br>| bit      | 位变量声明             |</p></li></ul><h2 id="1-5-单片机结构"><a href="#1-5-单片机结构" class="headerlink" title="1.5 单片机结构"></a>1.5 单片机结构</h2><ul><li><p>内部结构<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403261647320.png" alt="image-20240326164714235" style="zoom:67%;" /></p><p>关于总线：总线(BUS)是计算机各部件之间传送信息的公共通道。微机中有内部总线和外部总线两类。</p><ul><li>内部总线是CPU内部之间的连线。</li><li>外部总线是指CPU与其它部件之间的连线。<ul><li>外部总线有三种：<strong>数据总线DB（Data Bus）、地址总线 AB（Address Bus）和控制总线CB（Control Bus）</strong></li></ul></li></ul></li></ul><ul><li>tx开发板外观<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403261654095.png" alt="image-20240326165450988" style="zoom:67%;" /></li></ul><h2 id="1-6-P3第二功能说明"><a href="#1-6-P3第二功能说明" class="headerlink" title="1.6 P3第二功能说明"></a>1.6 P3第二功能说明</h2><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403261646199.png" alt="image-20240326164647132" style="zoom:67%;" /></p><h2 id="1-7-单片机主要需要掌握"><a href="#1-7-单片机主要需要掌握" class="headerlink" title="1.7 单片机主要需要掌握"></a>1.7 单片机主要需要掌握</h2><ul><li>最小系统能够运行起来的必要条件<ul><li>电源</li><li>晶振</li><li>复位电路</li></ul></li><li>对单片机任意IO口的随意操作<ul><li>输出控制电平高低</li><li>输出检测电平高低。</li></ul></li><li>定时器:重点掌握最常用的方式2</li><li>中断:外部中断、定时器中断、串口中断</li><li>串口通信:单片机之间、单片机与计算机间</li></ul><h2 id="1-8-实验：点亮第一个led灯"><a href="#1-8-实验：点亮第一个led灯" class="headerlink" title="1.8 实验：点亮第一个led灯"></a>1.8 实验：点亮第一个led灯</h2><p> 51单片机IO口默认高电平</p><h3 id="1-8-1-操作P0-0为点亮第一个led灯"><a href="#1-8-1-操作P0-0为点亮第一个led灯" class="headerlink" title="1.8.1 操作P0_0为点亮第一个led灯"></a>1.8.1 操作P0_0为点亮第一个led灯</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 操作P0_0为点亮第一个led灯</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sbit D0 = P1^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    D0 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么<code>sbit D0 = P1^0;</code>要在main函数之外？</p><blockquote><p>sbit声明的部分是编译器预处理的部分，就是为了给寄存器（位或字节）取个别名，是在函数没有编译之前必须完成的，放在主函数中就是编译中要处理的内容了，对于那些符号地址，C编译器不认识，有的名字也不允许（如P1.1）,必须在编译之前进行替代，就是sbit声明，替代的内容为相应单片机寄存器的头文件里边定义的，如REG51.H</p></blockquote><h3 id="1-8-2-操作总线为点亮第一个led灯"><a href="#1-8-2-操作总线为点亮第一个led灯" class="headerlink" title="1.8.2 操作总线为点亮第一个led灯"></a>1.8.2 操作总线为点亮第一个led灯</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 操作总线为点亮第一个led灯</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    P1 = <span class="number">0xfe</span>; <span class="comment">//1111 1110</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-3-结果"><a href="#1-8-3-结果" class="headerlink" title="1.8.3 结果"></a>1.8.3 结果</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403261619131.png" alt="image-20240326161919076"></p><h2 id="1-9-硬件补充知识"><a href="#1-9-硬件补充知识" class="headerlink" title="1.9 硬件补充知识"></a>1.9 硬件补充知识</h2><p>LED电路展示</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403261917038.png" alt="image-20240326191751980"></p><h3 id="1-9-1-如何计算排阻的阻值？"><a href="#1-9-1-如何计算排阻的阻值？" class="headerlink" title="1.9.1 如何计算排阻的阻值？"></a>1.9.1 如何计算排阻的阻值？</h3><ul><li>计算排阻值<ul><li>上图的P2即排阻，内部其实就是并联的一堆电阻如下图所示。</li><li>下图中展示了如何根据电阻大小来控制通过led的电流，进而控制led的亮度。</li><li>如图<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403261931451.png" alt="image-20240326193115416"></li></ul></li></ul><ul><li><p>电阻的分类：</p><ul><li><p>限流电阻<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403261943929.png" alt="image-20240326194305877" style="zoom: 50%;" /></p></li><li><p>上拉电阻</p></li><li><p>下拉电阻</p></li></ul></li></ul><h3 id="1-9-2-74HC573锁存器"><a href="#1-9-2-74HC573锁存器" class="headerlink" title="1.9.2 74HC573锁存器"></a>1.9.2 74HC573锁存器</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403261938111.png" alt="image-20240326193830074"></p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403261939651.png" alt="image-20240326193934617"></p><p>$\overline{\text{OE}}$（output enable）：上划线表示只有低电平时，芯片才有效。</p><p>D：输入端</p><p>Q：输出端</p><p>LE：锁存器的锁存端</p><p>Z：高阻态</p><p>$Q_0$ ：上一次的值</p><p>X：任意值</p><h3 id="1-9-3-STC-ISP的用法"><a href="#1-9-3-STC-ISP的用法" class="headerlink" title="1.9.3 STC-ISP的用法"></a>1.9.3 STC-ISP的用法</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403261953050.png" alt="image-20240326195307951"></p><h3 id="1-9-4-单片机的命名"><a href="#1-9-4-单片机的命名" class="headerlink" title="1.9.4 单片机的命名"></a>1.9.4 单片机的命名</h3><p>STC89C5240CPDIP0721CV4336</p><p>89：系列</p><p>C：cmos</p><p>52：2*4k存储空间</p><p>40：最高40Mhz</p><p>C：商用级</p><p>PDIP：双列直插式封装</p><p>0721：生产日期</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>protues配置相关</title>
      <link href="/2024/02/27/protues%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/"/>
      <url>/2024/02/27/protues%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>遇到多种问题：</p><ol><li>Proteus仿真报错：未找到“LEDA.MDF”</li><li>第一次仿真成功，停止后，重新仿真终止，报一堆错。包括：<code>[SPICE] TRAN: Timestep too small; initial timepoint: trouble with instance Q1</code>等</li></ol><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p><strong>以管理员身份运行protues</strong>：</p><p>在Windows操作系统中，你可以通过以下步骤将软件设置为默认以管理员身份运行：</p><ol><li><strong>找到应用程序的可执行文件</strong>：首先，找到你想要设置为默认以管理员身份运行的应用程序的可执行文件。通常，这些文件的扩展名为.exe。</li><li><strong>右键单击可执行文件</strong>：在文件资源管理器中，找到应用程序的可执行文件，然后右键单击它以显示上下文菜单。</li><li><strong>选择“属性”</strong>：在上下文菜单中，选择“属性”选项。这将打开应用程序的属性对话框。</li><li><strong>切换到“兼容性”选项卡</strong>：在属性对话框中，切换到“兼容性”选项卡。</li><li><strong>勾选“以管理员身份运行此程序”</strong>：在“兼容性”选项卡下方，你会看到一个复选框，标有“以管理员身份运行此程序”。勾选这个复选框以激活管理员权限。</li><li><strong>保存更改</strong>：点击“应用”或“确定”按钮，然后关闭属性对话框。<br>现在，每次运行这个应用程序时，Windows都会提示你是否要以管理员身份运行它。如果你选择是，程序将以管理员权限运行。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> protues </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>platformio配置问题</title>
      <link href="/2024/02/26/platformio%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/02/26/platformio%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="P1-0-sfr等报错：未定义"><a href="#P1-0-sfr等报错：未定义" class="headerlink" title="P1_0,__sfr等报错：未定义"></a><code>P1_0</code>,<code>__sfr</code>等报错：未定义</h1><p><a href="https://github.com/microsoft/vscode-cpptools/issues/2499">参考链接</a></p><p><code>c_cpp_properties.json</code>中defines添加：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;__interrupt(IntelliSense_Hack)=&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;__sfr=unsigned char&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;__sbit=int&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;__at(a)= &quot;</span></span><br></pre></td></tr></table></figure><h1 id="生成-hex文件"><a href="#生成-hex文件" class="headerlink" title="生成.hex文件"></a>生成.hex文件</h1><ul><li><p>项目根目录添加<code>extra_script.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Import(<span class="string">&quot;env&quot;</span>)</span><br><span class="line"></span><br><span class="line">env.AddPostAction(</span><br><span class="line">    <span class="string">&quot;$BUILD_DIR/$&#123;PROGNAME&#125;.elf&quot;</span>,</span><br><span class="line">    env.VerboseAction(<span class="string">&quot; &quot;</span>.join([</span><br><span class="line">        <span class="string">&quot;$OBJCOPY&quot;</span>, <span class="string">&quot;-O&quot;</span>, <span class="string">&quot;ihex&quot;</span>, <span class="string">&quot;-R&quot;</span>, <span class="string">&quot;.eeprom&quot;</span>,</span><br><span class="line">        <span class="string">&quot;$BUILD_DIR/$&#123;PROGNAME&#125;.elf&quot;</span>, <span class="string">&quot;$BUILD_DIR/$&#123;PROGNAME&#125;.hex&quot;</span></span><br><span class="line">    ]), <span class="string">&quot;Building $BUILD_DIR/$&#123;PROGNAME&#125;.hex&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><code>platformio.ini</code>追加</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extra_scripts</span> = extra_script.py</span><br></pre></td></tr></table></figure></li><li><p>重新编译即可</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> platformio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过代码配置PlatformIO生成HEX文件</title>
      <link href="/2024/02/24/%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AEPlatformIO%E7%94%9F%E6%88%90HEX%E6%96%87%E4%BB%B6/"/>
      <url>/2024/02/24/%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AEPlatformIO%E7%94%9F%E6%88%90HEX%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://blog.csdn.net/chang_jiang123/article/details/106215699">原文链接</a> </strong></p><p>  如果要通过串口给51或者32等单片机烧写程序，很多时候需要HEX文件。Keil软件中就有输出HEX文件的设置，勾选一下就行，但是，PlatformIO好像还没这么方便的操作，下面我以STM32工程为例，介绍一下如何通过代码配置PlatformIO生成HEX文件。  </p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402241708785592.png" alt="2020051915391067"></p><p>首先，在工程目录下新建<strong>extra_script.py</strong>文件（和platformio.ini在同一目录下），代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Import(<span class="string">&quot;env&quot;</span>)</span><br><span class="line"></span><br><span class="line">env.AddPostAction(</span><br><span class="line">    <span class="string">&quot;$BUILD_DIR/$&#123;PROGNAME&#125;.elf&quot;</span>,</span><br><span class="line">    env.VerboseAction(<span class="string">&quot; &quot;</span>.join([</span><br><span class="line">        <span class="string">&quot;$OBJCOPY&quot;</span>, <span class="string">&quot;-O&quot;</span>, <span class="string">&quot;ihex&quot;</span>, <span class="string">&quot;-R&quot;</span>, <span class="string">&quot;.eeprom&quot;</span>,</span><br><span class="line">        <span class="string">&quot;$BUILD_DIR/$&#123;PROGNAME&#125;.elf&quot;</span>, <span class="string">&quot;$BUILD_DIR/$&#123;PROGNAME&#125;.hex&quot;</span></span><br><span class="line">    ]), <span class="string">&quot;Building $BUILD_DIR/$&#123;PROGNAME&#125;.hex&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后，在VS Code左侧项目列表打开platformio.ini文件，在最后一行增加如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extra_scripts = extra_script.py</span><br></pre></td></tr></table></figure><p>我的platformio.ini完整如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">env</span>:genericSTM32F103C8]</span><br><span class="line">platform = ststm32</span><br><span class="line">board = genericSTM32F103C8</span><br><span class="line">framework = arduino</span><br><span class="line">extra_scripts = extra_script.py</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>OK，配置完成，可以点击VS Code底部的“对勾”按钮进行编译了，编译成功就会生成HEX文件，生成路径如下：  </p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402241708785613.png" alt="20200519154856980"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> platformio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt程序打包发布，含三方库</title>
      <link href="/2024/02/19/Qt%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83%EF%BC%8C%E5%90%AB%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
      <url>/2024/02/19/Qt%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83%EF%BC%8C%E5%90%AB%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/sasafa/article/details/126538432?utm_source=pocket_saves">原文链接</a></p><p>1、在Qt里选择release构建。</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251541925.png" alt="1"></p><p>2、点击run运行，保证程序能够成功运行出来。</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251541781.png" alt="2"></p><p>3、成功能运行后，去构建成功的build release文件夹下找到刚刚编译后的.exe文件。</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251542830.png" alt="3"></p><p>4、单独复制出来到一个新文件夹model，复制进去。</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251542268.png" alt="4"></p><p>5、在qt程序找到如下，构建的时候选择64位，现在打包编译也是需要64位，一一对应，不能混32位。</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251543700.png" alt="5"></p><p>6、点击，进入到刚刚创建的文件夹下。</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251543670.png" alt="6"></p><p>7、执行<code>windeployqt jie_mian1.exe</code>，也就是windeployqt+你自己刚刚编译后的程序名称.exe。</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251544003.png" alt="7"></p><p>8、此时已经在model文件下qt依赖库已经安装好了，直接点击就可以运行。<strong>但是如果含有第三库.dll，点击会提示找不到，所以这时候把.dll拷贝到model文件夹下，即可。</strong></p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251544197.png" alt="8"></p><p>9、<strong>把缺少的第三方库拷贝到model文件夹下和qt依赖库放一起，即可打开</strong>，因为原来在qt上debug的时候，第三方库也是放在build debug文件夹下的，所以debug模式编译时候能找到。</p><p>10、打开打包软件。用 <strong>Enigma Virtual Box软件</strong>。没有的同学，自己要去网上下载一个。</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251545787.png" alt="9"></p><p>11、点击浏览，选择要打包的.exe文件。</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251545740.png" alt="10"></p><p>12、点击文件选项，勾选压缩文件。</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251546508.png" alt=""></p><p>13、点击左下角添加，选择按文件递归。</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251546976.png" alt=""></p><p>14、选择刚刚的model文件夹，点击确定。</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251546747.png" alt=""></p><p>15、选择默认，确定即可。</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251546799.png" alt=""></p><p>16、最后看到下图，最后点击打包即可。</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251546463.png" alt=""></p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251547614.png" alt=""></p><p>17、打包成功之后在<strong>刚刚设置的输出目标目录</strong>会出现打包好的<strong>XXXXX_boxed.exe</strong>应用程序，这个程序就是可以直接完全打包好的，<strong>点击即用</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vmware安装过增强工具还是无法拖放</title>
      <link href="/2024/02/19/vmware%E5%AE%89%E8%A3%85%E8%BF%87%E5%A2%9E%E5%BC%BA%E5%B7%A5%E5%85%B7%E8%BF%98%E6%98%AF%E6%97%A0%E6%B3%95%E6%8B%96%E6%94%BE/"/>
      <url>/2024/02/19/vmware%E5%AE%89%E8%A3%85%E8%BF%87%E5%A2%9E%E5%BC%BA%E5%B7%A5%E5%85%B7%E8%BF%98%E6%98%AF%E6%97%A0%E6%B3%95%E6%8B%96%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<p>vmware安装过增强工具还是无法拖放</p><p>还需安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install open-vm-tools-desktop</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> vmware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1panel+雨云服务器+https配置lsky-pro（兰空图床）</title>
      <link href="/2024/02/15/lsky+1panel+https+%E9%9B%A8%E4%BA%91%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/02/15/lsky+1panel+https+%E9%9B%A8%E4%BA%91%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：摸了两天终于在自己的服务器配置了图床，根据回忆记录一下，大致是这样。</p></blockquote><h1 id="1-在1panel下载lsky"><a href="#1-在1panel下载lsky" class="headerlink" title="1 在1panel下载lsky"></a>1 在1panel下载lsky</h1><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402151031160.png" alt="202402151031160"></p><h1 id="2-登录lsky"><a href="#2-登录lsky" class="headerlink" title="2 登录lsky"></a>2 登录lsky</h1><h2 id="2-1-创建一个数据库"><a href="#2-1-创建一个数据库" class="headerlink" title="2.1 创建一个数据库"></a>2.1 创建一个数据库</h2><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402151033507.png" alt="image-20240215103349371"></p><h2 id="2-2-浏览器新建标签页"><a href="#2-2-浏览器新建标签页" class="headerlink" title="2.2 浏览器新建标签页"></a>2.2 浏览器新建标签页</h2><ul><li>在浏览器地址栏输入<code>服务器地址:lsky服务端口</code></li><li>等待环境检测 -&gt; 下一步</li><li>配置数据库<ul><li>ip修改为<code>服务器的公网ip</code></li><li><code>数据库连接端口</code>不用改</li><li>后面根据下图修改</li><li>安装完成后，使用管理员账户登录</li><li>此后就可以使用<code>http://服务器地址:lsky服务端口</code>登录图床了</li><li>上传一张图片，默认是：<code>http://服务器地址:lsky服务端口/i/图片名</code>查看图片</li></ul></li></ul><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402151039534.png" alt="image-20240215103914436"></p><h1 id="3-配置图床"><a href="#3-配置图床" class="headerlink" title="3 配置图床"></a>3 配置图床</h1><ul><li><p>更改保存文件格式</p></li><li><p>图床空间大小等</p></li><li>图像设置为<strong>公开</strong></li></ul><p>参考：</p><ul><li><a href="https://blog.musnow.top/posts/370869610/?highlight=lsky">配置lsky</a></li></ul><h1 id="4-https"><a href="#4-https" class="headerlink" title="4 https"></a>4 https</h1><h2 id="4-1-创建雨云二级域名"><a href="#4-1-创建雨云二级域名" class="headerlink" title="4.1 创建雨云二级域名"></a>4.1 创建雨云二级域名</h2><ul><li><p><a href="https://www.rainyun.com/docs/domain/introduce">参考</a>，假设创建的域名为<code>kekepiclsky.skyman.cloud</code></p></li><li><p>添加cname解析，以腾讯云为例：</p><ul><li>设主机记录栏填写（假设<code>lsky</code>），</li><li>记录类型栏须<code>cname</code>；记录值须为雨云二级域名，此处为<code>kekepiclsky.skyman.cloud</code></li></ul><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402151049666.png" alt="image-20240215104951601"></p></li></ul><h2 id="4-2-添加ssl"><a href="#4-2-添加ssl" class="headerlink" title="4.2 添加ssl"></a>4.2 添加ssl</h2><ul><li>在雨云ssl证书中心-&gt;<code>自己的域名.xxx.xxx</code>（例：lsky.hekeke.top，我的主域名为hekeke.top）-&gt;立即创建-&gt;复制主机名和记录值<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402151052183.png" alt="image-20240215105210092"></li></ul><ul><li><a href="https://www.rainyun.com/docs/ssl/">参考雨云ssl证书</a>，以在4.1节图中第一行所示，主机记录值填<code>_acme-challenge.自己的域名</code>（例：_acme-challenge.lsky），记录值复制进去，点击确认</li><li>等2分钟，点击<code>我已完成解析</code></li></ul><h2 id="4-3-反向代理"><a href="#4-3-反向代理" class="headerlink" title="4.3 反向代理"></a>4.3 反向代理</h2><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402151102029.png" alt="image-20240215110250880"></p><p>在域名管理中，找到申请ssl的域名，复制<code>查看&amp;下载</code>中的文本</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402151108894.png" alt="image-20240215110843840"></p><p>进入网站配置，点击https，选择手动导入，将上一步复制的文本导入（要对应），保存</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402151108204.png" alt="image-20240215110810124"></p><h2 id="4-4-修改访问网址"><a href="#4-4-修改访问网址" class="headerlink" title="4.4 修改访问网址"></a>4.4 修改访问网址</h2><p>浏览器地址栏输入<code>服务器地址:lsky端口</code>进入控制面板</p><p>点击存储策略，修改访问网址</p><p>将原来的<code>http://服务器地址:lsky端口/i</code>改为<code>https//example.com/i</code>（例：<a href="https://hezexian.oss-cn-guangzhou.aliyuncs.com）">https://hezexian.oss-cn-guangzhou.aliyuncs.com）</a></p><h2 id="4-5-图像https可访问"><a href="#4-5-图像https可访问" class="headerlink" title="4.5 图像https可访问"></a>4.5 图像https可访问</h2><p>从</p><p><a href="http://服务器ip:lsky端口/i/picture/202402151108204.png">http://服务器ip:lsky端口/i/picture/202402151108204.png</a></p><p>变为</p><p><a href="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/20240215118204.png">https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/20240215118204.png</a></p><h1 id="5-picgo"><a href="#5-picgo" class="headerlink" title="5 picgo"></a>5 picgo</h1><p><a href="https://blog.musnow.top/posts/370869610/?highlight=lsky">点击此链接获取配置lsky-picgo的方法；token的获取方法如下面的连接所示</a></p><p><a href="https://github.com/hellodk34/picgo-plugin-lankong">注意token的获取方式，不是从‘接口-验证方式’直接复制，参考readme</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl --location --request POST <span class="string">&#x27;https://your.domain/api/v1/tokens&#x27;</span> \</span><br><span class="line">--form <span class="string">&#x27;email=&quot;your_email@address&quot;&#x27;</span> \</span><br><span class="line">--form <span class="string">&#x27;password=&quot;your_passwd&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402151128836.png" alt="image-20240215112803734"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://blog.musnow.top/posts/370869610/?highlight=lsky">配置lsky</a></p><p>[2] <a href="https://www.rainyun.com/docs/ssl/">参考雨云ssl证书</a></p><p>[3] <a href="https://github.com/hellodk34/picgo-plugin-lankong">picgo 兰空图床插件</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>emit和connect的顺序问题</title>
      <link href="/2024/01/31/emit%E5%92%8Cconnect%E7%9A%84%E9%A1%BA%E5%BA%8F/"/>
      <url>/2024/01/31/emit%E5%92%8Cconnect%E7%9A%84%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>下述代码，无论如何都进不到槽函数<code>MonoCalibrate::calibrate</code>里面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QThread *caliThread = <span class="keyword">new</span> <span class="built_in">QThread</span>(<span class="keyword">this</span>);</span><br><span class="line">MonoCalibrate *monocali = <span class="keyword">new</span> <span class="built_in">MonoCalibrate</span>(m_res_ckbd);</span><br><span class="line">monocali-&gt;<span class="built_in">moveToThread</span>(caliThread);</span><br><span class="line">caliThread-&gt;<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">emit monocali-&gt;<span class="built_in">startCalibration</span>();</span><br><span class="line"><span class="built_in">connect</span>(monocali,&amp;MonoCalibrate::startCalibration,monocali,&amp;MonoCalibrate::calibrate);</span><br></pre></td></tr></table></figure><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>需要先连接（connect）再发射信号（emit）：</p><p>在连接信号和槽函数之前就发出了信号，将导致信号连接无效，因为在连接之前，没有接收槽函数的对象。</p><p>为了解决这个问题，可以将信号发出的代码移到连接之后。这样，当信号被发出时，槽函数已经连接并准备好执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; QThread::<span class="built_in">currentThread</span>();</span><br><span class="line"></span><br><span class="line">QThread *caliThread = <span class="keyword">new</span> <span class="built_in">QThread</span>(<span class="keyword">this</span>);</span><br><span class="line">MonoCalibrate *monocali = <span class="keyword">new</span> <span class="built_in">MonoCalibrate</span>(m_res_ckbd);</span><br><span class="line">monocali-&gt;<span class="built_in">moveToThread</span>(caliThread);</span><br><span class="line">caliThread-&gt;<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(monocali, &amp;MonoCalibrate::startCalibration, monocali, &amp;MonoCalibrate::calibrate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在连接之后发出信号</span></span><br><span class="line">emit monocali-&gt;<span class="built_in">startCalibration</span>();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo在butterfly/next主题下代码块缩进问题</title>
      <link href="/2024/01/25/hexo%E4%BB%A3%E7%A0%81%E5%9D%97%E7%BC%A9%E8%BF%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2024/01/25/hexo%E4%BB%A3%E7%A0%81%E5%9D%97%E7%BC%A9%E8%BF%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>遇到了一个问题：hexo的butterfly、next主题下，代码块缩进特别大。</p><p>对比发现，当缩进为一个tab时才会出现问题。当缩进为4个空格时，则表现正常。</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p><a href="https://www.zhihu.com/question/466823990/answer/1956882758">hexo的next主题(v 8.5)编译之后代码块缩进特别大，怎么调整？ - Mr.J的回答 - 知乎</a></p><p>文中说，</p><blockquote><p>可能原因，你缩进使用了tab，在HTML下，默认等于8个空格，建议修改为空格缩进，或者修改tab-size属性</p><p>把vscode的缩进改成空格就好了。</p></blockquote><p>可是，我的文章已经写了上万字，逐个修改显然不可能实现。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p><code>hexo根目录/_config.yml</code>第50行(若没改过的话)，<code>tab_replace</code>改为四个空格，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;    &#x27;</span> </span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>问题解决。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer</title>
      <link href="/2024/01/08/C++Primer/"/>
      <url>/2024/01/08/C++Primer/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><strong>固然，轻薄短小的书籍乍见之下让所有读者心情轻松，但如果舍弃太多应该深入的地方不谈，也难免令人行止失据，进退两难。</strong></p><p>……</p><p><strong>作为一个好的学习者，背景不是重点，重要的是，你是否具备正确的学习态度。起步固然可从轻松小品开始，但如果碰上大部头巨著就退避三舍、逃之夭夭，面对任何技术只求快餐速成，学语言却从来不写程序，那就绝对没有成为高手乃至专家的一天。</strong></p><p><strong>有些人的学习，自练就一身钢筋铁骨，可以在热带丛林中披荆斩棘，在莽莽草原中追奔逐北。有些人的学习，既未习惯大部头书，也未习惯严谨格调，更未习惯自修勤学，是温室里的一朵花，没有自立自强的本钱</strong>。</p><p>——《Essential C++》前言，侯捷</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/cpp-standard-library-reference?view=msvc-170">C++ 标准库参考 (STL)—Microsoft</a></p><p>[2] <a href="https://cplusplus.com">cplusplus.com</a></p><p>[3] <a href="https://zh.wikipedia.org/wiki/C%2B%2B%E6%A8%99%E6%BA%96%E5%87%BD%E5%BC%8F%E5%BA%AB">stl—wiki</a></p><div align="center"><h1>------C++ 基础------</h1></div><h1 id="二-变量和基本类型"><a href="#二-变量和基本类型" class="headerlink" title="二 变量和基本类型"></a>二 变量和基本类型</h1><h2 id="2-1-基本内置类型"><a href="#2-1-基本内置类型" class="headerlink" title="2.1 基本内置类型"></a>2.1 基本内置类型</h2><h3 id="2-1-1-变量类型的大小"><a href="#2-1-1-变量类型的大小" class="headerlink" title="2.1.1 变量类型的大小"></a>2.1.1 变量类型的大小</h3><p>下图列出了各类型的最小尺寸。</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401081030476.png" alt="数据类型最小大小" style="zoom:67%;" /></p><h3 id="2-1-2-符号"><a href="#2-1-2-符号" class="headerlink" title="2.1.2 符号"></a>2.1.2 符号</h3><ul><li><p>整型</p><ul><li>int：正数、负数和0</li><li>usigned int: 大于0</li></ul></li><li><p>字符型</p><ul><li>char :在有些机器上是signed，有些机器是unsigned</li><li>signed char</li><li>unsigned char</li></ul></li></ul><p>如何选择？</p><ul><li><p>明知数值不可能为负，用无符号</p></li><li><p>整数运算用int、long long</p></li><li><p>浮点用double</p></li></ul><h3 id="2-1-3类型转化"><a href="#2-1-3类型转化" class="headerlink" title="2.1.3类型转化"></a>2.1.3类型转化</h3><ul><li><p>:question:有个不明白的地方，不明白怎么算的:(P33)赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。</p></li><li><p>当一个算术表达式中既有无符号又有int，int就会转换成无符号，有可能引发错误。  &lt;-混用引发错误</p></li></ul><h2 id="2-2-字面值常量"><a href="#2-2-字面值常量" class="headerlink" title="2.2 字面值常量"></a>2.2 字面值常量</h2><ul><li><p>整型和浮点型</p><ul><li>自动选择能匹配的空间最小的一个作为其数据类型</li><li>十进制不会是负数。符号不在字面值之内，负号的作用是对字面值取负</li><li>科学计数法指数部分用E或e标识</li></ul></li><li><p>字符和字符串字面值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> <span class="comment">// 字符, &#x27;a&#x27;</span></span><br><span class="line"><span class="string">&quot;a&quot;</span> <span class="comment">// 字符串，&#x27;a&#x27;+&#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则实际上是一个整体</span></span><br><span class="line">std::cout&lt;&lt; <span class="string">&quot;a really, really long string literal &quot;</span></span><br><span class="line">        &lt;&lt;<span class="string">&quot;that spans two lines&quot;</span> &lt;&lt;std::endl;</span><br></pre></td></tr></table></figure></li><li><p>转义<br><a href="https://www.cnblogs.com/chuijingjing/p/9246669.html">常用转义字符</a></p></li><li><p>布尔和指针</p><ul><li>bool ：true ，false</li><li>指针：nullptr</li></ul></li></ul><p>如何指定字面值类型？</p><ul><li>通过添加下表的前缀和后缀，改变整型、浮点型和字符型字面值的默认类型<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401081025034.png" alt="指定字面值类型" style="zoom:67%;" /></li></ul><h2 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h2><h3 id="2-3-1-了解变量"><a href="#2-3-1-了解变量" class="headerlink" title="2.3.1 了解变量"></a>2.3.1 了解变量</h3><ul><li>定义</li></ul><ul><li>初始化<ul><li>初始化不是赋值：<ul><li>初始化是创建变量时赋予其一个初始值；</li><li>赋值是把对象的当前值擦除，而以一个新值替代。</li></ul></li></ul></li></ul><ul><li><p>四种初始化方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能有信息丢失的风险</span></span><br><span class="line"><span class="type">long</span> <span class="type">double</span> b = <span class="number">3.1415929</span></span><br><span class="line"><span class="type">int</span> a = b;  <span class="comment">// a = 3, 信息丢失</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(b)</span></span>;  <span class="comment">// a = 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用列表初始化，存在上述风险将报错</span></span><br><span class="line"><span class="type">int</span> a = &#123;b&#125;;</span><br><span class="line"><span class="type">int</span> a&#123;b&#125;;</span><br></pre></td></tr></table></figure></li><li><p>默认初始化</p><ul><li><p>内置类型默认初始化的值由定义的位置决定</p><ul><li>定义与任何函数体之外 ，初始化为0</li><li>…内，不被默认初始化，变量值未定义</li></ul></li><li><p><strong>建议初始化每一个内置类型的变量</strong></p></li></ul></li><li><p>声明和定义的关系</p><ul><li><p>声明使得名字为程序所知；定义负责创建与名字关联的实体，并申请存储空间。</p></li><li><p>只能被定义一次，可以被声明多次。</p></li><li><p>如果想声明一个变量而非定义，使用<code>extern</code>，并且不要显示地初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;     <span class="comment">//仅声明</span></span><br><span class="line"><span class="type">int</span> i ;         <span class="comment">//声明并定义</span></span><br></pre></td></tr></table></figure></li><li><p>在函数体内部，初始化一个又<code>extern</code>标记的变量，将引发错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i = <span class="number">3.14</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li><li><p>如果要在多个文件中使用同一个变量，必须将声明和定义分离。变量的定义必须出现且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。例，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Class2.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class2::<span class="built_in">print_i</span>();  <span class="comment">// 重点输出：Class2: 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class2.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;    <span class="comment">// &lt;- 注意这里，如果不写就会报：i未声明标识符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Class2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print_i</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Class2: &quot;</span>&lt;&lt;i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Class2.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> i = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>标识符</p><ul><li>用户自定义标识符中不能连续出现两个下划线；不能下划线紧邻大写字母；定义在函数体外的标识符不能以下划线开头。</li><li>变量名一般小写字母；类名以大写字母开头</li></ul><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401081104469.png" style="zoom:67%;" /></p></li></ul><h3 id="2-3-2-作用域"><a href="#2-3-2-作用域" class="headerlink" title="2.3.2 作用域"></a>2.3.2 作用域</h3><p>对于嵌套作用域：</p><ul><li>作用域中一旦声明了某个名字，它所嵌套着的所有作用域都能访问这个名字。</li><li>同时，允许在内层作用域中重新定义外层作用域中已有的名字。</li><li><code>::</code>访问全局变量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; endl; <span class="comment">//42,0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">//0,0</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ::a &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">//42,0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-复合类型"><a href="#2-4-复合类型" class="headerlink" title="2.4 复合类型"></a>2.4 复合类型</h2><ul><li>声明语句：一条语句声明由一个基本数据类型和紧随其后的声明符列表组成。</li><li>指针和引用，前后的类型都要严格匹配</li></ul><h3 id="2-4-1-引用"><a href="#2-4-1-引用" class="headerlink" title="2.4.1 引用"></a>2.4.1 引用</h3><ul><li>引用必须被初始化，且只能绑定到对象上，不能与字面值或某个表达式的计算结果绑定；</li><li>无法令引用重新绑定到另一个对象；</li><li>引用本身不是对象，所以不能定义引用的引用</li></ul><h3 id="2-4-2-指针"><a href="#2-4-2-指针" class="headerlink" title="2.4.2 指针"></a>2.4.2 指针</h3><ul><li><p>指针本身是一个对象；</p></li><li><p>无须在定义时赋初值；</p></li><li><p>引用不是对象，没有实际地址，不能定义指向引用的指针；但指针是对象，存在对指针的引用，例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> *&amp;r = p; <span class="comment">// r是对指针p的引用</span></span><br></pre></td></tr></table></figure><p>注：上面的代码如何阅读？从又向左阅读r的定义，离变量名最近的符号（此处为<code>&amp;</code>）对变量的类型有直接的影响，因此上文中r是一个引用。</p></li></ul><p><code>void *</code>可用于存放任意对象的地址，我们不清楚其到底指向的是什么类型的对象，也无法访问其指向的内存空间中的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">void</span> *ptr = &amp;a;</span><br><span class="line">cout&lt;&lt;*ptr&lt;&lt;endl; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>定义多个变量时，类型修饰符（如 *）只修饰一个变量，对该声明语句中的其他变量，不产生任何作用。例，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样写容易产生误导</span></span><br><span class="line"><span class="type">int</span>* p1,p2;        <span class="comment">// p1是指向int的指针，p2是int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议写成</span></span><br><span class="line"><span class="type">int</span> *p1, p2;</span><br></pre></td></tr></table></figure><h2 id="2-5-const"><a href="#2-5-const" class="headerlink" title="2.5 const"></a>2.5 const</h2><ul><li>const的宗旨：<strong>任何试图改变<code>const</code>修饰的变量都将引发错误</strong></li><li>const对象一旦创建就不能改变，因此必须初始化，初始值可以是任意复杂表达式</li><li>默认状态下，const对象仅在文件内生效。如果想要在多个文件中共享，最好的办法是不管是声明还是定义都加上<code>extern</code>关键字。</li></ul><h3 id="2-5-1-常量引用"><a href="#2-5-1-常量引用" class="headerlink" title="2.5.1 常量引用"></a>2.5.1 常量引用</h3><ul><li><p>即对const的引用</p></li><li><p>初始化常量引用允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">//const int temp = a;  // &lt;-编译器内部自己做的操作,生成一个临时变量</span></span><br><span class="line"><span class="comment">//const int &amp;r = temp; //&lt;-编译器内部自己做的操作，将引用绑定到一个临时变量上</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = a;  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></li><li><p>const的左值引用可以绑定到右值<br><a href="#1361-右值引用">右值引用</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i*<span class="number">42</span>; <span class="comment">// 错误，左值引用不可绑定到右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = i*<span class="number">42</span>; <span class="comment">// 正确，const的左值引用可以绑定到右值</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5-2-指针和const"><a href="#2-5-2-指针和const" class="headerlink" title="2.5.2 指针和const"></a>2.5.2 指针和const</h3><ul><li><p>指针常量 — 指向常量的指针</p><ul><li><p>想要存放常量对象的地址，只能使用指向常量的指针；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span>  <span class="type">double</span> *cptr = &amp;pi;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>- 允许一个指向常量的指针指向非常量对象。</code></pre><ul><li><p>常量指针 — 指针本身是一个常量</p><ul><li><p>把*放在const之后，用以说明指针是一个常量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> ptr = &amp;a;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-5-3-顶层const和底层const"><a href="#2-5-3-顶层const和底层const" class="headerlink" title="2.5.3 顶层const和底层const"></a>2.5.3 顶层const和底层const</h3><ul><li>顶层const表示指针本身是一个常量。推广：任意的对象是常量，如算术类型、类、指针…</li><li>底层const表示指针所指的对象是常量。推广：指针和引用等复合类型的基本类型部分有关。</li></ul><p>当执行拷贝时，</p><ul><li>顶层const不受影响；</li><li>底层const对象必须具有相同的const资格，或者两个对象的数据类型必须能够转换。</li></ul><h3 id="2-5-4-常量表达式和constexpr"><a href="#2-5-4-常量表达式和constexpr" class="headerlink" title="2.5.4 常量表达式和constexpr"></a>2.5.4 常量表达式和constexpr</h3><ul><li><p>常量表达式</p><ul><li><p>常量表达式是指：值不会改变 且 在编译过程就能得到计算结果 的表达式</p></li><li><p>一个对象是不是常量表达式有其数据类型和初始值共同决定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********** 例1 **************/</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mf = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = mf +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********** 例2 **************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>();  <span class="comment">// 通过</span></span><br><span class="line">    cout &lt;&lt; sz &lt;&lt; endl;    <span class="comment">// 输出1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>constexpr</code> — 由编译器来验证变量是否是一个常量表达式。声明为<code>constexpr</code>的变量:</p><ul><li><p>一定是一个常量</p></li><li><p>必须用常量表达式初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********** 例1 **************/</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mf = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit = mf +<span class="number">1</span>;</span><br><span class="line"><span class="comment">/*********** 例2 **************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int get_size() &#123; return 1; &#125; //C++表达式必须含有常量值,无法调用非constexpr函数 </span></span><br><span class="line"><span class="comment">//const int get_size() &#123; return 1; &#125; //同上</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">get_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>(); </span><br><span class="line">    cout &lt;&lt; sz &lt;&lt; endl;    <span class="comment">// 输出1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p>字面值类型</p><ul><li><p>算术类型、引用和指针都属于，可被定义为constexpr；</p><p>注意：</p><ul><li><p>引用和指针初始值受限：必须是0或者nullptr，或者存储于某个固定地址中的对象。函数提内的对象一般不在固定地址，不能用constexpr；允许函数定义的一类超出函数体本身的变量，其存在于固定地址，constexpr引用（指针）也能（绑定）指向该变量。</p></li><li><p>constexpr定义了一个指针，constexpr仅对指针本身有效，对指针所指的对象无关 &lt;-顶层const。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *q = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// 类似</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> q = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------</span></span><br><span class="line"><span class="comment">//可得</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> *p  = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// 类似</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>io、string等不属于字面值类型</p></li></ul></li><li><p>constexpr函数<a href="#653-constexpr函数">（笔记6.5.3）</a></p></li><li><p>constexpr类<a href="#742-constexpr类">（笔记7.4.2）</a></p></li></ul><h2 id="2-6-处理类型"><a href="#2-6-处理类型" class="headerlink" title="2.6 处理类型"></a>2.6 处理类型</h2><h3 id="2-6-1-类型别名"><a href="#2-6-1-类型别名" class="headerlink" title="2.6.1 类型别名"></a>2.6.1 类型别名</h3><ul><li><p><code>typedef</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages;</span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">//base = double, p = double *</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>using</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> wages = <span class="type">double</span>;</span><br></pre></td></tr></table></figure></li></ul><p>需要注意的是，<strong>类型别名不能直接往代码中替换，要将类型别名看成一个整体</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *pstring; <span class="comment">//pstring = char *</span></span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">// 指针本身是一个常量，char *const cstr = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接替换是错误的：</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *cstr = <span class="number">0</span>; <span class="comment">//指向常量的指针</span></span><br></pre></td></tr></table></figure><h3 id="2-6-2-auto"><a href="#2-6-2-auto" class="headerlink" title="2.6.2 auto"></a>2.6.2 auto</h3><ul><li><p>auto定义的变量必须有初始值</p></li><li><p>编译器以引用对象的类型作为auto的类型（auto会忽略引用）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, &amp; r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r; <span class="comment">// auto = int</span></span><br></pre></td></tr></table></figure></li><li><p>auto一般会忽略掉顶层const，保留底层const。想要保留顶层const，则需要手动指出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i, &amp; cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;  <span class="comment">//int (顶层const)</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;  <span class="comment">//int  （顶层const）</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;  <span class="comment">//int *  （顶层const）</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;  <span class="comment">//const int *  （底层const）</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = ci; <span class="comment">//const int  (为保留顶层const而手动指出)</span></span><br></pre></td></tr></table></figure></li><li><p>auto和引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;g = ci; <span class="comment">//g 的类型为const int &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//auto &amp;h = 42; //错误，不能为非常量引用绑定字面值</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;h = <span class="number">42</span>;  <span class="comment">//const int &amp;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>利用auto在一条语句中声明多个变量时，这多个变量的初始值必须是同一类型。</li></ul><h3 id="2-6-3-decltype"><a href="#2-6-3-decltype" class="headerlink" title="2.6.3 decltype"></a>2.6.3 decltype</h3><ul><li><p>选择并返回操作数的数据类型 — 编译器分析表达式并得到其类型，却不计算其值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func</span>()) sun = x;</span><br></pre></td></tr></table></figure></li><li><p>如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用）&lt;-区别于auto</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x= <span class="number">0</span>;  <span class="comment">// const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x; <span class="comment">//const int &amp;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>decltype和引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(r+<span class="number">0</span>) b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype(*p) c; //出错，“引用变量c需要初始值设定项”</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c = i; <span class="comment">//c的类型是int &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(i) d;  <span class="comment">// int</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) e = i;  <span class="comment">//int &amp;</span></span><br></pre></td></tr></table></figure><ul><li><code>decltype(r)</code>的结果是引用，如果想让结果类型是r所指的类型，只需把r作为表达式的一部分，如<code>decltype(r+0)</code></li><li><strong>decltype表达式的类型是解引用操作，将得到引用类型</strong>，因此必须初始化，如<code>decltype(*p) c = i;</code></li><li><strong><code>decltype((variable))</code>  （注意是双层括号）的结果永远是引用类型</strong></li></ul></li></ul><h1 id="三-字符串、向量和数组"><a href="#三-字符串、向量和数组" class="headerlink" title="三 字符串、向量和数组"></a>三 字符串、向量和数组</h1><h2 id="3-1-using"><a href="#3-1-using" class="headerlink" title="3.1 using"></a>3.1 <code>using</code></h2><ul><li><p>每个名字都需要独立的<code>using</code>声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br></pre></td></tr></table></figure></li><li><p>注意：头文件中不应包含<code>using</code> &lt;-否则，每个使用该头文件的代码都会包含该声明，从而引起命名的冲突。</p></li></ul><h2 id="3-2-string"><a href="#3-2-string" class="headerlink" title="3.2 string"></a>3.2 string</h2><p><a href="# 9.6 string专题">笔记9.6 - string专题</a></p><h3 id="3-2-1-初始化"><a href="#3-2-1-初始化" class="headerlink" title="3.2.1 初始化"></a>3.2.1 初始化</h3><ul><li>拷贝初始化。<code>string s = &quot;a&quot;;</code></li><li>直接初始化。<code>string s(&quot;a&quot;);</code></li></ul><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401101530079.png" alt="初始化string的方式"></p><p><a href="#962-构造string的其他方法">笔记9.6.2 其他初始化string的方法</a></p><h3 id="3-2-2-string对象的操作"><a href="#3-2-2-string对象的操作" class="headerlink" title="3.2.2 string对象的操作"></a>3.2.2 string对象的操作</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401101536561.png" alt="string的操作"></p><ul><li><p>读写</p><ul><li><p>读取操作时，string对象会自动忽略开头的空白，并从真正的第一个字符开始读起，直到遇到下一个空白。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入&quot;  hello world&quot;;</span></span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl; <span class="comment">//hello</span></span><br><span class="line"></span><br><span class="line">string s1,s2;</span><br><span class="line">cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">cout &lt;&lt; s1&lt;&lt;s2&lt;&lt;endl; <span class="comment">//helloworld</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//endl 结束当前行，刷新缓冲区</span></span><br></pre></td></tr></table></figure></li><li><p>读取未知数量的string对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;s)&#123; <span class="comment">//遇到文件结束标记或非法输入，循环结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>读取一整行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string line;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin,line))&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>getline</code>从给定的输入流中读取内容，直到遇到换行符为止（换行符也被读取进来了），将内容存入string对象中（不存换行符）。</li><li>如果一开始就是换行符，则得到空的string对象。</li><li>和cin一样返回流参数，因此可作为循环的判断条件</li></ul></li></ul></li><li><p>size</p><ul><li><code>size()</code>返回一个<code>string::size_type</code>类型的值，是一个无符号类型的值，因此要避免与有符号数混用所带来的问题。</li></ul></li><li><p>相加<br><strong>当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符两侧的<font color="red">运算对象至少有一个是string</font>.</strong><br> <a href="#141-基本概念">14.1最后一点，<code>operator+</code>在string类中为非成员</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string s1 = s+<span class="string">&quot;,&quot;</span>; <span class="comment">//正确</span></span><br><span class="line">string s2 = <span class="string">&quot;hello&quot;</span>+<span class="string">&quot;,&quot;</span>; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line">string s3 = s+<span class="string">&quot;,&quot;</span>+<span class="string">&quot;hello&quot;</span>; <span class="comment">//正确</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">string s3 = (s+<span class="string">&quot;,&quot;</span>)+<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">string tmp = s1+<span class="string">&quot;,&quot;</span>;</span><br><span class="line">string s3 = tmp+<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">string s4 = <span class="string">&quot;hello&quot;</span>+<span class="string">&quot;,&quot;</span>+s; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-3-处理string对象中的字符"><a href="#3-2-3-处理string对象中的字符" class="headerlink" title="3.2.3 处理string对象中的字符"></a>3.2.3 处理string对象中的字符</h3><ul><li>处理函数</li></ul><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401110941997.png" alt="cctype头文件中的函数" style="zoom:67%;" /></p><ul><li><p>范围for</p><ul><li>注意declaration是引用时，是直接对experssion中原来的元素进行操作</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(declaration : experssion)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>下标运算符（[ ]）接收的输入是<code>string::size_type</code>类型的值，返回值是该位置上字符的引用。</p><ul><li><code>str[str.size()-1]</code>是最后一个字符</li><li>在访问指定字符之前，需要检查字符串是否为空：<code>if(!str.isempty())&#123; /*访问指定字符*/&#125;</code>，并注意下标的合法范围<code>[0 , str.size())</code>。</li></ul></li></ul><h2 id="3-3-vector"><a href="#3-3-vector" class="headerlink" title="3.3 vector"></a>3.3 vector</h2><h3 id="3-3-1-初始化vector对象"><a href="#3-3-1-初始化vector对象" class="headerlink" title="3.3.1 初始化vector对象"></a>3.3.1 初始化vector对象</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401111004548.png" alt="初始化vector对象的方法" style="zoom:67%;" /></p><ul><li><p>使用拷贝初始化（=）只能提供一个初始值；</p></li><li><p>类内初始值只能使用拷贝初始化或使用花括号形式的初始值；</p></li><li><p>列表初始化使用{}，而不是()</p><ul><li><p>值得注意的是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v1&#123;<span class="number">10</span>&#125;;             <span class="comment">// 10个默认初始化的元素</span></span><br><span class="line">vector&lt;string&gt; v2&#123;<span class="number">10</span>,<span class="string">&quot;hi&quot;</span>&#125;;        <span class="comment">// 10个值为hi的元素</span></span><br></pre></td></tr></table></figure><p>以上两者都不是列表初始化，花括号的值必须与元素类型相同，显然不能用int初始化string对象，因此上面两者的花括号中都不能作为元素的初始值。在无法执行列表初始化后，编译器会尝试用默认值初始化vector对象。</p></li></ul></li></ul><h3 id="3-3-2-vector操作"><a href="#3-3-2-vector操作" class="headerlink" title="3.3.2 vector操作"></a>3.3.2 vector操作</h3><ul><li><p>添加元素 — <code>push_back()</code></p><ul><li><blockquote><p>在定义vector对象的时候设定其大小就没什么必要了，事实上如果这么做性能可能更差</p></blockquote></li></ul></li><li><p>vector其他操作罗列</p><ul><li><p>注意<code>size()</code>同样返回<code>vector&lt;xxx&gt;::size_type</code>类型</p><blockquote><p>要使用<code>size_type</code>类型，需要首先指定它是由哪些类型定义的</p></blockquote></li></ul><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401111025007.png" alt="vector的其他操作" style="zoom:67%;" /></p></li><li><p>只有当元素的值可比时，vector对象才能被比较：元素个数相等，对应位置的元素也相等</p></li></ul><h3 id="3-3-3-迭代器"><a href="#3-3-3-迭代器" class="headerlink" title="3.3.3 迭代器"></a>3.3.3 迭代器</h3><ul><li><p>用法</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401111524526.png" alt="迭代器运算符" style="zoom:67%;" /></p><blockquote><p>在for循环中使用<code>!=</code>，原因是c++程序员更愿意使用迭代器而非下标。并非所有的容器的迭代器都定义了<code>&lt;</code>等，但都定义了<code>==</code>和<code>!=</code></p></blockquote></li><li><p>迭代器的类型 — <code>iterator</code>和<code>const_iterator</code>（只读）</p><ul><li>如果迭代器对象是一个常量，则只能用const_iterator</li><li>不是常量，则都能用</li></ul></li><li><p>begin和end、cbegin和cend</p><ul><li><p>它们返回的具体类型由对象是否是常量决定，如是常量返回const_iterator，否则返回iterator</p></li><li><p>如果只需读取，而不写入，可使用<code>cbegin</code>和<code>cend</code>，返回const_iterator</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.<span class="built_in">begin</span>();        <span class="comment">// vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.<span class="built_in">begin</span>();        <span class="comment">// vector&lt;int&gt;::const_iterator</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it3 = v.<span class="built_in">cbegin</span>();         <span class="comment">// vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>使vector迭代器失效的操作：</p><ul><li>在范围for循环中向vector对象添加元素</li><li>任何一种可能改变vector对象的操作，如push_back</li></ul></li><li><p>运算<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401111547255.png" alt="vector和string迭代器支持的运算" style="zoom:67%;" /></p><ul><li>迭代器相减的结果的类型：<code>difference_type</code>的带符号整型数</li></ul></li></ul><h2 id="3-4-数组"><a href="#3-4-数组" class="headerlink" title="3.4 数组"></a>3.4 数组</h2><h3 id="3-4-1-定义和初始化数组"><a href="#3-4-1-定义和初始化数组" class="headerlink" title="3.4.1 定义和初始化数组"></a>3.4.1 定义和初始化数组</h3><ul><li><p>定义</p><ul><li>编译的时候维度必须是已知的，维度必须是一个常量表达式（<code>constexpr</code>）</li><li>和内置类型的变量一样，如果在<strong>函数内部定义</strong>了某种内置类型的数组，那么<strong>默认初始化会令数组含有未定义的值</strong></li><li>不许用auto指定数组；</li><li>不存在引用的数组</li></ul></li><li><p>初始化</p><ul><li><p>显式地初始化数组</p><ul><li><p>列表初始化时，可不写维度，编译器会自动推测</p></li><li><p>指明维度后，初始值数量不应超过维度大小</p></li></ul></li><li><p>字符数组的特殊性 — 注意字符串结尾的空字符也会被拷贝到数组中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a3[] = <span class="string">&quot;c++&quot;</span>;  <span class="comment">// 维度为4</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="type">char</span> a3[] = &#123;<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>数组不允许拷贝和赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> a2[] = a;     <span class="comment">// 错误</span></span><br><span class="line">a2 = a;            <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>复杂的数组声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*parray)[<span class="number">10</span>] = &amp;arr;</span><br></pre></td></tr></table></figure><p>从数组名开始，由内向外，由右向左 —&gt;parray是一个指针，指向大小为10的数组，数组中包含int对象</p></li></ul><ul><li>在使用数组下标时，通常将其定义为<code>size_t</code>类型，它是一种无符号整型，定义于<code>cstddef</code>中</li></ul><ul><li>两个特殊性质<ul><li>不允许拷贝数组</li><li>使用数组时通常会将其转化成指针</li></ul></li></ul><h3 id="3-4-2-指针和数组"><a href="#3-4-2-指针和数组" class="headerlink" title="3.4.2 指针和数组"></a>3.4.2 指针和数组</h3><ul><li><p>数组名是指向数组首元素的指针</p><ul><li><p><code>auto</code>推断得到的类型是<strong>指针</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;  <span class="comment">// auto == int *</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>使用<code>decltype</code>时，返回的类型是<strong>数组</strong>  &lt;— 与auto区分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">ia3[<span class="number">1</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>“迭代器”</p><ul><li><p>获取数组的“尾后迭代器” &lt;—不能对尾后指针进行解引用或者递增</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *e = &amp;arr[<span class="comment">/*元素个数*/</span>];</span><br></pre></td></tr></table></figure></li><li><p>然而这种方法极易出错，c++11在<code>iterator</code>头文件中定义了两个函数<code>begin</code>和<code>end</code>，它们分别返回头指针和尾指针，用法如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *begin = <span class="built_in">begin</span>(ia);    <span class="comment">// 正确的使用形式是将数组作为它们的参数</span></span><br><span class="line"><span class="type">int</span> *end = <span class="built_in">end</span>(ia);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>两个指向同一数组不同元素的指针相减得到它们之间的距离，类型为<code>ptrdiff_t</code>，定义于<code>cstddef</code>,为带符号类型。<a href="#3.3.3 迭代器">（对比3.3.3节-运算-两个迭代器相减的结果类型）</a></p></li><li><p>与vector与string等标准库下标运算仅支持无符号数不同，数组的下标运算（内置下标运算）支持负数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = &amp;a[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> j = *(p+<span class="number">1</span>);  <span class="comment">// j = a[3]</span></span><br><span class="line"><span class="type">int</span> k = p[<span class="number">-2</span>];  <span class="comment">//k = a[0]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-3-多维数组"><a href="#3-4-3-多维数组" class="headerlink" title="3.4.3 多维数组"></a>3.4.3 多维数组</h3><blockquote><p>严格来说，c++没有多维数组，所说多维数组其实是数组的数组。谨记这一点，对今后理解和使用多维数组大有裨益。</p></blockquote><ul><li><p><code>int arr[3][4]</code>: 大小为3的数组，每个元素是含有4个整数的数组</p></li><li><p>初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">                &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------</span></span><br><span class="line"><span class="comment">//初始化每行首元素</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">4</span>&#125;,&#123;<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//不等于</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">4</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>下标和多维数组  略</p></li><li><p>范围for处理多维数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; row :ia)&#123;  &lt;--注意此处一定为 引用，原因如下所述</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> col :row)&#123;</span><br><span class="line">        cout&lt;&lt;col&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>auto会将<a href="#3.4.2-指针和数组">数组自动转成指针</a> （3.4.2节-<code>auto</code>推断得到…），row的类型就成了<code>int *</code>，怎么可能再进行内层循环呢？</p></li><li><p>指针和多维数组</p><ul><li><p>多维数组名 ：指向第一个内层数组的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = <span class="built_in">begin</span>(ia); p!=<span class="built_in">end</span>(ia); p++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> q = <span class="built_in">begin</span>(*p); q != <span class="built_in">end</span>(*p); q++)&#123;</span><br><span class="line">        <span class="comment">/*...*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401121552247.png" style="zoom: 67%;" /></p></li><li><p>参考资料</p><ul><li><a href="https://blog.csdn.net/xiang_bolin/article/details/130448488">数组大小可省略的定义 — 努力学习游泳的鱼</a></li></ul></li></ul></li></ul><h3 id="3-4-4-与旧代码接口"><a href="#3-4-4-与旧代码接口" class="headerlink" title="3.4.4 与旧代码接口"></a>3.4.4 与旧代码接口</h3><ul><li><p>C风格字符串</p><ul><li>c++程序中最好不要使用<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401121142358.png" alt="c风格字符串操作函数列举"></li><li>传入上述函数的指针<strong>必须指向以空字符串作为结束</strong>的数组</li></ul></li><li><p>string和c风格字符串</p><ul><li>任何出现字符串字面值的地方都可以用  以空字符结束的字符数组  替代<ul><li>允许用…来初始化string对象或为string对象赋值</li><li>允许作为加法运算中的一员（P111）</li></ul></li><li>但是，不能反过来用string对象直接初始化指向字符数组的指针，<ul><li><code>string.c_str()</code>返回一个指向以空字符结束的字符数组的指针（char  *），数组存放的数据恰好与string对象一样；</li><li>但如果后续操作改变string，之前返回的字符数组将会失效</li></ul></li></ul></li><li><p>使用数组初始化vector</p><ul><li><p>允许使用数组来初始化vector对象，只需指明首元素地址和<strong>尾后</strong>地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec1</span><span class="params">(begin(arr),end(arr))</span></span>;    <span class="comment">//&#123;0,1,2,3,4,5&#125;</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec2</span><span class="params">(arr+<span class="number">1</span>,arr+<span class="number">3</span>)</span></span>;            <span class="comment">//&#123;1,2&#125;  &lt;--不包含rr[3]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="四-表达式"><a href="#四-表达式" class="headerlink" title="四 表达式"></a>四 表达式</h1><h2 id="4-1-基础"><a href="#4-1-基础" class="headerlink" title="4.1 基础"></a>4.1 基础</h2><ul><li><p>小整数类型（bool、char、short等）通常会被提升成较大的整数类型，主要是int</p></li><li><p>运算符重载时，运算对象的个数、运算符的优先级和结合律都是无法改变的</p></li><li><p>左值和右值 &lt;— 有些迷惑（P121，2024/1/13）:question:</p><ul><li>左值表示一个占据<a href="https://so.csdn.net/so/search?q=内存&amp;spm=1001.2101.3001.7020">内存</a>中可识别位置的一个对象，更进一步地，可以对左值取地址</li><li><p>判断右值的一个简单方法就是能不能对变量或者表达式取地址，如果不能，他就是右值</p></li><li><p>参考文献</p><ul><li><a href="https://blog.csdn.net/weixin_45425093/article/details/120310405">左值与右值 — 不摆烂的zzz</a></li></ul></li></ul></li></ul><ul><li><p>求值顺序</p><ul><li><p>对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。</p></li><li><p>求值顺序与优先级和结合律无关（P123底部）  &lt;—拿不准的时候用括号来强制符合要求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如，int i = f()+g()*h()+j()</span><br><span class="line">这些函数的调用顺序没有明确的规定，如果它们互不相关，则无妨。如果其中某几个函数影响同一个对象，则将会产生未定义行为</span><br></pre></td></tr></table></figure></li><li><p>这4种运算符明确规定了运算对象的求值顺序：<code>&amp;&amp;</code>, <code>||</code>, <code>?:</code>, <code>,</code></p></li><li><p>例外情况：当  改变运算对象的子表达式本身  就是  另一个子表达式的运算对象  ，则没有什么影响：如<code>*++iter</code>，递增运算先发生（改变运算对象的子表达式）,解引用后发生。</p></li></ul></li></ul><h2 id="4-2-运算符"><a href="#4-2-运算符" class="headerlink" title="4.2 运算符"></a>4.2 运算符</h2><p>本节运算符表都是按照优先级顺序将其分组，同优先级按照从左到右的顺序。</p><h3 id="4-2-1-算术运算符"><a href="#4-2-1-算术运算符" class="headerlink" title="4.2.1 算术运算符"></a>4.2.1 算术运算符</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401131600803.png" alt="算术运算符" style="zoom:67%;" /></p><ul><li>算术对象和求值结果都是<strong>右值</strong></li><li>小整数的对象被提升成较大整数</li><li>一元正号、加法、减法运算符都能作用于指针</li><li>一元正（负）号，（负数将运算对象值取负后）返回对象值的一个（提升后的）副本</li><li>c++11规定<strong>商一律向0取整</strong></li><li><code>%</code>返回两个<strong>整数</strong>相除所得的余数</li><li><strong>如果<code>m%n!=0</code>,结果符号与m相同</strong></li></ul><h3 id="4-2-2-逻辑和关系运算符"><a href="#4-2-2-逻辑和关系运算符" class="headerlink" title="4.2.2 逻辑和关系运算符"></a>4.2.2 逻辑和关系运算符</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401131603212.png" alt="逻辑和关系运算符表" style="zoom:67%;" /></p><ul><li>关系运算符作用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型。</li><li>返回值都是布尔类型，运算结果和求值对象都是<strong>右值</strong></li><li>因为关系运算法的求值结果是布尔类型，所以将几个关系运算符连写在一起会产生意想不到的效果</li></ul><h3 id="4-2-3-赋值运算符"><a href="#4-2-3-赋值运算符" class="headerlink" title="4.2.3 赋值运算符"></a>4.2.3 赋值运算符</h3><ul><li>赋值运算符的左侧运算对象必须是一个<strong>可修改</strong>的<strong>左值</strong></li><li>右侧运算对象将转换成左侧运算对象的类型</li></ul><h3 id="4-2-4-递增、递减运算符"><a href="#4-2-4-递增、递减运算符" class="headerlink" title="4.2.4 递增、递减运算符"></a>4.2.4 递增、递减运算符</h3><ul><li><p><code>++</code>、<code>--</code>运算符必须作用于左值运算对象，前置版本将对象本身作为左值返回，后置版本将对象原始值的副本作为右值返回</p></li><li><blockquote><p>除非必须，否则不用递增递减运算符的后置版本  &lt;— 额外增加开销（P132）</p></blockquote></li><li><p>如果一个子表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话，运算对象的求值顺序就很关键了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P133</span></span><br><span class="line">*beg = <span class="built_in">toupper</span>(*beg++);  <span class="comment">// 未定义行为</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2-5-成员访问运算符"><a href="#4-2-5-成员访问运算符" class="headerlink" title="4.2.5 成员访问运算符"></a>4.2.5 成员访问运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;mem;</span><br><span class="line">(*ptr).men;</span><br></pre></td></tr></table></figure><ul><li><p>解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上<code>()</code>：<code>(*ptr).men</code></p></li><li><blockquote><p>箭头运算符作用于一个指针类型的对象，结果是一个左值。点运算符分成两种情况：如果成员所属的对象是左值，那么结果是左值；反之，如果成员所属的对象是右值，那么结果是右值。</p></blockquote></li></ul><h3 id="4-2-6-条件运算符"><a href="#4-2-6-条件运算符" class="headerlink" title="4.2.6 条件运算符"></a>4.2.6 条件运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition ? expr1 : expr2;</span><br></pre></td></tr></table></figure><ul><li><p>当条件运算符的两个表达式都是左值或者能转换成同一类左值类型时，运算结果是左值，否者，运算结果是右值。</p></li><li><p>可嵌套，最好别超过2到3层，如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond1?expr1:cond2?expr2:expr3;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>满足右结合律，右边的条件运算构成了靠左边条件运算的分支。上述代码实际为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond1 ? expr1  :   (cond2?expr2:expr3)  <span class="comment">// &lt;--从右边开始结合，括号中的是分支</span></span><br></pre></td></tr></table></figure></li><li><p>条件运算符的优先级非常低，当一条长表达式中嵌套了条件运算子表达式时，通常需要在其两端加上括号</p></li></ul><h3 id="4-2-7-位运算符"><a href="#4-2-7-位运算符" class="headerlink" title="4.2.7 位运算符"></a>4.2.7 位运算符</h3><ul><li><p>位运算符整数类型的运算对象，并且把运算对象看成二进制位的集和</p></li><li><p>如果运算对象是“小整型”，则它的值将会被自动提升为较大的整数类型。 —— <strong>先提升，再对提升后的整体进行位运算</strong></p></li><li><p>不同机器对于符号位的处理各不相同，因此建议位运算符<strong>仅用于处理无符号类型</strong></p></li></ul><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401141127468.png" alt="位运算符（左结合律）" style="zoom:67%;" /></p><ul><li><p>移位运算符</p><ul><li><p><code>&lt;&lt;</code>、<code>&gt;&gt;</code>的右侧的运算符一定不能为负，并且值严格小于结果的位数</p></li><li><p>满足左结合律</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;hi&quot;</span>&lt;&lt;<span class="string">&quot;three&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">( (cout&lt;&lt;<span class="string">&quot;hi&quot;</span>) &lt;&lt; <span class="string">&quot;three&quot;</span> ) &lt;&lt;endl;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>示例<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401141128465.png" alt="位移运算符" style="zoom:67%;" /></li></ul><ul><li><p>位求反运算符  略</p></li><li><p>位与、位或、位异或 </p><ul><li>异或 ：不同出1，相同处0</li></ul></li></ul><h3 id="4-2-8-sizeof运算符"><a href="#4-2-8-sizeof运算符" class="headerlink" title="4.2.8 sizeof运算符"></a>4.2.8 sizeof运算符</h3><ul><li><p><strong><code>sizeof</code>返回一条表达式或一个类型名字所占的字节数</strong>，满足右结合律，得到<code>size_t</code>类型的常量表达式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span> (type);  <span class="comment">// sizeof (类型名)</span></span><br><span class="line"><span class="keyword">sizeof</span> expr;    <span class="comment">// sizeof 表达式  &lt;-- 不实际计算表达式的值，意味着即使是无效指针依然安全</span></span><br></pre></td></tr></table></figure></li><li><p>c++11新标准允许使用作用域运算符来获取类成员大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> Sale_data::revenue;</span><br></pre></td></tr></table></figure></li><li><p>常见的sizeof运算结果</p><ul><li><p>char或类型为char的表达式，结果为1</p></li><li><p>引用类型，结果为被引用对象所占空间的大小</p></li><li><p>指针，指针本身所占空间的大小</p></li><li><p>解引用指针，指针指向的对象所占空间的大小，指针不需要有效</p></li><li><p>数组，整个数组所占的大小；等价于对数组中所有元素各执行一次sizeof并求和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;...&#125; <span class="comment">// 一个很多元素的数组</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> sz = <span class="built_in">sizeof</span>(ia) / <span class="built_in">sizeof</span>(*ia); <span class="comment">// 返回ia数组的元素的数量</span></span><br><span class="line"><span class="type">int</span> arr2[sz];   <span class="comment">// sizeof返回一个常量表达式，所有可以用于声明数组的维度</span></span><br></pre></td></tr></table></figure></li><li><p>string和vector，只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。&lt;— 什么意思？没看懂</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(<span class="type">int</span>)&lt;&lt;endl; <span class="comment">// 4</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;  <span class="comment">// 10个5，10个int大小按理来说应该是40个字节</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ia : a) &#123;</span><br><span class="line">        cout &lt;&lt; ia ;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;  <span class="comment">// 却是32？          &lt;-- 不懂</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="4-2-9-逗号运算符"><a href="#4-2-9-逗号运算符" class="headerlink" title="4.2.9 逗号运算符"></a>4.2.9 逗号运算符</h3><ul><li><p>首先对左侧的表达式求值，然后将结果丢弃。<strong>真正的运算结果是右侧表达式的值</strong>，如果右侧运算对象是左值，那么最终的求值结果也是左值</p></li><li><p>一般用于for循环，例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::size_type cnt = ivec.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::size_type ix = <span class="number">0</span>; ix != ivec.<span class="built_in">size</span>(); ++ix, --cnt)&#123;</span><br><span class="line">    ivec[ix] = cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-3-类型转换"><a href="#4-3-类型转换" class="headerlink" title="4.3 类型转换"></a>4.3 类型转换</h2><p>如果两种类型可相互转换，则它们是关联的。</p><h3 id="4-3-1-隐式转换"><a href="#4-3-1-隐式转换" class="headerlink" title="4.3.1 隐式转换"></a>4.3.1 隐式转换</h3><ul><li><p>算术转换<br>运算符的运算对象将转换至最宽的类型</p><ul><li><p>整型提升</p><ul><li>小整数类型提升成较大的整数类型：bool、char、signed char、unsigned char、short、unsigned short 所有可能的值都能存在int里，则提升为int，否则为unsigned int</li><li>较大的char（wchar_t, char16_t, char32_t）提升成int、unsigned int、long、unsigned  long、long long和 unsigned long long 中最小的一种类型</li></ul></li><li><p>无符号类型的运算对象</p><ul><li><p>注意有符号和无符号的混用带来的意外后果</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401141601280.png" style="zoom: 50%;" /></p></li></ul></li></ul></li></ul><ul><li><p>数组转换成指针</p><ul><li>在大多数情况下，数组名自动转化成数组首元素的指针</li><li>当数组名被用作<code>decltype关键字、取地址符、sizeof、typeid、用一个引用来初始化数组</code>时，上述转化不会发生</li></ul></li><li><p>指针的转换</p><ul><li>0、nullptr能转化成任意指针类型</li><li>任意非常量指针能转换成void *</li><li>任意对象指针能转化成const void *</li><li>有继承关系的类型间</li></ul></li><li><p>转换成bool</p><ul><li>0:false 否则true</li></ul></li><li><p>转换成常量</p><ul><li><p>允许将指向非常量类型的指针（引用）转化成指向相应的常量类型的指针（引用）</p></li><li><p>不能反过来，因为这样试图删掉底层const</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = i;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>类类型定义的转换  （P144）</p><ul><li>类类型能定义由编译器自动执行的转换</li><li>每次只能执行一种类类型的转换</li></ul></li></ul><h3 id="4-3-2-显式转换"><a href="#4-3-2-显式转换" class="headerlink" title="4.3.2 显式转换"></a>4.3.2 显式转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast-<span class="built_in">name</span>&lt;type&gt;(expression)</span><br></pre></td></tr></table></figure><p>type：要转换的类型，expression：要转换的值；如果type是引用类型，则结果是左值</p><p>cast-name包括：static_cast、dynamic_cast、const_cast和reinterpret_cast</p><ul><li><p>static_cast    &lt;— 最常用</p><ul><li><p>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast</p></li><li><p>当需要把一个较大的算术类型赋给较小的类型时，利用static_cast可关闭“精度损失”的警告信息</p></li><li><p>利用static_cast找回void *指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *p = &amp;d;</span><br><span class="line"><span class="type">double</span> * dp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span> *&gt;(p);  <span class="comment">//确保等号两边类型一样，否则产生未定义行为</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>const_cast</p><ul><li><p><strong>只能改变对象的底层const</strong>，<strong>仅用于进行去除 const 属性</strong>，它也是四个强制类型转换运算符中<strong>唯一能够去除 const 属性的运算符</strong>。</p></li><li><p>要注意可能发生的未定义后果</p></li><li><p><a href="#6.4 重载">常用于有重载函数的上下文</a>  &lt;— 比如？</p></li><li><p>用法举例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*例1*/</span>       <span class="comment">//（P145,改）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* pc = &amp;a;   <span class="comment">// 底层const</span></span><br><span class="line">cout &lt;&lt; *pc &lt;&lt; endl; <span class="comment">//0</span></span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(pc); </span><br><span class="line">*p = <span class="number">5</span>;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例2*/</span>      <span class="comment">// 参考文献[1]</span></span><br><span class="line"><span class="comment">//const_cast只针对指针、引用、this指针 （只能改变对象的底层const）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* k = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;n);<span class="comment">//指针</span></span><br><span class="line">    *k = <span class="number">123</span>;</span><br><span class="line">    cout &lt;&lt; *k &lt;&lt; endl;  <span class="comment">//123</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp; kRef = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(n);<span class="comment">//引用</span></span><br><span class="line">    kRef = <span class="number">456</span>;</span><br><span class="line">    cout &lt;&lt; kRef &lt;&lt; endl;  <span class="comment">//456</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例3*/</span>    <span class="comment">// 参考文献[1]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CTest</span>() : <span class="built_in">m_nTest</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">//常成员函数，不能修改成员变量的值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> nTest)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">//void* p = this;</span></span><br><span class="line">        <span class="comment">//m_nTest = nTest;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//m_nTest = nTest; 错误</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//&lt;CTest* const&gt;指针地址不可改变，(this)代表常成员函数的this指针</span></span><br><span class="line">        <span class="comment">//const_cast去除CTest*前面的const</span></span><br><span class="line">        <span class="built_in">const_cast</span>&lt;CTest* <span class="type">const</span>&gt;(<span class="keyword">this</span>)-&gt;m_nTest = nTest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_nTest;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CTest t;</span><br><span class="line">    t.<span class="built_in">foo</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>参考</p><ul><li>[1] <a href="https://blog.csdn.net/Dasis/article/details/121343011">C++新特性06_强制转换运算符_const_cast - 十月旧城</a></li></ul></li></ul><ul><li><p>reinterpret_cast</p><ul><li><p>通常为运算对象的位模式提供较低层次上的重新解释</p></li><li><p>非常有风险</p><blockquote><p>本质上依赖于机器，想要安全地使用必须对涉及的类型和编译器实现转换的过程都非常了解</p></blockquote></li></ul></li><li><p>dynamic_cast （19章介绍）</p></li></ul><h2 id="4-4-运算符优先级表"><a href="#4-4-运算符优先级表" class="headerlink" title="4.4 运算符优先级表"></a>4.4 运算符优先级表</h2><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401131535739.png" alt="运算符优先级表"></p><h1 id="五-语句"><a href="#五-语句" class="headerlink" title="五 语句"></a>五 语句</h1><h2 id="5-1-简单语句"><a href="#5-1-简单语句" class="headerlink" title="5.1 简单语句"></a>5.1 简单语句</h2><ul><li><p>空语句 — 没有什么用，但是需要注意对循环的影响</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;  <span class="comment">//&lt;--空语句，真么用也没有</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;;  <span class="comment">// &lt;-- 不会报错，就是多了一条空语句 :)</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="5-2-作用域"><a href="#5-2-作用域" class="headerlink" title="5.2 作用域"></a>5.2 作用域</h2><p>略</p><h2 id="5-3-条件语句"><a href="#5-3-条件语句" class="headerlink" title="5.3 条件语句"></a>5.3 条件语句</h2><h3 id="5-3-1-if…else"><a href="#5-3-1-if…else" class="headerlink" title="5.3.1 if…else"></a>5.3.1 if…else</h3><ul><li>注意花括号</li><li>悬垂else<ul><li>我们怎么知道给定的else和那个if相匹配？   这个问题被称为悬垂else</li><li>c++规定，与离它最近的尚未匹配的if匹配，从而消除程序的二义性</li></ul></li></ul><h3 id="5-3-2-switch…case"><a href="#5-3-2-switch…case" class="headerlink" title="5.3.2 switch…case"></a>5.3.2 switch…case</h3><ul><li><p>case标签必须是整型常量表达式</p></li><li><p>switch的默认动作是从某个匹配成功的case开始，顺序执行其下的所有case，直到遇到break。最好在每个case中都添加break，以避免不必要的问题。虽然在某些情况下，我们确实希望多个case共享同一组操作而不写break，此种情况最好加一段注释以说明。</p></li><li><p>最好添加default，声明我们已经考虑了默认情况，即使现在什么都没有做。</p><ul><li>标签不应该孤零零地出现，它后面必须跟上一条语句或者另外一个 case标签。如果switch 结构以一个空的 default 标签作为结束则该default 标签后面必须跟上一条空语句或一个空块。  &lt;— （P163，没怎么懂在说什么）</li></ul></li><li><p>switch内部的变量定义</p><ul><li><blockquote><p>在C++11的标准下，【变量定义】操作在编译阶段就会执行分配内存，而涉及【变量初始化】操作的语句则必须等到程序运行时才会调用执行。</p></blockquote></li><li><blockquote><p><strong>因此对于<code>switch</code>语句的使用，如果确实有需要在内部定义变量的场景，最好的方法就是在编程的时候，将整个<code>switch</code>语句中都用到的变量在<code>switch</code>外定义好，到了<code>switch</code>内部，则可以针对某个<code>case</code>需要单独使用某些变量的情况，用<code>&#123;&#125;</code>作用域符号来明确此<code>case</code>语句的作用域</strong></p></blockquote></li><li><p>参考文献</p><ul><li>[1] <a href="https://blog.csdn.net/LvzJason/article/details/123445116">switch case内部的变量定义问题 - John Chen1223</a></li></ul></li></ul></li></ul><h2 id="5-4-迭代语句"><a href="#5-4-迭代语句" class="headerlink" title="5.4 迭代语句"></a>5.4 迭代语句</h2><h3 id="5-4-1-while"><a href="#5-4-1-while" class="headerlink" title="5.4.1 while"></a>5.4.1 while</h3><p>略</p><h3 id="5-4-2-for"><a href="#5-4-2-for" class="headerlink" title="5.4.2 for"></a>5.4.2 for</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(init-statemen; condition; expression)&#123; statement; &#125;</span><br></pre></td></tr></table></figure><ul><li>只要condition为真，就执行一次statement，如果为false，一次也不执行</li><li>init-statemen可以定义多个变量，但只能有一条声明语句，因此意味着所有变量的基础类型必须相同</li><li>init-statemen 、condition、 expression都可以省略（P167）</li></ul><h3 id="5-4-3-do…while"><a href="#5-4-3-do…while" class="headerlink" title="5.4.3 do…while"></a>5.4.3 do…while</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    statement;</span><br><span class="line">&#125;<span class="keyword">while</span>(condition);  <span class="comment">//&lt;--最后还有个分号</span></span><br></pre></td></tr></table></figure><ul><li>condition不能为空</li><li>condition使用的变量不能定义在循环体之外</li><li>不允许在condition部分定义变量</li></ul><h2 id="5-5-跳转语句"><a href="#5-5-跳转语句" class="headerlink" title="5.5 跳转语句"></a>5.5 跳转语句</h2><ul><li><p>break</p><ul><li>终止最近的<code>while</code>，<code>do...while</code>，<code>for</code>，<code>switch</code>，并从这些语句之后的第一条语句开始执行;</li></ul></li><li><p>continue</p><ul><li><p><code>while</code>，<code>do...while</code>，<code>for</code>可用</p></li><li><p>终止最近的循环中的当前迭代  并立即开始下一次迭代</p></li></ul></li><li><p>goto</p></li></ul><h2 id="5-6-异常处理"><a href="#5-6-异常处理" class="headerlink" title="5.6 异常处理"></a>5.6 异常处理</h2><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401151047619.png" alt="image-20240115104749450" style="zoom:67%;" /></p><h3 id="5-6-1-异常类"><a href="#5-6-1-异常类" class="headerlink" title="5.6.1 异常类"></a>5.6.1 异常类</h3><p>c++标准库定义了一组类，分别在4个头文件中：</p><ul><li>exception<ul><li>定义exception，只报告异常的发生，不提供任何额外信息</li></ul></li><li>stdexcept<ul><li>定义了几种常用的异常，下图列出</li></ul></li><li>new<ul><li><code>bad_alloc</code>（12章）</li></ul></li><li>type_info<ul><li><code>bad_cast</code>（19章）</li></ul></li></ul><p>其中，<code>exception</code>、<code>bad_alloc</code>、<code>bad_cast</code>只能默认初始化，不允许提供初值。反之，其余的异常类必须提供string或c风格字符串以初始化。</p><p>异常类只有一个名为<code>what()</code>的成员函数，没有任何参数，返回初始化异常类时用到string（c风格）字符串。对于默认初始化的异常类，返回内容由编译器决定。</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401151426222.png" alt="image-20240115142614063" style="zoom:67%;" /></p><h3 id="5-6-2-抛出异常"><a href="#5-6-2-抛出异常" class="headerlink" title="5.6.2 抛出异常"></a>5.6.2 抛出异常</h3><p>用<code>throw</code>关键字抛出一个异常后，会直接跳转到对应的<code>catch</code>块，节选5.6.4中示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_isbn != item.m_isbn)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;data must refer to same isbn.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_sales_volume + item.m_sales_volume;</span><br></pre></td></tr></table></figure><h3 id="5-6-3-处理异常"><a href="#5-6-3-处理异常" class="headerlink" title="5.6.3 处理异常"></a>5.6.3 处理异常</h3><p><code>try...catch</code>接住throw抛出的异常并处理，语法如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//正常逻辑</span></span><br><span class="line">    <span class="comment">//抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="comment">/*（可能未命名的）异常声明1*/</span>) &#123;</span><br><span class="line">    <span class="comment">//异常处理1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="comment">/*（可能未命名的）异常声明2*/</span>) &#123;</span><br><span class="line">    <span class="comment">//异常处理2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。</p><ul><li><p>函数在寻找  异常处理代码  的过程中  退出（P175）</p><blockquote><p>在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个 try语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能调用了包含又一个 try 语句块的新函数，以此类推。</p><p>寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的 catch 子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的 catch 子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路逐层回退，直到找到适当类型的 catch 子句为止。</p><p>如果最终还是没能找到任何匹配的 catch 子句，程序转到名为<code>terminate</code> 的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。对于那些没有任何 try语句块定义的异常，也按照类似的方式处理：毕竟，没有 try语句块也就意味着没有匹配的catch 子句。如果一段程序没有 try 语句块且发生了异常系统会调用terminate函数并终止当前程序的执行。</p></blockquote></li></ul><h3 id="5-6-4-示例"><a href="#5-6-4-示例" class="headerlink" title="5.6.4 示例"></a>5.6.4 示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_item</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_item</span>(string isbn, <span class="type">int</span> sales_volume)</span><br><span class="line">        :m_isbn&#123; isbn &#125;, m_sales_volume&#123; sales_volume &#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_isbn; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">saleVolume</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_sales_volume; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>+(Sales_item item) &#123;</span><br><span class="line">        <span class="comment">// 使用异常处理将相加的代码和与用户交互的代码分离</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_isbn != item.m_isbn)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;data must refer to same isbn.&quot;</span>);  <span class="comment">//跳转到catch (runtime_error err) &#123;行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_sales_volume + item.m_sales_volume;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (runtime_error err) &#123;</span><br><span class="line">            cout &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_isbn;</span><br><span class="line">    <span class="type">int</span> m_sales_volume; <span class="comment">//销售额</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Sales_item <span class="title">item1</span><span class="params">(<span class="string">&quot;1-2-3&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Sales_item <span class="title">item2</span><span class="params">(<span class="string">&quot;1-2-3&quot;</span>, <span class="number">11</span>)</span></span>;</span><br><span class="line">    <span class="function">Sales_item <span class="title">item3</span><span class="params">(<span class="string">&quot;4-5-6&quot;</span>, <span class="number">12</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res1 = item1 + item2;</span><br><span class="line">    cout &lt;&lt; res1 &lt;&lt; endl;<span class="comment">//21</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res2 = item1 + item3;</span><br><span class="line">    cout &lt;&lt; res2 &lt;&lt; endl;<span class="comment">//失败并输出-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六-函数"><a href="#六-函数" class="headerlink" title="六 函数"></a>六 函数</h1><h2 id="6-1-基础"><a href="#6-1-基础" class="headerlink" title="6.1 基础"></a>6.1 基础</h2><ul><li>函数最外层的作用于中的局部变量也不能使用和函数形参一样的名字。（P184顶部，不理解）</li><li>函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针</li><li>函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，函数声明也被称为函数原型</li><li>局部静态对象：在局部变量前加<code>static</code>，第一次经过该对象定义语句的时候初始化，并且直到程序终止才销毁，在此期间即使对象所在的函数结束也不会对它有影响。</li></ul><h2 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h2><h3 id="6-2-1-参数传递的方式"><a href="#6-2-1-参数传递的方式" class="headerlink" title="6.2.1 参数传递的方式"></a>6.2.1 参数传递的方式</h3><ul><li>值传递</li><li>指针传递<ul><li>其实是一种形式的值传递</li><li>在c++中，建议用引用类型的形参代替指针</li></ul></li><li>引用传递<ul><li>当函数无须修改引用形参的值时最好使用常量引用</li><li>使用引用形参返回额外的信息</li></ul></li></ul><h3 id="6-2-2-const形参和实参"><a href="#6-2-2-const形参和实参" class="headerlink" title="6.2.2  const形参和实参"></a>6.2.2  const形参和实参</h3><ul><li><p>顶层const被忽略</p><ul><li><p>当形参有顶层const时，形参的顶层const被忽略，传给他常量对象或非常量对象都是可以的</p></li><li><p><strong>因为顶层const被忽略掉了，所以下述的两个func是一样的，不能<a href="#6.4 重载">重载</a></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i; &#125; <span class="comment">// 函数“int func(const int)”已有主体</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>指针或引用参与const</p><ul><li><p>遵循“任何可能引发修改const值的操作都是非法的”</p></li><li><p>P191，略</p></li></ul></li></ul><ul><li><p>尽量使用常量引用</p><ul><li><p>把函数不会改变的形参定义成普通的引用是一种比较常见的错误，</p><ul><li><p>会给函数调用者“函数可以修改它们实参值的误导”</p></li><li><p>极大限制函数所能接收的实参类型（<strong>我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参</strong>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*例1*/</span></span><br><span class="line"><span class="function">string <span class="title">func</span><span class="params">(<span class="type">const</span> string&amp;i)</span></span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="string">&quot;a&quot;</span>) &lt;&lt; endl;  <span class="comment">// a</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例2*/</span></span><br><span class="line"><span class="function">string <span class="title">func</span><span class="params">( string&amp;i)</span></span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//无法用 &quot;const char [2]&quot; 类型的值初始化 &quot;std::string &amp;&quot; 类型的引用(非常量限定)</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="string">&quot;a&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>参考文献</p><ul><li><a href="https://blog.csdn.net/qq_39827640/article/details/129431021">函数原型、函数签名、函数定义、函数参数传递方式 — 凶猛的瘦子</a></li></ul><h3 id="6-2-3-数组形参"><a href="#6-2-3-数组形参" class="headerlink" title="6.2.3 数组形参"></a>6.2.3 数组形参</h3><ul><li><p>因为不能拷贝数组，我们无法以值传递的方式使用数组参数；又因数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</p></li><li><p>三种等价的数组传参方式，数组大小对函数调用无影响</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>; <span class="comment">// 10表示我们期望，实际上不一定</span></span><br></pre></td></tr></table></figure></li><li><p>数组以指针传参，函数不知道大小，有三种常用管理方式管理指针形参：</p><ul><li><p>使用  结束标记  指定数组长度</p><ul><li>使用  类似c风格字符串数组的结束标记  标记数组结束的位置</li></ul></li><li><p>使用标准库规范</p><ul><li><p>使用begin和end函数，传递首元素和尾后元素的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>*beg, <span class="type">const</span> <span class="type">int</span>*end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(beg != end)</span><br><span class="line">        cout&lt;&lt;*beg++&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////调用</span></span><br><span class="line"><span class="type">int</span> j[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">begin</span>(j),<span class="built_in">end</span>(j));</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>显式传递一个表示数组大小的形参 — 旧式风格</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *ia, <span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////调用</span></span><br><span class="line"><span class="type">int</span> j[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">func</span>(j, <span class="built_in">end</span>(j) - <span class="built_in">begin</span>(j) );</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>数组引用形参</p><ul><li><p>形参是数组的引用，维度是类型的一部分</p></li><li><p>下例中，<code>(&amp;arr)</code>括号必不可少，否则 <code>int &amp;arr[10]</code>是将arr声明成了引用的数组</p></li><li><p>下例中，[10]不可少，因为数组的大小是构成数组的一部分，只能将函数作用于大小为10的数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>传递多维数组</p><ul><li><p>多维数组是数组的数组，又因为将数组传递进函数的时候，传入的是指向第一个元素的指针。所以将多维数组传入函数，传入的是指向第一个数组（即多维数组的第一个元素）的指针。函数声明可以写为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形参matrix看起来是一个二维数组，实际上是指向含有10个整数的数组的指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> matrix[][<span class="number">10</span>],<span class="type">int</span> rowSize)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//matrix是一个指针，指向10个整数的数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> (*matrix)[<span class="number">10</span>], <span class="type">int</span> rowSize)</span></span>&#123;&#125;  <span class="comment">//int (*matrix)[10] 小括号不可少，否则是10个指针构成的数组</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>main处理命令行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-2-4-可变形参"><a href="#6-2-4-可变形参" class="headerlink" title="6.2.4 可变形参"></a>6.2.4 可变形参</h3><p>可变形参用于编写可处理不同数量实参的函数，主要有三种方法：</p><ul><li><p><code>initializer_list</code></p><ul><li><p>要求所有实参<strong>类型相同</strong></p></li><li><p>其中的对象<strong>永远是常量</strong>，无法改变其中的元素值</p></li><li><p>如果向其中传递的是一个序列，则必须放在花括号中</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*声明*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(ErrorCode e, initializer_list&lt;string&gt; il)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;e.<span class="built_in">msg</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;msg : il)</span><br><span class="line">        cout&lt;&lt;msg&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用*/</span></span><br><span class="line"><span class="built_in">error_msg</span>(<span class="built_in">ErrorCode</span>(<span class="number">0</span>), &#123;<span class="string">&quot;functionX&quot;</span>,<span class="string">&quot;okay&quot;</span>&#125; ); </span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>&lt;img src=&quot;https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401171100692.png&quot; alt=&quot;image-20240117110037435&quot; style=&quot;zoom:67%;&quot; /&gt;</code></pre><ul><li><p>可变参数模板  （16章）</p><ul><li>实参类型不同  </li></ul></li><li><p>省略符</p><ul><li><p><code>varargs</code>c标准库功能</p></li><li><p>省略符只能出现在形参列表的最后一个位置</p></li><li><p>仅用于c和c++通用的类型，大多数类类型的对象在传递给省略符形参时都无法正确拷贝</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(parm_list, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="6-3-返回类型和return"><a href="#6-3-返回类型和return" class="headerlink" title="6.3 返回类型和return"></a>6.3 返回类型和return</h2><h3 id="6-3-1-有返回值的函数"><a href="#6-3-1-有返回值的函数" class="headerlink" title="6.3.1 有返回值的函数"></a>6.3.1 有返回值的函数</h3><ul><li><p>在含有return语句的循环后面也有一条return语句</p></li><li><p>不要返回  对局部对象的引用  或  指向局部变量的指针，局部变量在函数完成后已经被释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在vs2022上测试，该程序能正常编译和运行，</span></span><br><span class="line"><span class="comment">* 但是运行结果不对，</span></span><br><span class="line"><span class="comment">* 显然意味着这种错误不容易被发现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">const</span> string&amp; <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!a.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;empty&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">test</span>() &lt;&lt; endl;  <span class="comment">// 期望输出a，实际上输出空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>引用返回左值</p><ul><li><p>调用一个返回引用的函数得到左值，其他返回类型得到右值</p></li><li><p>我们能为返回类型是非常量引用的函数的结果赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>&amp; <span class="title">get_val</span><span class="params">(string &amp;str, string::size_type ix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str[ix];  <span class="comment">// 返回对 str[ix]的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;a test&quot;</span>;</span><br><span class="line">    <span class="built_in">get_val</span>(s, <span class="number">0</span>) = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>可返回列表初始化，<code>return &#123;&quot;funcX&quot;,&quot;okay&quot;&#125;</code></p></li><li><p>main函数的返回值</p><ul><li><p><code>cstdlib</code>中定义了两个预处理变量，表示成功或者失败</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> EXIT_FALLURE;</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>递归</p><ul><li>在递归函数中，一定有某条路径是不包含递归调用的，否则将一直递归循环，直至内存耗尽</li></ul></li></ul><h3 id="6-3-2-数组指针"><a href="#6-3-2-数组指针" class="headerlink" title="6.3.2 数组指针"></a>6.3.2 数组指针</h3><p>数组不能被拷贝，所以函数不能返回数组，不过函数可以返回数组的指针或引用。定义一个返回数组的指针或引用的函数有如下几种方法：</p><ul><li><p>使用类型别名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*两个等价的定义类型别名的方法*/</span></span><br><span class="line"><span class="comment">//arrT是一个类型别名，它表示的类型是含有10个整数的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> arrT[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">using</span> arrT = <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用*/</span></span><br><span class="line"><span class="function">arrT *<span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>普通方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">func</span>(<span class="type">int</span> i))[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401171607017.png" alt="202401171607017"></p></li></ul><ul><li><p>尾置返回类型</p><ul><li><p>c++11新标准可使用 ，将返回类型放在<code>-&gt;</code>后，并在原来写返回值类型的地方放个auto</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>;  <span class="comment">// 返回一个指针，指向放10个int数据的数组</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>decltype</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> odd[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> even[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(odd) *<span class="built_in">arrPtr</span>(<span class="type">int</span> i)&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%<span class="number">2</span>) ? &amp;odd : &amp;even;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>decltype 并不负责把数组类型转换成对应的指针，所以decltype 的结果（即<code>int[]</code>）是个数组，要想表示 arrPtr 返回指针还必须在函数声明时加一个<code>*</code>符号。</p></li></ul><h2 id="6-4-重载"><a href="#6-4-重载" class="headerlink" title="6.4 重载"></a>6.4 重载</h2><ul><li>如果<strong>同一作用域内</strong>的几个<strong>函数名字相同但形参列表不同</strong>，称之为函数重载（overloaded）</li><li>重载和const形参<ul><li><a href="#6.2.2  const形参和实参">顶层const不影响传入的对象，有无顶层const不能构成重载</a></li><li>底层const会实现重载：<ul><li>指向const的指针（引用）传递给const形参</li><li>对于非常量，编译器会优先选择非常量版本的函数 （6.6-最佳匹配-实参类型的转换）</li></ul></li></ul></li><li><a href="#4.3.2-显式转换">重载和const_cast</a><ul><li>const_cast在重载函数的情境中最有用 — 保障了安全性<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401181007150.png" alt="image-20240118100745867"></li></ul></li><li>重载与作用域<ul><li>不要把函数声明置于局部作用域内</li></ul></li></ul><h2 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h2><h3 id="6-5-1-默认实参"><a href="#6-5-1-默认实参" class="headerlink" title="6.5.1 默认实参"></a>6.5.1 默认实参</h3><ul><li><p>一旦某个形参被赋予了默认值，其后所有形参都必须有默认值</p></li><li><p>默认实参负责填补函数调用缺少的尾部实参</p></li><li><p>合理设置形参顺序，将经常使用默认值的形参放在后面</p></li><li><p>函数后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz,sz,<span class="type">char</span>=<span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz,sz,<span class="type">char</span>= <span class="string">&#x27;*&#x27;</span>)</span></span>; <span class="comment">//错误，重复声明</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = <span class="number">24</span>, sz = <span class="number">80</span>, <span class="type">char</span>)</span></span>;<span class="comment">// 正确，添加默认形参</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>默认实参初始值</p><ul><li><p>局部变量不能作为默认实参，用作默认实参初始值的  表达式的值   必须声明在函数之外</p></li><li><p>只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sz wd = <span class="number">80</span>;</span><br><span class="line"><span class="type">char</span> def = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = ht(), sz = wd, <span class="type">char</span> = def)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string window = <span class="built_in">screen</span>(); <span class="comment">//screen(ht(), 80, &#x27; &#x27; );</span></span><br><span class="line">    </span><br><span class="line">    def = <span class="string">&#x27;*&#x27;</span>;   <span class="comment">// 将传递这个更新过的  全局变量的  值</span></span><br><span class="line">    sz wd = <span class="number">100</span>;  <span class="comment">//局部变量与默认实参没有任何关系</span></span><br><span class="line">    window = <span class="built_in">screen</span>(); <span class="comment">//screen(ht(), 80, &#x27;*&#x27;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="6-5-2-内联函数"><a href="#6-5-2-内联函数" class="headerlink" title="6.5.2 内联函数"></a>6.5.2 内联函数</h3><ul><li><p><code>inline</code></p></li><li><p>对编译器的建议，</p></li><li>加速程序</li></ul><h3 id="6-5-3-constexpr函数"><a href="#6-5-3-constexpr函数" class="headerlink" title="6.5.3 constexpr函数"></a>6.5.3 constexpr函数</h3><ul><li><p>能用于常量表达式的函数</p></li><li><p><strong>函数的返回类型及所有形参的类型都得是字面值类型，函数体中必须有且只有一条return语句</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化任务时，编译器会把constexpr函数的调用替换成其结果值，函数被隐式地指定为内联函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="built_in">new_sz</span>()];</span><br></pre></td></tr></table></figure></li><li><p>constexpr函数中也可以包含其他语句，只要这些语句在运行时不执行任何操作（空语句、typedef、using）  &lt;— 唯一可执行的语句就是return</p></li><li><p>允许返回非常量：当实参是是一个常量表达式时，返回常量表达式，反之则不然：   &lt;— <strong>constexpr函数不一定返回常量表达式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">scale</span><span class="params">(<span class="type">size_t</span> cnt)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">new_sz</span>() * cnt ;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="built_in">scale</span>(<span class="number">2</span>)]; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> arr[<span class="built_in">scale</span>(i)]; <span class="comment">//错误，返回的不是常量表达式，无法初始化数组</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-5-4-调试帮助"><a href="#6-5-4-调试帮助" class="headerlink" title="6.5.4 调试帮助"></a>6.5.4 调试帮助</h3><ul><li><p><code>assert(expr)</code> — <code>#include &lt;cassert&gt;</code></p><ul><li>expr为假，输出信息并终止，为真，什么也不做。即expr为不可能情况</li></ul></li></ul><ul><li><p>NDEBUG预处理变量</p><ul><li><p>针对<code>assert()</code>：定义NDEBUG能避免检查各种条件所需的运行时开销，当然此时根本就不会执行运行时检查。因此，<strong>assert 应该仅用于验证那些确实不可能发生的事情</strong>。我们可以把assert当成调试程序的一种辅助手段，但是<strong>不能用它替代真正的运行时逻辑检查，也不能替代程序本身应该包含的错误检查</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*例1*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">assert</span>(i &gt; <span class="number">6</span>);  <span class="comment">// Assertion failed: i &gt; 6, file ... line 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例2  NDEBUG要写在整个程序的开头，否则没有用*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">assert</span>(i &gt; <span class="number">6</span>);  <span class="comment">// 失效</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例3  NDEBUG要写在整个程序的开头，否则没有用*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">assert</span>(i &gt; <span class="number">6</span>);  <span class="comment">// Assertion failed: i &gt; 6,file ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>针对<code>#ifndef ...#endif</code></p><ul><li>如果定义了NDEBUG，<code>#ifndef ...#endif</code>之间的代码将被忽略</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#define NDEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li><p>补充，预处理器定义的几个  用于调试程序的  变量</p><p>| 变量名     | 功能                                          |<br>| ————— | ——————————————————————- |<br>| <code>__func__</code> | const char 的一个静态数组，存放<strong>函数的名字</strong> |<br>| <code>__FILE__</code> | 存放<strong>文件名</strong>的字符串字面值                  |<br>| <code>__LINE__</code> | 存放<strong>当前行号</strong>的整型字面值                  |<br>| <code>__TIME__</code> | 存放文件<strong>编译时间</strong>的字符串字面值            |<br>| <code>__DATE__</code> | 存放文件<strong>编译日期</strong>的字符串字面值            |</p><ul><li>示例</li></ul></li></ul></li></ul></li></ul><pre><code>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line">std::cout&lt;&lt;__func__</span><br><span class="line">    &lt;&lt;<span class="string">&quot;in file: &quot;</span>&lt;&lt;__FILE__</span><br><span class="line">    &lt;&lt;<span class="string">&quot;line &quot;</span>&lt;&lt;__LINE__;</span><br></pre></td></tr></table></figure></code></pre><p>​      </p><h2 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a>6.6 函数匹配</h2><ul><li><p>候选函数</p><ul><li>与被调用的函数同名</li><li>其声明在调用的可见</li></ul></li><li><p>可行函数 — 从候选函数中选出能被这组实参调用的函数</p><ul><li>实参数量相等，类型相同</li></ul></li><li><p>最佳匹配</p><ul><li><p>单个参数：实参类型与形参类型越接近，它们匹配得越好</p></li><li><p>多个参数：如果有且只有一个函数满足下列条件，则匹配成功。如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用的信息。</p><ul><li>该函数每个实参的匹配都不劣于其他可行函数需要的匹配。</li><li>至少有一个实参的匹配优于其他可行函数提供的匹配。</li></ul></li><li><p>实参类型的转换 （P219）</p><ul><li><p>编译器将实参类型到形参类型的转换划分成几个等级：<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401181617249.png" alt="image-20240118161700062" style="zoom:67%;" /></p></li><li><p>在设计良好的系统中函数很少会含有与下列例子相似的形参：（P219底部-220）</p><ul><li>假设有两个函数，一个接受 int、另一个接受short，则只有当调用提供的是 short 类型的值时才会选择 short 版本的函数。有时候，即使实参是一个很小的整数值，也会直接将它提升成int 类型。</li><li>所有算术类型转换的级别都一样。例如，从int 向unsigned int 的转换并不比从int向 double的转换级别高。当存在两种可能的算数类型转换时，调用具有二义性。</li></ul></li><li><p>重载忽略顶层const，因此顶层const不能用于重载；而底层const可重载：如果重载函数的区别在于它们的引用类型的形参是否引用了 const（或者指针类型的形参是否指向const），则当调用发生时编译器<strong>通过实参是否是常量来决定选择哪个函数</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">lookup</span>(a); <span class="comment">// 调用 lookup( string &amp;);</span></span><br><span class="line"><span class="built_in">lookup</span>(b); <span class="comment">// 调用 lookup(const string &amp;);</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a>6.7 函数指针</h2><h3 id="6-7-1-函数指针是什么？"><a href="#6-7-1-函数指针是什么？" class="headerlink" title="6.7.1 函数指针是什么？"></a>6.7.1 函数指针是什么？</h3><ul><li><p>函数指针指向的是函数而非对象</p></li><li><p>函数指针指向某种特定类型。函数的类型由它的返回类型和形参列表共同决定，与函数名无关</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型</span></span><br><span class="line"><span class="built_in">bool</span>(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向函数的指针</span></span><br><span class="line"><span class="built_in">bool</span> (*ptr)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span><br><span class="line"><span class="comment">/*ptr是一个指针，指向参数是（const string &amp;, const string &amp;）的函数，返回bool类型*/</span></span><br><span class="line"><span class="comment">/*（*ptr）的括号不可少，否则ptr变成了一个返回 bool* 类型的函数*/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-7-2-如何使用"><a href="#6-7-2-如何使用" class="headerlink" title="6.7.2 如何使用"></a>6.7.2 如何使用</h3><ul><li>当我们把函数名作为一个值使用时，该函数自动转换成指针</li><li>还能指向函数的指针调用该函数，而无须提前解引用指针</li><li>不同类型的函数指针间不存在转换</li><li>可用nullptr或0初始化指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="comment">/* 指向函数的指针 */</span></span><br><span class="line"><span class="built_in">bool</span> (*ptr)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);</span><br><span class="line"><span class="comment">/*声明的同时定义*/</span></span><br><span class="line"><span class="built_in">bool</span> (*ptr)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;) = lengthCompare;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 */</span></span><br><span class="line">ptr = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">/* 赋值 */</span></span><br><span class="line">ptr = lengthCompare; </span><br><span class="line"><span class="comment">// 等价于 </span></span><br><span class="line">ptr = &amp;lengthCompare;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用 */</span></span><br><span class="line"><span class="type">bool</span> b = <span class="built_in">ptr</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="type">bool</span> b = (*ptr)(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="type">bool</span> b = <span class="built_in">lengthCompare</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="6-7-3-重载函数的指针"><a href="#6-7-3-重载函数的指针" class="headerlink" title="6.7.3 重载函数的指针"></a>6.7.3 重载函数的指针</h3><ul><li>编译器通过指针类型决定选用哪个函数</li><li>指针类型必须与重载函数中的某一个<strong>精确匹配</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载的func函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向func函数的指针</span></span><br><span class="line"><span class="built_in">void</span> (*ptr)(<span class="type">unsigned</span> <span class="type">int</span>) = func; <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">void</span> (*ptr)(<span class="type">int</span>) = func; <span class="comment">// 错误，没有一个重载的func与该形参列表匹配</span></span><br><span class="line"><span class="built_in">double</span> (*ptr)(<span class="type">unsigned</span> <span class="type">int</span>) = func; <span class="comment">// 错误，没有一个重载的func与该返回类型匹配</span></span><br></pre></td></tr></table></figure><h3 id="6-7-4-函数指针作形参"><a href="#6-7-4-函数指针作形参" class="headerlink" title="6.7.4 函数指针作形参"></a>6.7.4 函数指针作形参</h3><ul><li><p><a href="#6.2.3-数组形参">和数组类型</a>（6.2.3节），形参可以是指向函数的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形参看起来是函数类型，实际上确实当成指针使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">bool</span> pf(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>可以直接把函数作为实参使用，他会被自动转换为指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">useBigger</span>(s1,s2,lengthCompare); <span class="comment">// 函数名即指向函数的指针</span></span><br></pre></td></tr></table></figure></li><li><p>如上，直接使用函数指针类型显得冗长，使用类型别名和decltype简化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数类型*/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">bool</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="keyword">using</span> Func = <span class="built_in">bool</span>(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指向函数的指针*/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncPtr)</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="keyword">using</span> FuncPtr = <span class="built_in">bool</span>(*)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncPtr</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*用简化的函数类型声明useBigger*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, Func)</span></span>; <span class="comment">// 编译器自动地将Func表示的函数类型转换成指针</span></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, FuncPtr)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-7-5-返回指向函数的指针"><a href="#6-7-5-返回指向函数的指针" class="headerlink" title="6.7.5 返回指向函数的指针"></a>6.7.5 返回指向函数的指针</h3><ul><li><p>与形参不同，编译器不会自动地将函数返回类型当成对应的指针类型处理，因此<strong>我们必须显式地将返回类型指定为指针</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//四个等价</span></span><br><span class="line"><span class="function">FuncPtr <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, FuncPtr)</span></span>;</span><br><span class="line"><span class="function">Func *<span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, FuncPtr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, FuncPtr)</span> -&gt; <span class="title">bool</span><span class="params">(*)</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;<span class="comment">//尾置返回类型 </span></span><br><span class="line"><span class="built_in">bool</span> (* <span class="built_in">useBigger</span>(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, FuncPtr) ) (<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);</span><br><span class="line"><span class="comment">/*解释：先看括号里的，useBigger有形参列表，是一个函数；其前面有*，是一个指针；指向一个bool(const string &amp;, const string &amp;)的函数类型*/</span></span><br></pre></td></tr></table></figure></li><li><p>将auto和decltype用于函数指针类型</p><ul><li><p>牢记将decltype作用于某个函数，它返回函数类型而非指针类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string::size_type <span class="title">sumlength</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function">string::size_type <span class="title">largerlength</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(sumlength) *<span class="built_in">getFunc</span>(<span class="type">const</span> string &amp;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="七-类"><a href="#七-类" class="headerlink" title="七 类"></a>七 类</h1><h2 id="7-1-定义抽象数据类型"><a href="#7-1-定义抽象数据类型" class="headerlink" title="7.1 定义抽象数据类型"></a>7.1 定义抽象数据类型</h2><h3 id="7-1-1-关于类的基础知识"><a href="#7-1-1-关于类的基础知识" class="headerlink" title="7.1.1 关于类的基础知识"></a>7.1.1 关于类的基础知识</h3><p>（P228~P235）主要讲述了“类”的基础知识。</p><p>一、</p><p>首先说明了类是什么：</p><ul><li>类的基本思想是<strong>数据抽象</strong> (data abstraction)和<strong>封装</strong>(encapsulation)。数据抽象是一种依赖于<strong>接口</strong>(interface)和<strong>实现 </strong>(implementation)分离的编程(以及设计)技术。</li><li>类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。</li><li>封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。</li></ul><p>二、</p><p>通过设计Sales_data类，讲述了数据成员及成员函数。并提出了如下建议：</p><blockquote><p>在一些简单的应用程序中，类的用户和类的设计者常常是同一个人。尽管如此，还是最好把角色区分开来。<strong>当我们设计类的接口时，应该考虑如何才能使得类易于使用；而当我们使用类时，不应该顾及类的实现机理。</strong></p></blockquote><p>三、</p><p>接着通过成员函数引入<code>this</code>指针，该指针是类的成员函数额外的隐式参数，指向调用它的那个对象。有如下代码，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Sale_data定义于P230中间</span></span><br><span class="line">Sales_data total;</span><br><span class="line">total.<span class="built_in">isbn</span>();  <span class="comment">// total调用了成员函数isbn()</span></span><br></pre></td></tr></table></figure><p>实际上，编译器将该调用重写成如下形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::<span class="built_in">isbn</span>(&amp;total);</span><br></pre></td></tr></table></figure><ul><li>任何对类成员的直接访问都被看做this的隐式引用；</li><li>任何自定义名为this的参数或变量的行为都是非法的；</li><li><code>this</code>是一个常量指针，不允许修改<code>this</code>中保存的地址。</li></ul><p>成员函数在紧随参数列表之后，可以有const，用以修改隐式this指针的类型。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bookNo; &#125;</span><br></pre></td></tr></table></figure><ul><li><p>默认的情况下，this是指向非常量版本的常量指针，所以不能把this绑定到常量对象上，这使得我们<strong>不能在一个常量对象上调用普通的成员函数</strong>。C++允许在成员函数<strong>紧随参数列表后，添加const关键字，使得this变成一个指向常量的常量指针</strong>。如此，该成员函数被称为常量成员函数，<strong>常量成员函数不能改变调用它的对象的内容</strong>。</p></li><li><blockquote><p>常量对象，及常量对象的引用或指针都只能调用常量成员函数。</p></blockquote></li></ul><p>四、</p><p>关于成员变量声明于成员函数之后，成员函数却能读取到成员变量，书中作出如下解释：</p><p>编译器分两步处理类：</p><ul><li>首先编译成员的声明</li><li>然后才轮到成员函数体(如果有的话)。</li></ul><p>因此，成员函数可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p><p>五、</p><p>之后，</p><ul><li><p>P232提及如何在类外部定义成员函数；</p></li><li><p>P233介绍了如何定义一个返回this对象的函数，通过<code>*this</code>以获得执行该函数的对象。</p></li><li><p>P234在“定义类相关的非成员函数”一节中，提到了如下几个关键点：</p><ul><li><p>一些辅助函数，尽管定义的操作从概念上来说属于类的接口的组成部分，但它们实际上并不属于类本身。<strong>这些函数也应与类声明(而非定义)在同一个头文件内</strong>。这样，用户使用接口的任何部分都只需要引入一个文件。</p></li><li><p><code>istream</code>、<code>ostream</code>等<strong>io类属于不能被拷贝的类型</strong>，因此，我们<strong>只能通过引用来传递它们</strong>。又因为<strong>读写操作会改变流的内容，所以两个函数接受的都是普通引用</strong>，而非对常量的引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, Sales_data &amp;item)</span></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    is&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">write</span><span class="params">(ostream &amp;os, Sales_data &amp;item)</span></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    os&lt;&lt;item.<span class="built_in">isbn</span>(); <span class="comment">//注意没有endl()等控制格式</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行<strong>输出任务的函数应该尽量减少对格式的控制</strong>，将格式控制交给用户</p></li><li><p>默认情况下，拷贝类的对象其实拷贝的是对象的数据成员（没有拷贝成员函数，不同的类对象共用成员函数，并用this控制（侯捷高级面向对象课程））</p></li></ul></li></ul><h3 id="7-1-2-构造函数"><a href="#7-1-2-构造函数" class="headerlink" title="7.1.2 构造函数"></a>7.1.2 构造函数</h3><h4 id="一、构造函数不能被声明成const。"><a href="#一、构造函数不能被声明成const。" class="headerlink" title="一、构造函数不能被声明成const。"></a>一、<strong>构造函数不能被声明成const</strong>。</h4><p>当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才真正取得“常量”属性—&gt;因此，<strong>构造函数在const对象的构造过程中可以向其写值</strong></p><h4 id="二、（编译器）合成的默认构造函数将按如下规则初始化类的数据成员："><a href="#二、（编译器）合成的默认构造函数将按如下规则初始化类的数据成员：" class="headerlink" title="二、（编译器）合成的默认构造函数将按如下规则初始化类的数据成员："></a>二、（编译器）合成的默认构造函数将按如下规则初始化类的数据成员：</h4><ul><li>如果存在类内初始值。则用它来初始化成员</li><li>否则，默认初始化</li></ul><p>（P262 默认构造函数的作用）</p><ul><li>类必须包含一个默认构造函数以便在下述情况下使用。</li><li>在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。</li></ul><ul><li><p>当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况下发生:</p><ul><li>当我们在块作用域内不使用任何初始值定义一个非静态变量(参见2.2.1节，第39页)或者数组时(参见3.5.1节，第101页)。</li><li>当一个类本身含有类类型的成员且使用合成的默认构造函数时(参见7.1.4 节，第235页)。</li><li>当类类型的成员没有在构造函数初始值列表中显式地初始化时(参见7.1.4 节，第237页)。</li></ul></li></ul><ul><li><p>值初始化在以下情况下发生:</p><ul><li>在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时 (参见3.5.1节，第 101页)。</li><li>当我们不使用初始值定义一个局部静态变量时(参见6.1.1节，第185页)。</li><li>当我们通过书写形如 T()的表达式显式地请求值初始化时，其中T是类型名(vector 的一个构造函数只接受一个实参用于说明 vector 大小(参见3.3.1节第88页)，它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化).</li></ul></li></ul><h4 id="三、某些类不能依赖于默认构造函数："><a href="#三、某些类不能依赖于默认构造函数：" class="headerlink" title="三、某些类不能依赖于默认构造函数："></a>三、某些类不能依赖于默认构造函数：</h4><ul><li>类内已经显式声明了构造函数</li><li><strong>类中包含内置类型（int等）或复合类型（如数组、指针），如执行默认构造，则他们的值将是未定义的。只有当这些值被赋予了初始值（7.3.4），才可使用默认构造</strong></li><li>类中包含一个其他类型的成员，其这个成员的类型没有默认构造，则编译器也无法对当前类执行默认构造</li></ul><h4 id="四、构造函数的几种方式"><a href="#四、构造函数的几种方式" class="headerlink" title="四、构造函数的几种方式"></a>四、构造函数的几种方式</h4><ul><li><p><code>=default</code></p><p>在c++11新标准中，可以在参数列表后面写<code>=default</code>来要求编译器生成默认构造函数。注意要为内置类型或复合类型数据成员提供初始值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure></li><li><p>构造函数列表初始化<br>当某个数据成员被构造函数初始值化列表忽略时，它将以与合成的默认构造函数相同的方式隐式初始化（此时要求有类内初始值），</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> string &amp;s,<span class="type">double</span> p) : <span class="built_in">bookNo</span>(s),<span class="built_in">revenue</span>(p) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>在类外部定义构造函数</p></li></ul><h4 id="五、拷贝、赋值和析构"><a href="#五、拷贝、赋值和析构" class="headerlink" title="五、拷贝、赋值和析构"></a>五、拷贝、赋值和析构</h4><blockquote><p>尽管编译器能替我们合成拷贝、赋值和销毁的操作，但是必须要清楚的一点是，对于某些类来说合成的版本无法正常工作。特别是，<strong>当类需要分配类对象之外的资源时，合成的版本常常会失效。管理动态内存的类通常不能依赖于上述操作的合成版本</strong>。</p></blockquote><h3 id="7-1-3-构造函数再探"><a href="#7-1-3-构造函数再探" class="headerlink" title="7.1.3 构造函数再探"></a>7.1.3 构造函数再探</h3><blockquote><p>本节应是   书本P257页开始7.5   的内容，为了笔记结构的简洁，放到   笔记7.1.2构造函数   之后。</p></blockquote><h4 id="一、关于列表初始"><a href="#一、关于列表初始" class="headerlink" title="一、关于列表初始"></a>一、关于列表初始</h4><ul><li><p>使用<em>列表初始化</em>和<em>在构造函数体内通过拷贝赋值的方式初始化</em>，看似一样，但有时必须使用列表初始化且必不可少：<strong>如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过列表初始化为这些成员变量提供初始值。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstRef</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*正确*/</span></span><br><span class="line"><span class="built_in">ConstRef</span>(<span class="type">int</span> ii):<span class="built_in">i</span>(ii),<span class="built_in">ci</span>(ii),<span class="built_in">ri</span>(i)&#123;&#125;</span><br><span class="line"><span class="comment">/*引发错误*/</span></span><br><span class="line">    <span class="built_in">ConstRef</span>(<span class="type">int</span> ii)&#123;</span><br><span class="line">        i = ii;</span><br><span class="line">        ci = ii;  <span class="comment">//错误，不能给const赋值</span></span><br><span class="line">        ri = i;   <span class="comment">//错误，引用未被初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ci; </span><br><span class="line">    <span class="type">int</span> &amp;ri;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>列表初始化的初始化顺序问题 — 成员列表初始化的顺序与它们在类定义中的出现顺序一致：</p><blockquote><p>构造函数初始值列表只说明用于初始化成员的值，而<strong>不限定初始化的具体执行顺序</strong>。<strong>成员列表初始化的顺序与它们在类定义中的出现顺序一致</strong>：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。一般来说，初始化的顺序没什么特别要求。<strong>不过一个成员用另一个成员来初始化，那么这两个成员的初始化顺序就很关键了。最好令构造函数初始值的顺序与成员声明的顺序保存一致，如果可能的话，尽量避免使用某些成员初始化其他成员。</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*例1*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConstRef</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*正确*/</span></span><br><span class="line">    <span class="built_in">ConstRef</span>(<span class="type">int</span> ii) :<span class="built_in">j</span>(ii),<span class="built_in">i</span>(j) &#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;i = &quot;</span>&lt;&lt; i &lt;&lt; <span class="string">&quot;, j = &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 终端输出：i = -858993460, j = 1 </span></span><br><span class="line">        <span class="comment">// 出错，因为根据声明的顺序，先初始化i，而此时j还是未定义状态</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例2*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConstRef</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*正确*/</span></span><br><span class="line">    <span class="built_in">ConstRef</span>(<span class="type">int</span> ii) :<span class="built_in">j</span>(ii),<span class="built_in">i</span>(j) &#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;i = &quot;</span>&lt;&lt; i &lt;&lt; <span class="string">&quot;, j = &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 终端输出：i = 1, j = 1</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 声明顺序与列表初始化顺序匹配</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li>如果为一个构造函数的所有参数都提供了默认实参，则其实际上也成为了默认构造函数。</li></ul><h4 id="二、委托构造"><a href="#二、委托构造" class="headerlink" title="二、委托构造"></a>二、委托构造</h4><ul><li>概念：一个委托构造函数   使用它所属类的其他构造函数    执行自身初始化过程。（将自身的（一些或全部）职责委托给了其他构造函数）</li><li>当一个构造函数委托给另一个构造函数时，受委托的构造函数的列表初始化和函数体被依次执行，然后才轮到委托者的函数体。</li><li>示例</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> unint = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line">    <span class="comment">//非委托构造使用对应的实参初始化成员</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(string s, unint cnt, <span class="type">double</span> price)</span><br><span class="line">        :<span class="built_in">bookNo</span>(s), <span class="built_in">sold</span>(cnt), <span class="built_in">rev</span>(cnt* price) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托构造</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() :<span class="built_in">Sales_data</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(string s) :<span class="built_in">Sales_data</span>(s, <span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(istream&amp; is) :<span class="built_in">Sales_data</span>() &#123; <span class="built_in">read</span>(is, *<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(istream&amp; is, Sales_data)</span> </span>&#123;<span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string bookNo;</span><br><span class="line">    unint sold;</span><br><span class="line">    <span class="type">double</span> rev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="三、隐式类型转换"><a href="#三、隐式类型转换" class="headerlink" title="三、隐式类型转换"></a>三、隐式类型转换</h4><ul><li><p>如果一个类的<strong>构造函数只接受一个参数</strong>，则有<strong>从  该参数类型  到   该类类型  的隐式转换</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> uint = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(string s, uint cnt, <span class="type">double</span> p)</span><br><span class="line">        :<span class="built_in">m_isbn</span>(s), <span class="built_in">m_cnt</span>(cnt), <span class="built_in">m_price</span>(p) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(string s) :<span class="built_in">m_isbn</span>(s) &#123;  &#125; <span class="comment">// 1.string 可隐式转换为 Sales_data</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(Sales_data sd)</span> </span>&#123; <span class="comment">// 3. &lt;-- string转换为Sales_data后带入</span></span><br><span class="line">        <span class="keyword">if</span> (sd.m_isbn != <span class="keyword">this</span>-&gt;m_isbn)</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;isbn is not same.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_cnt += sd.m_cnt;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_isbn = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    uint m_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> m_price = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Sales_data <span class="title">item</span><span class="params">(<span class="string">&quot;978-7-121-15535-2&quot;</span>)</span></span>; <span class="comment">// 直接初始化</span></span><br><span class="line">    <span class="comment">//也可拷贝初始化</span></span><br><span class="line">    <span class="comment">//Sales_data item = string(&quot;978-7-121-15535-2&quot;);</span></span><br><span class="line">    </span><br><span class="line">    string isbn = <span class="string">&quot;978-7-121-15535-2&quot;</span>;</span><br><span class="line">    item.<span class="built_in">combine</span>(isbn); <span class="comment">// 2.正确，string 隐式转换为 Sales_data类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>但是，这种类型转换只允许一步完成，下面这种分开是不允许的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Sales_data <span class="title">item</span><span class="params">(<span class="string">&quot;978-7-121-15535-2&quot;</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="comment">/*错误*/</span></span><br><span class="line">    item.<span class="built_in">combine</span>(<span class="string">&quot;978-7-121-15535-2&quot;</span>); </span><br><span class="line">    <span class="comment">//编译器先向字符串常量转化为string；再将该string临时变量转换成Sales_data</span></span><br><span class="line">    <span class="comment">//两步转换导致隐式转换失败</span></span><br><span class="line">    <span class="comment">//编译器报错: 不存在从 &quot;const char [18]&quot; 转换到 &quot;Sales_data&quot; 的适当构造函数    </span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*正确*/</span></span><br><span class="line">    item.<span class="built_in">combine</span>(<span class="built_in">string</span>(<span class="string">&quot;978-7-121-15535-2&quot;</span>));</span><br><span class="line">    <span class="comment">//或</span></span><br><span class="line">    item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(<span class="string">&quot;978-7-121-15535-2&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用<code>explicit</code>关键字抑制单参数构造函数的隐式类型转换</p><ul><li><p><strong>关键字 <code>explicit</code>只对一个实参的构造函数有效</strong>。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为<code>explicit</code> 的。</p></li><li><p><strong>只能在类内声明</strong>构造函数时使用explicit 关键字，在<strong>类外部定义时不应重复</strong></p></li><li><p>使用了<code>explicit</code>关键字的构造函数只能以直接初始化的形式使用，不再支持拷贝形式的初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(string s)</span> :m_isbn(s) &#123;</span>  &#125; <span class="comment">// 禁止隐式转换</span></span><br><span class="line">&#125;;</span><br><span class="line">string isbn = <span class="string">&quot;978-7-121-15535-2&quot;</span>;</span><br><span class="line"><span class="function">Sales_data <span class="title">item1</span><span class="params">(isbn)</span></span>; <span class="comment">// 正确</span></span><br><span class="line">Sales_data item2 = isbn; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line">item1.<span class="built_in">combine</span>(isbn); <span class="comment">// 错误，隐式转化为explicit禁止了</span></span><br></pre></td></tr></table></figure></li><li><p>可是我们非要类型转换怎么办？可以显式类型转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">item1.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(isbn)); <span class="comment">// 错误，隐式转化为explicit禁止了</span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">item1.<span class="built_in">combine</span>(<span class="built_in">static_cast</span>&lt;Sales_data&gt;(isbn));</span><br></pre></td></tr></table></figure></li></ul></li><li><p>标准库中含有显式构造（explicit）的类</p><ul><li>接受一个单参数的const char*的string构造函数(参见3.21节，第76页)不是explicit的。</li><li>接受一个容量参数的 vector 构造函数(参见3.3.1节，第87页)是explicit 的。</li></ul></li></ul><h2 id="7-2-控制访问和封装"><a href="#7-2-控制访问和封装" class="headerlink" title="7.2 控制访问和封装"></a>7.2 控制访问和封装</h2><h3 id="7-2-1-访问说明符"><a href="#7-2-1-访问说明符" class="headerlink" title="7.2.1 访问说明符"></a>7.2.1 访问说明符</h3><ul><li>public</li><li>private</li><li>protected</li></ul><h3 id="7-2-2-class与struct"><a href="#7-2-2-class与struct" class="headerlink" title="7.2.2 class与struct"></a>7.2.2 class与struct</h3><ul><li>class默认private</li><li>struct默认public</li></ul><h3 id="7-3-3-友元"><a href="#7-3-3-友元" class="headerlink" title="7.3.3 友元"></a>7.3.3 友元</h3><h4 id="一、友元函数"><a href="#一、友元函数" class="headerlink" title="一、友元函数"></a>一、友元函数</h4><ul><li>当类的数据成员被设为private，非成员函数（所谓辅助函数）就无法访问到它们了。为解决这个问题，可将这些非成员函数设为友元<code>friend</code>;</li><li>友元生命只能定义在类的内部，但是在类内出现的具体位置不限。友元不是类的成员，也不受它所在区域访问控制级别的约束。不过，一般来说，最好在类开始或结束的位置集中声明友元。</li><li>友元的声明仅仅指定了访问权限，而非通常意义上的函数声明，所以必须在友元声明之外再专门对函数进行一次声明。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales</span> data&#123;</span><br><span class="line">    <span class="comment">//为Salesdata的非成员函数所做的友元声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;，<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//其他成员及访问说明符与之前一致  </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Salesdata接口的非成员组成部分的声明</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales data&amp;，<span class="type">const</span> Sales datas)</span></span>;  <span class="comment">//类的非成员函数声明</span></span><br></pre></td></tr></table></figure><h4 id="二、友元类"><a href="#二、友元类" class="headerlink" title="二、友元类"></a>二、友元类</h4><p>书本P250~P252对友元进行了补充，介绍了类与类之间的友元关系。</p><p>1.类作友元</p><ul><li><p>友元类的成员函数可以访问此类的所有成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Window_mgr</span>; <span class="comment">// Window_mgr的成员函数可以访问Screen的所有成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>友元关系不具有传递性。Window_mgr的友元与Screen没有关系。</p></li></ul><p>2.类的成员函数作友元</p><ul><li><p>当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIdx)</span></span>; <span class="comment">// Window_mgr的成员函数可以访问Screen的所有成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>想要某个成员函数作为友元，必须仔细组织程序结构，以满足声明和定义的彼此依赖关系：</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401221042529.png" alt="image-20240122104212361" style="zoom:67%;" /></p></li><li><p>尽管重载函数名字相同，但它们是不同的函数，友元声明要分别声明。</p></li></ul><p>3.友元声明和作用域</p><ul><li><p>要理解：友元声明的作用是设定访问权限，其本身并不是普通意义上的声明。（必须在别处书写真正的声明。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 即使在此处定义，也要在类的外部提供声明</span></span><br><span class="line">    <span class="built_in">X</span>() &#123; <span class="built_in">f</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void f(); //在此处定义，本例类的构造函数会报“f找不到标识符”</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="7-3-类的其他特性"><a href="#7-3-类的其他特性" class="headerlink" title="7.3 类的其他特性"></a>7.3 类的其他特性</h2><h3 id="7-3-1-在类中定义类型成员"><a href="#7-3-1-在类中定义类型成员" class="headerlink" title="7.3.1 在类中定义类型成员"></a>7.3.1 在类中定义类型成员</h3><ul><li>类还可以自定义某种类型在类中的别名，该别名同样存在访问权限。</li><li>与不同成员不用关注定义的顺序不同，定义类型的成员必须先定义后使用。因此类型成员通常出现在类开始的地方；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 在类中定义类型成员 */</span></span><br><span class="line">    <span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line">    <span class="comment">//等价</span></span><br><span class="line">    <span class="comment">//using pos = string::size_type;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width = <span class="number">0</span>; <span class="comment">// 默认初始值</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如何在类外使用？*/</span></span><br><span class="line">Screen::pos myPos;</span><br></pre></td></tr></table></figure><h3 id="7-3-2-令成员做inline函数"><a href="#7-3-2-令成员做inline函数" class="headerlink" title="7.3.2 令成员做inline函数"></a>7.3.2 令成员做inline函数</h3><ul><li><p>最好在类外部定义的地方说明inline，以使类更容易理解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Screen &amp;<span class="title">move</span><span class="params">(pos r, pos c)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function">Screen &amp;<span class="title">Screen::move</span><span class="params">(pos r, pos c)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>inline成员函数也应与相应的类定义在同一个头文件中</li></ul><h3 id="7-3-3-可变数据成员-—-mutable"><a href="#7-3-3-可变数据成员-—-mutable" class="headerlink" title="7.3.3 可变数据成员 — mutable"></a>7.3.3 可变数据成员 — <code>mutable</code></h3><ul><li>可以通过向类的某个变量声明中加入<code>mutable</code>关键字，达到即使是在一个const成员函数内也能修改该成员变量的目的。</li><li><strong>可变数据成员永远不会是const，任何时候都能被修改</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="type">const</span> </span>&#123; ++access_ctr; &#125; <span class="comment">//access_ctr用于记录成员函数被调用了多少次</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">size_t</span> access_ctr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-4-类数据成员的初始值"><a href="#7-3-4-类数据成员的初始值" class="headerlink" title="7.3.4 类数据成员的初始值"></a>7.3.4 类数据成员的初始值</h3><ul><li>希望自己设计的类一开始就被一个默认初始化，最好的方式就是<strong>将默认值声明成类内初始值</strong></li><li>当我们提供一个类内初始值时，必须以等号或者花括号表示</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span>&#123;    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Screen&gt; screens&#123;<span class="built_in">Screen</span>(<span class="number">24</span>,<span class="number">80</span>,<span class="string">&#x27; &#x27;</span>)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-5-star-成员函数利用引用返回-this"><a href="#7-3-5-star-成员函数利用引用返回-this" class="headerlink" title="7.3.5 :star:成员函数利用引用返回*this"></a>7.3.5 :star:成员函数利用引用返回*this</h3><h4 id="一、可将一系列操作连接成一条表达式"><a href="#一、可将一系列操作连接成一条表达式" class="headerlink" title="一、可将一系列操作连接成一条表达式"></a>一、可将一系列操作连接成一条表达式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::move</span><span class="params">(pos r, pos c)</span></span>&#123;  <span class="comment">// &lt;-- 返回*this的引用</span></span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::set</span><span class="params">(<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，返回引用的函数是左值的，意味着上述函数返回的是对象本身而非副本。将this对象作为左值返回，可以把一系列操作连接成一条表达式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Screen myScreen;</span><br><span class="line">myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>).<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>);  <span class="comment">// 一系列操作连接成一条表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line">myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">myScreen.<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>);</span><br></pre></td></tr></table></figure><p>反之，如果返回的非引用（Screen &amp;）而是值传递（Screen），则调用<code>set()</code>只是改变副本，而不能改变myScreen的值，连续调用将会失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scream tmp = myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">tmp.<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>);</span><br></pre></td></tr></table></figure><p>对比实验如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line">    <span class="built_in">Screen</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值为引用的版本    &lt;-- 正确的版本</span></span><br><span class="line">    <span class="function">Screen&amp; <span class="title">move</span><span class="params">(pos r, pos c)</span></span>;</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">set</span><span class="params">(<span class="type">char</span> ch)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载返回值非引用的版本，noRefer是用于重载的参数，无实际意义</span></span><br><span class="line">    <span class="function">Screen <span class="title">move</span><span class="params">(pos r, pos c, string noRefer)</span></span>;</span><br><span class="line">    <span class="function">Screen <span class="title">set</span><span class="params">(<span class="type">char</span> ch, string noRefer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; m_r &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; m_c &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; m_ch &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos m_r = <span class="number">0</span>, m_c = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> m_ch = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 返回值为引用的版本</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen&amp; <span class="title">Screen::move</span><span class="params">(pos r, pos c)</span> </span>&#123;  </span><br><span class="line">    m_r = r;</span><br><span class="line">    m_c = c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen&amp; <span class="title">Screen::set</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">    m_ch = ch;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载返回值非引用的版本，noRefer是用于重载的参数，无实际意义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen <span class="title">Screen::move</span><span class="params">(pos r, pos c, string noRef)</span> </span>&#123;</span><br><span class="line">    m_r = r;</span><br><span class="line">    m_c = c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen <span class="title">Screen::set</span><span class="params">(<span class="type">char</span> ch, string noRef)</span> </span>&#123;</span><br><span class="line">    m_ch = ch;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Screen myScreen1,myScreen2;</span><br><span class="line">    myScreen1.<span class="built_in">print</span>(); <span class="comment">//0,0,</span></span><br><span class="line"></span><br><span class="line">    myScreen1.<span class="built_in">move</span>(<span class="number">4</span>, <span class="number">0</span>).<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    myScreen1.<span class="built_in">print</span>(); <span class="comment">//4,0,#</span></span><br><span class="line"></span><br><span class="line">    myScreen2.<span class="built_in">move</span>(<span class="number">4</span>, <span class="number">0</span>, <span class="string">&quot;noRef&quot;</span>).<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>, <span class="string">&quot;noRef&quot;</span>); <span class="comment">// set失败，作用于了myScreen的副本</span></span><br><span class="line">    myScreen2.<span class="built_in">print</span>(); <span class="comment">//4,0,</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、const成员函数的重载和-this指针的返回"><a href="#二、const成员函数的重载和-this指针的返回" class="headerlink" title="二、const成员函数的重载和*this指针的返回"></a>二、const成员函数的重载和*this指针的返回</h4><ul><li>重载多个const成员函数如何选择？下图1</li><li>从const成员函数返回*this：一个const成员函数如果以引用形式返回this，返回类型将是常量引用，下图2。</li><li>this指针的隐式传递，下图3</li></ul><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401212100323.png" alt="image-20240121210058172" style="zoom:67%;" /></p><h3 id="7-3-6-类类型"><a href="#7-3-6-类类型" class="headerlink" title="7.3.6 类类型"></a>7.3.6 类类型</h3><ul><li><p>只声明而未定义的类被称作前向声明；</p></li><li><p>在类定义之后，声明之前被称为不完全类型；</p></li><li><p>不完全类型用于有限的场景：</p><ul><li><p>可以定义指向这种类型的指针或引用</p></li><li><p>可以声明（但不可定义）以不完全类型作为参数或者返回类型的函数</p></li></ul></li><li><p>我们创建类的对象之前，该类必须被定义过</p></li></ul><ul><li>一种例外情况：（此处没有读懂，但是知道该用法）<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401212228151.png" alt="image-20240121222858971"></li></ul><h2 id="7-4-类的其他形式"><a href="#7-4-类的其他形式" class="headerlink" title="7.4 类的其他形式"></a>7.4 类的其他形式</h2><h3 id="7-4-1-聚合类"><a href="#7-4-1-聚合类" class="headerlink" title="7.4.1 聚合类"></a>7.4.1 聚合类</h3><ul><li><p>用户可以直接访问其成员，且具有特殊初始化语法</p></li><li><p>满足如下条件：</p><ul><li>所有成员都是 public的。</li><li>没有定义任何构造函数。</li><li>没有类内初始值</li><li>没有基类，也没有 virtual函数</li></ul></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span>&#123;</span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    string s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>初始化 — 顺序必须与生命顺序一致</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data val&#123;<span class="number">0</span>,<span class="string">&quot;anna&quot;</span>&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-4-2-constexpr类"><a href="#7-4-2-constexpr类" class="headerlink" title="7.4.2 constexpr类"></a>7.4.2 constexpr类</h3><ul><li>对于聚合类，如果数据成员都是字面值类型，则为字面值常量类</li><li>对于普通的类，满足：<ul><li>数据成员都必须是字面值类型</li><li>类必须至少含有一个 constexpr 构造函数。</li><li>如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式(笔记2.5.4）；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。</li><li>类必须使用析构函数的默认定义，该成员负责销毁类的对象(书7.1.5节，第239页)。</li></ul></li></ul><p>关于constexpr构造函数</p><ul><li>尽管构造函数不能是 const 的，但是字面值常量类的构造函数可以是 constexpr函数。</li><li>事实上，<strong>一个字面值常量类必须至少提供一个constexpr 构造函数</strong>。</li><li>constexpr构造函数的形式：<ul><li>法一：<code>=default</code></li><li>法二：既符合构造函数的要求（无返回语句），又符合constexpr函数的要求。 &lt;— constexpr构造函数体一般是空的。</li></ul></li><li>constexpr构造函数必须初始化所有数据成员。初始值  或者使用constexpr 构造函数 ，或者是一条常量表达式。</li><li>constexpr 构造函数用于生成constexpr 对象以及 constexpr 函数的参数或返回类型。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Debug</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">bool</span> b = <span class="literal">true</span>)</span> : hw(b),io(b),other(b) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">bool</span> h,<span class="type">bool</span> i, <span class="type">bool</span> o)</span> : hw(h),io(i),other(o) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*constexpr */</span><span class="function"><span class="type">bool</span> <span class="title">any</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> hw || io || other; &#125; </span><br><span class="line">    <span class="comment">//在vs2022上须指定为const成员函数，否则：</span></span><br><span class="line">    <span class="comment">//“bool Debug::any(void)”: 不能将“this”指针从“const Debug”转换为“Debug &amp;”</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_io</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123; io = b; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_hw</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123; hw = b; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_other</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123; hw = b; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> hw;</span><br><span class="line">    <span class="type">bool</span> io;</span><br><span class="line">    <span class="type">bool</span> other;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*调用*/</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> Debug <span class="title">io_sub</span><span class="params">(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (io_sub.<span class="built_in">any</span>()) <span class="comment">// if(true)</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;print appropriate error messages&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> Debug <span class="title">prod</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (prod.<span class="built_in">any</span>())  <span class="comment">// if(false)</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;print anerror message&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-5-类的作用域"><a href="#7-5-类的作用域" class="headerlink" title="7.5 类的作用域"></a>7.5 类的作用域</h2><h3 id="7-5-1-类名-的作用范围"><a href="#7-5-1-类名-的作用范围" class="headerlink" title="7.5.1 类名::的作用范围"></a>7.5.1 <code>类名::</code>的作用范围</h3><p>本节从书本P253开始，首先简述了如何通过类访问其中的成员变量、成员函数和typedef的类型别名。</p><p>接着，讲述了<code>类名::</code>的作用范围，即其后的所有东西，包括函数名、参数列表和函数体。而其之前的返回值类型不包含在其中，如果返回值类名在此类中定义，也要用<code>类名::</code>额外声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 在类中定义类型成员 */</span></span><br><span class="line">    <span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line">    <span class="comment">//等价</span></span><br><span class="line">    <span class="comment">//using pos = string::size_type;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">pos <span class="title">clear</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width = <span class="number">0</span>; <span class="comment">// 默认初始值</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用*/</span></span><br><span class="line"><span class="comment">// Screen::clear中的 `Screen::`不作用于pos，pos需要额外声明其所属类</span></span><br><span class="line"><span class="function">Screen::pos <span class="title">Screen::clear</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-2-名字查找"><a href="#7-5-2-名字查找" class="headerlink" title="7.5.2 名字查找"></a>7.5.2 名字查找</h3><ul><li><p>类成员声明的名字查找，考虑下述代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line">string bal;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> bal;&#125; <span class="comment">//1.</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//typedef double Money; //2.错误，Money不可重复定义</span></span><br><span class="line">    Money bal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><strong>编译器处理完类中的全部声明后，才会处理成员函数的定义。</strong></p></li><li><p>在注释1处，编译器没有找到  在Account中  使用Money前  出现的声明，接着到Account外层作用域寻找，找到了Money。</p></li><li><p>另一方面，成员函数<code>balance()</code>的函数体在整个类全部可见（声明）后才被处理（函数定义），因此返回成员变量bal，而非外层的string的bal。</p></li><li><p>在注释2处，</p><blockquote><p>一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。</p><p><strong>建议将类型名的定义放在类开始处，这样保证所有使用该类的成员都出现在类名定义之后。</strong></p></blockquote></li></ul></li><li><p>成员函数中使用的名字的查找方式：<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401232246190.png" alt="image-20240123224641037" style="zoom:67%;" /></p><ul><li><p>成员变量名和成员函数参数名重名，降低了代码的阅读性。</p><blockquote><p><strong>建议不要将成员名字作为参数或其他局部变量使用</strong>，如下述代码例3所示。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> height;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line">    <span class="comment">/*********** 例1 *************/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(pos height)</span></span>&#123;</span><br><span class="line">        cursor = width * height;  <span class="comment">// height是参数声明</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*****************************/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>,width = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将例1替换成例2*/</span></span><br><span class="line"><span class="comment">/*********** 例2 *************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(pos height)</span></span>&#123;</span><br><span class="line">    cursor = width * <span class="keyword">this</span>-&gt;height; <span class="comment">//类成员height</span></span><br><span class="line">    <span class="comment">//等价</span></span><br><span class="line">    cursor = width * Screen::height;  <span class="comment">//类成员height</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将例1替换成例3*/</span></span><br><span class="line"><span class="comment">/*********** 例3 建议的写法*************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(pos ht)</span></span>&#123;</span><br><span class="line">    cursor = width * height;  <span class="comment">// 类成员height</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将例1替换成例4*/</span></span><br><span class="line"><span class="comment">/*********** 例4 *************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(pos height)</span></span>&#123;</span><br><span class="line">    cursor = width * ::height; <span class="comment">// 全局的那个int height;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****************************/</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>在文件中名字的出现处进行解析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> height;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(pos)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>,width = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Screen::pos <span class="title">verify</span><span class="params">(Screen::pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(pos var)</span></span>&#123;</span><br><span class="line">    height = <span class="built_in">verify</span>(var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然函数<code>verify()</code>在类Screen定义之后，但出现在了成员函数<code>func()</code>定义之前的全局作用域，所以可被正常使用。（参见：成员函数中使用的名字的查找方式第3点：如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。）</p></li></ul><h2 id="7-6-类的静态成员"><a href="#7-6-类的静态成员" class="headerlink" title="7.6 类的静态成员"></a>7.6 类的静态成员</h2><h3 id="7-6-1-基础"><a href="#7-6-1-基础" class="headerlink" title="7.6.1 基础"></a>7.6.1 基础</h3><ul><li>在成员声明前加上<code>static</code>关键字声明静态成员。静态成员直接与类关联，而不是与类的对象关联。</li><li>静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。只会存在一个静态数据，被所有对象共享。</li><li>静态成员函数不与任何对象绑定，不包含this指针，不能声明为const成员函数。</li></ul><h3 id="7-6-2-定义静态成员"><a href="#7-6-2-定义静态成员" class="headerlink" title="7.6.2 定义静态成员"></a>7.6.2 定义静态成员</h3><ul><li>因为静态成员不属于类的任何一个对象，因此不能用类的构造函数初始化。</li><li>一般来说，<strong>不能再类内初始化静态成员，必须在类外部定义和初始化每个静态成员。</strong>除了笔记7.6.3的情况。</li><li>一旦定义，将存在于整个程序的生命周期。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Account</span>();</span><br><span class="line">    ~<span class="built_in">Account</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i; <span class="comment">/*= 0;//错误,带有类内初始值设定项的成员必须为常量*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Account::i = <span class="number">0</span>; <span class="comment">// 类外定义和初始化</span></span><br></pre></td></tr></table></figure><h3 id="7-6-3-静态成员的类内初始化"><a href="#7-6-3-静态成员的类内初始化" class="headerlink" title="7.6.3 静态成员的类内初始化"></a>7.6.3 静态成员的类内初始化</h3><p>笔记7.6.2说：“不能再类内初始化静态成员，必须在类外部定义和初始化每个静态成员。”但是，有一种例外。</p><p>我们可以为静态成员提供<strong>const 整数类型</strong>的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr(参见 7.5.6 节，第267 页)。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适合于常量表达式的地方。例如，我们可以用一个初始化了的静态数据成员指定数组成员的维度:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> period = <span class="number">30</span>;</span><br><span class="line">    <span class="type">double</span> daily_tbl[period];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带初始值的定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> Account::period; </span><br></pre></td></tr></table></figure><p>书中提到了两种情况，说明<code>static constexpr</code>是否需要重复定义：</p><ul><li>仅用静态常量表达式替换它的值，如定义数组维度，则不用重复定义（也可以多此一举地定义）</li><li>当需要将其传递为一个接收该类型的函数时，则需要重复定义。</li></ul><p><strong>为省去麻烦，干脆不论上述何种情况，都在类外重新<em>不带初始值</em>地定义一下该成员。</strong>如上述代码最后一行所示。</p><h3 id="7-6-4-能使用静态成员，而不能使用普通成员变量的场景"><a href="#7-6-4-能使用静态成员，而不能使用普通成员变量的场景" class="headerlink" title="7.6.4 能使用静态成员，而不能使用普通成员变量的场景"></a>7.6.4 能使用静态成员，而不能使用普通成员变量的场景</h3><h4 id="一、静态数据成员可以是不完全类型"><a href="#一、静态数据成员可以是不完全类型" class="headerlink" title="一、静态数据成员可以是不完全类型"></a>一、静态数据成员可以是不完全类型</h4><p>有关不完全类型见<em>书P250—类的声明</em>和<a href="#7.3.6-类类型"><em>笔记7.3.6 类类型</em></a></p><ul><li>特别的，静态数据成员的类型可以就是它所属的类型，而非静态成员变量只能声明它所属的类的指针或引用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Bar mem1;    <span class="comment">//正确，静态成员可以是不完全类型</span></span><br><span class="line">    Bar *men2;            <span class="comment">//正确，指针成员可以是不完全类型</span></span><br><span class="line">    Bar mem3;             <span class="comment">// 错误，数据成员必须是完整类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二、可以使用静态成员作默认实参，而普通成员不行"><a href="#二、可以使用静态成员作默认实参，而普通成员不行" class="headerlink" title="二、可以使用静态成员作默认实参，而普通成员不行"></a>二、可以使用静态成员作默认实参，而普通成员不行</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//静态成员作默认实参</span></span><br><span class="line">    <span class="function">Screen&amp; <span class="title">clear</span><span class="params">(<span class="type">char</span> = bg)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> bg;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> Screen::bg = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 类外定义static数据成员</span></span><br><span class="line"></span><br><span class="line"><span class="function">Screen&amp; <span class="title">Screen::clear</span><span class="params">(<span class="type">char</span> s)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Screen a;</span><br><span class="line">    a.<span class="built_in">clear</span>(); <span class="comment">// 使用默认实参bg，终端输出   a</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><h1>------标准库------</h1></div><h1 id="八-标准库的IO操作"><a href="#八-标准库的IO操作" class="headerlink" title="八 标准库的IO操作"></a>八 标准库的IO操作</h1><h2 id="8-1-IO类"><a href="#8-1-IO类" class="headerlink" title="8.1 IO类"></a>8.1 IO类</h2><h3 id="8-1-1-IO库类型和头文件"><a href="#8-1-1-IO库类型和头文件" class="headerlink" title="8.1.1 IO库类型和头文件"></a>8.1.1 IO库类型和头文件</h3><ul><li>标准库给出的IO类型如下图所示；其中，以“w”开头的版本是为了支持宽字符语言，标准库定义了一组类型和对象来操纵<code>wchar_t</code>类型的数据。</li></ul><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401242153870.png" alt="image-20240124215309669"></p><h3 id="8-1-2-IO对象无拷贝或赋值"><a href="#8-1-2-IO对象无拷贝或赋值" class="headerlink" title="8.1.2 IO对象无拷贝或赋值"></a>8.1.2 IO对象无拷贝或赋值</h3><ul><li>IO对象不能拷贝或者赋值<ul><li>不能拷贝io对象，因此我们不能将形参或返回值类型设置为流类型，而<strong>常以引用方式传递</strong></li><li>读写一个io对象会改变其状态，因此传递和返回的引用不能是<code>const</code></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ofstream out1,out2;</span><br><span class="line">out1 = out2;            <span class="comment">//错误，不能对流对象赋值</span></span><br><span class="line"><span class="function">ofstream <span class="title">print</span><span class="params">(ofstream)</span></span>;    <span class="comment">//错误，不能初始化ofstream参数</span></span><br><span class="line">out1 = <span class="built_in">print</span>(out2);        <span class="comment">//错误，不能拷贝流对象（不能将形参设置为流对象）</span></span><br></pre></td></tr></table></figure><h3 id="8-1-3-IO状态"><a href="#8-1-3-IO状态" class="headerlink" title="8.1.3  IO状态"></a>8.1.3  IO状态</h3><ul><li>条件状态表</li></ul><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401242233996.png" alt="202401242233996" style="zoom:67%;" /></p><ul><li><p>判断一个流是否处于良好状态的最简单的方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin&gt;&gt;word)&#123;</span><br><span class="line">    <span class="comment">//读取成功的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>IO 库定义了一个与机器无关的 <code>iostate</code>类型，该类型应<strong>作为一个位集合来使用</strong>。有4个iostate类型的constexpr值（<code>badbit</code>,<code>failbit</code>,<code>eofbit</code>,<code>goodbit</code>），表示特定的位模式，这些值可以与位运算符一起使用来一次性检测或设置多个标志位：</p><ul><li><code>badbit</code> 表示系统级错误，如不可恢复的读写错误。通常情况下，一旦 <code>badbit</code>被置位，流就无法再使用了。</li><li><code>failbit</code> 被置位于发生可恢复错误后，如期望读取数值却读取一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。</li><li>如果到达文件结束位置，<code>eofbit</code>和 <code>failbit</code> 都会被置位。</li><li><code>goodbit</code> 的值为0，表示流未发生错误。如果<code>badbit</code>、<code>failbit</code>和<code>eofbit</code>任一个被置位，则检测流状态的条件会失败。</li></ul></li><li><p>为检测流的状态，IO库提供了一组函数。其中，<code>good()</code>和<code>fail()</code>是确定流的总体状态的方法。下面列出两种使用方法：</p><ul><li><p>状态管理：保存流的状态并恢复</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> old_state = cin.<span class="built_in">rdstate</span>();</span><br><span class="line">cin.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">proess_func</span>(cin);</span><br><span class="line">cin.<span class="built_in">setstate</span>(old_state);</span><br></pre></td></tr></table></figure></li><li><p>将failbit和badbit复位，但保持eofbit不变：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">clear</span>(cin.<span class="built_in">rdstate</span>() &amp; ~cin.failbit &amp; ~cin.badbit);</span><br></pre></td></tr></table></figure><p>过程如下图所示<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401251044101.png" alt="image-20240125104415847"></p></li></ul></li></ul><h3 id="8-1-4-缓冲区"><a href="#8-1-4-缓冲区" class="headerlink" title="8.1.4 缓冲区"></a>8.1.4 缓冲区</h3><ul><li><p>导致缓冲区刷新的原因</p><ul><li><p>程序正常结束，作为main函数<code>return</code>操作的一部分，缓冲刷新被执行。</p></li><li><p>缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。</p></li><li>我们可以使用操纵符如<code>endl</code>(参见1.2节，第6页)来显式刷新缓冲区。</li><li>在每个输出操作之后，我们可以用操纵符<code>unitbuf</code>设置流的内部状态，来清空缓冲区。默认情况下，对<code>cerr</code> 是设置<code>unitbuf</code>的，因此写到<code>cerr</code>的内容都是立即刷新的。</li><li>一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，<code>cin</code>和 <code>cerr</code> 都关联到 <code>cout</code>。因此，读<code>cin</code>或写<code>cerr</code>都会导致<code>cout</code>的缓冲区被刷新。</li></ul></li></ul><ul><li><p>刷新缓冲区的几种方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">&quot;hi&quot;</span>&lt;&lt;endl;    <span class="comment">//附加一个换行符，然后刷新缓冲区</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;hi&quot;</span>&lt;&lt;flush;    <span class="comment">//不附加任何字符，刷新缓冲区</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;hi&quot;</span>&lt;&lt;end;    <span class="comment">//附加一个空字符，然后刷新缓冲区</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;unitbuf;</span><br><span class="line"><span class="comment">//任何输出都立即刷新，无缓冲</span></span><br><span class="line">......;<span class="comment">// 一些操作</span></span><br><span class="line">cout&lt;&lt;nounitbuf; <span class="comment">// 回到正常的缓冲模式</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>书中提到的一个注意事项：</p><blockquote><p>警告：如果程序崩溃，输出缓冲区不会被刷新</p><p>如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩溃后，它所输出的数据很可能停留在输出缓冲区中等待打印。</p><p>当调试一个已经崩溃的程序时，需要确认那些你认为已经输出的数据确实已经刷新了。否则，可能将大量时间浪费在追踪代码为什么没有执行上，而实际上代码已经执行了，只是程序崩溃后缓冲区没有被刷新，输出数据被挂起没有打印而已。</p><p><strong>程序员常常在调试添加打印语句。这类语句应该保证一直刷新流。否则，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。</strong></p></blockquote></li></ul><h3 id="8-1-5-关联输入流和输出流"><a href="#8-1-5-关联输入流和输出流" class="headerlink" title="8.1.5 关联输入流和输出流"></a>8.1.5 关联输入流和输出流</h3><ul><li><p>当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将cin和cout关联，因此<code>cin &gt;&gt;ival</code>将会导致cout的缓冲区被刷新。</p></li><li><p>利用<code>iostream::tie()</code>函数，既可以将一个istream对象关联到另一个ostream上，也可以将一个ostream关联到另一个ostream上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">tie</span>(&amp;cout); <span class="comment">// 标准库中，cin与cout关联</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//old_tie指向旧的关联</span></span><br><span class="line">ostream *old_tie = cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);<span class="comment">//cin不再与任何流关联（即解除关联）</span></span><br><span class="line"></span><br><span class="line">cin.<span class="built_in">tie</span>(&amp;cerr); <span class="comment">// 将cin与cerr关联，读取cin会导致cerr的刷新</span></span><br><span class="line"></span><br><span class="line">cin.<span class="built_in">tie</span>(old_tie); <span class="comment">// 恢复之前的关联</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="8-2-iostream"><a href="#8-2-iostream" class="headerlink" title="8.2 iostream"></a>8.2 iostream</h2><p>书本第5页（略）</p><h2 id="8-3-fstream（文件流）"><a href="#8-3-fstream（文件流）" class="headerlink" title="8.3 fstream（文件流）"></a>8.3 fstream（文件流）</h2><h3 id="8-3-1-fstream的特有操作"><a href="#8-3-1-fstream的特有操作" class="headerlink" title="8.3.1 fstream的特有操作"></a>8.3.1 fstream的特有操作</h3><ul><li>fstream继承与iostream，除了可以使用iostream的操作外，还有其特有的操作，如下所示：<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401242237156.png" alt="image-20240124223730897" style="zoom:67%;" /><ul><li><strong>在要求使用基类类型对象的地方，我们可以用继承类型的对象来替代。</strong>因为fstream（和sstream）继承于iostream，所以接受iostream的引用（或指针）参数的函数，可以用对用的fstream（或sstream）类型来调用。</li><li>通过构造函数打开文件的，会自动调用<code>open()</code>和<code>close()</code> （自动构造和析构）。通过<code>open()</code>打开文件，则必须在结束是手动书写<code>close()</code>。</li><li>对一个已经打开的文件流调用<code>open()</code>会失败，并导致<code>failbit</code>被置位。必须先关闭（<code>close()</code>）已经关联的文件，再打开新文件。</li></ul></li></ul><h3 id="8-3-2-文件模式"><a href="#8-3-2-文件模式" class="headerlink" title="8.3.2 文件模式"></a>8.3.2 文件模式</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401242235255.png" alt="image-20240124223522104" style="zoom:67%;" /></p><ul><li>默认模式<ul><li>ifstream：in模式</li><li>ofstream：out模式</li><li>fstream：in+out模式</li></ul></li></ul><ul><li>一些注意事项<ul><li>以<code>out</code>模式打开文件会将文件清空，除非同时显式指定<code>app</code>或<code>in</code>。</li><li>只有当<code>out</code>也被设定时才可设定<code>trunc</code></li><li>每次调用<code>open()</code>都要（显式或隐式地）重新设置文件模式。</li><li>只可以对<code>ofstream</code>或<code>fstream</code>设置<code>out</code></li><li>只可以对<code>ifstream</code>或<code>fstream</code>设置<code>in</code></li><li>只要<code>trunc</code>没被设定，就可以设定<code>app</code> 模式。在 <code>app</code>模式下，即使没有显式指定<code>out</code> 模式，文件也总是以输出方式被打开。</li><li><code>ate</code>和<code>binary</code>模式可用于任何类型的文件流对象，且可以与其他任何文件模式组合使用。</li></ul></li></ul><h2 id="8-4-sstream（string流）"><a href="#8-4-sstream（string流）" class="headerlink" title="8.4 sstream（string流）"></a>8.4 sstream（string流）</h2><ul><li><p>和fstream同样继承与ostream，既可以使用iostream的操作，也有其特有操作：<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401251631905.png" alt="image-20240125163147587"></p></li><li><p><code>strm.str(s)</code>会清空strm中原有的数据，示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ostringstream nums;</span><br><span class="line">    vector&lt;string&gt; nums_vec&#123;<span class="string">&quot;123&quot;</span>,<span class="string">&quot;456&quot;</span>,<span class="string">&quot;789&quot;</span>,<span class="string">&quot;101112&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> num : nums_vec) &#123;</span><br><span class="line">        nums &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; nums.<span class="built_in">str</span>() &lt;&lt; endl; <span class="comment">//123 456 789 101112</span></span><br><span class="line"></span><br><span class="line">    nums.<span class="built_in">str</span>(<span class="built_in">string</span>(<span class="string">&quot;888&quot;</span>)); <span class="comment">// 清空了string流中原有的数据</span></span><br><span class="line">    cout &lt;&lt; nums.<span class="built_in">str</span>() &lt;&lt; endl; <span class="comment">//888</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-4-1-istringstream"><a href="#8-4-1-istringstream" class="headerlink" title="8.4.1 istringstream"></a>8.4.1 istringstream</h3><ul><li>何时使用？<ul><li>当我们对整行文本进行处理，并同时需要处理行内的单个单词时。</li></ul></li><li>示例</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PersonInfo</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    vector&lt;string&gt; phones;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string line, phone;</span><br><span class="line">    vector&lt;PersonInfo&gt; people;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件中的所有数据存入people:vector&lt;PersonInfo&gt;中</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line)) &#123;</span><br><span class="line">        PersonInfo info;</span><br><span class="line">        <span class="function">istringstream <span class="title">record</span><span class="params">(line)</span></span>;</span><br><span class="line">        record &gt;&gt; info.name;</span><br><span class="line">        <span class="keyword">while</span> (record &gt;&gt; phone)</span><br><span class="line">        &#123;</span><br><span class="line">            info.phones.<span class="built_in">push_back</span>(phone);</span><br><span class="line">        &#125;</span><br><span class="line">        people.<span class="built_in">push_back</span>(info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐人验证号码是否有效</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;entry : people)</span><br><span class="line">    &#123;</span><br><span class="line">        ostringstream formated, badNums;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;phone :entry.phones)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">valid</span>(phone)) &#123; <span class="comment">// 省略判断电话是否有效的代码</span></span><br><span class="line">                badNums &lt;&lt; phone &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                formated &lt;&lt; format(phone) &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//省略格式化电话号码的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (badNums.<span class="built_in">str</span>().<span class="built_in">empty</span>())</span><br><span class="line">            cout &lt;&lt; entry.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; formated.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;input error: &quot;</span> &lt;&lt; entry.name </span><br><span class="line">            &lt;&lt; <span class="string">&quot; invalid numbers(s) &quot;</span>&lt;&lt; badNums.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-2-ostringstream"><a href="#8-4-2-ostringstream" class="headerlink" title="8.4.2 ostringstream"></a>8.4.2 ostringstream</h3><ul><li><p>何时使用？我们想逐步构造输出的内容，希望放在最后一起打印。（此构造非构造函数的构造，不要过分解读））</p></li><li><p>接着8.4.1节的代码，示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逐人验证号码是否有效</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;entry : people)</span><br><span class="line">&#123;</span><br><span class="line">    ostringstream formated, badNums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;phone :entry.phones)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">valid</span>(phone)) &#123; <span class="comment">// 省略判断电话是否有效的代码</span></span><br><span class="line">            badNums &lt;&lt; phone &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            formated &lt;&lt; format(phone) &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//省略格式化电话号码的代码        </span></span><br><span class="line">            <span class="comment">/*注意此处 ↑。</span></span><br><span class="line"><span class="comment">            使用标准的输出运算符`&lt;&lt;`向这些对象写入数据，</span></span><br><span class="line"><span class="comment">            但这些“写入”操作实际上转换为 `string`操作，</span></span><br><span class="line"><span class="comment">            分别向` formatted`和`badNums`中的`string `对象添加字符。*/</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (badNums.<span class="built_in">str</span>().<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; entry.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; formated.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;input error: &quot;</span> &lt;&lt; entry.name </span><br><span class="line">        &lt;&lt; <span class="string">&quot; invalid numbers(s) &quot;</span>&lt;&lt; badNums.<span class="built_in">str</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><blockquote><p>程序最有趣的部分是对字符串流 <code>formatted</code>和<code>badNums</code>的使用。我们使用标准的输出运算符<code>&lt;&lt;</code>向这些对象写入数据，但这些“写入”操作实际上转换为 <code>string</code>操作，分别向<code>formatted</code>和<code>badNums</code>中的<code>string</code>对象添加字符。</p></blockquote></li></ul><h3 id="8-4-3-本节完整的示例代码"><a href="#8-4-3-本节完整的示例代码" class="headerlink" title="8.4.3 本节完整的示例代码"></a>8.4.3 本节完整的示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件中的数据 */</span></span><br><span class="line"><span class="comment">//morgan 2015552368 8625550123</span></span><br><span class="line"><span class="comment">//drew 9735550130l</span></span><br><span class="line"><span class="comment">//ee 6095550132 2015550175 8005550000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PersonInfo</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    vector&lt;string&gt; phones;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string line, phone;</span><br><span class="line">    vector&lt;PersonInfo&gt; people;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件中的所有数据存入people:vector&lt;PersonInfo&gt;中</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line)) &#123;</span><br><span class="line">        PersonInfo info;</span><br><span class="line">        <span class="function">istringstream <span class="title">record</span><span class="params">(line)</span></span>;</span><br><span class="line">        record &gt;&gt; info.name;</span><br><span class="line">        <span class="keyword">while</span> (record &gt;&gt; phone)</span><br><span class="line">        &#123;</span><br><span class="line">            info.phones.<span class="built_in">push_back</span>(phone);</span><br><span class="line">        &#125;</span><br><span class="line">        people.<span class="built_in">push_back</span>(info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐人验证号码是否有效</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;entry : people)</span><br><span class="line">    &#123;</span><br><span class="line">        ostringstream formated, badNums;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;phone :entry.phones)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">valid</span>(phone)) &#123; <span class="comment">// 省略判断电话是否有效的代码</span></span><br><span class="line">                badNums &lt;&lt; phone &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                formated &lt;&lt; format(phone) &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//省略格式化电话号码的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (badNums.<span class="built_in">str</span>().<span class="built_in">empty</span>())</span><br><span class="line">            cout &lt;&lt; entry.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; formated.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;input error: &quot;</span> &lt;&lt; entry.name </span><br><span class="line">            &lt;&lt; <span class="string">&quot; invalid numbers(s) &quot;</span>&lt;&lt; badNums.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="九-顺序容器"><a href="#九-顺序容器" class="headerlink" title="九 顺序容器"></a>九 顺序容器</h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401260921334.png" alt="image-20240126092125836"></p><ul><li><code>forward_list</code>没有<code>size</code>操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其他容器而言，<code>size</code>保证的是一个快速的常量时间的操作。</li></ul><h3 id="9-1-1-选用顺序容器的原则"><a href="#9-1-1-选用顺序容器的原则" class="headerlink" title="9.1.1 选用顺序容器的原则"></a>9.1.1 选用顺序容器的原则</h3><ul><li>首选<code>vector</code></li><li>很多小元素，且空间开销重要 —&gt; 不要使用<code>list</code>或<code>forward_list</code></li><li>要求随机访问 —&gt; <code>vector</code>或<code>deque</code></li><li>中间插入和删除 —&gt; <code>list</code>或<code>forward_list</code></li><li>头尾插入和删除，但不在中间插入和删除 —&gt; <code>deque</code></li><li>如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则<ul><li>首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向 <code>vector</code> 追加数据，然后再调用标准库的<code>sort</code>函数，来重排容器中的元素，从而避免在中间位置添加元素。</li><li>如果必须在中间位置插入元素，考虑在输入阶段使用<code>list</code>，一旦输入完成，将<code>list</code>中的内容拷贝到一个 <code>vector</code> 中。</li></ul></li><li>如果程序既需要随机访问元素，又需要在容器中间位置插入元素，则取决于在<code>list</code>或<code>forward_list</code> 中访问元素与 <code>vector</code>或<code>deque</code>中插入/删除元素的相对性能，一般来说，应用中占主导地位的操作(执行的访问操作更多还是插入/删除更多)决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了）。</li></ul><blockquote><p>如果你不确定应该使用哪种容器，那么可以在程序中只使用 <code>vector</code>和<code>list</code>公共的操作：迭代器，而不是使用下标，以避免随机访问。这样，在必要时选择使用<code>vector</code>或<code>list</code>都很方便。</p></blockquote><h2 id="9-2-容器库概览"><a href="#9-2-容器库概览" class="headerlink" title="9.2 容器库概览"></a>9.2 容器库概览</h2><blockquote><p>对于容器类型的操作，有些适用于所有容器；有些仅针对顺序或关联或无序；有些适用于个别容器。</p><p>本节介绍适用于所用容器的操作。</p><p>本章剩余部分则聚焦顺序容器的操作。</p></blockquote><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401260943509.png" alt="202401260943509"></p><blockquote><p> 虽然我们可以在容器中保存几乎任何类型，但某些容器操作对元素类型有其自己的特殊要求。我们可以为不支持特定操作需求的类型定义容器，但这种情况下就只能使用那些没有特殊要求的容器操作了。有如下示例。</p></blockquote><p>顺序容器的  接受容器大小的  构造函数版本，要求其中元素的类型必须能够被默认初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NoDefault：a Type With No Default Constructor</span></span><br><span class="line"><span class="function">vector&lt;NoDefault&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>,init)</span></span>;  <span class="comment">// 正确，提供了元素初始化器</span></span><br><span class="line"><span class="function">vector&lt;NoDefault&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;        <span class="comment">// 错误，需要元素初始化</span></span><br></pre></td></tr></table></figure><h3 id="9-2-1-迭代器"><a href="#9-2-1-迭代器" class="headerlink" title="9.2.1 迭代器"></a>9.2.1 迭代器</h3><p>在书P296~P299，介绍了容器的迭代器。书中首先说，与容器一样，迭代器有着公共的接口，不同容器的迭代器都执行着类似的操作。 <strong>并特别指出，<code>forward_list</code>的迭代器不支持<code>--</code> 。</strong></p><p>接着介绍了迭代器的左闭右开区间：<code>[ begin , end )</code>，以及利用该特性对容器中元素进行访问的操作。特别提到<strong>需要保证在合法的范围内解引用begin</strong>。</p><p>然后提到了类型成员，特别提到了<strong>反向迭代器</strong>，与正向迭代器相比，各种操作的含义都发生了颠倒。比如，<code>++</code>会得到上一个元素；<code>rbegin</code>和<code>rend</code>会获得尾元素和首元素之前位置的迭代器。<a href="#10.4.3-反向迭代器">笔记10.4.3介绍</a></p><p>提到容器相关的类型别名在书16章介绍。</p><p>P298，书9.2.3节begin和end成员 中提到：</p><ul><li><p>迭代器中（begin，cbegin，rbegin，crbegin，end，cend，rend，crend），不以<code>c</code>开头的版本都是重载过的。</p></li><li><p>可以将一个普通版本的<code>iterator</code>转化为对应的<code>const_iterator</code>，反之则不然。</p></li><li><p>当<code>auto</code>与<code>begin</code>或<code>end</code>结合使用时，获得的选代器类型依赖于容器类型，与我们想要如何使用迭代器毫不相干。但以<code>c</code>开头的版本还是可以获得 <code>const_iterator</code> 的而不管容器的类型是什么。示例如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it7 = a.<span class="built_in">begin</span>();    <span class="comment">// 仅当a是const时，it7是const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it8 = a.<span class="built_in">cbegin</span>();    <span class="comment">// it8是const_iterator</span></span><br></pre></td></tr></table></figure><blockquote><p>当不需要写访问时，应使用 <code>cbegin</code> 和<code>cend</code>。</p></blockquote></li></ul><p><a href="#10.4-再探迭代器">笔记10.4 再探迭代器</a>将对迭代器的内容进行拓展。</p><h3 id="9-2-2-容器定义和初始化"><a href="#9-2-2-容器定义和初始化" class="headerlink" title="9.2.2 容器定义和初始化"></a>9.2.2 容器定义和初始化</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401261224291.png" alt="image-20240126122404847" style="zoom:67%;" /></p><h4 id="一、拷贝初始化"><a href="#一、拷贝初始化" class="headerlink" title="一、拷贝初始化"></a>一、拷贝初始化</h4><p>将一个新容器创建为另一个容器的拷贝的方法有两种：</p><ul><li><p>直接拷贝整个容器</p><ul><li><p><strong>要求两个容器的类型及其元素类型必须匹配</strong></p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; authors = &#123;<span class="string">&quot;Milton&quot;</span>,<span class="string">&quot;Shakespeare&quot;</span>,<span class="string">&quot;Austen&quot;</span>&#125;; <span class="comment">// 列表初始化</span></span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">list2</span><span class="params">(authors)</span></span>;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line">list&lt;string&gt; list2 = authors;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">list3</span><span class="params">(authors)</span></span>; <span class="comment">//错误，容器的类型不匹配</span></span><br><span class="line"><span class="function">list&lt;<span class="type">char</span> *&gt; <span class="title">list4</span><span class="params">(authors)</span></span>; <span class="comment">//错误，元素的类型不匹配</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>拷贝由  迭代器对  指定的元素范围</p><ul><li><p><strong>不要求容器的类型相同，也不要求元素的类型相同</strong>。只要能将要拷贝的元素转换为要初始化的容器的元素类型即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">const</span> <span class="type">char</span> *&gt; authors = &#123;<span class="string">&quot;Milton&quot;</span>,<span class="string">&quot;Shakespeare&quot;</span>,<span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line"><span class="function">forward_list&lt;string&gt; <span class="title">words</span><span class="params">(authors.begin(), authors.end())</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>array不适用</p></li></ul></li></ul><h4 id="二、列表初始化"><a href="#二、列表初始化" class="headerlink" title="二、列表初始化"></a>二、列表初始化</h4><p>略</p><h4 id="三、顺序容器独有：指定容器大小来初始化"><a href="#三、顺序容器独有：指定容器大小来初始化" class="headerlink" title="三、顺序容器独有：指定容器大小来初始化"></a>三、顺序容器独有：指定容器大小来初始化</h4><ul><li><p>只有顺序容器的构造函数才接受大小参数，关联容器并不支持。</p></li><li><p>如果元素类型是内置类型或者是具有默认构造函数的类类型，可以只为构造函数提供一个容器大小参数。<strong>如果元素类型没有默认构造函数，除了大小参数外，还必须指定一个显式的元素初始值。</strong>举个例子，创建一个Test类，并将其默认构造函数删除，编译器报错如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">/*删除了默认构造函数，成员变量a无法执行默认初始化。</span></span><br><span class="line"><span class="comment">    * 当创建10个Test类型的vector的时候，找不到默认构造函数，编译器报错如下：</span></span><br><span class="line"><span class="comment">    * 错误  C2280  “Test::Test(void)”: 尝试引用已删除的函数    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;Test&gt; <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不指定大小的容器中，元素可以没有构造函数。如上面提到的拷贝初始化、列表初始化等。</p></li></ul><h4 id="四、array的固定大小"><a href="#四、array的固定大小" class="headerlink" title="四、array的固定大小"></a>四、array的固定大小</h4><ul><li><p><strong>大小也是类型的一部分</strong>，必须同时指定元素类型和大小。</p></li><li><p>和其他容器不同，默认构造的array是非空的。其包含了指定数量的被默认初始化后的元素（因此元素类型一定要有默认初始化）。</p></li><li><p>值得注意的是，虽然<strong>不能对内置数组类型进行拷贝或者对象赋值</strong>，但<strong>array没有该限制</strong>。<code>array&lt;&gt;</code>在拷贝赋值的时候，注意元素类型和数量要一样。内置数组拷贝赋值和<code>array</code>容器拷贝赋值对比如下：<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401261613618.png" alt="202401261613618"></p></li></ul><h3 id="9-2-3-赋值和swap"><a href="#9-2-3-赋值和swap" class="headerlink" title="9.2.3 赋值和swap"></a>9.2.3 赋值和swap</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401261224557.png" alt="image-20240126122444107" style="zoom:67%;" /></p><ul><li><p>上表中列出的，<strong>与赋值有关的运算符</strong>可用于所有容器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1=c2;</span><br><span class="line">c1=&#123;a,b&#125;;</span><br></pre></td></tr></table></figure></li><li><p>由于右边运算对象的大小可能与左边运算对象的大小不同，<strong>因此array类型不支持assign，也不允许用花括号值列表进行赋值</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>,10&gt; a1 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">array&lt;<span class="type">int</span>,10&gt; a2 = &#123;<span class="number">0</span>&#125;; <span class="comment">// 10个0</span></span><br><span class="line"></span><br><span class="line">a2 = a1; <span class="comment">//正确</span></span><br><span class="line">a2 = &#123;<span class="number">0</span>&#125;; <span class="comment">//错误，不能用花括号值列表给array赋值</span></span><br></pre></td></tr></table></figure></li><li><p><code>assign()</code></p><ul><li><p>仅顺序容器</p></li><li><p>允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;string&gt; names;</span><br><span class="line">    vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; old_style;</span><br><span class="line">    </span><br><span class="line">    names = old_style; <span class="comment">// 错误,容器类型不匹配</span></span><br><span class="line">    </span><br><span class="line">    names.<span class="built_in">assign</span>(old_style.<span class="built_in">begin</span>(), old_style.<span class="built_in">end</span>()); <span class="comment">// 自动进行了类型转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于其旧元素被替代，因此传递给assign的迭代器不能指向调用assign的容器。以下是ChatGPT给出的例子，人为制造一个错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; originalList = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 试图在循环中使用迭代器来调用 assign</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = originalList.<span class="built_in">begin</span>(); it != originalList.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="comment">// 尝试在循环中调用 assign，传递迭代器指向原始列表</span></span><br><span class="line">        originalList.<span class="built_in">assign</span>(it, it);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里迭代器已经失效，因为 assign 改变了容器的大小</span></span><br><span class="line">        <span class="comment">// 这可能导致未定义的行为或程序崩溃</span></span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; std::endl;  <span class="comment">// 试图访问失效的迭代器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>swap()</code></p><ul><li>交换两个相同类型的容器内容。</li><li>除<code>array</code>外，<code>swap</code>不对任何元素进行拷贝、删除或插入操作，只交换两个容器的内部数据结构，因此速度非常快。而对<code>array</code>则会真正交换它们的元素。</li><li>除<code>string</code>外，指向容器的迭代器、引用和指针，在<code>swap</code>操作后都不会失效，仍指向<code>swap</code>操作前所指向的那些元素。但是这些元素已经属于不同的容器了。</li><li>统一使用非成员版本的<code>swap()</code>是个好习惯。</li></ul></li></ul><h3 id="9-2-4-容器大小"><a href="#9-2-4-容器大小" class="headerlink" title="9.2.4 容器大小"></a>9.2.4 容器大小</h3><ul><li><code>size()</code>：返回元素数目。<strong><code>forward_list</code>不支持<code>size()</code></strong></li><li><code>empty()</code>：容器是否为空</li><li><code>max_size()</code>：返回一个大于或等于该类型<strong>容器所能容纳的最大元素数</strong>的值。</li></ul><h3 id="9-2-5-关系运算"><a href="#9-2-5-关系运算" class="headerlink" title="9.2.5 关系运算"></a>9.2.5 关系运算</h3><ul><li>每个容器类型都支持相等运算符（==和!=）</li><li>除无序关联容器外都支持关系运算符（&gt; 、&gt;=、 &lt; 、&lt;=）</li><li>比较的对象必须有相同的容器类型和相同的元素类型。</li><li>用于比较的元素类型必须重载了（定义了）关系运算符</li><li>比较规则类似string，如下：<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401261757615.png" alt="image-20240126175704307" style="zoom:67%;" /></li></ul><h2 id="9-3-顺序容器的特有操作"><a href="#9-3-顺序容器的特有操作" class="headerlink" title="9.3 顺序容器的特有操作"></a>9.3 顺序容器的特有操作</h2><h3 id="9-3-1-插入元素"><a href="#9-3-1-插入元素" class="headerlink" title="9.3.1 插入元素"></a>9.3.1 插入元素</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401261226532.png" alt="202401261226532" style="zoom: 67%;" /></p><h4 id="一、push-back"><a href="#一、push-back" class="headerlink" title="一、push_back"></a>一、push_back</h4><ul><li><p>除<code>array</code>和<code>forward_list</code>外，每个顺序容器（包括string）都支持<code>push_back</code>。</p></li><li><p>push_back是将对象<strong>拷贝</strong>，</p><blockquote><p>关键概念:容器元素是拷贝<br>当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。</p></blockquote></li></ul><h4 id="二、push-front"><a href="#二、push-front" class="headerlink" title="二、push_front"></a>二、push_front</h4><ul><li><code>list</code>、<code>forward_list</code>、<code>deque</code>还支持<code>push_front</code></li></ul><h4 id="三、insert"><a href="#三、insert" class="headerlink" title="三、insert"></a>三、insert</h4><ul><li><p><code>vector</code>、<code>deque</code>、<code>list</code>、<code>string</code>都支持<code>insert</code>。（注：<code>forward_list</code>为特殊版本，于forward_list专题介绍）</p></li><li><p>每个insert都接受一个迭代器作为其第一参数，表示将某个（些）额外的元素添加到这个迭代器所指向的元素之<strong>前</strong>。 &lt;—注意，是之前插入</p></li><li><p>虽然某些容器（如vector）不支持push_front 操作，但它们对于 insert 操作并无类似的限制（插入开始位置）。因此我们可以将元素插入到容器的开始位置，而不必担心容器是否支持push_front :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; vec_str = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// vector不支持push_front,但是可以通过insert插入新的首元素，但是可能很耗时</span></span><br><span class="line">    vec_str.<span class="built_in">insert</span>(vec_str.<span class="built_in">begin</span>(), <span class="string">&quot;hello&quot;</span>);  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;word : vec_str)</span><br><span class="line">        cout&lt;&lt;word&lt;&lt;<span class="string">&quot; &quot;</span>;  <span class="comment">// hello a b c</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>一、插入特定元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">insert</span>(p,t);    <span class="comment">//对容器c，向p位置之前插入元素t</span></span><br></pre></td></tr></table></figure><p>二、插入范围内元素</p><ul><li><p><code>c.insert(p,n,t)</code> ：对容器c，向p位置之前插入n个元素t</p></li><li><p><code>c.insert(p,b,e)</code>：对容器c，向p位置之前插入一对迭代器，<strong>特别说明，这对迭代器不能指向  调用insert的容器对象（此处为c）  的元素</strong></p></li><li><code>c.insert(p,il)</code>：对容器c，向p位置之前插入初始化列表il</li></ul><p>本节的三种插入方式，返回<strong>指向第一个新加入元素的迭代器</strong>。如果插入为空，则将insert的第一个参数返回。</p><p>通过使用该返回值，可以在容器中一个特定的位置反复插入元素。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;string&gt; lst;</span><br><span class="line">    string word;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> iter = lst.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;word)</span><br><span class="line">        <span class="comment">//等价于调用push_front</span></span><br><span class="line">        iter = lst.<span class="built_in">insert</span>(iter,word);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三、</p><p><code>emplace_front</code>、<code>emplace</code>、<code>emplace_back</code>与<code>push_front</code>、<code>insert</code>、<code>push_back</code>对应。</p><p>push_xxx和insert，将元素类型的<strong>对象拷贝到容器</strong>中；</p><p>emplace_xxx则是<strong>将参数传递给元素类型的构造函数，以在容器管理的内存空间中直接构造元素</strong>。传递给emplace函数的参数必须元素类型的构造函数相匹配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, Sales_data sd);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> uint = <span class="type">unsigned</span> ;</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(string isbn, uint cnt, <span class="type">double</span> price)</span><br><span class="line">            :<span class="built_in">m_isbn</span>(isbn),<span class="built_in">m_cnt</span>(cnt),<span class="built_in">m_price</span>(price)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_isbn;</span><br><span class="line">    uint m_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> m_price = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, Sales_data sd)&#123;</span><br><span class="line">    os&lt;&lt;sd.m_isbn&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;sd.m_cnt&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;sd.m_price;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Sales_data&gt; vec;</span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="string">&quot;123&quot;</span>,<span class="number">25</span>,<span class="number">15.99</span>);<span class="comment">//直接在容器的内存空间中创建对象</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">Sales_data</span>(<span class="string">&quot;456&quot;</span>,<span class="number">15</span>,<span class="number">36.2</span>)); <span class="comment">// 创建元素的临时对象，并将其拷贝到容器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; sales_data : vec)</span><br><span class="line">        cout&lt;&lt;sales_data&lt;&lt;endl;</span><br><span class="line">        <span class="comment">/* 终端输出：</span></span><br><span class="line"><span class="comment">        123 25 15.99</span></span><br><span class="line"><span class="comment">        456 15 36.2</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9-3-2-访问元素"><a href="#9-3-2-访问元素" class="headerlink" title="9.3.2 访问元素"></a>9.3.2 访问元素</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401271500480.png" alt="image-20240127150051109"></p><ul><li><code>at</code>和下标运算符只使用于<code>string、vector、deque、array</code></li><li><code>back</code>不适用<code>forward_list</code></li><li><code>back()</code> 、<code>front()</code>、 <code>at</code> 和<code>下标运算符</code>返回的都是<strong>引用</strong>。</li><li><code>at</code>相较于下标运算符较安全，越界抛出<code>out_of_range</code>的异常。</li></ul><p>因为返回的是引用，可通过访问元素的函数修改容器内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    vec.<span class="built_in">front</span>() = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> &amp;v1 = vec.<span class="built_in">back</span>();</span><br><span class="line">    v1 = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//理解auto的规则（笔记2.6.2）：</span></span><br><span class="line">    <span class="comment">// auto以引用对象的类型作为auto的类型</span></span><br><span class="line">    <span class="keyword">auto</span> v2 = vec.<span class="built_in">back</span>();    <span class="comment">//不是引用，是一个拷贝</span></span><br><span class="line">    v2 = <span class="number">0</span>; <span class="comment">//未能改变vec中的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; num : vec)</span><br><span class="line">        cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-3-删除元素"><a href="#9-3-3-删除元素" class="headerlink" title="9.3.3 删除元素"></a>9.3.3 删除元素</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401271525056.png" alt="image-20240127152516619"></p><ul><li><p><code>pop_front()</code>和<code>pop_back()</code>返回void，如果还需要弹出的元素值，要在弹出前保存。</p></li><li><p><code>erase(p)</code>返回p的下一个元素的迭代器</p></li><li><p><code>erase(b,e)</code>e指向<strong>要删除的最后一个元素的下一个位置</strong>，结束后b==e</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">vec.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line">vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li></ul><p>补充：forward_list没有pop_back()，如何删除尾元素？</p><p>在C++中，<code>std::forward_list</code>是单向链表，由于单向链表的特性，删除最后一个元素需要一些额外的考虑，因为它没有直接提供像<code>pop_back</code>这样的成员函数，而是需要从头开始遍历链表找到倒数第二个元素，然后将其<code>next</code>指针置为空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* forward_list删除尾元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; myList = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果列表为空，无需进行任何操作</span></span><br><span class="line">    <span class="keyword">if</span> (!myList.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> current = myList.<span class="built_in">before_begin</span>(); <span class="comment">// 迭代器指向头之前的位置</span></span><br><span class="line">        <span class="keyword">auto</span> last = myList.<span class="built_in">begin</span>(); <span class="comment">// 迭代器指向头</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历找到倒数第二个元素</span></span><br><span class="line">        <span class="keyword">while</span> (std::<span class="built_in">next</span>(last) != myList.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            ++current;</span><br><span class="line">            ++last;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除最后一个元素</span></span><br><span class="line">        myList.<span class="built_in">erase_after</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出删除后的列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; value : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::next</code>是C++标准库中的一个函数模板，用于<strong>返回给定迭代器的下一个迭代器</strong>。该函数的定义位于头文件 <code>&lt;iterator&gt;</code> 中。下面是它的基本语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt &gt;</span></span><br><span class="line"><span class="function">InputIt <span class="title">next</span><span class="params">( InputIt it, <span class="keyword">typename</span> std::iterator_traits&lt;InputIt&gt;::difference_type n = <span class="number">1</span> )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>it</code>：要获取下一个迭代器的起始迭代器。</li><li><code>n</code>：要移动的步数，默认为1。<br><code>std::next</code>在迭代器上执行递增操作，允许你在容器中向前移动指定数量的位置。这对于在算法中进行迭代器操作时非常有用。<br>以下是一个简单的示例，演示如何使用<code>std::next</code>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::next 将迭代器向前移动两个位置</span></span><br><span class="line">    <span class="keyword">auto</span> advancedIt = std::<span class="built_in">next</span>(it, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original iterator value: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Advanced iterator value: &quot;</span> &lt;&lt; *advancedIt &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>std::next</code>被用来将迭代器 <code>it</code> 向前移动两个位置，产生一个新的迭代器 <code>advancedIt</code>。这样，你可以在容器中灵活地移动迭代器，而不必手动进行逐步增加。<br>如果有其他问题或需要更详细的解释，请随时提出。</p><h3 id="9-3-4-改变容器大小"><a href="#9-3-4-改变容器大小" class="headerlink" title="9.3.4 改变容器大小"></a>9.3.4 改变容器大小</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401271558280.png" alt="image-20240127155838890"></p><ul><li><p>如果当前大小大于所要求的大小，容器后部的元素会被删除:如果当前大小小于新大小，会将新元素添加到容器后部:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">ilist</span><span class="params">(<span class="number">10</span>,<span class="number">42</span>)</span></span>;     <span class="comment">//10个int:每个的值都是42</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">15</span>);           <span class="comment">//将5个值为0的元素添加到 ilist 的末尾</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">25</span>,<span class="number">-1</span>);        <span class="comment">//将10个值为-1的元素添加到 ilist的末尾</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">5</span>);            <span class="comment">//从ilist末尾删除20个元素</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>resize 操作接受一个可选的元素值参数，用来初始化添加到容器中的元素。如果调用者未提供此参数，新元素进行值初始化。</p></li><li><p>如果容器保存的是<strong>类类型元素</strong>，且 resize 向容器添加新元素，则我们<strong>必须提供初始值，或者元素类型必须提供一个默认构造函数</strong>。</p></li></ul><h3 id="9-3-5-容器操作可能使迭代器失效"><a href="#9-3-5-容器操作可能使迭代器失效" class="headerlink" title="9.3.5 容器操作可能使迭代器失效"></a>9.3.5 容器操作可能使迭代器失效</h3><h4 id="一、添加元素"><a href="#一、添加元素" class="headerlink" title="一、添加元素"></a>一、添加元素</h4><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401271611838.png" alt="image-20240127161124456" style="zoom:67%;" /></p><h4 id="二、删除元素"><a href="#二、删除元素" class="headerlink" title="二、删除元素"></a>二、删除元素</h4><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401271615161.png" alt="image-20240127161526765" style="zoom:67%;" /></p><h4 id="三、因此，我们需要管理迭代器"><a href="#三、因此，我们需要管理迭代器" class="headerlink" title="三、因此，我们需要管理迭代器"></a>三、因此，我们需要管理迭代器</h4><blockquote><p>当你使用迭代器（或指向容器元素的引用或指针）时，最小化要求迭代器必须保持有效的程序片段是一个好的方法。</p><p>由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确地重新定位迭代器。这个建议对 vector、string和 deque尤为重要。</p></blockquote><p>有两个要求：</p><ul><li><p>添加/删除vector、string 或deque 元素的循环程序必须考虑迭代器、引用和指针可能失效的问题：</p><blockquote><p><strong>每次循环都更新迭代器、引用或指针</strong>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加/删除vector、string 或deque 元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。</span></span><br><span class="line"><span class="comment"> * 程序必须保证每个循环步中都更新迭代器、引用或指针。</span></span><br><span class="line"><span class="comment"> * 如果循环中调用的是insert()或erase()，那么更新迭代器很容易，因为这些操作都返回迭代器，我们可以用来更新:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(it!=vec.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="comment">//注意等号左侧，每步循环都更新了迭代器</span></span><br><span class="line">        <span class="keyword">if</span>(*it % <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//奇数</span></span><br><span class="line">            it = vec.<span class="built_in">insert</span>(it, *it);</span><br><span class="line">            it += <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 向前移动迭代器，跳过当前元素及插入到它之前的元素</span></span><br><span class="line">            <span class="comment">// insert()在it的前面插入新元素，并返回指向新插入元素的迭代器，所以+2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//偶数</span></span><br><span class="line">            it = vec.<span class="built_in">erase</span>(it);</span><br><span class="line">            <span class="comment">// 不必向前移动迭代器，erase()使it指向删除元素的下一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;num:vec)</span><br><span class="line">        cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>;  <span class="comment">// 1 1 3 3 5 5 7 7 9 9</span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>不要保存end返回的迭代器</strong></p><p>当添加/删除vector、string的元素，或在deque中首元素之外的任何位置添加/删除元素，原来的end返回的迭代器总是失效。</p><p>因此，如果在一个循环中插入/删除deque、string、vector中的元素，不要缓存end返回的迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 想要往每两个数中间插入42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> be = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//    auto en = vec.end(); /*insert后，end迭代器失效会引发死循环*/</span></span><br><span class="line"><span class="comment">//    while(be != en)&#123;  /*循环中，不要缓存尾后迭代器*/</span></span><br><span class="line">    <span class="keyword">while</span>(be != vec.<span class="built_in">end</span>())&#123; <span class="comment">/*应该在每次插入操作后重新调用end()*/</span></span><br><span class="line">        ++be;</span><br><span class="line">        be = vec.<span class="built_in">insert</span>(be,<span class="number">42</span>);</span><br><span class="line">        ++be;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;num:vec)</span><br><span class="line">        cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// 0 42 1 42 2 42 3 42 4 42 5 42 6 42 7 42 8 42 9 42</span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="9-4-vector对象是如何增长的？"><a href="#9-4-vector对象是如何增长的？" class="headerlink" title="9.4 vector对象是如何增长的？"></a>9.4 vector对象是如何增长的？</h2><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401280912213.png" alt="image-20240128091159836"></p><ul><li>resize和reserve<ul><li>resize改变容器中元素的数目，而不是容器的容量，如不能减少预留的内存空间。</li><li>reserve仅影响vector/string预先分配多大的内存，并不改变容器中元素的数目</li></ul></li><li>capacity和size<ul><li>size已经保存的元素数目</li><li>capacity表示在不分配新的内存的前提下，容器最多保存多少元素。</li></ul></li></ul><p>示例</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401280928465.png" alt="image-20240128092852165"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size = &quot;</span>&lt;&lt;ivec.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; | &quot;</span>&lt;&lt;<span class="string">&quot;capacity = &quot;</span>&lt;&lt;ivec.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// size = 0 | capacity = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; ++i)</span><br><span class="line">        ivec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size = &quot;</span>&lt;&lt;ivec.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; | &quot;</span>&lt;&lt;<span class="string">&quot;capacity = &quot;</span>&lt;&lt;ivec.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// size = 24 | capacity = 32</span></span><br><span class="line">    <span class="comment">// 存了24个元素，分配了可保存32个元素内存</span></span><br><span class="line"></span><br><span class="line">    ivec.<span class="built_in">reserve</span>(<span class="number">50</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size = &quot;</span>&lt;&lt;ivec.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; | &quot;</span>&lt;&lt;<span class="string">&quot;capacity = &quot;</span>&lt;&lt;ivec.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// size = 24 | capacity = 50、</span></span><br><span class="line">    <span class="comment">// reserve()将内存括展到了50，ivec内元素个数没变</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(ivec.<span class="built_in">size</span>()!=ivec.<span class="built_in">capacity</span>())</span><br><span class="line">        ivec.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="comment">//写满预分配的内存</span></span><br><span class="line">    ivec.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">// 在添加1位</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size = &quot;</span>&lt;&lt;ivec.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; | &quot;</span>&lt;&lt;<span class="string">&quot;capacity = &quot;</span>&lt;&lt;ivec.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// size = 51 | capacity = 100</span></span><br><span class="line">    <span class="comment">// 超出预分配的内存，ivec的内存两倍括展</span></span><br><span class="line"></span><br><span class="line">    ivec.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size = &quot;</span>&lt;&lt;ivec.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; | &quot;</span>&lt;&lt;<span class="string">&quot;capacity = &quot;</span>&lt;&lt;ivec.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// size = 51 | capacity = 51</span></span><br><span class="line">    <span class="comment">// 请求退还没有用过的内存（不一定采纳）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-5-forward-list专题"><a href="#9-5-forward-list专题" class="headerlink" title="9.5 forward_list专题"></a>9.5 forward_list专题</h2><p>原文《特殊的forward_list》操作</p><blockquote><p>当添加或删除一个元素时，删除或添加的元素之前的那个元素的后继会发生改变。为了添加或删除一个元素，我们需要访问其前驱，以便改变前驱的链接。但是，forward_list 是单向链表。在一个单向链表中，没有简单的方法来获取一个元素的前驱。</p><p>出于这个原因，在一个 forward list 中添加或删除元素的操作是通过改变给定元素之后的元素来完成的。这样，我们总是可以访问到被添加或删除操作所影响的元素。由于这些操作与其他容器上的操作的实现方式不同，forward_list 并未定义insert、emplace和erase，而是定义了名为insert_after、emplace_after和erase_after 的操作(参见表 9.8)。</p><p>例如，在我们的例子中，为了删除 elem3，应该用指向elem2的迭代器调用 <code>erase_after</code>。为了支持这些操作，forward_list还定义了<code>before_begin</code>，它返回一个<strong>首前迭代器</strong>。这个选代器允许我们在链表首元素之前并不存在的元素“之后”添加或删除元素(亦即在链表首元素之前添加删除元素)。</p></blockquote><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401272203790.png" alt="image-20240127220317328"></p><p>示例：</p><p><strong>当向forward_list中添加或删除元素时，我们必须关注两个选代器：一个指向我们要处理的元素，另一个指向其前驱。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 知识点：</span></span><br><span class="line"><span class="comment"> * 当向forward_list中添加或删除元素时，我们必须关注两个选代器：</span></span><br><span class="line"><span class="comment"> * 一个指向我们要处理的元素，另一个指向其前驱。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例：删除forward_list中的奇数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    forward_list&lt;<span class="type">int</span>&gt; flist = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> prev = flist.<span class="built_in">before_begin</span>();<span class="comment">//首前迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> curr = flist.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(curr != flist.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(*curr%<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//奇数</span></span><br><span class="line">            curr = flist.<span class="built_in">erase_after</span>(prev);<span class="comment">//返回删除的元素的下一个位置的迭代器，并用其更新curr</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            prev = curr;</span><br><span class="line">            ++curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;num:flist)</span><br><span class="line">        cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>;  <span class="comment">//0 2 4 6 8</span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-6-string专题"><a href="#9-6-string专题" class="headerlink" title="9.6 string专题"></a>9.6 string专题</h2><p>书P320《9.5 额外的string操作》</p><p>除了顺序容器的共同操作外，string还提供了一些额外的操作，如所述。</p><h3 id="9-6-1-string操作函数汇总"><a href="#9-6-1-string操作函数汇总" class="headerlink" title="9.6.1 string操作函数汇总"></a>9.6.1 string操作函数汇总</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281520448.png" alt="202401281520448" style="zoom:67%;" /></p><h3 id="9-6-2-构造string的子序列"><a href="#9-6-2-构造string的子序列" class="headerlink" title="9.6.2 构造string的子序列"></a>9.6.2 构造string的子序列</h3><p>除了在<a href="#3.2.1 初始化">笔记3.2.1</a>已经介绍过的构造函数方法，以及与其他顺序容器相同的构造函数外，string还支持另外3个构造函数。</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281553783.png" alt="image-20240128155347371"></p><p>当我们从一个const char*创建string时</p><ul><li>通常，指针指向的数组必须以空字符结尾，<strong>拷贝操作遇到空字符时停止</strong>。</li><li>如果我们还传递给构造函数一个计数值，数组就不必以空字符结尾。</li><li>如果我们未传递计数值且数组也未以空字符结尾，或者给定计数值大于数组大小，则构造函数的行为是未定义的。</li></ul><p>因此，const char *数组最好以空字符结尾。</p><p>当从string拷贝：</p><ul><li>开始位置要小于或等于size</li><li>计数值再大，最多拷贝到string结束的位置</li></ul><p>子字符串操作：</p><ul><li><code>str.substr(pos = 0, n = str.size() -pos);</code></li></ul><h3 id="9-6-2-改变string的其他方法"><a href="#9-6-2-改变string的其他方法" class="headerlink" title="9.6.2 改变string的其他方法"></a>9.6.2 改变string的其他方法</h3><p>联想：<a href="#3.4.4 与旧代码接口">3.4.4 与旧代码接口—c风格字符串</a></p><p>string类型支持顺序容器的赋值运算符以及assign、insert 和erase操作(表9.4；表9.7)外，还定义了额外的insert和erase版本。</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281619598.png" alt="202401281619598" style="zoom:67%;" /></p><ul><li><p>insert、erase、assign示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStr</span><span class="params">(string &amp;str)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;<span class="string">&quot; | size = &quot;</span>&lt;&lt;str.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;abcdefghij&quot;</span>;</span><br><span class="line">    <span class="built_in">printStr</span>(s);  <span class="comment">// abcdefghij | size = 10</span></span><br><span class="line"></span><br><span class="line">    string s1 = s;</span><br><span class="line">    s1.<span class="built_in">insert</span>(s1.<span class="built_in">size</span>(), <span class="number">5</span>, <span class="string">&#x27;!&#x27;</span>); <span class="comment">//末尾插入5个感叹号</span></span><br><span class="line">    <span class="built_in">printStr</span>(s1);  <span class="comment">// abcdefghij!!!!! | size = 15</span></span><br><span class="line"></span><br><span class="line">    string s2 = s;</span><br><span class="line">    s2.<span class="built_in">erase</span>(s.<span class="built_in">size</span>()<span class="number">-5</span><span class="comment">/*, 5*/</span>); <span class="comment">// 从s的倒数5个位置开始，删除最后5个字符</span></span><br><span class="line">    <span class="built_in">printStr</span>(s2); <span class="comment">// abcde | size = 5</span></span><br><span class="line"></span><br><span class="line">    string s3 = s;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *cp = <span class="string">&quot;stately, plump buck&quot;</span>;</span><br><span class="line">    s3.<span class="built_in">assign</span>(cp,<span class="number">2</span>); <span class="comment">// 用cp的前2个字符覆盖整个s</span></span><br><span class="line">    <span class="built_in">printStr</span>(s3); <span class="comment">// st | size = 2</span></span><br><span class="line"></span><br><span class="line">    string s4 = s;</span><br><span class="line">    s4.<span class="built_in">insert</span>(s.<span class="built_in">size</span>(), cp+<span class="number">7</span>);</span><br><span class="line">    <span class="comment">// 从cp向后移动7位所指向的元素开始，到cp结束之间的所有字符，插入到s的末尾(s.size())</span></span><br><span class="line">    <span class="built_in">printStr</span>(s4);  <span class="comment">// abcdefghij, plump buck | size = 22</span></span><br><span class="line"></span><br><span class="line">    string s5 = s;</span><br><span class="line">    string s5_ = <span class="string">&quot;,xyz&quot;</span>;</span><br><span class="line">    s5.<span class="built_in">insert</span>(<span class="number">0</span>,s5_); <span class="comment">//在s5的位置0处插入s5_</span></span><br><span class="line">    <span class="built_in">printStr</span>(s5);  <span class="comment">// ,xyzabcdefghij | size = 14</span></span><br><span class="line"></span><br><span class="line">    string s6 = s;</span><br><span class="line">    s6.<span class="built_in">insert</span>(<span class="number">0</span>,s5_,<span class="number">0</span>,s5_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 在s6[0]之前插入s5_中s5_[0]开始的s5_.size()个字符</span></span><br><span class="line">    <span class="built_in">printStr</span>(s6); <span class="comment">//,xyzabcdefghij | size = 14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>append、replace示例</p><ul><li><code>append(str)</code>：末尾追加str</li><li><code>replace(开始位置pos，删除几个元素n，在当前位置添加字符串str)</code> = erase+insert；<strong>删除的字符数n可以不等于添加的字符数量str</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStr</span><span class="params">(string &amp;str)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;<span class="string">&quot; | size = &quot;</span>&lt;&lt;str.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s&#123;<span class="string">&quot;c++ primer&quot;</span>&#125;;</span><br><span class="line">    s.<span class="built_in">append</span>(<span class="string">&quot; 4th Ed.&quot;</span>);</span><br><span class="line">    <span class="built_in">printStr</span>(s); <span class="comment">// c++ primer 4th Ed. | size = 18</span></span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">replace</span>(<span class="number">11</span>,<span class="number">3</span>,<span class="string">&quot;5th&quot;</span>);</span><br><span class="line">    <span class="built_in">printStr</span>(s);  <span class="comment">//c++ primer 5th Ed. | size = 18</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//replace时，删除的字符数和添加的字符数可以不相等</span></span><br><span class="line">    s.<span class="built_in">replace</span>(<span class="number">11</span>,<span class="number">3</span>,<span class="string">&quot;Fifth&quot;</span>);<span class="comment">// 删除3个字符，但增加5个字符</span></span><br><span class="line">    <span class="built_in">printStr</span>(s);  <span class="comment">// c++ primer Fifth Ed. | size = 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-6-3-string搜索操作"><a href="#9-6-3-string搜索操作" class="headerlink" title="9.6.3 string搜索操作"></a>9.6.3 string搜索操作</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401282149718.png" alt="202401282149718" style="zoom:67%;" /></p><ul><li><p>string类提供了6个搜索函数，每个函数都有4个重载版本。</p></li><li><p>搜索操作返回<code>string::size_type</code>值，表示匹配发生位置的下标。若搜索失败，返回<code>string::npos</code>的static成员。标准库将npos定义为const string::size_type类型，并初始化为-1。又由于npos是unsigned类型，此初始值意味着npos等于任何string最大的可能大小。</p></li><li><p>搜索操作大小写敏感</p></li><li><p>str.find_first_of(args)：返回str中第一个出现在args中的元素的下标</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str&#123;<span class="string">&quot;pi=3.14&quot;</span>&#125;;</span><br><span class="line">string nums&#123;<span class="string">&quot;+-.0123456789&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> pos = str.<span class="built_in">find_first_of</span>(nums);</span><br><span class="line"><span class="comment">//str中第一个出现在nums的元素的下标（即“pi=3.14”的‘3’的下标）</span></span><br><span class="line">cout&lt;&lt;pos&lt;&lt;endl;  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>find_last_of、find_first_not_of、find_last_not_of</p></li><li><p>逆向搜索：有从左向右搜索，也有从右向左搜索的函数</p></li><li><p>一个常见的设计模式：<br>通过指定   从哪里搜索的可选参数   在字符串中循环地搜索   子字符串出现的所有位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">string::size_type pos=<span class="number">0</span>;</span><br><span class="line">string name&#123;<span class="string">&quot;bananabananabanana&quot;</span>&#125;;</span><br><span class="line">string nums&#123;<span class="string">&quot;hb&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>((pos=name.<span class="built_in">find_first_of</span>(nums,pos))!=string::npos)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;found number at idx: &quot;</span>&lt;&lt;pos</span><br><span class="line">        &lt;&lt;<span class="string">&quot;element is &quot;</span>&lt;&lt; name[pos]&lt;&lt;endl;</span><br><span class="line">    ++pos;  <span class="comment">//&lt;-- 必须，否则死循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">found number at idx: 0element is b</span></span><br><span class="line"><span class="comment">found number at idx: 6element is b</span></span><br><span class="line"><span class="comment">found number at idx: 12element is b</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="9-6-4-compare"><a href="#9-6-4-compare" class="headerlink" title="9.6.4 compare"></a>9.6.4 compare</h3><p>见笔记9.6.1汇总 表9.15</p><h3 id="9-6-5-数值转换"><a href="#9-6-5-数值转换" class="headerlink" title="9.6.5 数值转换"></a>9.6.5 数值转换</h3><p>书P327~P328</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281801235.png" alt="202401281801235" style="zoom:67%;" /></p><ul><li><p>要转换为数值的string中，第一个空白字符必须是数值可能出现的字符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str&#123;<span class="string">&quot;pi = 3.14&quot;</span>&#125;;</span><br><span class="line"><span class="type">double</span> val = <span class="built_in">stod</span>(str.<span class="built_in">substr</span>(str.<span class="built_in">find_first_of</span>(<span class="string">&quot;+-.0123456789&quot;</span>)));</span><br><span class="line">cout&lt;&lt;val&lt;&lt;endl; <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure><ul><li>如果string不能转换为数值，表9.6中函数抛出<code>invalid_argument</code>异常</li><li>如果转换得到的数值无法用任何类型表示，抛出<code>out_of_range</code></li></ul></li><li><p>查找原则</p><blockquote><p>string 参数中<strong>第一个非空白符必须是符号(+ 或 -)或数字</strong>。它可以以0x 或0X开头来表示十六进制数。</p><p>对那些将字符串转换为浮点值的函数，string 参数也可以以小数点 (.)开头，并可以包含 e 或 E 来表示指数部分。</p><p>对于那些将字符串转换为整型值的函数，根据基数不同，string 参数可以包含字母字符，对应大于数字9的数。</p></blockquote></li></ul><h2 id="9-7-适配器"><a href="#9-7-适配器" class="headerlink" title="9.7  适配器"></a>9.7  适配器</h2><p>（adaptor）</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281035812.png" alt="image-20240128103539423"></p><h3 id="9-7-1-什么是适配器"><a href="#9-7-1-什么是适配器" class="headerlink" title="9.7.1 什么是适配器"></a>9.7.1 什么是适配器</h3><h3 id="9-7-2-定义一个适配器"><a href="#9-7-2-定义一个适配器" class="headerlink" title="9.7.2 定义一个适配器"></a>9.7.2 定义一个适配器</h3><h4 id="一、每个适配器都定义两个构造函数"><a href="#一、每个适配器都定义两个构造函数" class="headerlink" title="一、每个适配器都定义两个构造函数"></a>一、每个适配器都定义两个构造函数</h4><ul><li><p><code>A a;</code>默认构造函数创建一个空对象</p></li><li><p><code>A a(c)</code>接受一个容器c的构造函数 ，<strong>拷贝容器c的元素来初始化适配器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; deq;</span><br><span class="line">    <span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">stk</span><span class="params">(deq)</span></span>; <span class="comment">// 拷贝deq的元素到stk，以初始化stk</span></span><br><span class="line">    <span class="comment">// 其实隐藏了默认容器类型，等价于</span></span><br><span class="line">    stack&lt;<span class="type">int</span>,deque&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">stk</span>(deq);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="二、重载默认容器类型"><a href="#二、重载默认容器类型" class="headerlink" title="二、重载默认容器类型"></a>二、重载默认容器类型</h4><p>默认容器类型：</p><ul><li>stack和queue基于deque实现</li><li>priority_queue基于vector实现</li></ul><p>我们可以在创建一个适配器时，将一个命名的顺序容器作为第二个  类型  参数，来重载默认容器类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在vector的基础上实现空栈</span></span><br><span class="line">    stack&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; stk1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在vector的基础上实现，初始化时保存vec的拷贝</span></span><br><span class="line">    stack&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">stk2</span>(vec);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、重载默认容器类型的限制"><a href="#三、重载默认容器类型的限制" class="headerlink" title="三、重载默认容器类型的限制"></a>三、重载默认容器类型的限制</h4><p><code>stack</code>：可用于除了array和forward_list之外的任何容器类型（deque、list、vector）</p><p><code>queue</code>：只能用于list和deque之上，不能用于vector</p><p><code>priority_queue</code>只能用于vector和deque，不能用于list</p><h3 id="9-7-3-栈适配器"><a href="#9-7-3-栈适配器" class="headerlink" title="9.7.3 栈适配器"></a>9.7.3 栈适配器</h3><p>参考资料</p><ul><li><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/stack-class?view=msvc-170">stack类 —— Microsoft</a></li></ul><p>stack定义在stack头文件中</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281102757.png" alt="image-20240128110200371"></p><p>用法示例（书P330）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        stk.<span class="built_in">push</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(i));</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然每个适配器都是基于底层容器的操作定义自己的操作，但我们只可以使用适配器的操作，而不可使用底层容器的操作。如，虽然stack基于deque实现，stack.push()基于deque.push_back()，但我们不能在一个stack上调用push_back()</p><h3 id="9-7-4-队列适配器"><a href="#9-7-4-队列适配器" class="headerlink" title="9.7.4 队列适配器"></a>9.7.4 队列适配器</h3><p>参考资料</p><ul><li><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/queue-class?view=msvc-170">queue类 —— Microsoft</a></li><li><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/priority-queue-class?view=msvc-170">priority_queue类 —— Microsoft</a></li></ul><p>queue和priority_queue定义在queue头文件中</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401281122221.png" alt="202401281122221"></p><p>queue（FIFO）</p><p>priority_queue:</p><blockquote><p>priority_queue 允许我们为队列中的元素建立优先级。新加入的元素会排在所有优先级比它低的已有元素之前。</p><p>饭店按照客人预定时间而不是到来时间的早晚来为他们安排座位，就是一个优先队列的例子。</p><p>默认情况下，标准库在元素类型上使用<code>&lt;</code>运算符来确定相对优先级。</p></blockquote><hr><p>对于表9.19有个疑问：表中第二行说，queue也可以用list或vector实现，是不是有有误？<br>在《笔记9.6.2三、重载默认容器类型的限制（书P329最下面的一大段话）》中提到：<code>queue</code>：只能用于list和deque之上，不能用于vector。<br>两者是不是冲突了？</p><p>不知道两句换描述的事物是不是不一样，但照我理解，两句话在说一个东西。</p><p>实际测试：</p><p>1.正确执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; deq&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    queue&lt;<span class="type">int</span>,deque&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">que1</span>(deq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!que1.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;que1.<span class="built_in">front</span>()&lt;&lt;endl;</span><br><span class="line">        que1.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.正常编译：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">que1</span>(vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.编译器报错：</p><blockquote><p>In template: no member named ‘pop_front’ in ‘std::vector<int>‘</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">que1</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!que1.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;que1.<span class="built_in">front</span>()&lt;&lt;endl;</span><br><span class="line">        que1.<span class="built_in">pop</span>();   <span class="comment">// &lt;--在此处报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我认为，确实queue能用vector构造，但是当碰到处理（增删）首元素的情况，就会出错。所以不要用vector构造queue。</p><hr><h2 id="9-8-特例汇总"><a href="#9-8-特例汇总" class="headerlink" title="9.8 特例汇总"></a>9.8 特例汇总</h2><h3 id="9-8-1-forward-list-lt-gt"><a href="#9-8-1-forward-list-lt-gt" class="headerlink" title="9.8.1 forward_list&lt;&gt;"></a>9.8.1 forward_list&lt;&gt;</h3><ul><li>没有<code>size</code>操作</li><li>不支持反向迭代器</li><li>不支持<code>--</code></li><li>不支持适配器（因为所有适配器都要求容器有添加、删除和访问尾元素的能力）</li></ul><p>单向链表对尾元素的处理很耗时，所以一般不支持<code>xxx_back()</code>操作，而是<code>xxx_after()</code>：</p><ul><li>不支持<code>push_back</code>和<code>emplace_back</code>，有自己专有的<code>insert</code>和<code>emplace</code></li><li>不支持<code>back()</code>获取尾元素的引用。</li><li>不支持<code>pop_back()</code></li><li>forward_list 并未定义insert、emplace和erase，而是定义了名为<code>insert_after</code>、<code>emplace_after</code>和<code>erase_after</code>的操作（见forward_list专题）</li></ul><h3 id="9-8-2-string"><a href="#9-8-2-string" class="headerlink" title="9.8.2 string"></a>9.8.2 string</h3><ul><li>不支持<code>C c(n)</code>构造</li><li><code>swap</code>会导致<code>string</code>的迭代器、指针和引用失效。而其他容器不会。</li></ul><h3 id="9-8-3-array-lt-gt"><a href="#9-8-3-array-lt-gt" class="headerlink" title="9.8.3 array&lt;&gt;"></a>9.8.3 array&lt;&gt;</h3><p>一、构造</p><ul><li><code>C c</code>默认构造的时候，c中的元素也会通过默认构造初始化。如果c是其他容器时，则为空。</li><li>不支持通过<code>C c(n,t)</code>、<code>C c(n)</code>构造容器。（n个值为t的元素）</li></ul><p>二、拷贝和赋值</p><ul><li>不支持<code>c = &#123;a,b,c,...&#125;</code></li><li>不支持<code>C c(b,e)</code>：b和e为迭代器的范围拷贝构造（见笔记9.2.2 一、拷贝初始化）</li><li><code>C c1=c2</code>两者必须是相同大小</li></ul><p>三、其他</p><ul><li><p>不支持添加/插入/删除元素的函数</p><ul><li>不支持笔记9.3.1中表9.5（如<code>push_back</code>）</li><li>不支持笔记9.3.3的所有操作</li></ul></li><li><p><code>swap</code>会真正交换<code>array</code>的元素值，而其他容器不会。</p></li><li><p>不支持<code>resize()</code></p></li><li><p>不支持适配器（因为所有适配器都要求容器有添加和删除元素的能力）</p></li></ul><h1 id="十-泛型算法"><a href="#十-泛型算法" class="headerlink" title="十 泛型算法"></a>十 泛型算法</h1><h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><blockquote><p>关键概念：算法永远不会执行容器的操作（算法只所用于迭代器）</p><ul><li><p>泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。<strong>泛型算法运行于迭代器之上而不会执行容器操作</strong>的特性带来了一个令人惊讶但非常必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。</p></li><li><p>如我们将在书本10.4.1节(第358页)所看到的，标准库定义了一类特殊的<strong>迭代器，称为插入器(inserter)</strong>。与普通迭代器只能遍历所绑定的容器相比，插入器能做更多的事情。当给这类迭代器赋值时，它们会在底层的容器上执行插入操作。因此，当一个算法操作一个这样的迭代器时，迭代器可以完成向容器添加元素的效果，但算法自身永远不会做这样的操作。</p></li></ul></blockquote><ul><li><p>大多数算法定义在<code>algorithm</code>中，<code>numeric</code>也定义了一组数值泛型算法。</p></li><li><p>一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。</p></li><li><p>迭代器令算法不依赖于容器，但是算法依赖于容器的元素类型。（因为算法要对元素进行比较等操作）</p></li></ul><h2 id="10-2-初识泛型算法"><a href="#10-2-初识泛型算法" class="headerlink" title="10.2 初识泛型算法"></a>10.2 初识泛型算法</h2><h3 id="10-2-1-只读算法"><a href="#10-2-1-只读算法" class="headerlink" title="10.2.1 只读算法"></a>10.2.1 只读算法</h3><ul><li><p><code>find</code>_<code>&lt;algorithm&gt;</code><br><code>fund(开始迭代器（指针）,结束迭代器（指针）,val)</code></p><ul><li>作用：在指定范围内<code>[开始迭代器，结束迭代器)</code>查找val值，找到了就返回   第一个   等于val的  元素的  迭代器，否则返回结束迭代器。</li></ul></li><li><p><code>count</code>_<code>&lt;algorithm&gt;</code></p><ul><li>作用：返回给定值在次序中出现的次数</li></ul></li><li><p><code>accumulate</code>_<code>&lt;numeric&gt;</code><br><code>sum = accumulate(vec.cbegin(),vec.cend(),0)</code></p><ul><li><p>作用：将范围内所有元素加到第三个参数上，返回最终的加法之和。</p></li><li><p>要求第三个参数重载过<code>+</code>。</p></li><li><p>第三个参数决定了函数中使用哪个类型重载的加法运算符，以及返回值类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string sum = <span class="built_in">accumulate</span>(str.<span class="built_in">cbegin</span>(),str.<span class="built_in">cend</span>(),<span class="built_in">string</span>(<span class="string">&quot;&quot;</span>)); <span class="comment">//正确</span></span><br><span class="line">string sum = <span class="built_in">accumulate</span>(str.<span class="built_in">cbegin</span>(),str.<span class="built_in">cend</span>(),<span class="string">&quot;&quot;</span>); <span class="comment">//错误，const char*没有重载过‘+’运算符</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>equal</code>_<code>&lt;algorithm&gt;</code><br><code>equal(roster1.cbegin(),roster1.cend(),roster2.cbegin());</code></p><ul><li>作用：用于确定两个序列是否保存相同的值。第三个参数是第二个序列的首元素的迭代器</li><li>基于假设：它假定第二序列至少与第一序列一样长<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401291125010.png" alt="image-20240129112533625"><br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401291152804.png" alt="image-20240129115208359"></li><li>由于equal利用迭代器完成操作，因此，我们可以通过调用<strong>equal来比较两个不同类型的容器中的元素，而且，元素类型也不必一样，只要我们能用<code>==</code>来比较两个元素类型即可</strong>。</li></ul></li></ul><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401291126731.png" alt="image-20240129112605375"></p><h3 id="10-2-2-写容器元素算法"><a href="#10-2-2-写容器元素算法" class="headerlink" title="10.2.2 写容器元素算法"></a>10.2.2 写容器元素算法</h3><ul><li><p><code>fill</code><br><code>fill(vec.begin(),vec.end(),val);</code></p><ul><li>作用：将范围内的每个元素重置为第三个参数</li></ul></li><li><p><code>fill_n</code><br><code>fill_n(起始位置迭代器,n,val)</code></p><ul><li><p>作用：从其实位置的迭代器开始，将n和元素替换为val</p></li><li><p>注意：<strong>不应在一个空容器上调用<code>fill_n</code>，或类似写元素的算法</strong>。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//灾难错误示例</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec; <span class="comment">//空vector</span></span><br><span class="line"><span class="comment">//修改了10个不存在的向量，引发未定义的结果</span></span><br><span class="line"><span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span>(), <span class="number">10</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>back_inserter</code>_<code>&lt;iterator&gt;</code>：“插入” 迭代器</p><ul><li><p>作用：接受一个指向容器的引用，返回一个与该容器绑定插入迭代器。</p></li><li><p>我们用此迭代器赋值时，<strong>赋值运算符会调用push_back</strong>。</p></li><li><p>常常使用back_inserter创建一个插入迭代器，作为<strong>算法的目的位置使用</strong></p></li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 有bug</span></span><br><span class="line"><span class="comment"> * 重载&lt;&lt;，流式输出容器中的元素</span></span><br><span class="line"><span class="comment"> * @tparam T</span></span><br><span class="line"><span class="comment"> * @param os </span></span><br><span class="line"><span class="comment"> * @param ctor </span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os,T &amp;ctor)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;ele:ctor)&#123;</span><br><span class="line">        os&lt;&lt;ele;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*例1*/</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec; <span class="comment">//空容器</span></span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">back_inserter</span>(vec); <span class="comment">// 插入迭代器</span></span><br><span class="line">    *iter = <span class="number">24</span>; <span class="comment">//赋值运算符调用push_back</span></span><br><span class="line">    cout&lt;&lt;vec&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*例2*/</span></span><br><span class="line">    vec.<span class="built_in">clear</span>(); <span class="comment">//清空容器</span></span><br><span class="line">    <span class="comment">//常常使用back_inserter创建一个插入迭代器，作为算法的目的位置使用</span></span><br><span class="line">    <span class="built_in">fill_n</span>(<span class="built_in">back_inserter</span>(vec),<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;vec&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>copy</code><br><code>copy(源起始迭代器，源终止迭代器，目的序列的起始位置)</code></p><ul><li><p>传递给copy的目的序列至少要包含与输入序列一样多的元素</p></li><li><p>返回目的位置迭代器增值后的值。下例中为a2尾后位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 有bug</span></span><br><span class="line"><span class="comment"> * 流式输出容器</span></span><br><span class="line"><span class="comment"> * @tparam T</span></span><br><span class="line"><span class="comment"> * @param os</span></span><br><span class="line"><span class="comment"> * @param ctor</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os,T &amp;ctor)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;ele:ctor)&#123;</span><br><span class="line">        os&lt;&lt;ele;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> a2[<span class="built_in">sizeof</span>(a1)/<span class="built_in">sizeof</span>(*a1)];</span><br><span class="line">    <span class="keyword">auto</span> re = <span class="built_in">copy</span>(<span class="built_in">begin</span>(a1), <span class="built_in">end</span>(a1),a2); <span class="comment">// re指向尾后</span></span><br><span class="line">    cout&lt;&lt;a2&lt;&lt;endl;  <span class="comment">// 123456789</span></span><br><span class="line">    cout&lt;&lt;*(re<span class="number">-1</span>)&lt;&lt;endl; <span class="comment">// 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>replace_copy</code><br><code>replace_copy(ilst.cbegin(), ilst.end(), back_inserter(ivec), 0, 42);</code><br>将ilst（值不会改变）中的所有元素拷贝到ivec（可以是空列表）之后，并将ivec中的0替换为24</p><ul><li>对比replace是将原来的序列范围内的值替换</li></ul></li></ul><h3 id="10-2-3-重排容器元素算法"><a href="#10-2-3-重排容器元素算法" class="headerlink" title="10.2.3 重排容器元素算法"></a>10.2.3 重排容器元素算法</h3><ul><li><code>sort</code>：sort(序列开始位置迭代器，结束位置迭代器)</li><li><code>unique</code>：返回不重复区域之后一个位置的迭代器 = unique(序列开始位置迭代器，结束位置迭代器)</li></ul><p>书中的例子：排序一个由单词组成的vector，并删除重复的单词</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202401291602660.png" alt="202401291602660"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printCtor</span><span class="params">(T &amp;ctor)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;ele:ctor)&#123;</span><br><span class="line">        cout&lt;&lt;ele&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;string&gt; vec&#123;<span class="string">&quot;the&quot;</span>,<span class="string">&quot;quick&quot;</span>,<span class="string">&quot;red&quot;</span>,<span class="string">&quot;fox&quot;</span>,<span class="string">&quot;jumps&quot;</span>,<span class="string">&quot;over&quot;</span>,<span class="string">&quot;the&quot;</span>,<span class="string">&quot;slow&quot;</span>,<span class="string">&quot;red&quot;</span>,<span class="string">&quot;turtle&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">printCtor</span>(vec);cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 输出：the quick red fox jumps over the slow red turtle</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*sort*/</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printCtor</span>(vec);cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 输出：fox jumps over quick red red slow the the turtle</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*unique 将重复项移动到末尾*/</span></span><br><span class="line">    <span class="comment">// iter指向不重复区域的下一个位置</span></span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">unique</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    vec.<span class="built_in">erase</span>(iter,vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printCtor</span>(vec);cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 输出：fox jumps over quick red slow the turtle</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-3-定制操作"><a href="#10-3-定制操作" class="headerlink" title="10.3 定制操作"></a>10.3 定制操作</h2><h3 id="10-3-1-谓词"><a href="#10-3-1-谓词" class="headerlink" title="10.3.1 谓词"></a>10.3.1 谓词</h3><h4 id="一、通过“谓词”改变算法的默认行为"><a href="#一、通过“谓词”改变算法的默认行为" class="headerlink" title="一、通过“谓词”改变算法的默认行为"></a>一、通过“谓词”改变算法的默认行为</h4><p>“谓词”是一种可调用的表达式，其返回结果是一个能用作条件的值。</p><ul><li>一元谓词，只接受一个单一参数的谓词</li><li>二元谓词，接受两个参数的谓词</li></ul><p>接受谓词参数的算法对输入序列中的元素调用谓词，元素类型必须能转化为谓词的参数类型。</p><p>根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或两个参数。</p><h4 id="二、举例"><a href="#二、举例" class="headerlink" title="二、举例"></a>二、举例</h4><p>接受一个二元谓词参数的<code>sort()</code>，用谓词替换<code>&lt;</code>来比较元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isShorter</span><span class="params">(<span class="type">const</span> string s1, <span class="type">const</span> string s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), isShorter);</span><br><span class="line"></span><br><span class="line"><span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), isShorter);<span class="comment">//可保持等长元素间的字典顺序</span></span><br></pre></td></tr></table></figure><h4 id="三、补充"><a href="#三、补充" class="headerlink" title="三、补充"></a>三、补充</h4><p><code>find_if()</code>算法接受一对迭代器，表示一个范围。与<code>find()</code>不同的是，<code>find_if()</code>的第三个参数是一个谓词，find_if算法对输入序列中的每个元素调用给定的这个谓词，返回第一个使谓词返回非0值的元素，如果不存在这样的元素，则返回尾迭代器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> sz = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>(), [sz](<span class="type">const</span> string &amp;s)&#123;<span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz ;&#125;);</span><br></pre></td></tr></table></figure><p><code>for_each()</code>接受一个可调用的对象，并对输入序列中的每个元素调用此对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>(), [](<span class="type">const</span> string &amp;s)&#123;cout&lt;&lt;s&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;);</span><br></pre></td></tr></table></figure><h3 id="10-3-2-lambda"><a href="#10-3-2-lambda" class="headerlink" title="10.3.2 lambda"></a>10.3.2 lambda</h3><p>（很重要，放在二级标题）</p><h4 id="一、书写格式"><a href="#一、书写格式" class="headerlink" title="一、书写格式"></a>一、书写格式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list) -&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure><p>我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = []&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;; <span class="comment">// 相当于空参数列表；自动推导返回类型。</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">f</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h4 id="二、参数"><a href="#二、参数" class="headerlink" title="二、参数"></a>二、参数</h4><p>lambda不能有默认参数  —-&gt; 一个lambda调用的实参数目永远与形参数目相等。</p><h4 id="三、捕获列表"><a href="#三、捕获列表" class="headerlink" title="三、捕获列表"></a>三、捕获列表</h4><h5 id="一、谁需要被捕获？"><a href="#一、谁需要被捕获？" class="headerlink" title="一、谁需要被捕获？"></a>一、谁需要被捕获？</h5><p><strong>捕获列表只适用于局部非static变量，可以直接使用局部static变量和在它所在函数之外声明的名字。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>; <span class="comment">// 只有局部非static变量需要捕获</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [b]() &#123;cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c; &#125;;</span><br><span class="line">    <span class="comment">// f的类型  main::__l2::&lt;lambda_1&gt;</span></span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 1 2 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二、几种捕获方式"><a href="#二、几种捕获方式" class="headerlink" title="二、几种捕获方式"></a>二、几种捕获方式</h5><p>1.值捕获</p><ul><li><p>采用值捕获的前提是变量可以拷贝</p></li><li><p>被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝。（与函数参数不同）</p></li><li><p>又由于 “ 被捕获的变量的值是在lambda创建时拷贝”，因此，随后对其修改不会影响到lambda内对应的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [v1]&#123;<span class="keyword">return</span> v1;&#125;;<span class="comment">// &lt;--值捕获</span></span><br><span class="line">    v1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = <span class="built_in">f</span>();<span class="comment">// j = 42;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>2.引用捕获</p><p>下例为引用捕获示例与上述值捕获示例的对比</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;v1]&#123;<span class="keyword">return</span> v1;&#125;; <span class="comment">// &lt;--引用捕获</span></span><br><span class="line">    v1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = <span class="built_in">f</span>();<span class="comment">// j = 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lambda捕获的都是函数的局部变量，函数结束后，捕获的引用指向的局部变量已经消失。</p><ul><li><p>必须确保被引用的对象在lambda执行的时候是存在的。</p></li><li><p>函数不能返回一个包含引用捕获的lambda（因为局部变量已消失，和函数不能返回局部变量的引用/指针是一个道理）</p></li></ul><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402021136952.png" alt="image-20240202113652567"></p><p>3.隐式捕获</p><ul><li>当我们混合使用隐式捕获和显式捕获时，<ul><li>必须以隐式捕获开头（原文：捕获列表的第一个元素必须是一个<code>&amp;</code>或<code>=</code>，以指定默认捕获方式）。</li><li>显式捕获的变量必须使用与隐式捕获不同的方式。</li></ul></li></ul><h5 id="三、捕获列表的书写方式汇总"><a href="#三、捕获列表的书写方式汇总" class="headerlink" title="三、捕获列表的书写方式汇总"></a>三、捕获列表的书写方式汇总</h5><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402021052259.png" alt="image-20240202105221721"></p><h5 id="四、可变lambda（mutable）"><a href="#四、可变lambda（mutable）" class="headerlink" title="四、可变lambda（mutable）"></a>四、可变lambda（mutable）</h5><ul><li>默认情况下，对于一个值被拷贝的变量，lambda 不会改变其值。但是，如果我们希望能改变个被捕获的变量的值，就必须在参数列表首加上关键字 mutable。</li><li><p>一个引用捕获的变量是否可以修改，依赖于此引用指向的是一个const还是一个非const</p></li><li><p>对于局部static变量和在它所在函数之外声明，不用mutable也可以在lambda中修改</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*如果我们希望能改变个被捕获的变量的值，就必须在参数列表首加上关键字 mutable。*/</span></span><br><span class="line"><span class="type">int</span> v1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [v1]() <span class="keyword">mutable</span> &#123;<span class="keyword">return</span> ++v1; &#125;;</span><br><span class="line"><span class="comment">// auto f = [v1]()  &#123; return ++v1; &#125;; //v1报错：表达式必须是可修改的左值（v1只读）</span></span><br><span class="line">cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl; <span class="comment">// 42 43</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*一个引用捕获的变量是否可以修改，依赖于此引用指向的是一个const还是一个非const*/</span></span><br><span class="line"><span class="keyword">auto</span> f1 = [&amp;v1]() &#123;<span class="keyword">return</span> ++v1; &#125;;</span><br><span class="line">cout &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">f1</span>() &lt;&lt; endl; <span class="comment">//43 43</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> v2 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//auto f2 = [&amp;v2] &#123;return ++v2; &#125;; //v2报错：表达式必须是可修改的左值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对于局部static变量和在它所在函数之外声明，不用mutable也可以在lambda中修改*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> v3 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> f3 = [] &#123;<span class="keyword">return</span> ++v3; &#125;;</span><br><span class="line">cout &lt;&lt; v3 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">f3</span>(); <span class="comment">// 2 2</span></span><br></pre></td></tr></table></figure><h4 id="四、指定lambda的返回类型"><a href="#四、指定lambda的返回类型" class="headerlink" title="四、指定lambda的返回类型"></a>四、指定lambda的返回类型</h4><ul><li><p>默认情况下，如果一个lambda体   除了单一return外   还包含了其他语句，则编译器假定lambda返回void。如果与本意不符，需要显式指明返回类型。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lambda体内只有一条return语句，编译器自动推导返回类型</span></span><br><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi,<span class="built_in">begin</span>(), </span><br><span class="line">         [](<span class="type">int</span> i)&#123; <span class="keyword">return</span> i &lt; <span class="number">0</span> ? -i : i; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译错误：</span></span><br><span class="line"><span class="comment">//除了单一return外   还包含了其他语句，编译器推断为void，实际却返回int</span></span><br><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi,<span class="built_in">begin</span>(),[](<span class="type">int</span> i)&#123; </span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -i;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> i; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确写法：显式指定返回类型</span></span><br><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi,<span class="built_in">begin</span>(),[](<span class="type">int</span> i)-&gt;<span class="type">int</span>&#123;  <span class="comment">// 尾置返回类型</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -i;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> i; &#125;);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>补充：<code>transform()</code><br>使用标准库 transform 算法和一个 lambda来将一个序列中的每个负数替换为其绝对值:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>()， vi.<span class="built_in">end</span>()， vi.<span class="built_in">begin</span>()，</span><br><span class="line">          [](<span class="type">int</span> i) &#123; <span class="keyword">return</span> i &lt; <span class="number">0</span> ?-i :i; &#125;);</span><br></pre></td></tr></table></figure><p>函数transform接受三个迭代器和一个可调用对象。前两个迭代器表示输入序列，第三个迭代器表示目的位置。算法对输入序列中每个元素调用可调用对象，并将结果写到目的位置。</p></li></ul><h4 id="五、参数绑定"><a href="#五、参数绑定" class="headerlink" title="五、参数绑定"></a>五、参数绑定</h4><p><strong>一、引入</strong></p><p>之前我们写过的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> sz = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>(), [sz](<span class="type">const</span> string &amp;s)&#123;<span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz ;&#125;);</span><br></pre></td></tr></table></figure><p>如果好多地方使用同样的操作，或者操作需要很多语句才能完成，使用lambda不方便，需要使用函数。但是如何用接受两个参数的函数替换一元谓词？如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_sz</span><span class="params">(<span class="type">const</span> string &amp;s, string::size_type sz)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt; sz ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>(), <span class="comment">/*check_sz*/</span>); <span class="comment">// 如何用接受两个参数的函数替换一元谓词?</span></span><br></pre></td></tr></table></figure><p><strong>二、bind</strong></p><p>使用在库<code>functional</code>中的<code>bind()</code>。可以将其看做函数适配器（类比容器适配器），接受一个可调用对象，生成一个新的可调用对象来“适应”原本对象的参数列表。一般形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = <span class="built_in">bind</span>(callable, arg_list);</span><br></pre></td></tr></table></figure><p><strong>当<em>调用newCallable</em>时，newCallable会调用<em>函数callable</em>，并向callable传递arg_list中的参数。</strong></p><p>其中，arg_list中可能会有<code>std::placeholders::_n</code>，为占位符。表示调用newCallable时，传入的参数应该填入callable形参列表的第n位。</p><p>举例，对于一中的例子，利用bind改写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_sz</span><span class="params">(<span class="type">const</span> string &amp;s, string::size_type sz)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt; sz ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> check6 = <span class="built_in">bind</span>(check_sz, std::placeholders::_1, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>(), check6); </span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namesapce std::placeholders;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_sz</span><span class="params">(<span class="type">const</span> string &amp;s, string::size_type sz)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt; sz ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> check6 = <span class="built_in">bind</span>(check_sz, _1, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">check6</span>(s); <span class="comment">// 相当于  check_sz(s,6);</span></span><br></pre></td></tr></table></figure><p>三、bind的参数</p><p>bind对参数的作用：</p><ul><li><p>绑定给定可调用对象中的参数（上文所述）</p></li><li><p>重新安排参数的顺序。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> g = <span class="built_in">bind</span>(func, a, b, _2, c, _1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">g</span>(X,Y);<span class="comment">//func(a,b,Y,c,X);</span></span><br></pre></td></tr></table></figure></li></ul><p>四、绑定引用参数</p><p>我们希望传递一个引用给bind，而不是拷贝，用<code>ref()</code>或<code>cref()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">bind</span>(print, <span class="built_in">ref</span>(os), _1, <span class="string">&#x27; &#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="10-4-再探迭代器"><a href="#10-4-再探迭代器" class="headerlink" title="10.4 再探迭代器"></a>10.4 再探迭代器</h2><p><a href="#9.2.1-迭代器">笔记9.2.1迭代器基础</a></p><p>补充额外的迭代器：</p><ul><li>插入迭代器（insert iterator）：迭代器被绑定到一个容器上，可以用来向容器插入元素</li><li>流迭代器（stream iterator）：迭代器被绑定到输入/输出流上，用来遍历所关联的io</li><li>反向迭代器（reverse iterator）：迭代器向反方向移动（++/—方向相反）。除了forward_list外标准库容器都有反向迭代器</li><li>移动迭代器（move iterator）：这些迭代器不是拷贝其中的元素，而是移动它们。</li></ul><h3 id="10-4-1-插入迭代器"><a href="#10-4-1-插入迭代器" class="headerlink" title="10.4.1 插入迭代器"></a>10.4.1 插入迭代器</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402031036331.png" alt="image-20240203103605570" style="zoom:67%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">inserter</span>(nums,++nums.<span class="built_in">begin</span>()); <span class="comment">// inserter(容器，迭代器)；插入迭代器之前的位置</span></span><br><span class="line">it = <span class="number">12</span>;  <span class="comment">//等价*it或++it或it++ = 12，因为这三个存在但什么都不做，只返回it</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//0 12 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">int</span> ins_num = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">auto</span> iter = nums.<span class="built_in">insert</span>(++nums.<span class="built_in">begin</span>(), ins_num);</span><br><span class="line">++iter; <span class="comment">// &lt;--特别注意这里，iter又指回了原来的地方</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//0 12 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个值得注意的地方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lst&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lst2, lst3;</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">begin</span>(), lst.<span class="built_in">end</span>(), <span class="built_in">front_inserter</span>(lst2));<span class="comment">//lst2=4 3 2 1</span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">begin</span>(), lst.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(lst3,lst3.<span class="built_in">begin</span>()));<span class="comment">//lst2=1 2 3 4</span></span><br></pre></td></tr></table></figure><p>原理如图所示：</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402031140878.png" alt="image-20240203114013429"></p><h3 id="10-4-2-流迭代器"><a href="#10-4-2-流迭代器" class="headerlink" title="10.4.2 流迭代器"></a>10.4.2 流迭代器</h3><p>原文：iostream迭代器</p><blockquote><p>虽然iostream类型不是容器，但标准库定义了可以用于这些IO类型对象的选代器(参见8.1 节，第278页)。</p><p>istream_iterator (参见表10.3)读取输入流，ostream_iterator(参见表10.4节，第361页)向一个输出流写数据。</p><p>这些选代器将它们对应的流当作一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。</p></blockquote><h4 id="一、istream-iterator"><a href="#一、istream-iterator" class="headerlink" title="一、istream_iterator"></a>一、istream_iterator</h4><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402031523800.png" alt="image-20240203152334297" style="zoom:67%;" /></p><p>用法示例：用一个istream_iterator从标准输入读取数据，存入一个vector的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 写法1 */</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span> <span class="comment">/* 从cin读取int类型的数据 */</span>, eof<span class="comment">/*istream尾后迭代器*/</span></span>;</span><br><span class="line"><span class="keyword">while</span> (in_iter != eof)</span><br><span class="line">&#123;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(*in_iter++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写法2，等价于写法1*/</span></span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span>, eof</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(in_iter, eof)</span></span>; <span class="comment">// 从迭代器范围构造vec（用一对表示元素范围的迭代器构造vec）</span></span><br></pre></td></tr></table></figure><p>要求：</p><ul><li>必须指定迭代器将要读写的对象类型</li><li>该对象类型定义了<code>&gt;&gt;</code>来读取流</li><li>默认初始化迭代器，即创建了istream流的尾后迭代器</li></ul><p>特点：允许使用懒惰求值。  &lt;— 没怎么看懂</p><blockquote><p>当我们将一个istream_iterator 绑定到一个流时，标准库<strong>并不保证迭代器立即从流读取数据</strong>。具体实现可以推迟从流中读取数据，<strong>直到我们使用迭代器时才真正读取</strong>。</p><p>标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取没什么差别。但是，如果我们创建了一个istream_iterator，没有使用就销毁了，或者我们正在从两个不同的对象同步读取同一个流，那么何时读取可能就很重要了。</p></blockquote><p>应用：用一对istream_iterator来调用accumulate</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in</span><span class="params">(cin)</span>, eof</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">accumulate</span>(in, eof, <span class="number">0</span>)&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h4 id="二、ostream-iterator"><a href="#二、ostream-iterator" class="headerlink" title="二、ostream_iterator"></a>二、ostream_iterator</h4><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402031523918.png" alt="image-20240203152310391" style="zoom:67%;" /></p><p>用法示例：用ostream_iterator来输出  值的序列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 写法1 */</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_iter</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; n : vec)</span><br><span class="line">    *out_iter++ = n; <span class="comment">// 0 1 2 3 4 5 6</span></span><br><span class="line">    <span class="comment">// 等价</span></span><br><span class="line">    <span class="comment">// out_iter = n; // 不推荐，因为上面的写法更易阅读</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写法2 */</span></span><br><span class="line"><span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), out_iter);</span><br></pre></td></tr></table></figure><p>要求：</p><ul><li>要输出的类型   定义了<code>&lt;&lt;</code></li><li>第二个可选参数表示：在输出的每个元素后都会打印该字符（必须是c风格字符串——字符串字面常量或以空字符结尾的字符数组的指针）</li><li>ostream_iterator必须绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator</li></ul><p>应用：（书P362）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="10-4-3-反向迭代器"><a href="#10-4-3-反向迭代器" class="headerlink" title="10.4.3 反向迭代器"></a>10.4.3 反向迭代器</h3><p><a href="#9.2.1-迭代器">返回笔记9.2.1</a></p><ul><li><code>rbegin(),rend(), crbegin(),crend()</code></li><li>forward_list和流迭代器不能创建反向迭代器</li><li>reverse_iterator的<code>base()</code>将反向迭代器转换为普通迭代器（在容器中正向移动）</li></ul><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402032113033.png" alt="image-20240203211300327" style="zoom:67%;" /></p><p>应用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*例1*/</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()); <span class="comment">// 顺序</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">rbegin</span>(), vec.<span class="built_in">rend</span>()); <span class="comment">// 逆序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例2*/</span></span><br><span class="line"><span class="comment">//first,middle,last</span></span><br><span class="line"><span class="keyword">auto</span> comma = <span class="built_in">find</span>(line.<span class="built_in">cbegin</span>(), line.<span class="built_in">cend</span>(), <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">cout&lt;&lt;<span class="built_in">string</span>(line.<span class="built_in">cbegin</span>(), comma);<span class="comment">//first</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> rcomma = <span class="built_in">find</span>(line.<span class="built_in">crbegin</span>(), line.<span class="built_in">crend</span>(), <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">cout&lt;&lt;<span class="built_in">string</span>(line.<span class="built_in">crbegin</span>(), rcomma);<span class="comment">//tsal</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">string</span>(rcomma.<span class="built_in">base</span>(),line.<span class="built_in">cend</span>());<span class="comment">//last</span></span><br></pre></td></tr></table></figure><h2 id="10-5-泛型算法结构"><a href="#10-5-泛型算法结构" class="headerlink" title="10.5 泛型算法结构"></a>10.5 泛型算法结构</h2><h3 id="10-5-1-五类迭代器"><a href="#10-5-1-五类迭代器" class="headerlink" title="10.5.1 五类迭代器"></a>10.5.1 五类迭代器</h3><p>任何算法最基本的特性是  它要求其迭代器提供哪些操作。</p><p>类似容器，迭代器也定义了一组公共操作。<strong>迭代器按其提供的操作分类，这些分类形成了一种层次，除了输出迭代器外，一个高层类别的迭代器支持低层类别迭代器的所有操作。</strong></p><p><strong>C++标准指明了泛型和数值算法的每个迭代器参数的最小类别（至少应该达到的类别）</strong>。例如，find 算法在个序列上进行一遍扫描，对元素进行只读操作，因此至少需要输入迭代器。对每个迭代器参数来说，<strong>其能力必须与规定的最小类别至少相当。向算法传递一个能力更差的迭代器会产生错误。</strong></p><p>迭代器提供的操作可以划分为5类。每个算法都会对   它的每个迭代器参数  指明  需要提供哪类迭代器。</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402032150537.png" alt="image-20240203215001891" style="zoom:67%;" /></p><p>迭代器类别简述：</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402042051427.png" alt="202402042051427"></p><h3 id="10-5-2-算法形参模式"><a href="#10-5-2-算法形参模式" class="headerlink" title="10.5.2 算法形参模式"></a>10.5.2 算法形参模式</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402042108959.png" alt="image-20240204210849325"></p><ul><li>dest<ul><li>表示算法可以写入的目的位置迭代器</li><li>使用dest时，算法假定：按其需要写入的数据，不管写入多少元素都是安全的</li><li>如果dest是一个直接指向容器的迭代器，算法将输出数据写到容器中<strong>已存在的元素内</strong></li></ul></li><li>beg2<ul><li><strong>接受单独beg2的算法   假定从beg2开始的序列   至少   与beg和end所表示的范围   一样大</strong></li></ul></li></ul><h3 id="10-5-3-算法命名规范"><a href="#10-5-3-算法命名规范" class="headerlink" title="10.5.3 算法命名规范"></a>10.5.3 算法命名规范</h3><ul><li><p>一些算法使用重载形式传递一个谓词</p></li><li><p>_if版本的算法</p><ul><li><p>接受一个元素值的算法通常有一个不同名的版本，接受一个谓词以替代元素值，这类接受谓词参数的算法都附加_if。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(beg,end,val);<span class="comment">//查找范围内val第一次出现的位置</span></span><br><span class="line"><span class="built_in">find_if</span>(beg,end,pred);<span class="comment">//查找第一个令pred为真的元素的位置</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>_copy版本的算法</p><ul><li><p>默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个<code>_copy</code></p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(begin,end); <span class="comment">// 反向输入范围中的序列</span></span><br><span class="line"><span class="built_in">reverse_copy</span>(begin,end,dest); <span class="comment">// 将元素按逆序拷贝到dest</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>一些算法同时提供_if和_copy，如<code>remove_if</code>和<code>remove_copy_if</code></p></li></ul><h2 id="10-6-特定容器算法"><a href="#10-6-特定容器算法" class="headerlink" title="10.6 特定容器算法"></a>10.6 特定容器算法</h2><ul><li><strong>对于<code>list</code>和<code>forward_list</code>，应该   优先使用成员函数版本的算法    而不是通用算法</strong><br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402042147204.png" alt="202402042147204"></li></ul><ul><li>链表类型还定义了<code>splice</code>成员（链表特有，<code>splice</code>和<code>splice_after</code>）<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402042148050.png" alt="image-20240204214806386"></li></ul><ul><li><p>链表特有的操作会改变容器</p><blockquote><p>多数链表特有的算法都与其通用版本很相似，但不完全相同。链表特有版本与通用版本间的一个至关重要的区别是<strong>链表版本  会  改变底层的容器</strong>。例如，remove 的链表版本会删除指定的元素。unique 的链表版本会删除第二个和后继的重复元素。</p><p>类似的，merge和splice 会销毁其参数。例如，通用版本的merge 将合并的序列写到一个给定的目的迭代器：两个输入序列是不变的。而链表版本的 merge 函数会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用 merge 的链表对象中。在merge 之后，来自两个链表中的元素仍然存在，但它们都已在同一个链表中。</p></blockquote></li></ul><h1 id="十一-关联容器"><a href="#十一-关联容器" class="headerlink" title="十一 关联容器"></a>十一 关联容器</h1><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402050716864.png" alt="image-20240205071603483"></p><ul><li><p>map &amp; set</p><ul><li>map中的元素是键值对</li><li>set每个元素只包含一个关键字</li></ul></li><li><p>8个容器见的不同体现在3个维度上</p><ul><li><p>map or set</p></li><li><p>要求不重复关键字 or 允许重复关键字 <code>multi</code></p></li><li><p>顺序存储 or 无序存储 <code>unordered</code></p><ul><li><p>有序存储会自动排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;string,string&gt; authors&#123;&#123;<span class="string">&quot;Alain&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Stanley&quot;</span>,<span class="string">&quot;c++Primer&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Alain&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Blain&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402052128072.png" alt="image-20240205212831668"></p></li></ul></li></ul></li><li><p>也可以对一个关联容器进行列表初始化</p></li></ul><h2 id="11-1-简单使用关联容器"><a href="#11-1-简单使用关联容器" class="headerlink" title="11.1 简单使用关联容器"></a>11.1 简单使用关联容器</h2><ul><li><p>map</p><ul><li><p>map是键值对的集和</p></li><li><p>map通常被称为关联数组，可使用key而不是位置作为下标来查找val</p></li><li><p><code>map&lt;key的类型，val的类型&gt;</code>  —&gt; <strong>每个元素是一个<code>pair类型</code>，</strong><code>.first</code> 表示key，<code>.second</code>表示val</p></li></ul></li><li><p>set</p><ul><li>set就是关键字的简单集和。</li><li>值就是关键字</li></ul></li></ul><p>简单应用：单词计数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,<span class="type">size_t</span>&gt; word_cnt;</span><br><span class="line">set&lt;string&gt; exclude&#123;<span class="string">&quot;the&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;but&quot;</span>&#125;; <span class="comment">//忽略计数的单词</span></span><br><span class="line">string word;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;word)</span><br><span class="line">    <span class="keyword">if</span>(exclude.<span class="built_in">find</span>(word) == exclude.<span class="built_in">end</span>()) <span class="comment">// 没找到，返回尾后指针</span></span><br><span class="line">        ++word_cnt[word]; <span class="comment">// ++是将val加1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;w:word_cnt)&#123;</span><br><span class="line">    cout&lt;&lt;w.first&lt;&lt;<span class="string">&quot; occurs &quot;</span>&lt;&lt;w.second</span><br><span class="line">        &lt;&lt;((w.second&gt;<span class="number">1</span>)?<span class="string">&quot; times &quot;</span>:<span class="string">&quot; time &quot;</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-2-关联容器概述"><a href="#11-2-关联容器概述" class="headerlink" title="11.2 关联容器概述"></a>11.2 关联容器概述</h2><h3 id="11-2-1-如何定义关联式容器"><a href="#11-2-1-如何定义关联式容器" class="headerlink" title="11.2.1 如何定义关联式容器"></a>11.2.1 如何定义关联式容器</h3><ul><li>除了不支持顺序容器的<code>push_back</code>等位置操作，以及构造函数和插入操作这些接受一个元素值和一个数量值的操作外，都支持<a href="#9.2 容器库概览">笔记9.2中表9.2</a>的普通容器操作。</li><li>关联容器的迭代器都是双向的</li><li>初始化<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402050956853.png" alt="image-20240205095623403"></li><li>初始化时，没有muti的关联容器会自动删除key重复的元素<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402050957004.png" alt="image-20240205095744626"></li></ul><h3 id="11-2-2-关键字类型的要求"><a href="#11-2-2-关键字类型的要求" class="headerlink" title="11.2.2 关键字类型的要求"></a>11.2.2 关键字类型的要求</h3><ul><li>对于有序容器，关键字类型必须定义元素比较的方法。默认情况下标准库使用key类型的<code>&lt;</code>运算符来比较两个关键字。</li><li>key类型可以提供自己的操作来替代默认的<code>&lt;</code>，遵循<strong>严格弱序（小于等于）</strong><br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051032678.png" alt="image-20240205103238274"></li></ul><ul><li><p>key如果没有自定义的<code>&lt;</code>运算符，也可使用关键字类型的比较函数，下例所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="type">const</span> Sales_data &amp;sd1, <span class="type">const</span> Sales_data &amp;sd2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sd1.<span class="built_in">isbn</span>() &lt; sd2.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义mutiset</span></span><br><span class="line"><span class="function">mutiset&lt;Sales_data, <span class="title">decltype</span><span class="params">(compareIsbn)</span> *&gt;  <span class="title">bookstore</span><span class="params">()</span></span>; <span class="comment">// decltype作用于函数时，返回函数类型而非指针类型，所以要另加*号</span></span><br></pre></td></tr></table></figure><ul><li>元素的操作类型（比较函数）也是容器类型的一部分</li><li>操作类型也仅仅只是类型，当创建容器时，才会以构造函数参数的形式提供真正的比较操作。</li></ul></li></ul><h3 id="11-2-3-pair"><a href="#11-2-3-pair" class="headerlink" title="11.2.3 pair"></a>11.2.3 pair</h3><ul><li><p><code>#include &lt;utility&gt;</code></p></li><li><p>pair上的操作<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402050959875.png" alt="image-20240205095922457"></p></li><li><p>如何创建一个<code>pair</code>对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*写法1*/</span></span><br><span class="line">&#123;key,val&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写法2*/</span></span><br><span class="line"><span class="built_in">pair</span>&lt;key_type,val_type&gt;(key,val); </span><br><span class="line"></span><br><span class="line"><span class="comment">/*写法3*/</span></span><br><span class="line"><span class="built_in">make_pair</span>(key,val);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*隐式构造一个空的pair*/</span></span><br><span class="line"><span class="built_in">pair</span>&lt;key_type,val_type&gt;();</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-3-关联容器操作"><a href="#11-3-关联容器操作" class="headerlink" title="11.3 关联容器操作"></a>11.3 关联容器操作</h2><h3 id="11-3-1-获得关联容器中元素的类型-amp-容器迭代器"><a href="#11-3-1-获得关联容器中元素的类型-amp-容器迭代器" class="headerlink" title="11.3.1 获得关联容器中元素的类型 &amp; 容器迭代器"></a>11.3.1 获得关联容器中元素的类型 &amp; 容器迭代器</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051455057.png" alt="image-20240205145535666"></p><ul><li><p>关键字是const的，不能随便改变一个元素的关键字</p><ul><li><p>1.类型别名<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051458429.png" alt="image-20240205145826046"></p></li><li><p>2.不能改变map的key的值，因为是const的<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051500619.png" alt="image-20240205150018200"></p></li><li><p>3.set的val就是key，同样是const的</p><blockquote><p>虽然set 类型同时定义了iterator和const_iterator类型，但两种类型<strong>都只允许只读访问 set 中的元素</strong>。</p><p>与不能改变一个map 元素的关键字一样，一个 <strong>set 中的关键字也是 const 的</strong>。</p></blockquote><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051501346.png" alt="image-20240205150123954"></p></li></ul></li></ul><ul><li><p>同样可由<code>++迭代器</code>遍历关联容器</p></li><li><p>关联容器和算法</p><ul><li>通常不对关联容器使用泛型算法——关键字是const的</li><li>关联容器可用于只读容器的算法——不过建议使用成员函数</li><li>在实际编程中，如果我们真要对一个关联容器使用算法，要么是将它当作一个源序列，要么当作一个目的序列。</li></ul></li></ul><h3 id="11-3-2-添加元素"><a href="#11-3-2-添加元素" class="headerlink" title="11.3.2 添加元素"></a>11.3.2 添加元素</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051515470.png" alt="image-20240205151520039"></p><ul><li><p>非muti在构造时会自动忽略重复的项</p></li><li><p>对map进行insert，切记所需元素类型的pair</p></li><li><p>insert/emplace的返回值</p><ul><li><p>对于非muti，返回一个pair。first是一个指向插入的元素的迭代器。second是一个bool，指出   插入成功（true）  还是  已在容器中（false）</p></li><li><p>对于first，通常用auto代替，详细的结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,<span class="type">size_t</span>&gt; word_cnt;</span><br><span class="line">pair&lt;map&lt;string,<span class="type">size_t</span>&gt;::iterator, <span class="type">bool</span>&gt; ret = </span><br><span class="line">    word_cnt.<span class="built_in">insert</span>(&#123;word,<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>对muti，返回值为指向新元素的迭代器，没有bool</p><ul><li>应用：添加具有相同关键字的多个元素</li></ul></li></ul><h3 id="11-3-3-删除元素"><a href="#11-3-3-删除元素" class="headerlink" title="11.3.3 删除元素"></a>11.3.3 删除元素</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051531873.png" alt="image-20240205153100464"></p><h3 id="11-3-4-map的下标操作"><a href="#11-3-4-map的下标操作" class="headerlink" title="11.3.4 map的下标操作"></a>11.3.4 map的下标操作</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051559437.png" alt="image-20240205155953031"></p><ul><li>仅map和unordered_map支持下标操作</li><li>如果<strong>关键字不在map/unordered_map中，会创建该关键字</strong>。初始化顺序如下：<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402051600520.png" alt="image-20240205160026146" style="zoom: 80%;" /></li><li>由于下标运算符可能插入一个新元素，所以只能对非const使用</li><li>解引用迭代器和下标操作所得到的值不同，前者为（value_type）,后者为（mapped_type）</li></ul><h3 id="11-3-5-访问元素"><a href="#11-3-5-访问元素" class="headerlink" title="11.3.5 访问元素"></a>11.3.5 访问元素</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402052102580.png" alt="202402052102580"></p><ul><li><p>只是为了判断特定元素在不在容器中，find是最佳选择，下标运算会有副作用</p></li><li><p><strong>muti</strong>容器中，具有<strong>相同关键字</strong>的多个元素<strong>相邻存储</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;string,string&gt; authors&#123;&#123;<span class="string">&quot;Alain&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Stanley&quot;</span>,<span class="string">&quot;c++Primer&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Alain&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Blain&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;&#125;;</span><br><span class="line">string author&#123;<span class="string">&quot;Alain&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> entries = authors.<span class="built_in">count</span>(author); <span class="comment">// 元素个数</span></span><br><span class="line"><span class="keyword">auto</span> iter = authors.<span class="built_in">find</span>(author);  <span class="comment">// 作者的第一本书</span></span><br><span class="line"><span class="keyword">while</span> (entries--)&#123;</span><br><span class="line">    cout&lt;&lt;iter-&gt;second&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// a b</span></span><br><span class="line">    ++iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>针对muti，lower_bound和upper_bound</p><ul><li>lower_bound返回的迭代器指向第一个具有给定关键字的元素</li><li>upper_bound返回的迭代器指向最后一个具有给定关键字的元素之后的位置</li><li>如果给定关键字不存在，则两个函数指向相同的位置——第一个安全的插入点（即能够保持容器顺序的插入位置）</li></ul></li></ul>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价上例</span></span><br><span class="line">multimap&lt;string,string&gt; authors&#123;&#123;<span class="string">&quot;Alain&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Stanley&quot;</span>,<span class="string">&quot;c++Primer&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Alain&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Blain&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">string author&#123;<span class="string">&quot;Alain&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> beg = authors.<span class="built_in">lower_bound</span>(author),</span><br><span class="line">    end = authors.<span class="built_in">upper_bound</span>(author);</span><br><span class="line">    beg != end; ++beg)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;beg-&gt;second&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// a b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402052147283.png" alt="image-20240205214737877"></p><p>  <img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402052154316.png" alt="image-20240205215417909"></p><ul><li><p>equal_bound</p><ul><li><p>此函数接受一个关键字，返回一个选代器对pair。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素（相当于lower_bound），第二个迭代器指向最后一个匹配元素之后的位置(相当于upper_bound)。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置（同样类似lower_bound和upper_bound）。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价上例</span></span><br><span class="line">multimap&lt;string,string&gt; authors&#123;&#123;<span class="string">&quot;Alain&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Stanley&quot;</span>,<span class="string">&quot;c++Primer&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Alain&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">&quot;Blain&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">string author&#123;<span class="string">&quot;Alain&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pos = authors.<span class="built_in">equal_range</span>(author);</span><br><span class="line">    pos.first != pos.second; ++pos.first)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;pos.first-&gt;second&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// a b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="11-4-无序容器"><a href="#11-4-无序容器" class="headerlink" title="11.4 无序容器"></a>11.4 无序容器</h2><ul><li><p>通常可以用无序容器替换对应的有序容器，反之亦然。但是，由于元素未按顺序存储，一个使用无序容器的输出（通常）会与使用有序容器的版本不同。</p></li><li><p>管理桶</p><ul><li><p>无序容器的形式如下图所示<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402060925431.png" alt="image-20240206092547916"></p></li><li><p>无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。</p><p>对于相同的参数，哈希函数必须总是产生相同的结果。理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但是，将不同关键字的元素映射到相同的桶也是允许的。当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在桶中搜索通常都是很快的操作。但是，如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作。</p></li><li><p>无序容器的管理操作<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402052211491.png" alt="image-20240205221101059"></p></li></ul></li></ul><ul><li><p>无序容器对key类型的要求</p><ul><li><p>无序容器需要<code>==</code>来比较元素和<code>hash&lt;key_type&gt;</code>来生成每个元素的hash值</p></li><li><p>可以通过重载关键字类型的默认操作，类定义无序容器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(string isbn)</span>:m_isbn(std::move(isbn))&#123;</span>&#125;</span><br><span class="line">    <span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_isbn;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_isbn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">hasher</span><span class="params">(<span class="type">const</span> Sales_data &amp;sd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(sd.<span class="built_in">isbn</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">eqop</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() == rhs.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> sd_mutiset = unordered_set&lt;Sales_data, <span class="keyword">decltype</span>(hasher)*, <span class="keyword">decltype</span>(eqop)*&gt;;</span><br><span class="line">    <span class="function">sd_mutiset <span class="title">bookstore</span><span class="params">(<span class="number">42</span>, hasher, eqop)</span></span>;<span class="comment">//桶数目、哈希函数指针、相等性判断运算符指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果Sales_data中重载了==，可省略等号</span></span><br><span class="line">    <span class="function">unordered_set&lt;Foo,<span class="title">decltype</span><span class="params">(FooHash)</span>*&gt; <span class="title">fooSet</span><span class="params">(<span class="number">10</span>,FooFash)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="十二-动态内存"><a href="#十二-动态内存" class="headerlink" title="十二 动态内存"></a>十二 动态内存</h1><h2 id="12-1-动态内存与智能指针"><a href="#12-1-动态内存与智能指针" class="headerlink" title="12.1 动态内存与智能指针"></a>12.1 动态内存与智能指针</h2><p>使用动态内存的原因：</p><ul><li>程序不知道自己使用多少个对象</li><li>程序不知道所需对象的准确类型</li><li>程序需要在对个对象间共享数据</li></ul><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402061053237.png" alt="image-20240206105347502"></p><h3 id="12-1-1-shared-ptr"><a href="#12-1-1-shared-ptr" class="headerlink" title="12.1.1 shared_ptr"></a>12.1.1 shared_ptr</h3><ul><li><p><code>make_shared()</code></p><ul><li><p>最安全的分配和使用动态内存的方法.</p></li><li><p>返回一个<code>shared_ptr</code>，指向函数在动态内存中分配的对象</p></li><li><p><code>#include &lt;memery&gt;</code></p></li><li><p>类似<code>emplace</code>，<code>make_shared()</code>用其参数构造给定类型的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; ptr = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>,<span class="string">&#x27;9&#x27;</span>);<span class="comment">// 9999999999</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>shared_ptr</code></p><ul><li>自动销毁所管理的对象，自动释放关联的内存（析构函数）</li><li>如果是容器中的元素，不用时记得用erase删除</li><li>如果多个对象共享底层数据（使用动态内存的原因），当某个对象被销毁时，我们不能单方面地销毁底层数据</li></ul></li></ul><h3 id="12-1-2-new-amp-delete"><a href="#12-1-2-new-amp-delete" class="headerlink" title="12.1.2 new &amp; delete"></a>12.1.2 new &amp; delete</h3><p>（原文：12.1.2 直接管理内存）</p><ul><li>直接管理内存的类不能依赖类对象的拷贝、赋值和销毁操作的任何默认定义。（相对于智能指针容易出错）</li></ul><ul><li><p>初始化方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">//默认构造</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(); <span class="comment">// 值初始化</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>); <span class="comment">// 传统构造方式</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">5</span>&#125;;<span class="comment">//列表初始化</span></span><br><span class="line"></span><br><span class="line">string *p = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">&#x27;9&#x27;</span>);<span class="comment">//*p为&quot;9999999999&quot;,注意&#x27;9&#x27;是单引号的字符</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>值初始化</p><ul><li><p>对于自定义构造函数会执行默认构造函数，默认/值初始化没有差别；</p></li><li><p>而对于<strong>内置类型， 建议使用值初始化</strong>，而不是默认初始化 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p0 = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//默认初始化，*p0的值未定义</span></span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="built_in">int</span>();<span class="comment">//值初始化，*p1=0</span></span><br><span class="line"></span><br><span class="line">string *p2 = <span class="keyword">new</span> string;<span class="comment">//string有默认构造函数，*p=&quot;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>同样，对于自定义类中的那些依赖于编译器合成的默认构造函数的内置类型成员，如果未在类内被初始化，那么它们的值也是未定义的。</p></li><li><p>如果提供了括号包围的初始化器，则可以用auto</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">auto</span>(obj);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>动态分配const对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const int *pci = new const int; //错误</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *pci = <span class="keyword">new</span> <span class="type">const</span> <span class="built_in">int</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="type">const</span> string *pcs = <span class="keyword">new</span> <span class="type">const</span> string; <span class="comment">// string有默认构造函数，隐式初始化</span></span><br></pre></td></tr></table></figure><ul><li>类似其他任何 const 对象，一个动态分配的 const 对象必须进行初始化。</li><li>对于一个定义了默认构造函数的类类型，其const 动态对象可以隐式初始化，而其他类型的对象就必须显式初始化。</li><li>由于分配的对象是 const 的，new 返回的指针是一个指向const的指针。</li></ul></li><li><p>内存耗尽，会抛出<code>bab_alloc</code>异常，可以通过定位new的方式阻止其抛出异常</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">new</span> (nothrow) <span class="built_in">int</span>(); <span class="comment">//如果分配失败，返回一个空指针，而不是抛出异常</span></span><br></pre></td></tr></table></figure></li><li><p>delete<br>（书本P409~P411）都是在讲delete的用法，并没有特别的知识。需要注意的地方有：</p><ul><li><p>delete销毁给定的指针指向的对象，并释放其内存</p></li><li><p>delete之后，指针变为空悬指针，最好将指针置为nullptr</p></li><li><p>delete指向数组的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> *p = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> *p1 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//delete p1;//只会删除数组中的一个元素</span></span><br><span class="line"><span class="keyword">delete</span>[] p1; <span class="comment">//告诉编译器，将要删除的是数组</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="12-1-3-shared-ptr-amp-new"><a href="#12-1-3-shared-ptr-amp-new" class="headerlink" title="12.1.3 shared_ptr &amp; new"></a>12.1.3 shared_ptr &amp; new</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402061545630.png" alt="202402061545630"></p><ul><li><p>可以使用new通过值初始化的方式构造智能指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>接受指针参数的智能指针构造函数时explicit的，<strong>不能使用隐式转换构造指针指针</strong>，有如下几种<strong>错误情况</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*例1*/</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);<span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例2*/</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//return new int(p); // 错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(p)); <span class="comment">// 正确，显式转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例3*/</span>    <span class="comment">// &lt;-- 不要混用普通指针和智能指针，推荐使用make_shared</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(shared_ptr&lt;<span class="type">int</span>&gt; ptr)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------</span></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="type">int</span> *x = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line"><span class="comment">//process(x); //错误,不可隐式转换</span></span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(x)); <span class="comment">// 错误。虽然合法，但x在process结束时会被释放</span></span><br><span class="line"><span class="type">int</span> j = *x; <span class="comment">//未定义行为，x已经被释放</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------</span></span><br><span class="line"><span class="comment">//正确的写法</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="built_in">process</span>(p); <span class="comment">// 引用计数+1</span></span><br><span class="line"><span class="type">int</span> i = *p; <span class="comment">//仍然存在</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>不要混用普通指针和智能指针，推荐使用make_shared。</p><ul><li>当将一个 shared_ptr 绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr。一旦这样做了，我们就<strong>不应该再使用内置指针来访问 shared_ptr所指向的内存了</strong>。如上例3错误写法所示。</li><li>也<strong>不要使用get初始化另一个智能指针或为智能指针赋值</strong>——<code>get()</code>返回内置指针，如果delete了，指针指针就失效了。<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402062126441.png" alt="image-20240206212657982"></li></ul></li></ul><ul><li><p><code>reset()</code>用一个新的指针赋予一个shared_ptr，常与<code>unique()</code>（注意：是shared_ptr的成员函数，不是unique_ptr&lt;&gt;）一起用，来控制多个shared_ptr共享的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; a,b;</span><br><span class="line"><span class="function">shared_ptr&lt;string&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;x&quot;</span>))</span></span>;</span><br><span class="line">a = p, b = p;</span><br><span class="line"><span class="keyword">if</span>(!p.<span class="built_in">unique</span>())</span><br><span class="line">    p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p));</span><br><span class="line">*p+=<span class="built_in">string</span>(<span class="string">&quot;y&quot;</span>);</span><br><span class="line">cout&lt;&lt;*p&lt;&lt;endl; <span class="comment">// xy</span></span><br><span class="line">cout&lt;&lt;*a&lt;&lt;endl;  <span class="comment">//x</span></span><br><span class="line">cout&lt;&lt;*b&lt;&lt;endl;  <span class="comment">//x</span></span><br></pre></td></tr></table></figure><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402061628874.png" alt="image-20240206162851438"></p></li></ul><h3 id="12-1-4-智能指针-amp-异常"><a href="#12-1-4-智能指针-amp-异常" class="headerlink" title="12.1.4 智能指针 &amp; 异常"></a>12.1.4 智能指针 &amp; 异常</h3><ul><li><p>如果在new和delete之间发生了异常，且异常没有在函数内部被捕获，new的内存就永远无法释放了——使用智能指针就不会有这样的问题。</p></li><li><p>智能指针陷阱<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402062201953.png" alt="image-20240206220131426"></p></li></ul><ul><li><p>shared_ptr额外的用法 ——释放哑类（没有析构函数的类）<br>（书P416）<br>利用<code>shared_ptr</code>并指定删除器（<code>deleter</code>），当<code>func()</code>退出时（即使由于异常而退出），哑类对象也会被正常关闭</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">destination</span>&#123;&#125;;<span class="comment">//目的ip</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">connection</span>&#123;&#125;; </span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destination *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnect</span><span class="params">(connection)</span></span>; <span class="comment">// 断开connect连接（析构）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除器（deleter）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">end_disconnect</span><span class="params">(connection *p <span class="comment">/*指向 shared_ptr尖括号中类型  的指针*/</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">disconnect</span>(*p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(destination &amp;d)</span></span>&#123;</span><br><span class="line">    connection c = <span class="built_in">connect</span>(&amp;d);</span><br><span class="line">    <span class="comment">// 如果我们在f()退出前没有调用disconnect，就无法关闭c了</span></span><br><span class="line">    <span class="comment">// 利用shared_ptr并指定删除器，当f()退出时（即使由于异常而退出），connection也会被正常关闭，如下:</span></span><br><span class="line">    <span class="function">shared_ptr&lt;connection&gt; <span class="title">p</span><span class="params">(&amp;c, end_disconnect)</span></span>; <span class="comment">// 第二个参数指定自定义的删除器（指向函数的指针）</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="12-1-5-unique-ptr"><a href="#12-1-5-unique-ptr" class="headerlink" title="12.1.5 unique_ptr"></a>12.1.5 unique_ptr</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402062227111.png" alt="image-20240206222750628"></p><ul><li><p>独占、“拥有”</p></li><li><p>初始化unique_ptr必须采用直接初始化形式。</p></li><li><p>不支持普通拷贝和赋值。但是有个例外：可以拷贝或赋值一个将要被销毁的unique_ptr，如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt; (<span class="keyword">new</span> <span class="built_in">int</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(p))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>虽然不能拷贝和赋值unique_ptr，但是可以通过调用release或reset将指针的所有权转移（非const）</p><ul><li><p><code>reset</code>（重置）就是将<code>std::unique_ptr</code>指向新的资源。由于<code>std::unique_ptr</code>就是最后一个指向当前资源的智能指针，因此，在重置前需要销毁回收当前的资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;p3&quot;</span>))</span></span>;</span><br><span class="line">p2.<span class="built_in">reset</span>(p3.<span class="built_in">release</span>()); </span><br><span class="line"><span class="comment">// reset释放p2原来的指向的内存，并令p2指向内存</span></span><br><span class="line"><span class="comment">// release返回p3当前指向的内存地址后，令p3 == nullptr</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>release</code>函数可以释放所有权，并返回指向<code>std::unique_ptr</code>所管理的资源的指针。</p><ul><li>注意：<strong><code>release</code>仅仅释放了所有权，并没有销毁回收所管理的资源</strong>。而回收内存资源的责任交还给了使用者。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*例1*/</span></span><br><span class="line">p2.<span class="built_in">release</span>(); <span class="comment">//错误，p2不会释放内存，并且我们丢失了指针</span></span><br><span class="line"><span class="keyword">auto</span> p = p2.<span class="built_in">release</span>(); <span class="comment">// 正确，但要记得手动  delete p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例2*/</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;p3&quot;</span>))</span></span>;</span><br><span class="line">string *pstr = p3.<span class="built_in">release</span>();</span><br><span class="line">cout&lt;&lt;*pstr; <span class="comment">//终端输出： p3</span></span><br><span class="line"><span class="keyword">delete</span> pstr;</span><br></pre></td></tr></table></figure></li><li><p>书中示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;p1&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>; <span class="comment">//**release只是将p1置空（p1==nullptr），并没有销毁原来指向的内存**</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;p3&quot;</span>))</span></span>;</span><br><span class="line">p2.<span class="built_in">reset</span>(p3.<span class="built_in">release</span>()); <span class="comment">// reset释放p2原来的指向的内存，并令p2指向内存</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>参考文献</p><ul><li><a href="https://zhuanlan.zhihu.com/p/475823415">Effective Modern C++(18): std::unique_ptr - 知乎 (zhihu.com)</a></li></ul></li></ul><ul><li><p>向unique_ptr传递删除器</p><ul><li><p>与shared_ptr不同，需要在<code>&lt;&gt;</code>指定删除器函数类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;objType,<span class="title">decltype</span><span class="params">(deleteFunc)</span>*&gt; <span class="title">n</span><span class="params">(<span class="keyword">new</span> ObjType, deleteFunc)</span></span></span><br></pre></td></tr></table></figure></li><li><p>用unique_ptr重写shared_ptr网络连接的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">destination</span>&#123;&#125;;<span class="comment">//目的ip</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">connection</span>&#123;&#125;; </span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destination *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnect</span><span class="params">(connection)</span></span>; <span class="comment">// 断开connect连接（析构）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除器（deleter）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">end_disconnect</span><span class="params">(connection *p <span class="comment">/*指向 shared_ptr尖括号中类型  的指针*/</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">disconnect</span>(*p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(destination &amp;d)</span></span>&#123;</span><br><span class="line">    connection c = <span class="built_in">connect</span>(&amp;d);</span><br><span class="line">    <span class="comment">// 如果我们在f()退出前没有调用disconnect，就无法关闭c了</span></span><br><span class="line">    <span class="comment">// 利用unique_ptr并指定删除器，当f()退出时（即使由于异常而退出），connection也会被正常关闭，如下:</span></span><br><span class="line">    <span class="function">unique_ptr&lt;connection,<span class="title">decltype</span><span class="params">(end_disconnect)</span>*&gt; <span class="title">p</span><span class="params">(&amp;c, end_disconnect)</span></span>; <span class="comment">// 第二个参数指定自定义的删除器（指向函数的指针）</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="12-1-6-weak-ptr"><a href="#12-1-6-weak-ptr" class="headerlink" title="12.1.6 weak_ptr"></a>12.1.6 weak_ptr</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402062228056.png" alt="image-20240206222828563"></p><ul><li><p>weak_ptr的主要特点</p><blockquote><p>weak_ptr(见表 12.5)是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个 weak_ptr 绑定到一个 shared_ptr 不会改变shared_ptr的引用计数。一旦最后一个指向对象的 shared_ptr 被销毁，对象就会被释放。即使有 weak_ptr 指向对象，对象也还是会被释放，因此，weak_ptr 的名字抓住了这种智能指针“弱”共享对象的特点。</p></blockquote></li><li><p>weak_ptr需要用shared_ptr初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt; (<span class="number">42</span>);</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>调用<code>lock()</code>以使用weak_ptr</p><ul><li><p>由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用<code>lock()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(shared_ptr&lt;<span class="type">int</span>&gt; np = wp.<span class="built_in">lock</span>())&#123;</span><br><span class="line">    <span class="comment">// lock检查weak_ptr指向的对象是否存在；</span></span><br><span class="line">    <span class="comment">// 如果存在，返回指向共享对象的shared_ptr</span></span><br><span class="line">    <span class="comment">// 否则返回空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="12-2-动态数组"><a href="#12-2-动态数组" class="headerlink" title="12.2 动态数组"></a>12.2 动态数组</h2><p>建议使用容器，而不是动态分配的数组</p><h3 id="12-2-1-new-amp-数组"><a href="#12-2-1-new-amp-数组" class="headerlink" title="12.2.1 new &amp; 数组"></a>12.2.1 new &amp; 数组</h3><h4 id="一、两种声明方法"><a href="#一、两种声明方法" class="headerlink" title="一、两种声明方法"></a>一、两种声明方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="comment">// 法1</span></span><br><span class="line"><span class="type">int</span> *pia = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">42</span>]; <span class="comment">// 必须指定大小，必须是整形，但不一定是常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 法2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> arrT[<span class="number">42</span>];</span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> arrT ;</span><br></pre></td></tr></table></figure><ul><li><p>分配一个数组会得到一个元素类型的指针，分配的内存不是数组类型。</p><ul><li><p>不能调用begin和end</p></li><li><p>不能使用范围for</p></li><li><p>原文</p><blockquote><p>分配一个数组会得到一个元素类型的指针</p><p>虽然我们通常称 new T[]分配的内存为“动态数组”，但这种叫法某种程度上有些误导。当用 new 分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。即使我们使用类型别名定义了一个数组类型，new 也不会分配一个数组类型的对象。在上例中，我们正在分配一个数组的事实甚至都是不可见的一一连[num]都没有。new 返回的是一个元素类型的指针。</p><p>由于分配的内存并不是一个数组类型，因此不能对动态数组调用 begin 或end(参见3.5.3 节，第106 页)。这些函数使用数组维度(回忆一下，维度是数组类型的一部分)来返回指向首元素和尾后元素的指针。出于相同的原因，也不能用范围 for 语句来处理所谓的)动态数组中的元素。</p></blockquote></li></ul></li></ul><h4 id="二、初始化"><a href="#二、初始化" class="headerlink" title="二、初始化"></a>二、初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pia = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">42</span>];  <span class="comment">// 10个未初始化的int。内置类型未初始化，其中的值是未定义的</span></span><br><span class="line"><span class="type">int</span> *pia2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">42</span>]();</span><br><span class="line"><span class="type">int</span> *pia3 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">string *psa = <span class="keyword">new</span> string[<span class="number">10</span>];  <span class="comment">// 10个值初始化的空stirng，string中有默认构造函数</span></span><br><span class="line">string *psa2 = <span class="keyword">new</span> string[<span class="number">10</span>]();</span><br><span class="line">string *psa3 = <span class="keyword">new</span> string[<span class="number">10</span>]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>,<span class="built_in">string</span>(<span class="number">3</span>,<span class="string">&#x27;x&#x27;</span>)&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>如果，初始化器中数目大于指定的元素数，new失败，不会分配任何内存，抛出<code>bad_array_new_length</code>异常（<code>#include &lt;new&gt;</code>）</p></li><li><p>虽然我们可用空括号对数组中的元素进行值初始化，但不能在括号中给出初始化器。意味着不能用auto分配数组——笔记<a href="#12.1.2-new-&amp;-delete">12.1.2 new &amp; delete</a>节—&gt;值初始化—&gt;第4小点</p></li><li><p>动态分配一个空数组是合法的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[<span class="number">0</span>]; <span class="comment">// 错误，不能定义长度为0的数组</span></span><br><span class="line"><span class="type">char</span> *cp = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">0</span>]; <span class="comment">//正确，但cp不能解引用。可用于循环的比较操作，如下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*动态分配一个空数组，用于循环的比较操作*/</span></span><br><span class="line"><span class="type">size_t</span> n = <span class="built_in">get_size</span>();</span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[n];  <span class="comment">// n为0，算法依然成立</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> *q = p; q != p+n; ++q)&#123;</span><br><span class="line">    <span class="comment">/*处理数组*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="三、释放动态数组"><a href="#三、释放动态数组" class="headerlink" title="三、释放动态数组"></a>三、释放动态数组</h4><p>必须带有方括号，不论是那种初始化形式。例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pia2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">42</span>]();</span><br><span class="line"><span class="keyword">delete</span>[] pia2;</span><br></pre></td></tr></table></figure><h4 id="四、智能指针和动态数组"><a href="#四、智能指针和动态数组" class="headerlink" title="四、智能指针和动态数组"></a>四、智能指针和动态数组</h4><ul><li><p>unique_ptr</p><ul><li><p>标准库提供了一个  管理new分配的数组的   unique_ptr版本，销毁时将自动调用<code>delete[]</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    unique_ptr&lt;int[]&gt; up = new int[10]; //No viable conversion from &#x27;int *&#x27; to &#x27;unique_ptr&lt;int[]&gt;&#x27;</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> p = up.<span class="built_in">release</span>(); <span class="comment">// 书P425说的是销毁其*指针*，而不是说销毁指针指向的元素</span></span><br><span class="line">cout&lt;&lt;*p; <span class="comment">//终端输出： 1</span></span><br></pre></td></tr></table></figure></li><li><p>也可以使用下标运算符，但不支持  点和箭头  运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)&#123;</span><br><span class="line">    up[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>unique_ptr管理数组的方式汇总<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402071759152.png" alt="image-20240207175919576"></p></li></ul></li></ul><ul><li><p>shared_ptr</p><p>shared_ptr不直接支持动态管理数组，需要我们：1）提供删除器；2）使用<code>get()</code>获取数组首元素指针，以访问数组中的元素。</p><ul><li><p>提供删除器（否则，shared_ptr将用delete销毁其所指向的对象）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span> *p)&#123; <span class="keyword">delete</span>[] p; &#125;)</span></span>;</span><br><span class="line">sp.<span class="built_in">reset</span>();<span class="comment">// 将调用我们提供的删除器</span></span><br></pre></td></tr></table></figure><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402071812706.png" alt="202402071812706"></p></li><li><p>使用<code>get()</code>获取数组首元素指针，以访问数组中的元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)&#123;</span><br><span class="line">    *(sp.<span class="built_in">get</span>() + i) = i; <span class="comment">// 使用get()获得内置指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="12-2-2-allocator类"><a href="#12-2-2-allocator类" class="headerlink" title="12.2.2 allocator类"></a>12.2.2 allocator类</h3><ul><li><code>#include &lt;memory&gt;</code></li><li>目的：先分配内存，在需要的时候再在该内存创建对象。（区别于new等同时分配内存和创建对象）</li></ul><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402072147044.png" alt="image-20240207214733502"></p><ul><li><p>基础用法示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">    allocator&lt;string&gt; alloc; <span class="comment">// 可以分配string内存的allocator对象</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> p = alloc.<span class="built_in">allocate</span>(n); <span class="comment">// 分配5个未初始化的string的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> q = p; <span class="comment">// q指向构造元素之后的位置</span></span><br><span class="line">    <span class="comment">// construct(指向当前要填充位置的指针，...构造函数所需的参数...)</span></span><br><span class="line">    alloc.<span class="built_in">construct</span>(q++); <span class="comment">// *q为空字符串</span></span><br><span class="line">    alloc.<span class="built_in">construct</span>(q++,<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>); <span class="comment">//*q为&quot;cccccccccc&quot;</span></span><br><span class="line">    alloc.<span class="built_in">construct</span>(q++,<span class="string">&quot;hi&quot;</span>); <span class="comment">// *q为&quot;hi&quot;</span></span><br><span class="line"><span class="comment">//  cout&lt;&lt;*q&lt;&lt;endl;//灾难：q指向未构造的内存，不能在未构造的情况下使用原始内存</span></span><br><span class="line">    cout&lt;&lt;*(q<span class="number">-1</span>)&lt;&lt;endl; <span class="comment">//hi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当我们用完对象后，必须对每个构造的元素调用destroy()销毁</span></span><br><span class="line">    <span class="keyword">while</span> (q != p)</span><br><span class="line">        alloc.<span class="built_in">destroy</span>(--q); <span class="comment">// 只能对真正构造了的元素调用destory</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一旦元素销毁，就可以用该内存保存其他的string元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序结束，释放alloc申请的内存（要先对所有元素destory）</span></span><br><span class="line">    alloc.<span class="built_in">deallocate</span>(p,n); <span class="comment">// p必须指向由allocate分配的内存，n必须等于allocate分配的大小</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>拷贝和填充未初始化的内存<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402072209158.png" alt="image-20240207220937592"></p><ul><li><p>书中例子：作为一个例子，假定有一个 int 的 vector，希望将其内容拷贝到动态内存中。我们将分配一块比 vector 中元素所占用空间大一倍的动态内存，然后将原 vector 中的元素拷贝到前一半空间，对后一半空间用一个给定值进行填充:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    allocator&lt;<span class="type">int</span>&gt; alloc;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> p = alloc.<span class="built_in">allocate</span>(v.<span class="built_in">size</span>() * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> q = <span class="built_in">uninitialized_copy</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(), p);</span><br><span class="line">    <span class="comment">// p:第三个参数**必须指向未构造的内存**</span></span><br><span class="line">    <span class="comment">// q:指向最后一个构造的元素之后的位置</span></span><br><span class="line"></span><br><span class="line">    q = <span class="built_in">uninitialized_fill_n</span>(q,v.<span class="built_in">size</span>(), <span class="number">42</span>);</span><br><span class="line">    <span class="comment">// 在目的指针（q）指向的内存中创建给定数目（v.size()）个对象，用给定的值（42）对他们进行初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p!=q)&#123;</span><br><span class="line">        cout&lt;&lt;*(--q)&lt;&lt;<span class="string">&quot; &quot;</span>;  <span class="comment">//输出： 42 42 42 42 42 4 3 2 1 0</span></span><br><span class="line">        alloc.<span class="built_in">destroy</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alloc.<span class="built_in">deallocate</span>(q,v.<span class="built_in">size</span>()*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="跳过的书中例子的记录"><a href="#跳过的书中例子的记录" class="headerlink" title="跳过的书中例子的记录"></a>跳过的书中例子的记录</h2><p>P391 一个单词转换的map</p><p>P404 ~ P406 StrBlob类<br>P420底部 ~ P422 核查指针类 —— 为StrBlob定义一个伴随指针类</p><p>P432 ~ P435 文本查询类的定义</p><div align="center"><h1>------类设计者工具------</h1></div><h1 id="十三-拷贝控制"><a href="#十三-拷贝控制" class="headerlink" title="十三 拷贝控制"></a>十三 拷贝控制</h1><blockquote><p>拷贝构造、拷贝赋值和析构  ：big three  —— 侯捷《面向对象高级编程》</p></blockquote><p>13.1,13.2：拷贝</p><p>13.4：移动</p><h2 id="13-1-拷贝、赋值和析构"><a href="#13-1-拷贝、赋值和析构" class="headerlink" title="13.1 拷贝、赋值和析构"></a>13.1 拷贝、赋值和析构</h2><h3 id="13-1-1-拷贝构造"><a href="#13-1-1-拷贝构造" class="headerlink" title="13.1.1 拷贝构造"></a>13.1.1 拷贝构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(); <span class="comment">//默认构造</span></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;); <span class="comment">// 拷贝构造</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>第一个参数必须是自身类型的<strong>引用</strong>，且几乎总是一个const，且额外参数都有默认值</li><li>不应该是<code>explicit</code></li><li>static成员不被拷贝（拷贝每个非static成员）</li></ul><h4 id="一：拷贝初始化"><a href="#一：拷贝初始化" class="headerlink" title="一：拷贝初始化"></a>一：拷贝初始化</h4><p><strong>拷贝初始化依靠拷贝构造函数或移动构造函数来完成。——<a href="#13433-合成的移动操作">左值拷贝，右值移动</a></strong></p><p>拷贝初始化的发生条件：</p><ul><li><p><code>=</code></p></li><li><p>作为实参  传递给一个非引用的形参</p></li><li>返回类型为非引用的函数  返回一个对象</li><li>列表初始化一个数组的元素或一个聚合类中的成员</li><li>标准库容器调用insert或push等</li></ul><h4 id="二：拷贝初始化的限制"><a href="#二：拷贝初始化的限制" class="headerlink" title="二：拷贝初始化的限制"></a>二：拷贝初始化的限制</h4><p>总结：主要是针对<code>explicit</code>的限制，拷贝构造不可隐式转化，可直接构造为临时对象再使用   —&gt;  当传递一个实参或从函数返回一个值时，不可隐式使用explicit，需要像<code>示例2</code>最后一行一样使用。</p><p>参考：</p><p>[1] <a href="https://en.cppreference.com/w/cpp/language/copy_initialization">Copy-initialization</a></p><p>[2] <a href="https://www.cnblogs.com/gqtcgq/p/7189888.html">C++复制初始化的限制 —— 对[1]的翻译 </a>  </p><p>相比于直接初始化，复制初始化有更加严格的限制。</p><p>1：<strong>在复制初始化时，不能使用声明为explicit的构造函数进行的隐式转换。而直接初始化则是允许的：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Exp</span> &#123; <span class="function"><span class="keyword">explicit</span> <span class="title">Exp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span> </span>&#123;&#125; &#125;; <span class="comment">// not convertible from const char*</span></span><br><span class="line"><span class="function">Exp <span class="title">e1</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;  <span class="comment">// OK</span></span><br><span class="line">Exp e2 = <span class="string">&quot;abc&quot;</span>; <span class="comment">// Error, copy-initialization does not consider explicit constructor</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Imp</span> &#123; <span class="built_in">Imp</span>(<span class="type">const</span> <span class="type">char</span>*) &#123;&#125; &#125;; <span class="comment">// convertible from const char*</span></span><br><span class="line"><span class="function">Imp <span class="title">i1</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;  <span class="comment">// OK</span></span><br><span class="line">Imp i2 = <span class="string">&quot;abc&quot;</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><ul><li><p>Exp类中的构造函数声明为了explicit，因此，复制初始化Exp e2 = “abc”将会发生编译错误：error: conversion from ‘const char [4]’ to non-scalar type ‘Exp’ requested.</p></li><li><p>Imp类中的构造函数没有声明为explicit，因此，可以用字符串”abc”进行直接初始化或复制初始化Imp的对象。</p></li></ul><p>2：<strong>在复制初始化中，使用隐式转换时，必须是从初始化器（=右边的表达式）可以直接转换为被初始化对象，而不是间接的。在直接初始化中，可以使用从初始化器到构造函数参数的隐式转换。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123; <span class="built_in">S</span>(std::string) &#123;&#125; &#125;; <span class="comment">// implicitly convertible from std::string</span></span><br><span class="line"> </span><br><span class="line"><span class="function">S <span class="title">s1</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>; <span class="comment">// OK: conversion from const char[4] to std::string</span></span><br><span class="line">S s2 = <span class="string">&quot;abc&quot;</span>; <span class="comment">// Error: no conversion from const char[4] to S</span></span><br><span class="line">S s3 = std::<span class="built_in">string</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">// OK: conversion from std::string to S</span></span><br></pre></td></tr></table></figure><ul><li><p>类S有一个接受std::string参数的构造函数，因此，可以使用”const char*”直接初始化S的对象s1。这里的转换序列是：const char* à std::string à struct S；</p></li><li><p>复制初始化中，则不允许这种转换，因为它不是直接转换，而是间接转换，因此，s2的初始化就会发生编译错误；</p></li><li><p>复制初始化中，可以使用直接隐式转换，因此，可以使用std::string的对象，初始化s3。</p></li></ul><h4 id="三：编译器可以绕过拷贝构造函数"><a href="#三：编译器可以绕过拷贝构造函数" class="headerlink" title="三：编译器可以绕过拷贝构造函数"></a>三：编译器可以绕过拷贝构造函数</h4><p><a href="https://www.cnblogs.com/uangyy/p/5516935.html">参考文献</a></p><p>C++ primer P442 P447:在拷贝初始化过程中，编译器可以跳过拷贝构造函数，直接创建对象。即，编译器允许将下面的代码　</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string null_book = <span class="string">&quot;999&quot;</span>;　　<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>改写为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">null_book</span><span class="params">(<span class="string">&quot;999&quot;</span>)</span></span>;　　<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>由于string的构造函数不是一个explicit的，所以说string类型允许从const char* 到string的隐式转换。</p><p>在行1中，首先将”999”隐式转化为一个string的临时对象，然后应该调用string的拷贝构造函数对null_book初始化。即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">temp_str</span><span class="params">(<span class="string">&quot;999&quot;</span>)</span></span>;</span><br><span class="line">string null_book = temp_str;    <span class="comment">//或者 string null_book(temp_str);</span></span><br></pre></td></tr></table></figure><p><strong>在这里编译器会进行优化，跳过拷贝构造函数直接创建对象，使临时变量直接成为所要创建的对象</strong>。</p><p>类似的下面代码也会跳过拷贝构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="built_in">string</span>();</span><br></pre></td></tr></table></figure><p>但是在这种情况下，拷贝构造函数必须是public的，否则编译会不通过。可能是因为如果拷贝构造函数是private的话，编译器会理解为不能够使用拷贝构造函数，进而不会进行这种优化。</p><h3 id="13-1-2-拷贝赋值"><a href="#13-1-2-拷贝赋值" class="headerlink" title="13.1.2 拷贝赋值"></a>13.1.2 拷贝赋值</h3><ul><li>在类中重载<code>=</code>运算符，必须是成员函数</li><li>通常应该<strong>返回指向其左侧运算对象的引用</strong></li><li>标准库通常要求保存在容器中的类型要具有赋值运算符</li><li>将右侧的非static成员赋予左侧（xxx除外）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo &amp;f)&#123;</span><br><span class="line">        <span class="comment">//this-&gt;xxx = f.xxx;</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：将于<a href="#132-拷贝控制和资源管理">笔记13.2</a>详细说明</p><ul><li>拷贝赋值运算符与往常一样执行类似拷贝构造函数和析构函数的工作。即，它必须递增右侧运算对象的引用计数(即，拷贝构造函数的工作)，并递减左侧运算对象的引用计数，在必要时释放使用的内存(即，析构函数的工作)。</li><li>必须处理自赋值（自己赋值给自己）</li></ul><h3 id="13-1-3-析构函数"><a href="#13-1-3-析构函数" class="headerlink" title="13.1.3 析构函数"></a>13.1.3 析构函数</h3><h4 id="13-1-3-1-什么时候需要析构函数"><a href="#13-1-3-1-什么时候需要析构函数" class="headerlink" title="13.1.3.1 什么时候需要析构函数"></a>13.1.3.1 什么时候需要析构函数</h4><blockquote><p>什么时候需要析构函数？一般是成员通过new动态申请了内存的时候。（管理类外资源的类）</p><p>因为：隐式销毁一个内置指针类型的成员不会delete它所指向的对象。</p></blockquote><h4 id="13-1-3-2-什么时候调用析构函数？"><a href="#13-1-3-2-什么时候调用析构函数？" class="headerlink" title="13.1.3.2 什么时候调用析构函数？"></a>13.1.3.2 什么时候调用析构函数？</h4><p>变量在离开其作用域时被销毁。</p><ul><li>当一个对象被销毁时，其成员被销毁</li><li>容器（包括数组）被销毁时，其元素被销毁</li><li>对于动态分配的对象,当对指向它的指针应用delete运算符时被销毁(参见12.1.2节，第409页)。</li><li>对于临时对象，当创建它的完整表达式结束时被销毁</li></ul><p>析构函数调用过程（P446）</p><p>如同构造函数有一个初始化部分和一个函数体，析构函数也有一个函数体和一个析构部分。</p><ul><li>在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。</li><li>在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。</li></ul><blockquote><p><strong>要认识到析构函数体自身并不直接销毁成员是非常重要的：成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。</strong></p></blockquote><h4 id="13-1-3-3-三-五法则"><a href="#13-1-3-3-三-五法则" class="headerlink" title="13.1.3.3 三/五法则"></a>13.1.3.3 三/五法则</h4><p><strong>需要析构函数的类也需要拷贝构造和拷贝赋值</strong></p><p><strong>需要拷贝构造的类也需要拷贝赋值，反之亦然。但不必然要求析构函数。</strong></p><h3 id="13-1-4-控制是否使用默认（合成）函数"><a href="#13-1-4-控制是否使用默认（合成）函数" class="headerlink" title="13.1.4 控制是否使用默认（合成）函数"></a>13.1.4 控制是否使用默认（合成）函数</h3><h4 id="13-1-4-1-default-amp-delete"><a href="#13-1-4-1-default-amp-delete" class="headerlink" title="13.1.4.1 =default &amp; =delete"></a>13.1.4.1 <code>=default</code> &amp; <code>=delete</code></h4><ul><li><p>显式地要求编译器使用默认版本：<code>=default</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;  <span class="comment">// 类内 = default将被声明为内联</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> Sales_data &amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Sales_data &amp;);</span><br><span class="line">    ~<span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>=(<span class="type">const</span> Sales_data &amp;) = <span class="keyword">default</span>; <span class="comment">// 这样写就不是内联</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>阻止拷贝：<code>=delete</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">noCopy</span>&#123;</span><br><span class="line">    <span class="built_in">noCopy</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">noCopy</span>(<span class="type">const</span> noCopy &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    noCopy &amp; <span class="keyword">operator</span>=(<span class="type">const</span> noCopy &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">noCopy</span>() = <span class="keyword">default</span>; <span class="comment">//析构函数不能是=delete，否则会导致一系列问题</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li>何时阻止拷贝？例如：iostream类阻止了拷贝，以避免多个对象读取或写入相同的io缓冲</li><li><code>=delete</code>必须出现在函数第一次声明的时候</li><li>可以对任何函数<code>=delete</code>：用于引导函数匹配过程。<strong>（析构函数除外)</strong></li><li>对上一点的补充：<strong>析构函数不能是<code>=delete</code></strong>，否则<ul><li>1)无法定义该类型的变量或临时对象；且如果它被包含进另一个类，则导致外层的类也不能定义变量或临时对象</li><li>2)无法释放指向该类型的动态分配到指针（可以new但不能delete）</li></ul></li></ul><h4 id="13-1-4-2-何时合成的拷贝控制成员被定义为删除"><a href="#13-1-4-2-何时合成的拷贝控制成员被定义为删除" class="headerlink" title="13.1.4.2 何时合成的拷贝控制成员被定义为删除"></a>13.1.4.2 何时合成的拷贝控制成员被定义为删除</h4><p>（P450）:question:有点乱</p><ul><li>如果<strong>类的某个成员的析构函数是删除的或不可访问的</strong>(例如，是 private 的),则类的合成析构函数被定义为删除的。</li><li>如果<strong>类的某个成员的拷贝构造函数是删除的或不可访问的</strong>，则类的合成拷贝构造函数被定义为删除的。如果<strong>类的某个成员的析构函数是删除的或不可访问</strong>的，则类合成的拷贝构造函数也被定义为删除的。</li><li>如果<strong>类的某个成员的拷贝赋值运算符是删除的或不可访问的,或是类有一个const的或引用成员</strong>，则类的合成拷贝赋值运算符被定义为删除的。</li><li>如果<strong>类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器(参见2.6.1节，第65页)，或是类有一个 const 成员，它没有类内初始化器且其类型未显式定义默认构造函数</strong>，则该类的默认构造函数被定义为删除的。</li></ul><p>总结：<strong>本质上，如果一个类中，存在某个数据成员不能默认构造、拷贝、赋值或销毁，则该类对应的成员函数将被定义为删除（=delete）。</strong></p><ul><li>类中存在引用成员或无法默认构造的const成员类，编译器不会合成<em>默认构造函数</em>。</li><li>类中存在引用成员或无法默认构造的const成员类，编译器不会合成<em>拷贝赋值运算符</em>。</li></ul><h4 id="13-1-4-3-private拷贝控制"><a href="#13-1-4-3-private拷贝控制" class="headerlink" title="13.1.4.3 private拷贝控制"></a>13.1.4.3 private拷贝控制</h4><p>没有<code>=delete</code>前（c++11前），通过声明（但不定义）private的拷贝构造和拷贝赋值，可以阻止任何拷贝该类对象的企图。</p><ul><li>private：试图拷贝对象的用户代码将在编译阶段被标记为错误</li><li>不定义：成员函数或友元函数中的拷贝操作将会导致链接错误</li></ul><h2 id="13-2-拷贝控制和资源管理"><a href="#13-2-拷贝控制和资源管理" class="headerlink" title="13.2 拷贝控制和资源管理"></a>13.2 拷贝控制和资源管理</h2><p>管理类外资源的类有两种拷贝方式：（a）拷贝指针指向的对象；（b）拷贝指针本身。</p><h3 id="13-2-1-行为像值的类——拷贝指针指向的对象"><a href="#13-2-1-行为像值的类——拷贝指针指向的对象" class="headerlink" title="13.2.1 行为像值的类——拷贝指针指向的对象"></a>13.2.1 行为像值的类——拷贝指针指向的对象</h3><p>一</p><ul><li>定义一个拷贝构造函数，完成string 的拷贝，而不是拷贝指针</li><li>定义一个析构函数来释放string</li><li>定义一个拷贝赋值运算符来释放对象当前的 string，并从右侧运算对象拷贝string</li></ul><p>二</p><p>其中，尤其需要<strong>注意拷贝赋值的写法</strong>：</p><ul><li><p>拷贝赋值运算符组合了类似拷贝构造函数和析构函数的工作：</p><ul><li><p>赋值运算符左侧：销毁左侧运算对象的资源——（析构函数的构造）</p></li><li><p>赋值运算符右侧：从右侧运算对象拷贝数据到左侧运算对象——（拷贝构造的工作）</p></li></ul></li><li><p>必须处理自赋值</p></li><li><p>需要异常安全——当异常发生时，能将左侧运算对象置于一个有意义的状态</p></li></ul><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402201501741.png" alt="202402201501741"></p><p>三</p><p>示例如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> string&amp; s = <span class="built_in">string</span>()) :</span><br><span class="line">        <span class="built_in">ps</span>(<span class="keyword">new</span> <span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>) &#123;&#125; <span class="comment">// 构造</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr&amp; p) :</span><br><span class="line">        <span class="built_in">ps</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p.ps)), <span class="built_in">i</span>(p.i) &#123;&#125;  <span class="comment">// 拷贝构造</span></span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp; p); <span class="comment">// &lt;-特别需要注意拷贝赋值</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">HasPtr</span>() &#123; <span class="keyword">delete</span> ps; &#125;  <span class="comment">//析构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string* ps;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span>(*p.ps); <span class="comment">// 现将数据保存在额外的空间中，避免因自赋值而将自身销毁</span></span><br><span class="line">    <span class="keyword">delete</span> ps; <span class="comment">// 先释放当前对象指针指向的空间</span></span><br><span class="line">    ps = newp; <span class="comment">// 后从右侧对象拷贝数据</span></span><br><span class="line">    i = p.i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*错误案例*/</span></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*如果有如下情况，ps将会指向无效内存：</span></span><br><span class="line"><span class="comment">    * HasPtr a；</span></span><br><span class="line"><span class="comment">    * a = a;</span></span><br><span class="line"><span class="comment">    * 调用operator=时，先将a.ps销毁了，又让a.ps指向了已经被销毁的空间，而产生未定义行为</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    ps = <span class="keyword">new</span> <span class="built_in">string</span>(*(p.ps));</span><br><span class="line">    i = p.i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-2-2-行为像指针的类——拷贝指针本身"><a href="#13-2-2-行为像指针的类——拷贝指针本身" class="headerlink" title="13.2.2 行为像指针的类——拷贝指针本身"></a>13.2.2 行为像指针的类——拷贝指针本身</h3><p>同样要注意拷贝赋值的写法：</p><ul><li><p>拷贝赋值运算符组合了类似拷贝构造函数和析构函数的工作：</p><ul><li><p>需要递增右侧运算对象的引用计数（拷贝构造）</p></li><li><p>递减左侧运算对象的引用计数，并在必要时释放资源（析构）</p></li></ul></li><li><p>处理自赋值</p></li><li>异常安全</li></ul><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> string&amp; s = <span class="built_in">string</span>()) :</span><br><span class="line">        <span class="built_in">ps</span>(<span class="keyword">new</span> <span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>) ,<span class="built_in">use</span>(<span class="keyword">new</span> <span class="built_in">size_t</span>(i))&#123;&#125; <span class="comment">//构造</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr&amp; p) :</span><br><span class="line">        <span class="built_in">ps</span>(p.ps), <span class="built_in">i</span>(p.i), <span class="built_in">use</span>(p.use) &#123; ++*use; &#125; <span class="comment">// 拷贝构造</span></span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp; p); <span class="comment">// 拷贝赋值</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">HasPtr</span>() &#123; </span><br><span class="line">        <span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123; <span class="comment">// 如果引用计数变为0，则释放内存</span></span><br><span class="line">            <span class="keyword">delete</span> ps;</span><br><span class="line">            <span class="keyword">delete</span> use;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string* ps;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span>* use; <span class="comment">// 引用计数器，保存在动态内存中</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    ++*p.use; <span class="comment">// 递增右侧运算对象的引用计数，可以避免自赋值被销毁：当=两边相同时，在递减之前，计数器已经被递增过了</span></span><br><span class="line">    <span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123; <span class="comment">// 递减左对象的引用计数</span></span><br><span class="line">        <span class="keyword">delete</span> ps;</span><br><span class="line">        <span class="keyword">delete</span> use;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;ps = p.ps;</span><br><span class="line">    <span class="keyword">this</span>-&gt;i = p.i;</span><br><span class="line">    <span class="keyword">this</span>-&gt;use = p.use;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-2-3-交换操作"><a href="#13-2-3-交换操作" class="headerlink" title="13.2.3 交换操作"></a>13.2.3 交换操作</h3><blockquote><p>与拷贝控制成员不同，swap并不是必要的。但是，对于分配了资源的类，定义swap可能是一种很重要的优化手段。</p></blockquote><h4 id="一：编写自定义swap"><a href="#一：编写自定义swap" class="headerlink" title="一：编写自定义swap"></a>一：编写自定义<code>swap</code></h4><p>两个类型交换的传统做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HasPtr tmp = v1;</span><br><span class="line">v1 = v2;</span><br><span class="line">v2 = tmp;</span><br></pre></td></tr></table></figure><p>可通过重载<code>swap</code>的默认行为，实现两个自定义类的交换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;, HasPtr &amp;)</span></span>; <span class="comment">// 定义为友元以访问类的private成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;l, HasPtr &amp;r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(l.ps, r.ps); <span class="comment">// 交换指针</span></span><br><span class="line">    <span class="built_in">swap</span>(l.i,r.i); <span class="comment">// 交换int成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用HasPtr定义的<code>swap</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(Foo &amp;, Foo &amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HasPtr h;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Foo &amp;r, Foo &amp;l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(r.h, l.h); <span class="comment">// 自定义版本的swap优先级高于std::swap, 此处会调用类中重载的版本</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换Foo的其他成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议使用<code>using std::swap</code>的写法：</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402201622418.png" alt="image-20240220162159834"></p><h4 id="二：在赋值构造中使用swap"><a href="#二：在赋值构造中使用swap" class="headerlink" title="二：在赋值构造中使用swap"></a>二：在赋值构造中使用<code>swap</code></h4><p>拷贝交换技术：将左侧运算对象与右侧运算对象的一个副本进行交换。</p><p>优势：自动处理了自赋值情况  且  天然异常安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HasPtr &amp; HasPtr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr rhs)&#123; <span class="comment">// &lt;-注意：参数以值方式传递</span></span><br><span class="line">    <span class="built_in">swap</span>(*<span class="keyword">this</span>,rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// rhs被销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-3-两个例子"><a href="#13-3-两个例子" class="headerlink" title="13.3 两个例子"></a>13.3 两个例子</h2><h3 id="13-3-1-拷贝控制示例"><a href="#13-3-1-拷贝控制示例" class="headerlink" title="13.3.1 拷贝控制示例"></a>13.3.1 拷贝控制示例</h3><p>Message.hpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Folder.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Folder</span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(Message&amp; l, Message&amp; r)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Message</span><span class="params">(<span class="type">const</span> string str = <span class="string">&quot;&quot;</span>)</span></span></span><br><span class="line"><span class="function">        :contents(str) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Message</span>(<span class="type">const</span> Message&amp;);<span class="comment">//拷贝构造</span></span><br><span class="line">    Message&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Message&amp;);</span><br><span class="line">    ~<span class="built_in">Message</span>() &#123; <span class="built_in">remove_from_folders</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从给定folder中添加/删除本message</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">(Folder&amp; f)</span> </span>&#123; <span class="keyword">this</span>-&gt;folders.<span class="built_in">insert</span>(&amp;f); f.<span class="built_in">addMsg</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Folder&amp; f)</span> </span>&#123; <span class="keyword">this</span>-&gt;folders.<span class="built_in">erase</span>(&amp;f); f.<span class="built_in">remMsg</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    string contents;</span><br><span class="line">    set&lt;Folder*&gt; folders; <span class="comment">// 包含本message的folder</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_to_folders</span><span class="params">(<span class="type">const</span> Message&amp;m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将本message添加到指向m的folder中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> f : m.folders) &#123;</span><br><span class="line">            f-&gt;<span class="built_in">addMsg</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove_from_folders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> f : <span class="keyword">this</span>-&gt;folders) &#123;</span><br><span class="line">            f-&gt;<span class="built_in">remMsg</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Message::<span class="built_in">Message</span>(<span class="type">const</span> Message&amp;m)</span><br><span class="line">    :<span class="built_in">contents</span>(m.contents), <span class="built_in">folders</span>(m.folders)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">add_to_folders</span>(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Message&amp; Message::<span class="keyword">operator</span>=(<span class="type">const</span> Message&amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">remove_from_folders</span>();</span><br><span class="line">    contents = r.contents;</span><br><span class="line">    folders = r.folders;</span><br><span class="line">    <span class="built_in">add_to_folders</span>(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Message&amp; l, Message&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将每个消息的指针从它（原来）所在的Folder中删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f: l.folders)</span><br><span class="line">        f-&gt;<span class="built_in">remMsg</span>(&amp;l);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : r.folders)</span><br><span class="line">        f-&gt;<span class="built_in">remMsg</span>(&amp;r);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(l.folders, r.folders); <span class="comment">// 交换set</span></span><br><span class="line">    <span class="built_in">swap</span>(l.contents, r.contents); <span class="comment">// 交换string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将每个Message的指针添加到它的（新）Folder中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-3-2-动态内存管理类"><a href="#13-3-2-动态内存管理类" class="headerlink" title="13.3.2 动态内存管理类"></a>13.3.2 动态内存管理类</h3><p>StrVec类</p><h2 id="13-4-star-对象移动"><a href="#13-4-star-对象移动" class="headerlink" title="13.4 :star:对象移动"></a>13.4 :star:对象移动</h2><p>（书P470）</p><p>为何使用移动？</p><ul><li><p><strong>提升性能。</strong>在某些情况下，对象拷贝后机立即被销毁了，在这种情况下，移动而非拷贝对象会大幅度提升性能。</p></li><li><p><strong>不能被共享的资源（io类或unique_ptr），不可被拷贝但可以移动。</strong></p><blockquote><p>在旧 C++标准中，没有直接的方法移动对象。因此，即使不必拷贝对象的情况下，我们也不得不拷贝。如果对象较大，或者是对象本身要求分配内存空间(如 string)，进行不必要的拷贝代价非常高。类似的，在旧版本的标准库中，容器中所保存的类必须是可拷贝的。但在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能被移动即可。</p></blockquote></li></ul><h3 id="13-4-1-什么是右值引用"><a href="#13-4-1-什么是右值引用" class="headerlink" title="13.4.1 什么是右值引用"></a>13.4.1 什么是右值引用</h3><h4 id="一、左值和右值"><a href="#一、左值和右值" class="headerlink" title="一、左值和右值"></a>一、左值和右值</h4><p>左值：表示一个对象的身份，通常<strong>可以被取地址</strong>。</p><ul><li>左值引用的作用对象：不能将左值引用绑定到要求转换的表达式、字面值常量、返回右值的表达式。</li></ul><p>右值：表示一个对象的值，通常<strong>无法取地址</strong>。</p><ul><li>右值引用的作用对象：不能将右值引用直接绑定到左值，如必须要绑定，则要先用<code>std::move</code>将左值转换成右值，再右值引用。</li></ul><p>左值和右值的对比：</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/1708483132022.png" alt="20240221103743320"></p><h4 id="二、右值引用"><a href="#二、右值引用" class="headerlink" title="二、右值引用"></a>二、右值引用</h4><p>右值引用就是<strong>必须绑定到右值</strong>的引用，通过<code>&amp;&amp;</code>表示。</p><p>右值引用的一个重要性质：只能绑定到一个将要销毁的对象上，从而将一个右值引用的资源“移动”到另一个对象上。</p><p>示例</p><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402211708483950.png" alt="image-20240221105229193" style="zoom:80%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp;&amp; rr1 = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span>&amp;&amp; rr2 = std::<span class="built_in">move</span>(rr1);</span><br><span class="line">    cout &lt;&lt; rr2 &lt;&lt; endl; <span class="comment">// 42</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>&amp;&amp; rr3 = <span class="number">42</span>;</span><br><span class="line">    cout &lt;&lt; rr3 &lt;&lt; endl; <span class="comment">// 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-4-2-std-move"><a href="#13-4-2-std-move" class="headerlink" title="13.4.2 std::move()"></a>13.4.2 <code>std::move()</code></h3><ul><li>通过<code>std::move</code>将左值转化为右值（原文：使用std::move获得绑定到左值上的右值引用）<ul><li><strong>move的作用是<font color='red'>偷取（窃取）</font>其他变量里的资源变为自己的（是资源所有权的变更，而不是拷贝资源）</strong>，如内存、线程等等，而不必自己再从0获取。很显然这样可以节约一些程序开销。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr1 = <span class="number">42</span>; <span class="comment">// 正确，字面值常量是右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = rr1; <span class="comment">// 错误，rr1是左值，右值引用只能绑定右值。（变量（rr1）可以看做没有运算符的表达式，而表达式都是左值）</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr1); <span class="comment">// 正确，使用std::move获得绑定到左值上的右值引用（我的理解：将左值转化为右值）</span></span><br><span class="line"><span class="comment">//之后，可以销毁rr1的源对象，也可以赋予它新值，但是不可再使用rr1源对象的值</span></span><br></pre></td></tr></table></figure><ul><li><p><code>#include &lt;utility&gt;</code></p></li><li><p>我们可以销毁一个移后源对象（此处指rr1），也可以赋予它新值，但不能使用一个移后源对象的值。</p><blockquote><p>move 调用告诉编译器:我们有一个左值，但我们希望像一个右值一样处理它。我们必须认识到，调用 move 就意味着承诺：<strong>除了对 rr1 赋值或销它外，我们将不再使用它。</strong>在调用move之后，我们不能对移后源对象的值做任何假设。</p><p>移动操作还必须<strong>保证源对象可以安全地为其赋予新值</strong>或者可以安全地使用而不依赖其当前值。</p><p>另一方面，<strong>移动操作对移后源对象中留下的值没有任何要求。因此，我们不可对其值进行假设，我们的程序也不应依赖于移后源对象中的数据。</strong></p></blockquote></li><li><p>使用move 的代码<strong>应该使用 std::move而不是move</strong>（不提供using声明）。这样做可以避免潜在的名字冲突。</p></li></ul><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202402221708579013.png" alt="image-20240222131649580"></p><hr><h3 id="13-4-3-自定义类中的移动构造和移动赋值"><a href="#13-4-3-自定义类中的移动构造和移动赋值" class="headerlink" title="13.4.3 自定义类中的移动构造和移动赋值"></a>13.4.3 自定义类中的移动构造和移动赋值</h3><p>对于移动构造和移动赋值：</p><ul><li><p>从给定对象窃取资源而不是拷贝资源，<strong>不新分配任何内存</strong></p></li><li><p><strong>必须在声明和定义中都标记为<code>noexcept</code></strong>，通知标准库不抛出任何异常（为什么需要noexcpt，书P474，:question:）</p></li><li><strong>源对象的所有指针置为<code>nullptr</code></strong>，确保移后源对象处于一个可析构的状态（必须确保移后源对象被销毁是无害的）</li><li><strong>后续程序不应依赖移后源对象中的数据</strong></li></ul><h4 id="13-4-3-1-移动构造"><a href="#13-4-3-1-移动构造" class="headerlink" title="13.4.3.1 移动构造"></a>13.4.3.1 移动构造</h4><p>模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*移动构造函数*/</span></span><br><span class="line">    <span class="built_in">StrVec</span>(StrVec&amp;&amp; s) <span class="keyword">noexcept</span> <span class="comment">// 移动操作不应抛出任何异常</span></span><br><span class="line">        <span class="comment">//成员初始化器接管s中的资源</span></span><br><span class="line">        :<span class="built_in">elements</span>(s.elements),<span class="built_in">first_free</span>(s.first_free),<span class="built_in">cap</span>(s.cap) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 源对象的指针全都要置空，确保移后源对象处于一个可析构的状态</span></span><br><span class="line">        s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string* elements;</span><br><span class="line">    string* first_free;</span><br><span class="line">    string* cap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>第一个参数须是该类型的右值引用，额外参数必须有默认值。（类似拷贝构造）</li></ul><h4 id="13-4-3-2-移动赋值"><a href="#13-4-3-2-移动赋值" class="headerlink" title="13.4.3.2 移动赋值"></a>13.4.3.2 移动赋值</h4><p>类似拷贝赋值：</p><ul><li>析构函数+移动构造</li><li>必须正确处理自赋值</li></ul><p>模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*拷贝赋值*/</span></span><br><span class="line">    StrVec&amp; <span class="keyword">operator</span>=(StrVec&amp;&amp; s) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">//if语句检测自赋值：对于“=”两端相同的资源，避免在使用右侧运算对象之前就释放了左侧对象（避免将自身释放）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s) &#123;  <span class="comment">// s是左值，取地址</span></span><br><span class="line">            <span class="comment">/*this-&gt;*/</span><span class="built_in">free</span>(); <span class="comment">// 释放左侧运算对象所使用的内存</span></span><br><span class="line">            elements = s.elements;</span><br><span class="line">            first_free = s.first_free;</span><br><span class="line">            cap = s.cap;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将s置于可析构状态</span></span><br><span class="line">            s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>; <span class="comment">// 源对象的指针全都要置空</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string* elements;</span><br><span class="line">    string* first_free;</span><br><span class="line">    string* cap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="13-4-3-3-合成的移动操作"><a href="#13-4-3-3-合成的移动操作" class="headerlink" title="13.4.3.3 合成的移动操作"></a>13.4.3.3 合成的移动操作</h4><p>何时会生成合成移动操作？</p><ul><li>只有当一个类<ul><li><strong>没有定义任何自己版本的拷贝控制成员</strong>，</li><li><strong>且它的所有数据成员都能移动构造或移动赋值时</strong>，编译器才会为它合成移动构造函数或移动赋值运算符。</li></ul></li></ul><p>何时移动操作被定义为删除？(P476 )</p><ul><li>与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是:<ul><li><strong>有类成员定义了自己的拷贝构造函数且未定义移动构造函数，</strong></li><li><strong>或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数</strong>。移动赋值运算符的情况类似。</li></ul></li><li>如果<strong>有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的</strong>，则类的移动构造函数或移动赋值运算符被定义为删除的。</li><li>类似拷贝构造函数，<strong>如果类的析构函数被定义为删除的或不可访问的</strong>，则类的移动构造函数被定义为删除的。</li><li>类似拷贝赋值运算符，如果<strong>有类成员是 const 的或是引用</strong>，则类的移动赋值运算符被定义为删除的。</li></ul><p>移动操作和合成拷贝之间的关系：</p><ul><li><p>如果<strong>类定义了一个移动构造函数和（或）一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为<em>删除</em></strong>。</p><ul><li>因此，定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。</li></ul></li></ul><p><strong>移动右值，拷贝左值，但如果没有移动构造函数，右值也将被拷贝。</strong>  —&gt;拷贝也是一种形式的“移动”，并且几乎是安全的。</p><ul><li><p>移动右值，拷贝左值：一个类既有拷贝构造，又有移动构造，编译器会实现最优匹配</p></li><li><p>如果没有移动构造函数，右值也将被拷贝。此种情况，即使通过<code>std::move</code>也会调用拷贝构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo &amp;); <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="comment">//未定义移动构造</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo x;</span><br><span class="line"><span class="function">Foo <span class="title">y</span><span class="params">(x)</span></span>; <span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="function">Foo <span class="title">z</span><span class="params">(std::move(x))</span></span>; <span class="comment">// 拷贝构造，因为没有定义移动构造；此处会将 Foo&amp;&amp; 隐式转化为 const Foo&amp;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="13-4-3-4-三-五法则"><a href="#13-4-3-4-三-五法则" class="headerlink" title="13.4.3.4 三/五法则"></a>13.4.3.4 三/五法则</h4><blockquote><p>所有五个拷贝控制成员应该看作一个整体：</p><p><strong>一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。</strong>如前所述，某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作(参见13.1.4 节，第447页)。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。</p></blockquote><h4 id="13-4-5-（基于）拷贝并交换（技术的）赋值运算符"><a href="#13-4-5-（基于）拷贝并交换（技术的）赋值运算符" class="headerlink" title="13.4.5 （基于）拷贝并交换（技术的）赋值运算符"></a>13.4.5 （基于）拷贝并交换（技术的）赋值运算符</h4><p>即，<strong>添加了移动构造函数之后，类中使用拷贝并交换技术的重载赋值运算符既是拷贝赋值，也是移动赋值。具体是那种赋值方式依赖于<code>operator=()</code>的实参类型：拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——移动右值，拷贝左值。如此，一个operator=函数就实现了拷贝赋值和移动赋值两种功能。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 添加移动构造</span></span><br><span class="line">    <span class="built_in">HasPtr</span>(HasPtr &amp;&amp;p)<span class="keyword">noexcept</span>:<span class="built_in">ps</span>(p.ps),<span class="built_in">i</span>(p.i)&#123;p.ps=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">// 赋值运算符既是拷贝赋值，也是移动赋值</span></span><br><span class="line">    HasPtr &amp;<span class="keyword">operator</span>=(HasPtr rhs)&#123; </span><br><span class="line">        <span class="built_in">swap</span>(*<span class="keyword">this</span>,rhs); <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考书中的论述：</p><p>值得注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁掉原对象，因此你只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法。</p><p>联想：operator=的作用包括构造+析构——对左对象析构并将右对象拷贝（移动）到左对象。</p><hr><h3 id="13-4-4-移动迭代器"><a href="#13-4-4-移动迭代器" class="headerlink" title="13.4.4 移动迭代器"></a>13.4.4 移动迭代器</h3><ul><li><p><strong>解引用移动迭代器生成右值引用</strong></p></li><li><p>调用<code>make_move_iterator()</code>将一个迭代器转为移动迭代器：<code>make_move_iterator(begin())</code></p></li><li><p>移动迭代器支持正常的迭代器操作，我们可以将一对移动迭代器传递给算法。</p></li><li><p>值得注意的是：</p><blockquote><p>值得注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁掉原对象，因此你<strong>只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法</strong>。</p></blockquote></li></ul><h2 id="13-5-右值引用和成员函数"><a href="#13-5-右值引用和成员函数" class="headerlink" title="13.5 右值引用和成员函数"></a>13.5 右值引用和成员函数</h2><h3 id="13-5-1-重载拷贝版本和移动版本"><a href="#13-5-1-重载拷贝版本和移动版本" class="headerlink" title="13.5.1 重载拷贝版本和移动版本"></a>13.5.1 重载拷贝版本和移动版本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> string&amp;s)</span></span>&#123; <span class="comment">// 拷贝：绑定到int</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        alloc.<span class="built_in">construct</span>(first_free++, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(string &amp;&amp;s)</span></span>&#123;     <span class="comment">// 移动：只能绑定到类型为int的可修改的右值 </span></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">       alloc.<span class="built_in">construct</span>(first_free++, std::<span class="built_in">move</span>(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------使用StrVec</span></span><br><span class="line">StrVec vec;</span><br><span class="line">string s = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">vec.<span class="built_in">push_back</span>(s); <span class="comment">// 调用拷贝的版本</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="string">&quot;done&quot;</span>); <span class="comment">//调用移动的版本：临时对象/常量调用右值的版本</span></span><br></pre></td></tr></table></figure><ul><li>区分拷贝和移动的重载函数通常由一个版本接受一个<code>const T&amp;</code>，而另一个版本接受一个<code>T&amp;&amp;</code></li></ul><h3 id="13-5-2-引用限定符"><a href="#13-5-2-引用限定符" class="headerlink" title="13.5.2 引用限定符"></a>13.5.2 引用限定符</h3><p>对一个右值进行赋值居然是成立的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;a&quot;</span>, s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">s1 + s2 = <span class="string">&quot;c&quot;</span>; <span class="comment">// 对s1和s2的连接结果赋值</span></span><br></pre></td></tr></table></figure><p>在新标准下可以阻止这一情况的发生：<strong>在参数列表后放置一个引用限定符</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class Foo&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Foo &amp;) &amp;;<span class="comment">//只能向可修改的左值赋值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>引用限定符可以是<code>&amp;</code>或<code>&amp;&amp;</code>，指出this可以指向一个左值或一个右值；</p></li><li><p>只能<strong>用于非static</strong>成员函数（类似const）</p></li><li><p>必须<strong>同时出现在函数的声明和定义</strong>中</p></li><li><p>可以与<code>const</code>连用，<strong>引用限定符必须在const之后</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">someM</span><span class="params">()</span> <span class="type">const</span> &amp;</span>; <span class="comment">// 必须注意const和&amp;的顺序</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>如果一个成员函数有引用限定符，则具有相同参数列表的所有参数版本都必须加引用限定符。（相同参数列表的重载版本要么都加，要么都不加引用限定符）</p><blockquote><p>就像一个成员函数可以根据是否有 const 来区分其重载版本一样(书：参见7.3.2节第247页)，引用限定符也可以区分重载版本。而且，我们可以综合引用限定符和 const 来区分一个成员函数的重载版本。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">puiblic:</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;&amp;</span>;</span><br><span class="line">    <span class="comment">//Foo sorted() const; // 错误</span></span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="type">const</span> &amp;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">(<span class="type">int</span> *)</span></span>;</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">(<span class="type">int</span> *)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------编译器会根据调用sorted的对象的左值/右值属性来确定使用哪个sorted版本</span></span><br><span class="line"><span class="built_in">retVal</span>().<span class="built_in">sorted</span>(); <span class="comment">// retVal()是右值，调用&amp;&amp;版本</span></span><br><span class="line"><span class="built_in">retFoo</span>().<span class="built_in">sorted</span>(); <span class="comment">// retFoo()是左值，调用const &amp;版本</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="十四-重载运算与类型转换"><a href="#十四-重载运算与类型转换" class="headerlink" title="十四 重载运算与类型转换"></a>十四 重载运算与类型转换</h1><h2 id="14-1-基本概念"><a href="#14-1-基本概念" class="headerlink" title="14.1 基本概念"></a>14.1 基本概念</h2><ul><li><p>除了重载的函数调用运算符<code>operator()</code>外，其他重载运算符<strong>不能含有默认实参</strong>。</p></li><li><p>对于一个运算符函数来说，它或是类的成员，或至少含有一个类类型的参数。—&gt;当运算符作用于内置类型（如int）的运算对象，我们无法改变该运算符的含义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:不能为int重定义内置的运算符</span></span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure></li><li><p>可以直接调用重载的运算符函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,等价</span></span><br><span class="line">data1+data2;</span><br><span class="line"><span class="keyword">operator</span>+(data1, data2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2,等价</span></span><br><span class="line">data1+=data2;</span><br><span class="line">data1.<span class="keyword">operator</span>+=(data2);</span><br></pre></td></tr></table></figure></li><li><p>通常情况下，可以重载却不应重载：逗号、取地址、逻辑与/或（原因：重载版本无法保留求值顺序和/或短路求值属性，导致运算符不符合用户习惯）<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403131710318400.png" alt="image-20240313162557121"></p></li></ul><ul><li><p>何时使用运算符重载？</p><ul><li>只有当操作的含义对于用户来说清晰明了时才可以重载运算符。如果用户对运算符可能有多种理解，重载运算符将产生二义性。</li></ul></li><li><p>使用与内置类型一致的含义：</p><ul><li>有<code>operator==</code>，也应有<code>operator!=</code>；有<code>operator&lt;</code>，也应有其他关系运算符。</li><li>有算符运算符或为运算符，最好也提供复合运算符。如有<code>operator+</code>，也应有<code>operator+=</code>，并用<code>+=</code>（复合）来实现<code>+</code>（算数）。</li><li>重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容：<ul><li>逻辑运算符和关系运算符应该返回 bool，</li><li>算术运算符应该返回一个类类型的值，</li><li>赋值运算符和复合赋值运算符则应该<strong>返回左侧运算对象的一个引用</strong>。</li></ul></li></ul></li><li><p>作为成员还是非成员?<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403141710401943.png" alt="image-20240314153519440"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如</span></span><br><span class="line">string s = <span class="string">&quot;w&quot;</span>;</span><br><span class="line">string t = s+<span class="string">&quot;hi&quot;</span>; <span class="comment">// 等价s.operator+(&quot;hi&quot;);</span></span><br><span class="line">string u = <span class="string">&quot;hi&quot;</span>+s; <span class="comment">// 如果+是string的成员，则产生错误</span></span><br></pre></td></tr></table></figure><blockquote><p>关于<code>对称性</code>的解释：如<code>+</code>，a+b==b+a  —&gt;对称性</p><p>因为标准库中，string将<code>+</code>定义成了普通的非成员函数，所以”hi”+s等价于operator+(“hi”,s)。</p><p>和任何其他函数调用一样，每个实参都能被转换成形参类型。唯一的要求是至少有一个运算对象是类类型，并且两个运算对象都能准确无误地转换成string。</p></blockquote></li></ul><h2 id="14-2-输入和输出运算符"><a href="#14-2-输入和输出运算符" class="headerlink" title="14.2 输入和输出运算符"></a>14.2 输入和输出运算符</h2><p><strong>非成员</strong></p><h3 id="14-2-1-operator-lt-lt"><a href="#14-2-1-operator-lt-lt" class="headerlink" title="14.2.1 operator&lt;&lt;"></a>14.2.1 operator&lt;&lt;</h3><ul><li><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream&amp;os, <span class="type">const</span> Sales_data &amp;item)&#123;</span><br><span class="line">    os&lt;&lt;item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">        &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>operator&lt;&lt;</code>应尽量减少格式化操作，更不应打印换行符。</p></li><li><p><code>operator&lt;&lt;</code>必须是非成员函数，又因需要读写非公成员，一般设置为友元。</p></li></ul><h3 id="14-2-2-operator-gt-gt"><a href="#14-2-2-operator-gt-gt" class="headerlink" title="14.2.2 operator&gt;&gt;"></a>14.2.2 operator&gt;&gt;</h3><ul><li><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Sales_data &amp;item)&#123;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">    is&gt;&gt;item.bookNo&gt;&gt;item.units_sold&gt;&gt;price;</span><br><span class="line">    <span class="keyword">if</span>(is) <span class="comment">// 检查输入是否成功</span></span><br><span class="line">        item.revenue = item.units_sold * price;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 输入失败，对象被赋予默认状态</span></span><br><span class="line">        <span class="comment">// 当读取操作发生错误时，</span></span><br><span class="line">        item = <span class="built_in">Sales_data</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>operator&gt;&gt;</code>必须处理输入可能失败的情况。利用<code>if(is)</code>检查是否输入成功。</p><ul><li>当流含有错误类型的数据时，读取操作可能失败：如输入的是int，读取的对象要求string</li><li>当读取到达文件尾 或 遇到输入流的其他错误</li></ul></li></ul><ul><li><code>operator&gt;&gt;</code>也应该设置流的条件状态以标识出失败信息：<ul><li>通常情况下，只需设置<code>failbit</code></li><li>除此之外，设置<code>eofbit</code>表示文件耗尽，<code>badbit</code>表示流被破坏等</li></ul></li></ul><h2 id="14-3-算数和关系运算符"><a href="#14-3-算数和关系运算符" class="headerlink" title="14.3 算数和关系运算符"></a>14.3 算数和关系运算符</h2><ul><li>通常情况下，我们把算数和关系运算符定义成<strong>非成员</strong>函数以允许左侧或右侧的运算对象进行转换</li><li>形参一般为常量的引用，<code>const Sales_data &amp;lhs</code></li></ul><h3 id="14-3-1-算数运算符"><a href="#14-3-1-算数运算符" class="headerlink" title="14.3.1 算数运算符"></a>14.3.1 算数运算符</h3><ul><li>最有效的方式是使用复合赋值来定义算数运算符，<code>+=</code> —&gt; <code>+</code></li></ul><h3 id="14-3-2-相等运算符"><a href="#14-3-2-相等运算符" class="headerlink" title="14.3.2 相等运算符"></a>14.3.2 相等运算符</h3><ul><li>相等运算符和不相等运算符中的一个应该把工作委托给另一个</li></ul><h3 id="14-3-3-关系运算符"><a href="#14-3-3-关系运算符" class="headerlink" title="14.3.3 关系运算符"></a>14.3.3 关系运算符</h3><ul><li>因为关联容器和一些算法要用到小于运算符，所以定义<code>operator&lt;</code>会比较有用</li><li>如果存在唯一一种逻辑可靠的<code>&lt;</code>定义，则应该考虑为这个类定义<code>&lt;</code>运算符；顺序关系应与关联容器中对关键字的要求一致。</li><li>如果该类同时包含<code>==</code>，则当且仅当<code>&lt;</code>的定义和<code>==</code>产生的结果一致时才定义<code>&lt;</code>运算符；特别是，如果两个对象时<code>!=</code>的，那么一个对象应该<code>&lt;</code>另外一个。（解释：P498-14.3.2-（第5段）尽管……）</li></ul><h2 id="14-4-赋值运算符"><a href="#14-4-赋值运算符" class="headerlink" title="14.4 赋值运算符"></a>14.4 赋值运算符</h2><ul><li>赋值运算符必须定义成<strong>类的成员</strong>，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。</li></ul><ul><li><p>赋值，除了移动赋值和拷贝赋值，还可接受元素列表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v;</span><br><span class="line">v = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StrVec &amp;<span class="keyword">operator</span>=(std::initializer_list&lt;std::string&gt; il)&#123;</span><br><span class="line">        <span class="keyword">auto</span> data = <span class="built_in">alloc_n_copy</span>(il.<span class="built_in">begin</span>(), il.<span class="built_in">end</span>()); <span class="comment">// 分配空间并拷贝元素</span></span><br><span class="line">        <span class="comment">/*this-&gt;*/</span><span class="built_in">free</span>(); <span class="comment">// 释放当前对象的内存</span></span><br><span class="line">        elements = data.first; <span class="comment">// 更新数据成员使其指向新的空间</span></span><br><span class="line">        first_free = cap = data.second;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>赋值运算符必须释放当前内存，在创建新内存。</li><li>此处不同的是，不必检查自我赋值</li></ul></li></ul><ul><li><p>复合赋值运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sales_data &amp;Sales_data::<span class="keyword">operator</span>+=(<span class="type">const</span> Sales_data &amp;rhs)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="14-5下标运算符"><a href="#14-5下标运算符" class="headerlink" title="14.5下标运算符"></a>14.5下标运算符</h2><ul><li><p><code>operator[]</code>必须是<strong>成员函数</strong></p></li><li><p>通常返回访问元素的引用</p></li><li><p>通常同时定义常量版本和非常量版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> elements[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> std::string&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> elements[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; elements-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string elements[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StrVec svec;</span><br><span class="line">    <span class="type">const</span> StrVec&amp; cvec = svec;</span><br><span class="line">    <span class="keyword">if</span> (svec.<span class="built_in">size</span>() &amp;&amp; svec[<span class="number">0</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        svec[<span class="number">0</span>] = <span class="string">&quot;zero&quot;</span>;</span><br><span class="line">        <span class="comment">//cvec[0] = &quot;zero&quot;;//没有与这些操作数匹配的&quot;=&quot;运算符.操作数类型为:  const std::string = const char [5]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="14-6-递增递减运算符"><a href="#14-6-递增递减运算符" class="headerlink" title="14.6 递增递减运算符"></a>14.6 递增递减运算符</h2><ul><li><p>建议是<strong>类的成员</strong></p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlobPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 前置 */</span></span><br><span class="line">    <span class="comment">// 如果显示调用则：p.operator++();</span></span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>++(); <span class="comment">// 返回递增或递减后对象的**引用**</span></span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 后置 */</span></span><br><span class="line">    <span class="comment">// 后置版本接受一个额外的（不被使用的）int类型的形参，该形参仅用于重载(用于区分前置和后置)</span></span><br><span class="line">    <span class="comment">// 如果显示调用则：p.operator++(0);</span></span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>++(<span class="type">int</span>); <span class="comment">// 应该返回对象的原值，返回的形式是一个**值**而非引用</span></span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>--(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">check</span>(curr, <span class="string">&quot;increment past end of StrBlobPtr.&quot;</span>);</span><br><span class="line">    <span class="comment">// check的作用：</span></span><br><span class="line">    <span class="comment">// 1-检查StrBlobPtr是否有效</span></span><br><span class="line">    <span class="comment">// 2-索引值是否有效  --&gt;curr已经到达vector末尾，则抛出异常</span></span><br><span class="line">    </span><br><span class="line">    ++curr;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">    --curr;</span><br><span class="line">    <span class="built_in">check</span>(curr, <span class="string">&quot;decrement past begin of StrBlobPtr.&quot;</span>);</span><br><span class="line">    <span class="comment">// curr如果已经是0，`--`后将是一个表示无效下标的非常大的正数值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="14-7-成员访问运算符"><a href="#14-7-成员访问运算符" class="headerlink" title="14.7 成员访问运算符"></a>14.7 成员访问运算符</h2><ul><li><p>常用语迭代器类及智能指针类</p></li><li><p>箭头运算符(<code>-&gt;</code>)必须是<strong>类的成员</strong>，解引用运算符(<code>*</code>)通常是类的成员。</p></li><li><p>这两个函数都是const函数，返回非const的引用或指针</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlobPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 成员访问运算符 */</span></span><br><span class="line">    std::string&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">check</span>(curr, <span class="string">&quot;dereference past end.&quot;</span>); <span class="comment">// 检查curr是否在合法范围内</span></span><br><span class="line">        <span class="keyword">return</span> (*p)[curr];  <span class="comment">// *p为对象所指的vector</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// 将实际工作交于operator*(),返回解引用结果的地址</span></span><br><span class="line">        <span class="keyword">return</span> &amp;<span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>对箭头运算符返回值有限定，只能用于获取成员。</p><blockquote><p>重载的箭头运算符必须返回类的指针 或 自定义了箭头运算符的某个类的对象</p></blockquote><p>对于<code>point-&gt;mem</code>，只能有两种含义，具体取决于<code>point</code>的类型：</p><ul><li><p>如果<code>point</code>是一个指针类型，那么<code>point-&gt;mem</code>等价于<code>(*point).mem</code>，表示访问指针<code>point</code>指向的对象的<code>mem</code>成员。</p></li><li><p>如果<code>point</code>是一个类类型的对象，并且该类重载了<code>operator-&gt;</code>，那么<code>point-&gt;mem</code>会调用<code>point.operator-&gt;()</code>来获取一个指针，然后再访问该指针的<code>mem</code>成员。</p></li></ul></li></ul><p>  这样的机制允许类型设计者为其类对象提供类似于指针的接口，使得使用这些对象时能够有类似直接使用指针一样的语法和方便性。</p><h2 id="14-8-函数调用运算符"><a href="#14-8-函数调用运算符" class="headerlink" title="14.8 函数调用运算符"></a>14.8 函数调用运算符</h2><h3 id="14-8-1-基础"><a href="#14-8-1-基础" class="headerlink" title="14.8.1 基础"></a>14.8.1 基础</h3><ul><li><p>必须是<strong>成员函数</strong></p></li><li><p>函数对象：对象的行为像函数一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">absInt</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt; <span class="number">0</span> ? -val : val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">-42</span>;</span><br><span class="line">    absInt absObj;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">absObj</span>(i);</span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; std::endl; <span class="comment">// 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>函数对象常常作为泛型算法的实参</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrintString</span>(ostream&amp; o = cout, <span class="type">char</span> c = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        :<span class="built_in">os</span>(o), <span class="built_in">step</span>(c) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp; s)</span><span class="type">const</span> </span>&#123; os &lt;&lt; s &lt;&lt; step; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ostream&amp; os;</span><br><span class="line">    <span class="type">char</span> step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本用法</span></span><br><span class="line">    string s = <span class="string">&quot;s&quot;</span>;</span><br><span class="line">    PrintString priterner;</span><br><span class="line">    <span class="built_in">priterner</span>(s); <span class="comment">// s</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数对象常常作为泛型算法的实参</span></span><br><span class="line">    vector&lt;string&gt; vs&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">    for_each(vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>(), <span class="built_in">PrintString</span>(cerr,<span class="string">&quot;\n&quot;</span>)); <span class="comment">// a b c</span></span><br><span class="line">    <span class="comment">// 首次时，PrintString()创建临时对象；</span></span><br><span class="line">    <span class="comment">// 之后for_each()的内部代码会调用这个对象（此时运行operator()）以排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="14-8-2-lambda表达式与operator"><a href="#14-8-2-lambda表达式与operator" class="headerlink" title="14.8.2 lambda表达式与operator()"></a>14.8.2 lambda表达式与operator()</h3><p>一、无捕获行为的lambda</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>();&#125;</span><br><span class="line"><span class="comment">// 等价</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShorterString</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        <span class="comment">//默认情况下lambda不能改变它捕获的变量。</span></span></span><br><span class="line"><span class="function">        <span class="comment">//因此在默认情况下，由lambda产生的类当中的函数调用运算符是一个const成员函数。</span></span></span><br><span class="line"><span class="function">        <span class="comment">//如果lambda被声明为可变的，则调用运算符就不是const的了。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*于是有*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stable_short</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b)</span><br><span class="line">             &#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>();&#125;);</span><br><span class="line"><span class="comment">// 等价</span></span><br><span class="line"><span class="built_in">stable_short</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),<span class="built_in">ShorterString</span>());</span><br><span class="line"><span class="comment">//第三个实参是新构建的Shorterstring对象，当stable_sort内部的代码每次比较两个string时就会“调用”这一对象，</span></span><br><span class="line"><span class="comment">//此时该对象将调用运算符的函数体，判断第一个string的大小小于第二个时返回 true。</span></span><br></pre></td></tr></table></figure><p>二、有捕获行为的lambda</p><blockquote><p>如我们所知，当一个lambda 表达式<strong>通过引用捕获变量时</strong>，将由程序负责确保lambda执行时引用所引的对象确实存在(参见10.3.3节，第350页)。因此，编译器可以直接使用该引用而<strong>无须</strong>在lambda产生的类中将其存储为数据成员。</p><p>相反，<strong>通过值捕获</strong>的变量被拷贝到lambda中(参见10.3.3节，第350页)。因此，这种<strong>lambda产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。</strong></p></blockquote><p>如，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">        [sz](<span class="type">const</span> string&amp; a) &#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz; &#125;);</span><br></pre></td></tr></table></figure><p>lambda将产生如下类，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SizeComp</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SizeComp</span>(std::<span class="type">size_t</span> n) :<span class="built_in">sz</span>(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp; s)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> sz;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda表达式产生的类不含默认构造函数、赋值运算符及默认析构函数;</span></span><br><span class="line"><span class="comment">//它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定</span></span><br></pre></td></tr></table></figure><p>则find_if等价于，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),<span class="built_in">SizeComp</span>(sz));</span><br></pre></td></tr></table></figure><h3 id="14-8-3-标准库定义的函数对象"><a href="#14-8-3-标准库定义的函数对象" class="headerlink" title="14.8.3 标准库定义的函数对象"></a>14.8.3 标准库定义的函数对象</h3><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403171710648132.png" alt="image-20240317120201949"></p><ul><li><p>标准库（<code>#include &lt;functional&gt;</code>）定义了一组表示算数运算、关系运算符和逻辑运算符的类，每个类分别定义了执行命名操作的调用运算符。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;<span class="type">int</span>&gt; intAdd;</span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">intAdd</span>(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//sum=30</span></span><br><span class="line"></span><br><span class="line">negate&lt;<span class="type">int</span>&gt; intNeg; <span class="comment">// 取反</span></span><br><span class="line"><span class="type">int</span> neg = <span class="built_in">intNeg</span>(<span class="number">-10</span>); <span class="comment">// neg = 10</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在算法中使用标准库函数</p><ul><li><p>表示运算符的函数对象类常用来替换算法中的默认运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认使用operator&lt;将序列升序，可做如下更改使其降序排列</span></span><br><span class="line"><span class="built_in">sort</span>(svec.<span class="built_in">begin</span>(), svec.<span class="built_in">end</span>(), greater&lt;string&gt;); <span class="comment">// 大于比较运算</span></span><br></pre></td></tr></table></figure></li><li><p>标准库规定其函数对于指针同样使用</p><ul><li><p>首先对于顺序容器，我们之前曾经介绍过比较两个无关指针将产生未定义的行为(书：参见3.5.3节，第107页)，然而我们可能会<strong>希望通过比较指针的内存地址来排序指针的vector</strong>。直接这么做将产生未定义的行为，因此我们可以使用一个标准库函数对象来实现该目的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string*&gt; nameTab;</span><br><span class="line"><span class="comment">// 错误，nameTab中的指针彼此没有关联，&lt;将产生未定义行为</span></span><br><span class="line"><span class="built_in">sort</span>(nameTab.<span class="built_in">begin</span>(), nameTab.<span class="built_in">end</span>(),</span><br><span class="line">    [](string* a, string* b) &#123;<span class="keyword">return</span> a &lt; b; &#125;); <span class="comment">// 妄图通过比较内存地址，类排序vector，将不会成功</span></span><br><span class="line"><span class="comment">// 正确,标准库规定指针的less是定义良好的</span></span><br><span class="line"><span class="built_in">sort</span>(nameTab.<span class="built_in">begin</span>(), nameTab.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;string*&gt;());</span><br></pre></td></tr></table></figure></li><li><p>其次，关联容器可以直接排序指针，而无需显式地声明。</p><blockquote><p>关联容器使用 <code>less&lt;key_type&gt;</code>对元素排序，因此我们可以定义一个指针的set或者在map中 使用指针作为关键值而无须直接声明less。</p></blockquote></li></ul></li></ul></li></ul><h3 id="14-8-4-可调用对象与function"><a href="#14-8-4-可调用对象与function" class="headerlink" title="14.8.4 可调用对象与function"></a>14.8.4 可调用对象与function</h3><ul><li><p>C++语言中有几种可调用的对象：函数、函数指针、lambda表达式(书：参见10.3.2节，第 346页)、bind 创建的对象(书：参见10.3.4节，第354页)以及重载了函数调用运算符的类。</p></li><li><p>不同的类型可能具有相同的调用方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如下可调用对象</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;<span class="keyword">return</span> i+j;&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="type">int</span> i, <span class="type">int</span> j)&#123;<span class="keyword">return</span> i%j; &#125;;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">divide</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i/j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具有相同的调用形式</span></span><br><span class="line"><span class="built_in">int</span>(<span class="type">int</span>, <span class="type">int</span>)</span><br></pre></td></tr></table></figure></li><li><p>使用<code>map</code>创建<em>函数表</em>用于存储可调用这些对象的“指针”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>(*)(<span class="type">int</span>, <span class="type">int</span>)&gt; binops;</span><br><span class="line">binops.<span class="built_in">insert</span>(&#123;<span class="string">&quot;+&quot;</span>,add&#125;); <span class="comment">// &#123;&quot;+&quot;,add&#125;:pair</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是不能将mod和divide存入binops</span></span><br><span class="line"><span class="comment">// 问题在于mod是个lambda表达式，而每个lambda有其自己的类型，该类型与存储在binops中的值的类型不匹配</span></span><br><span class="line"><span class="comment">// 如何才能将mod和divide存入binops呢？使用function&lt;T&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>function&lt;T&gt;</code></p><ul><li><p><code>#include &lt;functional&gt;</code><br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403171710654733.png" alt="image-20240317135208426"></p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i + j; &#125;</span><br><span class="line"><span class="comment">// 2.lambda</span></span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="type">int</span> i, <span class="type">int</span> j) &#123;<span class="keyword">return</span> i % j; &#125;;</span><br><span class="line"><span class="comment">// 3.可调用对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">divide</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i / j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = add; <span class="comment">// 函数指针</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f2 = <span class="built_in">divide</span>(); <span class="comment">// 函数对象类的对象</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f3 = mod; <span class="comment">// lambda</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f1</span>(<span class="number">4</span>, <span class="number">2</span>) &lt;&lt; endl; <span class="comment">// 6</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f2</span>(<span class="number">4</span>, <span class="number">2</span>) &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f3</span>(<span class="number">4</span>, <span class="number">2</span>) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建map函数表</span></span><br><span class="line">    map&lt;string, function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; binops = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;+&quot;</span>,add&#125;,                  <span class="comment">// 函数指针</span></span><br><span class="line">        &#123;<span class="string">&quot;-&quot;</span>,std::<span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;()&#125;,    <span class="comment">// 标准库中的函数对象</span></span><br><span class="line">        &#123;<span class="string">&quot;/&quot;</span>,<span class="built_in">divide</span>()&#125;,             <span class="comment">// 用户定义的函数对象</span></span><br><span class="line">        &#123;<span class="string">&quot;*&quot;</span>,[](<span class="type">int</span> i, <span class="type">int</span> j) &#123;<span class="keyword">return</span> i * j; &#125;&#125;, <span class="comment">// 未命名的lambda</span></span><br><span class="line">        &#123;<span class="string">&quot;%&quot;</span>,mod&#125; <span class="comment">// 命名的lambda</span></span><br><span class="line">    &#125;;</span><br><span class="line">    cout &lt;&lt; binops[<span class="string">&quot;+&quot;</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 15</span></span><br><span class="line">    cout &lt;&lt; binops[<span class="string">&quot;-&quot;</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line">    cout &lt;&lt; binops[<span class="string">&quot;/&quot;</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">    cout &lt;&lt; binops[<span class="string">&quot;*&quot;</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 50</span></span><br><span class="line">    cout &lt;&lt; binops[<span class="string">&quot;%&quot;</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>但是我们不能不能直接将重载的函数名置于<code>function&lt;T&gt;</code>中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;<span class="keyword">return</span> i+j;&#125;</span><br><span class="line"><span class="comment">// 2.重载add</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">map&lt;string, function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; binops;</span><br><span class="line">binops.<span class="built_in">insert</span>(&#123;<span class="string">&quot;+&quot;</span>,add&#125;); <span class="comment">// 错误：哪一个add？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种方法解决该二义性问题</span></span><br></pre></td></tr></table></figure><ul><li><p>将函数指针传入function，而不是直接传入重载的函数的名字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>) = add;</span><br><span class="line">binops.<span class="built_in">insert</span>(&#123;<span class="string">&quot;+&quot;</span>,fp&#125;);</span><br></pre></td></tr></table></figure></li><li><p>用lambda消除二义性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binops.<span class="built_in">insert</span>(&#123;<span class="string">&quot;+&quot;</span>,[](<span class="type">int</span> i, <span class="type">int</span> j)&#123; <span class="keyword">return</span> <span class="built_in">add</span>(a,b);&#125;&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="14-9-重载、类型转换与运算符"><a href="#14-9-重载、类型转换与运算符" class="headerlink" title="14.9 重载、类型转换与运算符"></a>14.9 重载、类型转换与运算符</h2><h3 id="14-9-1-类型转换运算符"><a href="#14-9-1-类型转换运算符" class="headerlink" title="14.9.1 类型转换运算符"></a>14.9.1 类型转换运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><ul><li>type可以是void之外的任意类型；</li><li>type不允许转换成数组或者函数类型，但允许转换成指针（包括数组指针及函数指针）或引用类型。</li><li>type也是该函数的返回类型</li><li>没有显式返回类型，type()中也不能写形参</li><li>必须定义成类的<strong>成员函数</strong></li><li>一般定义成const（类型转换通常不改变转换对象的内容）</li></ul><p>举例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="type">int</span> i = <span class="number">0</span>):<span class="built_in">val</span>(i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;<span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Bad SmallInt value.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SmallInt si;</span><br><span class="line">    si = <span class="number">4</span>; <span class="comment">// 4被隐式转换为SmallInt，然后调用SmallInt::operator=</span></span><br><span class="line">    si + <span class="number">3</span>; <span class="comment">// si被隐式转化为int，后执行整数加法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，隐式转换有时会带来一些问题(书P515底~516顶)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//operator bool()引发的问题</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">cin &lt;&lt; i;</span><br></pre></td></tr></table></figure><p>上述代码的解释：cin没有定义&lt;&lt;，这段代码本应报错。然而，cin中使用了operator bool()，将cin隐式转化成了bool，bool又被提升为了int，并被作为内置左移运算符的左侧运算对象。最终，提升后的bool（0或1）被左移了42个位置。</p><p>因此在必要的时候，需要用<code>explicit</code>禁用隐式转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="type">int</span> i = <span class="number">0</span>):<span class="built_in">val</span>(i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;<span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Bad SmallInt value.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SmallInt si;</span><br><span class="line">    si = <span class="number">4</span>; <span class="comment">// 4被隐式转换为SmallInt，然后调用SmallInt::operator=</span></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(si) + <span class="number">3</span>; <span class="comment">// si被显式转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意，在下列情况（表达式被用作条件时），显式类型转换将被隐式地执行：</p><ul><li>if、while、do的条件部分</li><li>for语句头的条件表达式</li><li>？ ：的条件表达式</li><li>！，||，&amp;&amp;</li></ul><p>对于上文因为operator bool()引发的问题，将其定义为explicit后，只有在条件中，才会隐式转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(std::cin &gt;&gt; value)&#123;&#125;</span><br></pre></td></tr></table></figure><p>对于此过程的解释：while 语句的条件执行输入运算符，它负责将数据读入到 value 并返回cin。为了对条件求值，cin被istream operator bool类型转换函数隐式地执行了转换。如果cin的条件状态是 good(参见8.1.2 节，第280 页)，则该函数返回为真；否则该函数返回为假。</p><blockquote><p>bool 的类型转换通常用在条件部分，因此<strong>operator bool一般定义成explicit</strong></p></blockquote><h3 id="14-9-2-避免有二义性的类型转换"><a href="#14-9-2-避免有二义性的类型转换" class="headerlink" title="14.9.2 避免有二义性的类型转换"></a>14.9.2 避免有二义性的类型转换</h3><p>（:question:有些难以理解）</p><ul><li>不要在两个类之间构建相同的类型转换，反例如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> B&amp;);  <span class="comment">// 以B为参数的构造函数，B-&gt;A</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//类型转换运算符，B-&gt;A</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">(<span class="type">const</span> A&amp;)</span></span>;</span><br><span class="line">B b;</span><br><span class="line">A a = <span class="built_in">f</span>(b); <span class="comment">// 二义性错误，不知道调用f(B::operator A())还是f(A::A(const B&amp;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如何解决上述问题？</span></span><br><span class="line"><span class="comment">//显式调用类型转换运算符 或 转换构造函数</span></span><br><span class="line">A a1 = <span class="built_in">f</span>(b.<span class="keyword">operator</span> <span class="built_in">A</span>());</span><br><span class="line">A a2 = <span class="built_in">f</span>(<span class="built_in">A</span>(b));</span><br><span class="line"><span class="comment">//注意，不可用强制类型转换，因为其本身也会碰到二义性问题</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>二义性与转换目标为内置类型的多重类型转换<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">// 最好不要创建两个转换源都是算数类型的类型转换，反例：</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>  = <span class="number">0</span>);    </span><br><span class="line">    <span class="built_in">A</span>(<span class="type">double</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最好不要创建两个转换对象都是算数类型的类型转换，反例：</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="keyword">operator</span> <span class="type">double</span> <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">long</span> <span class="type">double</span>)</span></span>;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">f2</span>(a); <span class="comment">// 二义性错误：f(A::operator int())还是f(A::operator double()) ?</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> lg;</span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(lg)</span></span>; <span class="comment">//二义性错误：A::A(int)还是A::A(double) ?</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> s = <span class="number">42</span>;</span><br><span class="line"><span class="function">A <span class="title">a3</span><span class="params">(s)</span></span>; <span class="comment">// 使用A::A(int),把short提升为int的优先级 大于 short提升为double</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>总结</li></ul><p><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403181710750203.png" alt="image-20240318162313244"></p><ul><li><p>重载函数与转换构造函数</p><ul><li>调用重载函数时，如果多个类型转换都提供了同一种可行的匹配，则这些类型转换优先级一样（书：这些类型转换一样好）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个转换构造函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    <span class="built_in">D</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载的manip()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">const</span> D&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">manip</span>(<span class="number">10</span>); <span class="comment">// 二义性错误，manip(C(10))还是manip(D(10));</span></span><br><span class="line"><span class="built_in">manip</span>(<span class="built_in">C</span>(<span class="number">10</span>)); <span class="comment">// 正确，需要显式声明</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>重载函数与用户定义的类型转换<br>同时，这种情况也不会考虑任何可能出现的优先级</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="built_in">E</span>(<span class="type">double</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载的manip()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip2</span><span class="params">(<span class="type">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip2</span><span class="params">(<span class="type">const</span> E&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">manip2</span>(<span class="number">10</span>); <span class="comment">// 二义性错误，manip(C(10))还是manip(E(double(10))) ?</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>只有当重载函数能<strong>通过同一个类型</strong>转换函数得到匹配时，我们才会考虑其中的类型转换（:question:同一类型转换指？原文书P520中间）</li></ul><blockquote><p>如果在调用重载函数时我们需要使用构造函数或者强制类型转换来改变实参的类型，则这通常意味着程序的设计存在不足。</p></blockquote><h3 id="14-9-3-函数匹配与重载的运算符"><a href="#14-9-3-函数匹配与重载的运算符" class="headerlink" title="14.9.3 函数匹配与重载的运算符"></a>14.9.3 函数匹配与重载的运算符</h3><ul><li><p>当在表达式中使用重载的运算符时，无法判断在使用的是成员函数还是非成员函数，他们都在候选函数集中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a + b 可能是</span></span><br><span class="line">a.<span class="keyword">operator</span>+(b);</span><br><span class="line"><span class="keyword">operator</span>+(a,b);</span><br></pre></td></tr></table></figure><p>对比：调用一个命名函数时，具有该名字的成员函数和非成员函数不会彼此重载，因为他们的调用语法是不同的。</p></li></ul><ul><li>如果我们对<strong>同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符</strong>，则将会遇到重载运算符与内置运算符的二义性问题。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> SmallInt <span class="keyword">operator</span>+(<span class="type">const</span> SmallInt&amp;, <span class="type">const</span> SmallInt&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="type">int</span> = <span class="number">0</span>) &#123;&#125;; <span class="comment">// int -&gt; SmallInt</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125; <span class="comment">// SmallInt -&gt; int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SmallInt s1, s2;</span><br><span class="line"></span><br><span class="line">SmallInt s3 = s1 + s2; <span class="comment">// 正确，使用重载的operator+</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = s3 + <span class="number">0</span>; <span class="comment">// 二义性错误</span></span><br><span class="line"><span class="comment">// 我们可以把0转换成SmallInt，然后使用SmallInt的+;</span></span><br><span class="line"><span class="comment">// 或者把s3转换成int，然后对于两个int 执行内置的加法运算。</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="十五-面向对象程序设计"><a href="#十五-面向对象程序设计" class="headerlink" title="十五 面向对象程序设计"></a>十五 面向对象程序设计</h1><h2 id="15-1-OOP：概述"><a href="#15-1-OOP：概述" class="headerlink" title="15.1 OOP：概述"></a>15.1 OOP：概述</h2><p>oop核心思想：数据抽象、继承、动态绑定。（或者说：封装、继承、多态）</p><ul><li><p>数据抽象：类的接口与实现分离</p></li><li><p>继承</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span> n)</span> <span class="type">const</span></span>; <span class="comment">// 虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote&#123;  <span class="comment">// public继承，我们完全可以把Bulk_quote的对象当成Quote的对象来用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span> n)</span> <span class="type">const</span> <span class="keyword">override</span></span>; <span class="comment">// 重写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>动态绑定（或者说运行时绑定）</p><ul><li>函数的运行版本由实参决定</li><li>当我们使用基类的<strong>引用、指针</strong>调用一个<strong>虚函数</strong>时，将引发动态绑定</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">print_total</span><span class="params">(<span class="type">const</span> Quote&amp; item, <span class="type">size_t</span> n)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> ret = item.<span class="built_in">net_price</span>(n);</span><br><span class="line">    <span class="comment">// 当item是Quote类型时调用Quote::net_price()</span></span><br><span class="line">    <span class="comment">// 当item是Bulk_quote类型时调用Bulk_quote::net_price()</span></span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;isbn: &quot;</span>&lt;&lt;item.<span class="built_in">isbn</span>()</span><br><span class="line">        &lt;&lt;<span class="string">&quot; sold: &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; total due: &quot;</span>&lt;&lt;ret&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="15-2-定义基类和派生类"><a href="#15-2-定义基类和派生类" class="headerlink" title="15.2 定义基类和派生类"></a>15.2 定义基类和派生类</h2><h3 id="15-2-1-定义基类"><a href="#15-2-1-定义基类" class="headerlink" title="15.2.1 定义基类"></a>15.2.1 定义基类</h3><ul><li><p><strong>基类通常都会定义一个虚析构函数</strong>，即使该函数不执行任何实际操作也是如此。</p></li><li><p>任何构造函数之外的非静态函数，都可以是虚构函数</p></li><li><strong>virtul只能出现在类内的声明语句之前</strong>，而不能用于类外部的函数定义</li></ul><h3 id="15-2-2-定义派生类"><a href="#15-2-2-定义派生类" class="headerlink" title="15.2.2 定义派生类"></a>15.2.2 定义派生类</h3><ul><li><p><strong>继承列表</strong>中，访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见。</p><blockquote><p>如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。此外，我们能将公有派生类型的对象绑定到基类的引用或指针上。因为我们在派生列表中使用了public，所以 Bulk_quote的接口隐式地包含 isbn 函数，同时在任何需要 Quote的引用或指针的地方我们都能使用Bulkquote的对象。</p></blockquote></li></ul><p>派生类中的虚函数</p><ul><li><p><strong>覆盖虚函数</strong>：如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员,派生类会直接继承其在基类中的版本。</p></li><li><p><strong>override</strong>的位置：写在声明语句最后。</p><blockquote><p>在形参列表后面、或者在const成员函数的 const 关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字override。</p></blockquote></li></ul><p>派生类对象及派生类向基类的类型转换</p><ul><li><p>因为在派生类对象中含有与其基类对应的组成部分，所以我们<strong>能把派生类的对象当成基类对象来使用</strong>，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403192013939.png" alt="image-20240319201317821"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Quote item; <span class="comment">// 基类对象</span></span><br><span class="line">Bulk_quote bulk; <span class="comment">// 子类对象</span></span><br><span class="line">Quote *p = &amp;item;  <span class="comment">// p指向Quote对象</span></span><br><span class="line"></span><br><span class="line">p = &amp;bulk; <span class="comment">// p指向bulk的Quote部分</span></span><br><span class="line">Quote &amp;r = bulk; <span class="comment">// p绑定到bulk的Quote部分</span></span><br><span class="line"><span class="comment">// 以上两个转换被称为  派生类到基类的转换  --&gt; 继承的关键所在</span></span><br></pre></td></tr></table></figure><p>这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方;同样的，我们也可以把派生类对象的指针用在需要基类指针的地方。</p><ul><li><strong>基类指针指向派生类（的基类部分）  —&gt; 继承的关键所在（多态、动态绑定）</strong></li></ul></li></ul><p>​        </p><p>在派生类中构造基类</p><ul><li><p>每个类控制它自己的成员初始化过程</p><blockquote><p>尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp; book, <span class="type">double</span> p, std::<span class="type">size_t</span> qty, <span class="type">double</span> disc)</span><br><span class="line">        :<span class="built_in">Quote</span>(book, p) <span class="comment">/* 通过初始化列表将实参传递给基类构造函数,否则基类部分会执行默认初始化 */</span></span><br><span class="line">            , <span class="built_in">min_qty</span>(qty), <span class="built_in">discount</span>(disc)&#123;&#125; </span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    std::<span class="type">size_t</span> min_qty;</span><br><span class="line">    <span class="type">double</span> discount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>在派生类中使用基类成员</p><ul><li><p>对于派生类，访问自己的成员和访问基类成员的方式一样。</p><blockquote><p><strong>派生类的作用域嵌套在基类的作用域之内</strong>。因此，对于派生类的一个成员来说，它使用派生类成员的方式与使用基类成员的方式没什么不同。</p></blockquote></li><li><p>然而，即使访问方式一样，也不能直接初始化基类的成员。</p><blockquote><p>必须明确一点:<strong>每个类负责定义各自的接口</strong>。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。 因此，<strong>派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。</strong>和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</p></blockquote></li></ul><p>继承与静态成员</p><p>:question:</p><p>派生类的声明</p><ul><li><p>派生类的声明中包含类名但不得包含其派生列表。</p></li><li><p>派生列表及与定义有关的其他细节必须与类的主题一起出现。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote; <span class="comment">// 错误，派生列表不能出现在这里</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span>; <span class="comment">// 正确，声明派生类的正确方式</span></span><br></pre></td></tr></table></figure></li></ul><p>被用作基类的类</p><ul><li><p>如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。 — &gt; 一个类不能派生其本身</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>; <span class="comment">// 声明但未定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote&#123;&#125;; <span class="comment">// 错误，必须被定义Quote</span></span><br></pre></td></tr></table></figure></li></ul><p>防止继承的发生</p><ul><li><p>在类名后面加<code>final</code>，以阻止继承</p></li><li><p>在函数后面加<code>final</code>，任何尝试覆盖该函数的操作都将引发错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span>:B&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D3</span> :D2&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>;  <span class="comment">//错误，D2已经声明为final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="15-2-3-类型转换与继承"><a href="#15-2-3-类型转换与继承" class="headerlink" title="15.2.3 类型转换与继承"></a>15.2.3 类型转换与继承</h3><p>派生类 —&gt; 基类的隐式转换</p><ul><li><p>我们可以将基类的指针或引用绑定到派生类对象上。</p></li><li><p>当使用基类的<strong>引用(或指针)</strong>时，实际上我们并不清楚该引用(或指针)所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象（动态类型）。</p></li><li><p>区分静态类型和动态类型</p><ul><li><p>静态类型：字面上要求的类型</p></li><li><p>动态类型：多态、动态绑定的类型</p></li></ul></li><li><p>如果表达式既不是引用也不是指针，则其动态类型 == 静态类型。</p></li></ul><p>但是不存在  基类  —&gt; 派生类的隐式转换</p><ul><li><p>因为  这样有可能会访问  基类中本不存在的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Quote base;</span><br><span class="line">Bulk_quote * bulkP = &amp;base; <span class="comment">// 错误，不能将基类转化为派生类</span></span><br></pre></td></tr></table></figure></li><li><p>即使一个基类指针或引用绑定在一个派生类对象上，也不能执行基类向派生类的转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *itemP = &amp;bulk; <span class="comment">// 正确，动态类型是Bulk_quote</span></span><br><span class="line">Bulk_qoute *bulk = itemP; <span class="comment">// 错误，不能将基类转换成派生类（除非使用强制转换static_cast）</span></span><br></pre></td></tr></table></figure></li></ul><p>对象之间不存在类型转换（能转换，但是会丢失派生类中，基类没有的数据）</p><ul><li><p>具体表述：派生类向基类的自动类型<strong>转换只对指针或引用有效</strong>，在派生类类型和基类类型之间不存在这样的转换。</p></li><li><p>原因：当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生部分被忽略掉（切掉）了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line"><span class="function">Quote <span class="title">item</span><span class="params">(bulk)</span></span>;  <span class="comment">// 使用Quote::Quote(const Quote&amp;)，只能构造派生类中的基类部分</span></span><br><span class="line">item = bulk;  <span class="comment">// 使用Quote::operator=(const Quote&amp;),只能处理基类中自己的成员</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="15-3-虚函数"><a href="#15-3-虚函数" class="headerlink" title="15.3 虚函数"></a>15.3 虚函数</h2><ul><li>我们<strong>必须为每一个虚函数提供定义，而不管他是否被用到</strong></li><li>对虚函数的调用可能在运行时才会被解析<ul><li>动态绑定只有当我们通过指针或引用调用虚函数时才会发生</li><li>当通过普通类型（非指针非引用）的表达式调用虚函数，不会发生动态绑定，只会运行静态类型的函数</li><li>note<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403231430309.png" alt="image-20240323143031094"></li></ul></li></ul><ul><li>派生类中的虚函数<ul><li>也是虚函数</li><li>函数类型与基类一致（返回值类型、形参类型）。但是有一个例外情况：<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403231444209.png" alt="image-20240323144408065"></li></ul></li></ul><ul><li><p>final和override说明符</p><ul><li>使用<code>override</code>标记了某个函数，但该函数并没有覆盖已经存在的虚函数，编译器将报错</li><li>在类名后面加<code>final</code>，以阻止继承</li><li>在函数后面加<code>final</code>，任何尝试覆盖该函数的操作都将引发错误</li></ul></li></ul><ul><li><p>虚函数和默认实参</p><ul><li><p>如果虚函数使用了默认实参，则基类和派生类中定义的默认实参最好一致。</p><blockquote><p>和其他函数一样，虚函数也可以拥有默认实参(参见6.5.1节，第211页)。如果某次函数调用使用了默认实参，则该<strong>实参值由本次调用的静态类型决定。</strong></p><p><strong>换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此</strong>。此时，传入派生类函数的将是基类函数定义的默认实参。如果派生类函数依赖不同的实参，则程序结果将与我们的预期不符。</p></blockquote></li></ul></li></ul><ul><li><p>回避虚函数机制</p><ul><li><p>在某些情况下，希望虚函数的调用不要动态绑定：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> undiscounted = baseP-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>); <span class="comment">// &#x27;Quote::&#x27;指明调用Quote的net_price(),而不管baseP的动态类型到底是什么</span></span><br></pre></td></tr></table></figure></li><li><p>什么情况下使用呢？通常是  当一个派生类的虚函数   调用  它覆盖的基类的虚函数版本  时。如果没有作用域运算符，将会被解析为派生类自身的调用，将导致无限递归。</p></li></ul></li></ul><h2 id="15-4-抽象基类"><a href="#15-4-抽象基类" class="headerlink" title="15.4 抽象基类"></a>15.4 抽象基类</h2><ul><li><p>一个纯虚函数无须定义，在结尾处加上<code>=0</code></p></li><li><p>含有纯虚函数的类是抽象基类</p><ul><li>不能创建抽象基类的对象</li><li>不重写纯虚函数的派生类也是抽象基类</li></ul></li><li><p>派生类构造函数只能初始化它的直接基类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Disc</span> : <span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Disc</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Disc</span>(<span class="type">const</span> string &amp;book, <span class="type">double</span> price, <span class="type">size_t</span> qty, <span class="type">double</span> disc)</span><br><span class="line">        :<span class="built_in">Quote</span>(book, price), <span class="built_in">quantity</span>(qty), <span class="built_in">discount</span>(disc)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(<span class="type">size_t</span>)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">size_t</span> quantity = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Disc&#123;</span><br><span class="line">    <span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Bulk_quote</span>(<span class="type">const</span> string &amp;book, <span class="type">double</span> price, <span class="type">size_t</span> qty, <span class="type">double</span> disc)</span><br><span class="line">        :<span class="built_in">Disc</span>(book, price, qty, disc)&#123;&#125;  <span class="comment">// &lt;-- 初始化它的直接基类,而不是初始化Quote</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(<span class="type">size_t</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>如前所述，每个类各自控制其对象的初始化过程。因此，即使Bulk_quote没有自己的数据成员，它也仍然需要像原来一样提供一个接受四个参数的构造函数。该构造函数将它的实参传递给Disc_quote的构造函数，随后Disc_quote的构造函数继续调用Quote的构造函数。Quote的构造函数首先初始化bulk的bookNo和price 成员，当Quote的构造函数结束后，开始运行Disc_quote的构造函数并初始化 quantity 和discount成员，最后运行Bulk_quote的构造函数，该函数无须执行实际的初始化或其他工作。</p></blockquote><h2 id="15-5-访问控制与继承"><a href="#15-5-访问控制与继承" class="headerlink" title="15.5 访问控制与继承"></a>15.5 访问控制与继承</h2><ul><li><p>参考</p><ul><li><a href="https://zhuanlan.zhihu.com/p/107709327">C++之访问控制与继承</a></li></ul></li><li><p>C++中的public、protect、private三个关键字既可以用于<strong>访问控制</strong>，也可以用于控制<strong>继承</strong>方式。</p><ul><li><p>参考</p><ul><li><a href="https://zhuanlan.zhihu.com/p/107709327">C++之访问控制与继承</a></li></ul></li><li><p>访问控制<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251657214.png" alt="image-20240325165736001"></p><p>大致解释就是：</p><ol><li>首先类本身对于自己的所有成员肯定是有访问权限的，无论是public、protect还是private</li><li>类的实例化对象只对类的public成员有访问权限</li><li>protect相比private成员的特别之处在于，protect对于派生类是可访问（或可见）的，而private成员在派生类中不可见。</li></ol><p>对于第三点，换句话说就是，只有父类的public、protect成员可以被子类继承，private成员子类压根是看不到的。至于父类的public、protect成员继承到子类后，是什么样子，这还要看下面的继承方式了。</p></li></ul></li></ul><ul><li>控制继承方式（继承方式的作用不影响派生类对基类的访问，而是影响派生类的用户——见派生说明符）<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/202403251658982.png" alt="image-20240325165814776"></li></ul><ul><li><p>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问权限。</p><ul><li><p>参考</p><ul><li><a href="https://www.zhihu.com/question/37051531/answer/70303204">C++派生类的成员或友员只能通过派生类对象来访问基类的受保护成员? - 晶龙的回答 - 知乎</a></li></ul></li><li><p>理解下面代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line">    Base baseObject;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">11</span>;             <span class="comment">// target object is self (kind of Derived)</span></span><br><span class="line">        baseObject.a = <span class="number">12</span>;  <span class="comment">// target object is kind of Base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意在Derived 的 foo() 的方法里，第一句是可以编译通过的，第二句不行，会报错</p><p>这正是因为，第一句</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 11</span><br></pre></td></tr></table></figure><p>操作的对象是Derived类型，因此他可以看到从Base继承下来的protected a成员</p><p>相对，第二句</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baseObject.a = 12</span><br></pre></td></tr></table></figure><p>是不行的，因为他的操作对象明确地是一个与自身self无关的另一个Base类型对象，其a成员是不可见的。</p></li><li><p>例2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">clas Sneaky : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="comment">//正确，派生类的成员和友元 访问 派生类对象中的基类部分 的受保护成员</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span></span>&#123;</span><br><span class="line">        s.j = </span><br><span class="line">        s.prot_mem = <span class="comment">// 派生类对象中的基类部分</span></span><br><span class="line">        <span class="number">0</span>;&#125;;</span><br><span class="line">    <span class="comment">//错误，操作对象明确地是一个与Sneaky自身无关的另一个Base类型对象</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span></span>&#123;b.prot_mem = <span class="number">0</span>;&#125;;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>综之，<strong>派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员；对于普通的基类对象中的成员不具有特殊的访问权限。</strong> &lt;—其实很好理解，感觉书上写复杂了。</li></ul><ul><li><p>派生说明符</p><ul><li>不影响派生类成员（及友元）访问其直接基类</li><li>作用是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限</li></ul></li></ul><ul><li><p>派生类向基类转换的可访问性<br>派生类向基类的转换 —&gt; 基类的指针（引用）指向派生类的对象</p><ul><li><p>参考</p><ul><li><a href="http://t.csdnimg.cn/lQ6hs">C++ 派生类向基类转换的可访问性——CSDN</a></li></ul></li><li><p>书中原文</p><p> 派生类向基类到转换是否可访问由使用该转换到代码决定，同时派生类到派生访问说明符也会有影响。假定D继承自B：</p><ul><li><p><strong>只有当D公有继承B时，<u>用户代码</u>才能使用派生类向基类到转换</strong>；如果D继承B的方式时受保护的或者私有的，则用户代码不能使用该转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _COUT(str) std::cout&lt;&lt;str&lt;&lt;<span class="string">&quot; &quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _COUTL(str) std::cout&lt;&lt;str&lt;&lt;std::endl;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _COUTL(<span class="string">&quot;我是A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _COUTL(<span class="string">&quot;我是B 继承A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">private</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _COUTL(<span class="string">&quot;我是C 继承A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *p;</span><br><span class="line">    B b;</span><br><span class="line">    C c;</span><br><span class="line">    </span><br><span class="line">    p = &amp;b;</span><br><span class="line">    p = &amp;c;<span class="comment">// error:Cannot cast &#x27;C&#x27; to its private base class &#x27;A&#x27;</span></span><br><span class="line">    p-&gt;<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>不论D以什么方式继承B，D的成员函数和友员函数都能使用派生类向基类的转换</strong>；派生类向其直接基类的类型转换对于派生类的成员和友员而言永远是可访问的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(D &amp;d)</span></span>&#123;</span><br><span class="line">        B b = d; <span class="comment">// 派生类向基类的转换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">friendFunction</span><span class="params">(D &amp;d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        B b = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>:<span class="keyword">protected</span> B&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(E &amp;e)</span></span>&#123;</span><br><span class="line">        B b = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">friendFunction</span><span class="params">(E &amp;e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        B b = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span>:<span class="keyword">private</span> B&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(F &amp;f)</span></span>&#123;</span><br><span class="line">        B b = f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">friendFunction</span><span class="params">(F &amp;f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        B b = f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>如果D继承B 的方式是公有的或者受保护的，则<strong>D的派生类</strong>的成员和友员可以使用D向B 的类型转换；反之，如果D继承B 的方式时私有的，则不能使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(D &amp;d)</span></span>&#123;</span><br><span class="line">        B b = d; <span class="comment">// 使用D向B 的类型转换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">friendFunction</span><span class="params">(D &amp;d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        B b = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>:<span class="keyword">protected</span> B&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(E &amp;e)</span></span>&#123;</span><br><span class="line">        B b = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">friendFunction</span><span class="params">(E &amp;e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        B b = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span>:<span class="keyword">private</span> B&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(F &amp;f)</span></span>&#123;</span><br><span class="line">        B b = f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">friendFunction</span><span class="params">(F &amp;f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        B b = f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">G</span> : D&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(D &amp;d)</span></span>&#123;</span><br><span class="line">        B b = d;  <span class="comment">//D的派生类的成员和友员可以使用D向B 的类型转换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H</span> : E&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(E &amp;e)</span></span>&#123;</span><br><span class="line">        B b = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">I</span> : F&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(F &amp;d)</span></span>&#123;</span><br><span class="line">        B b = f; <span class="comment">//error:&#x27;B&#x27; is a private member of &#x27;B&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">friendFunction2</span><span class="params">(F &amp;f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        B b = f; <span class="comment">//error:&#x27;B&#x27; is a private member of &#x27;B&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><pre><code>tips：对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。</code></pre><blockquote><p>不考虑继承的话，我们可以认为一个类有两种不同的用户:普通用户和类的实现者.</p><p>其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有(接口)成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有(实现)部分。<br>如果进一步考虑继承的话就会出现第三种用户，即派生类。基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。<br>和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组：一组可供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据;对于后者应该声明为私有的。</p></blockquote><ul><li><p>友元和继承<br>友元不能传递，也不可继承</p><ul><li><p>但是，基类中的友元，可以访问派生类中的基类部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(Base b)</span> </span>&#123; <span class="keyword">return</span> b.prot_mem; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">(Sneaky s)</span> </span>&#123; <span class="keyword">return</span> s.j; &#125; <span class="comment">// 错误，Pal不是Sneaky的友元</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f3</span><span class="params">(Sneaky s)</span> </span>&#123; <span class="keyword">return</span> s.prot_mem; &#125; <span class="comment">// 却可以访问派生类中的基类部分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>友元关系不可继承</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span> : <span class="keyword">public</span> Pal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mem</span><span class="params">(Base b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.prot_mem; <span class="comment">// 错误，成员prot_mem不可访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>利用using改变个别成员的了访问性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Der</span> : <span class="keyword">private</span> Base &#123; <span class="comment">// 注意private继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span>  Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>默认的继承保护</p><ul><li>struct:公有继承，公有访问</li><li>class：私有继承，私有访问</li></ul></li></ul><h2 id="15-6-继承中的类作用域"><a href="#15-6-继承中的类作用域" class="headerlink" title="15.6 继承中的类作用域"></a>15.6 继承中的类作用域</h2><h2 id="15-7-构造函数和拷贝控制"><a href="#15-7-构造函数和拷贝控制" class="headerlink" title="15.7 构造函数和拷贝控制"></a>15.7 构造函数和拷贝控制</h2><h2 id="15-8-容器和继承"><a href="#15-8-容器和继承" class="headerlink" title="15.8 容器和继承"></a>15.8 容器和继承</h2><h1 id="十六-模板与泛型编程"><a href="#十六-模板与泛型编程" class="headerlink" title="十六 模板与泛型编程"></a>十六 模板与泛型编程</h1><div align="center"><h1>------高级主题------</h1></div>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> C++ Primer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基本操作</title>
      <link href="/2024/01/03/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/01/03/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol><li>基本配置</li><li>建立本地仓库</li><li>推送到远程仓库</li></ol><h1 id="1-基本配置"><a href="#1-基本配置" class="headerlink" title="1 基本配置"></a>1 基本配置</h1><h2 id="1-1-配置基本信息"><a href="#1-1-配置基本信息" class="headerlink" title="1.1 配置基本信息"></a>1.1 配置基本信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name “itcast”</span><br><span class="line">git config --global user.email “hello@itcast.cn”</span><br></pre></td></tr></table></figure><h2 id="1-2-查看配置信息"><a href="#1-2-查看配置信息" class="headerlink" title="1.2 查看配置信息"></a>1.2 查看配置信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name</span><br><span class="line">git config --globa user.email</span><br></pre></td></tr></table></figure><h2 id="1-3-设置常用指令别名"><a href="#1-3-设置常用指令别名" class="headerlink" title="1.3 设置常用指令别名"></a>1.3 设置常用指令别名</h2><ol><li><p>打开<strong>用户目录</strong>，创建 .bashrc 文件<br> 部分windows系统不允许用户创建点号开头的文件，可以打开gitBash,执行 <code>touch ~/.bashrc</code></p></li><li><p>在 .bashrc 文件中输入如下内容：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用于输出git提交日志 </span></span><br><span class="line"><span class="built_in">alias</span> git-log=<span class="string">&#x27;git log --pretty=oneline --all --graph --abbrev-commit&#x27;</span> </span><br><span class="line"><span class="comment">#用于输出当前目录所有文件及基本信息 </span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -al&#x27;</span></span><br></pre></td></tr></table></figure><ol><li>打开gitBash，执行 <code>source ~/.bashrc</code></li></ol><h2 id="1-4-解决GitBash乱码问题"><a href="#1-4-解决GitBash乱码问题" class="headerlink" title="1.4 解决GitBash乱码问题"></a>1.4 解决GitBash乱码问题</h2><ol><li>打开GitBash执行下面命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br></pre></td></tr></table></figure><ol><li><code>$&#123;git_home&#125;/etc/bash.bashrc</code> 文件最后加入下面两行</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export LANG=&quot;zh_CN.UTF-8&quot; </span><br><span class="line">export LC_ALL=&quot;zh_CN.UTF-8&quot;</span><br></pre></td></tr></table></figure><h1 id="2-建立本地仓库"><a href="#2-建立本地仓库" class="headerlink" title="2 建立本地仓库"></a>2 建立本地仓库</h1><h2 id="2-1-基本步骤"><a href="#2-1-基本步骤" class="headerlink" title="2.1 基本步骤"></a>2.1 基本步骤</h2><ol><li><p><code>git init</code> (初始化)</p></li><li><p><code>git add 单个文件名</code>或<code>git add .</code> (工作区 —&gt; 暂存区)</p></li><li><p><code>git commit -m &#39;注释内容&#39;</code> (暂存区 —&gt; 本地仓库)</p></li></ol><h2 id="2-2-版本控制"><a href="#2-2-版本控制" class="headerlink" title="2.2 版本控制"></a>2.2 版本控制</h2><ol><li><p><code>git status</code> (查看的修改的状态（暂存区、工作区）)</p></li><li><p><code>git-log</code> (查看日志)</p></li><li><p><code>git log [option]</code> （查看日志）<br> options</p><ul><li>all 显示所有分支</li><li>pretty=oneline 将提交信息显示为一行</li><li>abbrev-commit 使得输出的commitId更简短</li><li>graph 以图的形式显示</li></ul></li><li><p><code>git reset --hard commitID</code> (版本回退，commitID可使用git-log查看)</p></li><li><p><code>git reflog</code> (查看已经删除的提交记录)</p></li><li><p>根目录创建 <em>.gitignore</em> 文件 添加文件至忽略列表</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># no .a files </span></span><br><span class="line"><span class="string">*.a</span> </span><br><span class="line"><span class="comment"># but do track lib.a, even though you&#x27;re ignoring .a files above </span></span><br><span class="line"><span class="type">!lib.a</span> </span><br><span class="line"><span class="comment"># only ignore the TODO file in the current directory, not subdir/TODO </span></span><br><span class="line"><span class="string">/TODO</span> </span><br><span class="line"><span class="comment"># ignore all files in the build/ directory </span></span><br><span class="line"><span class="string">build/</span> </span><br><span class="line"><span class="comment"># ignore doc/notes.txt, but not doc/server/arch.txt </span></span><br><span class="line"><span class="string">doc/*.txt</span> </span><br><span class="line"><span class="comment"># ignore all .pdf files in the doc/ directory </span></span><br><span class="line"><span class="string">doc/**/*.pdf</span></span><br></pre></td></tr></table></figure><h2 id="2-3-分支"><a href="#2-3-分支" class="headerlink" title="2.3 分支"></a>2.3 分支</h2><ol><li><p><code>git branch 分支名</code> (创建分支)</p></li><li><p><code>git checkout 分支名</code> (切换到分支)<br> <code>git checkout -b 分支名</code> （创建并切换分支）</p></li><li><p><code>git merge 分支名</code> (合并分支，前提是已经git checkout master)</p></li><li><p>如果有冲突，手动解决冲突.</p></li><li><p><code>git branch -d 分支名</code> （删除分支）<br> <code>git branch -D 分支名</code> (强制删除分支)</p></li></ol><h1 id="3-Git远程仓库"><a href="#3-Git远程仓库" class="headerlink" title="3 Git远程仓库"></a>3 Git远程仓库</h1><h2 id="3-1-Gitee"><a href="#3-1-Gitee" class="headerlink" title="3.1 Gitee"></a>3.1 Gitee</h2><ol><li><p>生成SSH公钥</p><ul><li><code>ssh-keygen -t rsa</code></li><li>不断回车</li></ul></li><li><p>获取公钥</p><ul><li><code>cat ~/.ssh/id_rsa.pub</code></li></ul></li><li>配置公钥<br> <img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/2440767-20220307114708294-1346510124.png" alt="配置公钥"></li><li><p>验证是否配置成功</p><ul><li><code>ssh -T git@gitee.com</code></li></ul></li><li><p>添加远端仓库</p><ul><li><code>git remote add origin git@gitee.com:......</code></li></ul></li><li><p>查看远程仓库</p><ul><li><code>git remote</code></li></ul></li><li><p>推送到远程仓库</p><ul><li><code>git push --set-upstream origin master</code> （—set-upstream 建立本地与远端的联系(首次)）</li><li><code>git push</code> (非首次)</li></ul></li><li><p>查看本地分支与远程分支的关联关系</p><ul><li><code>git branch -vv</code></li></ul></li><li><p>克隆</p><ul><li><code>git clone &lt;仓库路径&gt; [本地目录]</code> (仓库路径使用SSH地址)</li></ul></li><li><p>抓取：将仓库里的更新都抓取到本地，但不合并</p><ul><li><code>git fetch [remote name] [branch name]</code></li></ul></li><li><p>拉取：将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge</p><ul><li><code>git pull [remote name] [branch name]</code></li><li>fetch和pull 如果不指定远端名称和分支名，则抓取所有并更新当前分支</li></ul></li></ol><p>在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要推送到远程仓库，此时B用户晚于A用户，故需要先拉取远程仓库的提交，经过合并后才能推送到远端分支。</p><h2 id="3-2-GitHub"><a href="#3-2-GitHub" class="headerlink" title="3.2 GitHub"></a>3.2 GitHub</h2><p>配置ssh密钥的方法：<a href="https://www.cnblogs.com/Maurice-code/p/10531303.html">https://www.cnblogs.com/Maurice-code/p/10531303.html</a></p><p>git clone 出现fatal: unable to access ‘<a href="https://github.com/">https://github.com</a> 的解决方法：将命令行的https改为git即可.</p><h1 id="参考连接"><a href="#参考连接" class="headerlink" title="[参考连接]"></a>[参考连接]</h1><p>[1] <a href="https://www.bilibili.com/video/BV1MU4y1Y7h5/">黑马程序员Git教程</a><br>[2] <a href="https://docs.github.com/cn">Github文档</a><br>[3] <a href="https://learngitbranching.js.org/?locale=zh_CN&amp;utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=830921089243820032">最好的git教程: Learn Git Branching</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hoxe+github建站笔记</title>
      <link href="/2024/01/02/hexo+github%E5%BB%BA%E7%AB%99%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/01/02/hexo+github%E5%BB%BA%E7%AB%99%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>在ubuntu上利用hexo+github建站网上有很多博文，但是由于时效原因，24年1月2日配置的时候遇到一些问题。遂本文对于细节不提而用步骤带过，主要汇总一下利用<a href="https://hexo.io/zh-cn/docs/">hexo中文官网文档</a>安装遇到的问题，需要有一丢丢linux基础。</p><h1 id="2-开胃菜"><a href="#2-开胃菜" class="headerlink" title="2.开胃菜"></a>2.开胃菜</h1><blockquote><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a></li></ul></blockquote><h2 id="2-1安装git"><a href="#2-1安装git" class="headerlink" title="2.1安装git"></a>2.1安装git</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><h2 id="2-2安装node-js"><a href="#2-2安装node-js" class="headerlink" title="2.2安装node.js"></a>2.2安装node.js</h2><blockquote><p>摘自 <a href="https://github.com/nodesource/distributions">NodeSource</a></p></blockquote><ol><li>Download and import the Nodesource GPG key</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y ca-certificates curl gnupg</span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://deb.nodesource.com/gpgkey/nodesource-repo.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/nodesource.gpg</span><br></pre></td></tr></table></figure><ol><li>Create deb repository</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NODE_MAJOR=20</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/etc/apt/keyrings/nodesource.gpg] https://deb.nodesource.com/node_<span class="variable">$NODE_MAJOR</span>.x nodistro main&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/nodesource.list</span><br></pre></td></tr></table></figure><blockquote><p><strong><em>Optional</em></strong>: <code>NODE_MAJOR</code> can be changed depending on the version you need.</p><p>（可选项）：选择node.js版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NODE_MAJOR=16</span><br><span class="line">NODE_MAJOR=18</span><br><span class="line">NODE_MAJOR=20</span><br><span class="line">NODE_MAJOR=21</span><br></pre></td></tr></table></figure></blockquote><ol><li>Run Update and Install</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nodejs -y</span><br></pre></td></tr></table></figure><h1 id="3-正餐"><a href="#3-正餐" class="headerlink" title="3.正餐"></a>3.正餐</h1><h2 id="3-1安装hexo"><a href="#3-1安装hexo" class="headerlink" title="3.1安装hexo"></a>3.1安装hexo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="3-2初始化"><a href="#3-2初始化" class="headerlink" title="3.2初始化"></a>3.2初始化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install</span><br><span class="line">hexo g <span class="comment"># 生成静态文件，即public文件夹</span></span><br></pre></td></tr></table></figure><p>此刻，在指定文件夹下生成了网站目录如下，对各目录的解释见<a href="https://hexo.io/zh-cn/docs/setup">hexo文档 . 建站</a>和<a href="https://www.bilibili.com/video/BV1q741167PJ/?share_source=copy_web&amp;vd_source=51091db9935f1f75957971565352265b">Hexo搭建个人博客——系列教程</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><h2 id="3-3本地验证"><a href="#3-3本地验证" class="headerlink" title="3.3本地验证"></a>3.3本地验证</h2><p>运行下面代码后，命令行中提示的网址，在本地查看网站</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server <span class="comment"># 或者 hexo s</span></span><br></pre></td></tr></table></figure><h1 id="4-github部署"><a href="#4-github部署" class="headerlink" title="4.github部署"></a>4.github部署</h1><h2 id="4-1github端"><a href="#4-1github端" class="headerlink" title="4.1github端"></a>4.1github端</h2><ol><li>建立名为 <code>&lt;你的 GitHub 用户名&gt;.github.io</code> 的储存库</li><li>参考我的<a href="https://www.cnblogs.com/hezexian/p/15975174.html">Git基本操作笔记</a>第三节1~4点，gitee改成github</li><li>参考<a href="http://t.csdnimg.cn/X3vjf">http://t.csdnimg.cn/X3vjf</a> ，获得person access token<ul><li>github右上角头像 - &gt; settings</li><li>左侧菜单栏，滑到最下面，选择Developer settings</li><li>左侧菜单栏，选择personal access tokens -&gt; tokens(classic) -&gt; Generate new token -&gt; Generate new token(classic)</li><li>expiration可选无限（no expiration）</li><li>下面的方框全选</li><li>点generate token</li><li>保存好生成的token，据说以后查不到了</li></ul></li></ol><h2 id="4-2本地端"><a href="#4-2本地端" class="headerlink" title="4.2本地端"></a>4.2本地端</h2><ol><li>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>如下，</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ol><li>在 <code>_config.yml</code> 中添加以下配置（如果配置已经存在，请将其替换为如下）:</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="comment"># 复制仓库的ssh</span></span><br><span class="line">  <span class="comment"># 如我的是，git@github.com:Hezexian/hezexian.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">gh-pages</span></span><br></pre></td></tr></table></figure><ol><li><p>执行 <code>hexo clean &amp;&amp; hexo deploy</code></p><ul><li>这一步会让你输入github名字密码，<strong>其中密码是4.1节生成的token</strong></li><li>执行完这一步，hexo文档被同步至github</li></ul></li><li><p>浏览&lt;你的 GitHub 用户名&gt;.github.io</p><ul><li>第三步执行完需要等一会儿网站才能打开，别心急 :)</li></ul></li></ol><h1 id="5-更新文章"><a href="#5-更新文章" class="headerlink" title="5.更新文章"></a>5.更新文章</h1><h2 id="法1："><a href="#法1：" class="headerlink" title="法1："></a>法1：</h2><p>将xxx.md文件添加进source/_posts中</p><p>注意md文件写标头，参考：<a href="https://hexo.io/zh-cn/docs/writing">写作</a>，<a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter</a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo+github建站笔记</span><br><span class="line">date: 2024/1/2 19:29</span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">-</span> 啥都会一点</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> hexo</span><br><span class="line"><span class="section">- 博客</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure></p><p>接着在hexo目录中<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 清除缓存</span><br><span class="line">hexo clean </span><br><span class="line"></span><br><span class="line"># 生成public，静态网页</span><br><span class="line">hexo g </span><br><span class="line"></span><br><span class="line"># 推送 github</span><br><span class="line">hexo d  </span><br></pre></td></tr></table></figure></p><h2 id="法2："><a href="#法2：" class="headerlink" title="法2："></a>法2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 三种布局 post、page 和 draft</span><br><span class="line">hexo new [layout] &lt;title&gt; </span><br></pre></td></tr></table></figure><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="butterfly主题分类、归档404"><a href="#butterfly主题分类、归档404" class="headerlink" title="butterfly主题分类、归档404"></a>butterfly主题分类、归档404</h2><p>按照官方文档的说法: </p><ul><li>前往你的 Hexo 博客的根目錄</li><li>輸入 <code>hexo new page categories</code></li><li>你會找到 <code>source/categories/index.md</code> 這個文件</li><li>修改這個文件：</li><li>記得添加 <code>type: &quot;categories&quot;</code>, 如下。      <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">分類</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-01-05 00:00:00</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li></ul><p>还是不行，原来是包没有安装：<br><code>npm list</code>对比</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├── hexo-deployer-git@3.0.0</span><br><span class="line">├── hexo-generator-archive@2.0.0</span><br><span class="line">├── hexo-generator-category@2.0.0</span><br><span class="line">├── hexo-generator-index@3.0.0</span><br><span class="line">├── hexo-generator-tag@2.0.0</span><br><span class="line">├── hexo-math@4.0.0</span><br><span class="line">├── hexo-renderer-ejs@2.0.0</span><br><span class="line">├── hexo-renderer-marked@6.0.0</span><br><span class="line">├── hexo-renderer-pug@3.0.0</span><br><span class="line">├── hexo-renderer-stylus@2.1.0</span><br><span class="line">├── hexo-server@3.0.0</span><br><span class="line">├── hexo-theme-landscape@0.0.3</span><br><span class="line">└── hexo@6.3.0</span><br></pre></td></tr></table></figure><p>安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmake包含vslam常用库</title>
      <link href="/2023/04/26/cmake%E5%8C%85%E5%90%ABvslam%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
      <url>/2023/04/26/cmake%E5%8C%85%E5%90%ABvslam%E5%B8%B8%E7%94%A8%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="number">6</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">23</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># OpenCV</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Eigen</span></span><br><span class="line"><span class="keyword">find_package</span>(Eigen3 REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;EIGEN3_INCLUDE_DIR&#125;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Pangolin</span></span><br><span class="line"><span class="keyword">find_package</span>(Pangolin REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;Pangolin_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Sophus</span></span><br><span class="line"><span class="keyword">find_package</span>(Sophus REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;Sophus_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># fmt</span></span><br><span class="line"><span class="keyword">find_package</span>(fmt REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;FMT_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Ceres</span></span><br><span class="line"><span class="keyword">find_package</span>(Ceres REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CERES_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># g2o</span></span><br><span class="line"><span class="keyword">find_package</span>(g2o REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;G2O_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">add_executable</span>(gaussNewton  gaussNewton.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(gaussNewton</span><br><span class="line">        <span class="variable">$&#123;OpenCV_LIBS&#125;</span></span><br><span class="line">        Eigen3::Eigen</span><br><span class="line">        <span class="variable">$&#123;Pangolin_LIBRARIES&#125;</span></span><br><span class="line">        Sophus::Sophus</span><br><span class="line">        fmt::fmt</span><br><span class="line">        <span class="variable">$&#123;CERES_LIBRARIES&#125;</span></span><br><span class="line">        g2o::core g2o::stuff)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 视觉slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视觉slam </tag>
            
            <tag> cmake </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmake+mingw32+win11+clion编译OpenCV4.5+contrib</title>
      <link href="/2022/06/09/cmake+mingw32+win11+clion%E7%BC%96%E8%AF%91OpenCV4.5+contrib/"/>
      <url>/2022/06/09/cmake+mingw32+win11+clion%E7%BC%96%E8%AF%91OpenCV4.5+contrib/</url>
      
        <content type="html"><![CDATA[<h2 id="step1-准备必要环境"><a href="#step1-准备必要环境" class="headerlink" title="step1 准备必要环境"></a>step1 准备必要环境</h2><p><strong>注意：以下软件的安装路径中不要有中文或空格！(尤其是mingw32)</strong></p><ol><li><p>安装cmake(不要安装最新的CMake,最好差3个版本以下)<br>添加到环境变量：<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/2440767-20220713203637717-1776050087.png" alt="添加到系统环境变量" style="zoom:75%;" /><br>默认安装环境：<br><img src="https://hezexian.oss-cn-guangzhou.aliyuncs.com/picture/2440767-20220713203651841-1027018717.png" alt="默认安装路径" style="zoom:75%;" /></p></li><li><p>安装mingw32：在<a href="https://sourceforge.net/projects/mingw-w64/files/">mingw32下载</a>处下载x86_64-posix-seh版本;<br>将bin文件夹路径添加至环境变量，cmd中输入<code>g++ --version</code>查看是否成功</p></li><li><p>安装python3:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pip install boost(3.10.5出错)</span></span><br><span class="line">pip <span class="keyword">install </span>cmake</span><br><span class="line">pip <span class="keyword">install </span>dlib</span><br></pre></td></tr></table></figure></li><li><p>安装visual studio</p></li></ol><h2 id="step2-下载opencv"><a href="#step2-下载opencv" class="headerlink" title="step2 下载opencv"></a>step2 下载opencv</h2><p>下载地址：<br><a href="https://opencv.org/releases/">opencv</a> 下载sources;<br><a href="https://github.com/opencv/opencv_contrib">contrib</a></p><ol><li>将contrib文件夹移动到opencv文件夹下</li><li>在opencv文件夹中新建build文件夹</li></ol><h2 id="step3-第一次编译"><a href="#step3-第一次编译" class="headerlink" title="step3 第一次编译"></a>step3 第一次编译</h2><ol><li>注意网络问题(只可意会不可言传)</li><li>打开cmake gui<ul><li>where is the sources code:填写opencv路径</li><li>where to build the binarise:填写自己创建的build的地址</li></ul></li><li>按钮：configure-&gt;在弹出的窗口中选择mingw makefiles-&gt;use default native compilers</li></ol><h2 id="step4-第二次编译"><a href="#step4-第二次编译" class="headerlink" title="step4 第二次编译"></a>step4 第二次编译</h2><ol><li>add entry-&gt;name:ENABLE_CXX11; type:BOOL; value:打上对勾</li><li>OPENCV_ENABLE_ALLOCATOR_STATS 取消对勾</li><li>OPENCV_EXTRA_MODULES_PATH:填写contrib/modules的路径</li><li><p>modules/videoio/src/cap_dshow.cpp中，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NO_DSHOW_STRSAFE</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _WIN32 &amp;&amp; <span class="keyword">define</span> HAVE_DSHOW</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cap_dshow.hpp&quot;</span></span></span><br></pre></td></tr></table></figure></li><li><p>按钮：configure + generate</p></li></ol><h2 id="step5-进入build文件夹"><a href="#step5-进入build文件夹" class="headerlink" title="step5 进入build文件夹"></a>step5 进入build文件夹</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmd</span><br><span class="line"><span class="meta prompt_">&gt;&gt;</span> cd build文件夹路径</span><br><span class="line"><span class="meta prompt_">&gt;&gt;</span> mingw32-make</span><br><span class="line"><span class="meta prompt_">&gt;&gt;</span> mingw32-make install</span><br></pre></td></tr></table></figure><h2 id="step6-将编译好的opencv添加进环境变量"><a href="#step6-将编译好的opencv添加进环境变量" class="headerlink" title="step6 将编译好的opencv添加进环境变量"></a>step6 将编译好的opencv添加进环境变量</h2><ol><li><p>name：OpenCV_DIR</p><p>value：build文件夹下的install文件夹的路径</p></li><li><p>path 新建：%OpenCV_DIR%\x64\mingw\bin</p></li></ol><h2 id="step7-在clion中测试"><a href="#step7-在clion中测试" class="headerlink" title="step7 在clion中测试"></a>step7 在clion中测试</h2><p>cmake文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.17</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="number">1</span>_demo)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure><p>cpp文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/opencv.hpp&quot;</span></span></span><br><span class="line">using namespace cv;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">Mat img = imread(<span class="string">&quot;1.jpg&quot;</span>); <span class="comment">//绝对路径</span></span><br><span class="line">imshow(<span class="string">&quot;1&quot;</span>, img);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> 视觉slam </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孙鑫VC++深入详解</title>
      <link href="/2021/06/01/%E5%AD%99%E9%91%ABVC++%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/06/01/%E5%AD%99%E9%91%ABVC++%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-Windows程序内部运行机制"><a href="#第一章-Windows程序内部运行机制" class="headerlink" title="第一章 Windows程序内部运行机制"></a>第一章 Windows程序内部运行机制</h1><h2 id="1-1-API和SDK"><a href="#1-1-API和SDK" class="headerlink" title="1.1 API和SDK"></a>1.1 API和SDK</h2><ul><li>API:Windows操作系统提供给应用程序编程的接口。 </li><li>SDK（软件开发包）:用于开发的所有资源的集合。 </li></ul><h2 id="1-2-窗口和句柄"><a href="#1-2-窗口和句柄" class="headerlink" title="1.2 窗口和句柄"></a>1.2 窗口和句柄</h2><ul><li>窗口 </li><li>句柄：系统在创建资源时会为他们分配内存，并返回这些资源的标识号，即句柄。(类似于指针）<br>窗口句柄(HWND)、图标(HICON)、光标(HCURSOR)、画刷(HBRUSH) </li></ul><h2 id="1-3-消息和队列"><a href="#1-3-消息和队列" class="headerlink" title="1.3 消息和队列"></a>1.3 消息和队列</h2><p>消息（先进先出）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMSG</span> &#123;</span></span><br><span class="line">  HWND   hwnd;           <span class="comment">//HWND:窗口变量，hwnd:消息所属的窗口</span></span><br><span class="line">  UINT   message;        <span class="comment">//message消息标识符，数值定义为WM_XXX  (P4)</span></span><br><span class="line">  WPARAM wParam; </span><br><span class="line">  LPARAM lParam;         <span class="comment">//指定消息的附加信息，ASCII等</span></span><br><span class="line">  DWORD  time;           <span class="comment">//消息投递到消息队列中的时间</span></span><br><span class="line">  POINT  pt;             <span class="comment">//当前鼠标的位置</span></span><br><span class="line">&#125; MSG, *PMSG;</span><br></pre></td></tr></table></figure><h2 id="1-4-WinMain"><a href="#1-4-WinMain" class="headerlink" title="1.4 WinMain"></a>1.4 WinMain</h2><ul><li>Win32实现的步骤 <ol><li>定义WinMain函数；</li><li>创建窗口；</li><li>消息循环；</li><li>窗口过程函数。</li></ol></li></ul><h3 id="1-4-1-WinMain函数的定义"><a href="#1-4-1-WinMain函数的定义" class="headerlink" title="1.4.1 WinMain函数的定义"></a>1.4.1 WinMain函数的定义</h3><p>winmain函数是程序入口函数，由系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> WINAPI <span class="title function_">WinMain</span><span class="params">(</span></span><br><span class="line"><span class="params">  HINSTANCE hInstance,      <span class="comment">// handle to current instance</span></span></span><br><span class="line"><span class="params">  HINSTANCE hPrevInstance,  <span class="comment">// handle to previous instance，always NULL in Win32</span></span></span><br><span class="line"><span class="params">  LPSTR lpCmdLine,          <span class="comment">// 空终止的字符串，指定传递给应用程序的命令行参数</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> nCmdShow              <span class="comment">// 指定窗口应该如何显示</span></span></span><br><span class="line"><span class="params">  )</span>;</span><br></pre></td></tr></table></figure><h3 id="1-4-2-窗口的创建"><a href="#1-4-2-窗口的创建" class="headerlink" title="1.4.2 窗口的创建"></a>1.4.2 窗口的创建</h3><ul><li>步骤 <ol><li>设计窗口类；</li><li>注册窗口；</li><li>创建窗口；</li><li>显示及更新窗口；</li></ol></li></ul><h4 id="1-4-2-1-设计窗口类"><a href="#1-4-2-1-设计窗口类" class="headerlink" title="1.4.2.1 设计窗口类"></a>1.4.2.1 设计窗口类</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WNDCLASS</span>                //窗口类</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    UINT       style;                      <span class="comment">/*（P7知识点方框）窗口样式；</span></span><br><span class="line"><span class="comment">                                             CS_XXX(都只有一位是1，且1位各不相同：位标志)；</span></span><br><span class="line"><span class="comment">                                             多种特点组合用（|）号；</span></span><br><span class="line"><span class="comment">                                             去掉style中的样式用（&amp;~）*/</span></span><br><span class="line">    WNDPROC    lpfnWndProc;             <span class="comment">//指向回调函数的指针；在特定的事件发生时，用于对该事件的响应</span></span><br><span class="line">    <span class="type">int</span>        cbClsExtra;               </span><br><span class="line">    <span class="type">int</span>        cbWndExtra;              <span class="comment">//cbClsExtra和cbWndExtra两个附加内存，一般都为0</span></span><br><span class="line">    HINSTANCE  hInstance;               <span class="comment">//实例句柄</span></span><br><span class="line">    HICON      hIcon;                  <span class="comment">//图标句柄；HICON LoadIcon(HINSTANCE hInstance, LPCTSTR lpIconName);</span></span><br><span class="line">    HCURSOR    hCursor;                  <span class="comment">//光标句柄；HCURSOR LoadCursor(HINSTANCE hInstance,LPCTSTR lpCursorName);</span></span><br><span class="line">    HBRUSH     hbrBackground;        <span class="comment">//画刷句柄，背景颜色；wndcls.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);</span></span><br><span class="line">    LPCTSTR    lpszMenuName;           <span class="comment">//菜单名字，NULL</span></span><br><span class="line">    LPCTSTR    lpszClassName;             <span class="comment">//类名，和创建窗口CreateWindow函数中的lpClassName一致</span></span><br><span class="line">&#125; WNDCLASS, *PWNDCLASS;</span><br></pre></td></tr></table></figure><h4 id="1-4-2-2-注册窗口"><a href="#1-4-2-2-注册窗口" class="headerlink" title="1.4.2.2 注册窗口"></a>1.4.2.2 注册窗口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ATOM <span class="title function_">RegisterClass</span><span class="params">(  CONST WNDCLASS *lpWndClass )</span>; <span class="comment">// 注册窗口</span></span><br></pre></td></tr></table></figure><h4 id="1-4-2-3-创建窗口"><a href="#1-4-2-3-创建窗口" class="headerlink" title="1.4.2.3 创建窗口"></a>1.4.2.3 创建窗口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HWND <span class="title function_">CreateWindow</span><span class="params">(  </span></span><br><span class="line"><span class="params">  LPCTSTR lpClassName,  <span class="comment">// registered class name，与窗口类WNDCLASS中的lpszClassName一致</span></span></span><br><span class="line"><span class="params">  LPCTSTR lpWindowName, <span class="comment">// window name，</span></span></span><br><span class="line"><span class="params">  DWORD dwStyle,        <span class="comment">/*window style；和WNDCLASS中的style不同，style是指定具体窗口的样式，dwstyle是窗口都具有的样式</span></span></span><br><span class="line"><span class="comment"><span class="params">                        常用WS_OVERLAPPEDWINDOW*/</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> x,                <span class="comment">// horizontal position of window</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> y,                <span class="comment">// vertical position of window</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> nWidth,           <span class="comment">// window width</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> nHeight,          <span class="comment">// window height;</span></span></span><br><span class="line"><span class="params">                        <span class="comment">/*如果x设为CW_USEDEFAULT,系统为窗口选择左上角并忽略y;</span></span></span><br><span class="line"><span class="comment"><span class="params">                        nWidth设为CW_USEDEFAULT，系统为默认大小并忽略nHeight。</span></span></span><br><span class="line"><span class="comment"><span class="params">                        窗口之间的父子关系，子窗口必须有WS_CHILD*/</span></span></span><br><span class="line"><span class="params">  HWND hWndParent,      <span class="comment">// handle to parent or owner window（父窗口句柄）；NULL</span></span></span><br><span class="line"><span class="params">  HMENU hMenu,          <span class="comment">// menu handle or child identifier;NULL</span></span></span><br><span class="line"><span class="params">  HINSTANCE hInstance,  <span class="comment">// handle to application instance;hInstance</span></span></span><br><span class="line"><span class="params">  LPVOID lpParam        <span class="comment">// window-creation data;NULL</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>注意：创建窗口成功，函数返回系统为该窗口分配的句柄，否则返回NULL。创建窗口之前应先定义一个窗口句柄变量来接收创建窗口之后返回的句柄值。</p><h4 id="1-4-2-4-显示及更新窗口"><a href="#1-4-2-4-显示及更新窗口" class="headerlink" title="1.4.2.4 显示及更新窗口"></a>1.4.2.4 显示及更新窗口</h4><p>显示窗口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">ShowWindow</span><span class="params">(</span></span><br><span class="line"><span class="params">  HWND hWnd,     <span class="comment">// 哪一个窗口？</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> nCmdShow   <span class="comment">// 如何显示？；常用SW_SHOWNORMAL</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>更新窗口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">UpdateWindow</span><span class="params">(</span></span><br><span class="line"><span class="params">    HWND hWnd   <span class="comment">// handle to window</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><h3 id="1-4-3-消息循环"><a href="#1-4-3-消息循环" class="headerlink" title="1.4.3 消息循环"></a>1.4.3 消息循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">GetMessage</span><span class="params">(</span></span><br><span class="line"><span class="params">  LPMSG lpMsg,         <span class="comment">// 指向一个消息结构体MSG，GetMessage取出的消息放入该结构体对象中</span></span></span><br><span class="line"><span class="params">  HWND hWnd,           <span class="comment">// handle to window，设为NULL接收所用窗口</span></span></span><br><span class="line"><span class="params">  UINT wMsgFilterMin,  <span class="comment">// first message</span></span></span><br><span class="line"><span class="params">  UINT wMsgFilterMax   <span class="comment">// last message；范围过滤，获得所有消息则设为0</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>注意：GetMessage函数除了接收到WM_QUIT（退出消息）外都返回非零值，出错返回-1。</p><p>通常编写的消息循环代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MSG msg;<span class="comment">//声明消息结构体变量</span></span><br><span class="line"><span class="keyword">while</span>(GetMessage(&amp;msg,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>))<span class="comment">//没接收到WM_QUIT时一致循环</span></span><br><span class="line">&#123;</span><br><span class="line">    TranslateMessage(&amp;msg);<span class="comment">//将WM_KEYDOWN和WM_KEYUP转化为WM_CHAR,不修改原消息</span></span><br><span class="line">    DispatchMessage(&amp;msg);<span class="comment">//将消息发送至操作系统，后者用窗口过程函数对消息响应； Dispatch：派遣</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708742389376-8d3746b0-03cd-4018-abe6-7773bef5b530.jpeg#averageHue=%23f9f9f9&amp;clientId=u36ddef60-4b23-4&amp;from=paste&amp;height=1305&amp;id=u43747779&amp;originHeight=1424&amp;originWidth=3039&amp;originalType=binary&amp;ratio=1.0909090909090908&amp;rotation=0&amp;showTitle=false&amp;size=415874&amp;status=done&amp;style=none&amp;taskId=ude1c62be-9fa7-401d-bf95-2ccea8ae71e&amp;title=&amp;width=2785.75" alt="IMG_20210623_120844.jpg"></p><p>1.4.2窗口创建和1.4.3消息循环都包含在WinMain函数体内</p><h3 id="1-4-4-窗口过程函数"><a href="#1-4-4-窗口过程函数" class="headerlink" title="1.4.4 窗口过程函数"></a>1.4.4 窗口过程函数</h3><p>即回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">WindowProc</span><span class="params">(</span></span><br><span class="line"><span class="params">  HWND hwnd,      <span class="comment">// 窗口句柄</span></span></span><br><span class="line"><span class="params">  UINT uMsg,      <span class="comment">// 消息代码</span></span></span><br><span class="line"><span class="params">  WPARAM wParam,  <span class="comment">// first message parameter</span></span></span><br><span class="line"><span class="params">  LPARAM lParam   <span class="comment">// second message parameter</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ol><li>过程函数名WindowProc可以换，但要和声明保持一致。</li><li>使用switch/case来对不同消息作出不同反应。</li></ol><p>如下方例子中的过程函数所示。</p><h2 id="课后程序"><a href="#课后程序" class="headerlink" title="课后程序"></a>课后程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_DEPRECATE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************函数声明****************************/</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WinSunProc</span><span class="params">(</span></span><br><span class="line"><span class="params">  HWND hwnd,      <span class="comment">// handle to window</span></span></span><br><span class="line"><span class="params">  UINT uMsg,      <span class="comment">// message identifier</span></span></span><br><span class="line"><span class="params">  WPARAM wParam,  <span class="comment">// first message parameter</span></span></span><br><span class="line"><span class="params">  LPARAM lParam   <span class="comment">// second message parameter</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************WinMain函数*************************/</span></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">WinMain</span><span class="params">(</span></span><br><span class="line"><span class="params">  HINSTANCE hInstance,      <span class="comment">// handle to current instance</span></span></span><br><span class="line"><span class="params">  HINSTANCE hPrevInstance,  <span class="comment">// handle to previous instance</span></span></span><br><span class="line"><span class="params">  LPSTR lpCmdLine,          <span class="comment">// command line</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> nCmdShow              <span class="comment">// show state</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*设计一个窗口类*/</span></span><br><span class="line">  WNDCLASS wndcls;</span><br><span class="line">  wndcls.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">  wndcls.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">  wndcls.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);</span><br><span class="line">  wndcls.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_CROSS);</span><br><span class="line">  wndcls.hIcon = LoadIcon(<span class="literal">NULL</span>, IDI_ERROR);</span><br><span class="line">  wndcls.hInstance = hInstance;</span><br><span class="line">  wndcls.lpfnWndProc = WinSunProc;</span><br><span class="line">  wndcls.lpszClassName=<span class="string">&quot;hezexian2021&quot;</span>;</span><br><span class="line">  wndcls.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">  wndcls.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">  RegisterClass(&amp;wndcls);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*创建窗口*/</span></span><br><span class="line">  HWND hwnd;</span><br><span class="line">  hwnd = CreateWindow(<span class="string">&quot;hezexian2021&quot;</span>, <span class="string">&quot;He Zexian&#x27;s home.&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="number">0</span>, <span class="number">0</span>, <span class="number">600</span>, <span class="number">400</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*显示及刷新窗口*/</span></span><br><span class="line">  ShowWindow(hwnd, SW_SHOWNORMAL);</span><br><span class="line">  UpdateWindow(hwnd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*消息循环*/</span></span><br><span class="line">  MSG msg;</span><br><span class="line">  <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    TranslateMessage(&amp;msg);<span class="comment">//将WM_KEYDOWN和WM_KEYUP转化为WM_CHAR,不修改原消息</span></span><br><span class="line">    DispatchMessage(&amp;msg);<span class="comment">//将消息发送至操作系统，后者用窗口过程函数对消息响应</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> msg.wParam;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************窗口过程函数*************************/</span></span><br><span class="line">LRESULT CALLBACK <span class="title function_">WinSunProc</span><span class="params">(</span></span><br><span class="line"><span class="params">  HWND hwnd,      <span class="comment">// handle to window</span></span></span><br><span class="line"><span class="params">  UINT uMsg,      <span class="comment">// message identifier</span></span></span><br><span class="line"><span class="params">  WPARAM wParam,  <span class="comment">// first message parameter</span></span></span><br><span class="line"><span class="params">  LPARAM lParam   <span class="comment">// second message parameter</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (uMsg)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> WM_CHAR:</span><br><span class="line">    <span class="type">char</span> szChar[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(szChar, <span class="string">&quot;char code is %d&quot;</span>, wParam);</span><br><span class="line">    MessageBox(hwnd, szChar, <span class="string">&quot;char&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">    MessageBox(hwnd, <span class="string">&quot;mouse clicked&quot;</span>, <span class="string">&quot;message&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    HDC hdc;                    <span class="comment">//要在窗口中输出文字或显示图形，要用到设备描述表（DC）。DC是一个包含设备信息的结构体，所有的图形操作都是利用DC来完成。</span></span><br><span class="line">                                <span class="comment">//定义类型为HDC的变量hdc</span></span><br><span class="line">        hdc = GetDC(hwnd);          <span class="comment">//GetDC返回与特定窗口相关联的DC句柄</span></span><br><span class="line">    TextOut(hdc, <span class="number">0</span>, <span class="number">50</span>, <span class="string">&quot;何泽贤之家&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;何泽贤之家&quot;</span>));</span><br><span class="line">    ReleaseDC(hwnd, hdc);          <span class="comment">//在使用完GetDC后一定要注意释放</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> WM_PAINT:<span class="comment">//窗口重绘</span></span><br><span class="line">    HDC hDC;</span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    hDC = BeginPaint(hwnd, &amp;ps);</span><br><span class="line">    TextOut(hDC, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;http://www.hezexian.org&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;http://www.hezexian.org&quot;</span>));</span><br><span class="line">    EndPaint(hwnd, &amp;ps);<span class="comment">//WM_PAINT、BeginPaint、EndPaint一起用，而不能用GetDC</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> WM_CLOSE:<span class="comment">//关闭消息</span></span><br><span class="line">    <span class="keyword">if</span> (IDYES == MessageBox(hwnd, <span class="string">&quot;是否真的结束了？&quot;</span>, <span class="string">&quot;message&quot;</span>, MB_YESNO))</span><br><span class="line">    &#123;</span><br><span class="line">      DestroyWindow(hwnd);<span class="comment">//销毁窗口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line"><span class="comment">//此时窗口销毁，但程序还在后台运行</span></span><br><span class="line">            </span><br><span class="line">  <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">    PostQuitMessage(<span class="number">0</span>);<span class="comment">//在响应消息后,投递一个退出的消息使用程序安全退出</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, uMsg, wParam, lParam);<span class="comment">//调用缺省的消息处理过程函数，对没有处理的其他消息以默认处理</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：<br>1、如遇到cannot convert from ‘const char [7]’ to ‘LPCWSTR’的错误，请对工程进行字符设置菜单栏-&lt;项目-&lt;xxx 属性-&lt;配置属性-&lt;高级-&lt;字符集,改成“not set”或改成“Use Multi-Byte Character Set”。<br>2、vs2019—Windows桌面应用程序</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] VC深入详解 孙鑫 第一章 Windows程序内部运行机制 - focusahaha - 博客园 (cnblogs.com).<a href="https:_www.cnblogs.com_focusahaha_p_12601081">https://www.cnblogs.com/focusahaha/p/12601081.html</a><br>[2]孙鑫.VC深度详解修订版[M]. 北京:电子工业出版社, 2012. 1-26.</p><hr><h1 id="第二章-掌握C"><a href="#第二章-掌握C" class="headerlink" title="第二章 掌握C++"></a>第二章 掌握C++</h1><h2 id="2-1-从结构到类"><a href="#2-1-从结构到类" class="headerlink" title="2.1 从结构到类"></a>2.1 从结构到类</h2><h3 id="2-1-1-结构体的定义"><a href="#2-1-1-结构体的定义" class="headerlink" title="2.1.1 结构体的定义"></a>2.1.1 结构体的定义</h3><ol><li>C++相比于C的特性：封装性、继承性、多态性；</li><li>对象具有状态和行为，状态保存在成员变量中，行为通过函数实现；</li><li>标准输入输出流对象：cin（&gt;&gt;）默认键盘   和    cout（&lt;&lt;）、cerr（&lt;&lt;）默认显示器；自动根据数据类型调整输入输出格式；</li><li>结构体中的函数称为成员函数。</li></ol><p><strong>程序2.1</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;   <span class="comment">//error C1083: 无法打开包括文件:“iostream.h”: No such file or directory</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> x, y;           <span class="comment">//状态</span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">output</span><span class="params">()</span>       <span class="comment">//行为</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x=&quot;</span>&lt;&lt; x &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;y=&quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//endl是换行符</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;pt;<span class="comment">//注意分号</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入x和y的值：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; pt.x;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; pt.y;</span><br><span class="line">  pt.output();    <span class="comment">//注意括号</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-结构体与类"><a href="#2-1-2-结构体与类" class="headerlink" title="2.1.2 结构体与类"></a>2.1.2 结构体与类</h3><p>在C++中，结构体（struct）和类（class）可以通用。<br>区别在于访问控制的差异：</p><ol><li>struct默认访问控制标识符public；public：可以在类的外部进行访问</li><li>class默认访问控制标识符private；private：只能在类的内部进行访问</li><li>protective。</li></ol><p><strong>程序2.2：将程序2.1中的struct point修改为class point</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span>   //类：抽象出一些事物共有的属性</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">  <span class="type">void</span> <span class="title function_">output</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x=&quot;</span>&lt;&lt; x &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;y=&quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;pt;   <span class="comment">//实例化了一个对象==类的实例化：具有具体的属性值</span></span><br></pre></td></tr></table></figure><h2 id="2-2-C-的特性"><a href="#2-2-C-的特性" class="headerlink" title="2.2 C++的特性"></a>2.2 C++的特性</h2><h3 id="2-2-1-类与对象"><a href="#2-2-1-类与对象" class="headerlink" title="2.2.1 类与对象"></a>2.2.1 类与对象</h3><p>类：抽象出一些事物共有的属性；<br>对象：有具体的属性值。</p><h3 id="2-2-2-构造函数"><a href="#2-2-2-构造函数" class="headerlink" title="2.2.2 构造函数"></a>2.2.2 构造函数</h3><p>作用：在定义对象的同时，对成员变量进行初始化；<br>创建对象本身（分配内存）<br>规定：构造函数的名字和类名相同（唯一性）；<br>没用返回值；<br>可以有参数。<br>注意：</p><ol><li>如果一个类没有定义任何构造函数，那么C会提供一个默认的不带参构造函数。而只要类中定义了一个构造函数，C便不再提供任何其他构造函数；</li><li>每个类必须有一个构造函数，没有构造函数不能创建任何对象。构造函数如代码2.3所示。</li></ol><h3 id="2-2-3-析构函数"><a href="#2-2-3-析构函数" class="headerlink" title="2.2.3 析构函数"></a>2.2.3 析构函数</h3><p><code>~类名(); //对象生命周期结束，释放其占用资源；是一个对象最后调用的成员函数</code><br>注意：析构函数不允许有返回值，更不允许有参数，并且一个类中只有一个构造函数。<br><strong>代码2.3：构造函数和析构函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span>       //类名：<span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">  <span class="type">int</span> x , y;</span><br><span class="line">    point()      <span class="comment">//构造函数  point()</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">0</span>;    <span class="comment">//在类中定义成员变量时，不能直接给其赋值(如int x=0;)，而是在构造函数中赋值(P37提示)</span></span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~point()    <span class="comment">//析构函数   ~point()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-2-4-函数的重载"><a href="#2-2-4-函数的重载" class="headerlink" title="2.2.4 函数的重载"></a>2.2.4 函数的重载</h3><p>条件：函数参数类型、个数不同才能构成重载。<br>注意：</p><ol><li>只有函数的返回值类型不同，不能重载；</li><li>重载时，注意函数带有默认参数的情况。(P38)</li><li>对比覆盖：重载是发生在同一个类当中；覆盖是发生在父类和子类之间</li></ol><p><strong>代码2.4 函数的重载</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">  <span class="type">int</span> x , y;</span><br><span class="line">    point()      <span class="comment">//函数1</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    point(<span class="type">int</span> a, <span class="type">int</span> b)    <span class="comment">//重载，函数2</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    point <span class="title function_">pt</span><span class="params">(<span class="number">5</span>,<span class="number">5</span>)</span>;   <span class="comment">//C++根据参数类型和个数，执行函数2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-5-this指针"><a href="#2-2-5-this指针" class="headerlink" title="2.2.5 this指针"></a>2.2.5 this指针</h3><ol><li>this指针是一个隐含的指针，指向对象本身，代表对象的地址。</li><li>用法：当形参的变量名和成员变量的变量名冲突时，可用this-&gt;来区别对哪一个变量进行赋值。(P40)</li></ol><p>this-&gt;x是对成员变量进行赋值；<br>x是对形参赋值。</p><h3 id="2-2-6-类的继承"><a href="#2-2-6-类的继承" class="headerlink" title="2.2.6 类的继承"></a>2.2.6 类的继承</h3><h4 id="2-2-6-1-继承"><a href="#2-2-6-1-继承" class="headerlink" title="2.2.6.1 继承"></a>2.2.6.1 继承</h4><p>例如：<code>class fish : public animal&#123;&#125;;</code></p><ol><li>animal是父类，fish是子类。子类fish以public（公有）的方式继承父类animal。</li><li>子类除了自己的成员变量和成员方法外，还可以继承父类的成员变量和成员方法。</li><li>构造函数和析构函数的调用次序：</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708742415566-92333483-5371-45dc-bd72-771fa5be5b33.png#averageHue=%23eeeeee&amp;clientId=u36ddef60-4b23-4&amp;from=paste&amp;height=211&amp;id=u03b2526e&amp;originHeight=230&amp;originWidth=296&amp;originalType=binary&amp;ratio=1.0909090909090908&amp;rotation=0&amp;showTitle=false&amp;size=12042&amp;status=done&amp;style=none&amp;taskId=u6dcd2671-8216-4537-b4de-ce5fe35207d&amp;title=&amp;width=271.33333333333337" alt="image.png"></p><h4 id="2-2-6-2-在子类中调用父类带参数的构造函数"><a href="#2-2-6-2-在子类中调用父类带参数的构造函数" class="headerlink" title="2.2.6.2 在子类中调用父类带参数的构造函数"></a>2.2.6.2 在子类中调用父类带参数的构造函数</h4><p>例如：父类构造函数： <code>animal(int h , int w)&#123;&#125;</code><br>则在构造子类时，应该显式地去调用父类的带参数构造函数： <code>fish():animal(400,300)&#123;&#125;</code></p><h4 id="2-2-6-3-类的继承及类中成员的访问特性"><a href="#2-2-6-3-类的继承及类中成员的访问特性" class="headerlink" title="2.2.6.3 类的继承及类中成员的访问特性"></a>2.2.6.3 类的继承及类中成员的访问特性</h4><p><strong>3种访问权限修饰符：</strong><br>public：定义的成员可以在任何地方被访问；<br>protected：定义的成员只能在该类及其子类中访问；<br>private：定义的成员只能在该类自身中访问。==&gt;不能被子类继承</p><p><strong>3种继承方式：</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708742427838-701c9a37-07b4-4745-aed1-da1345bfb30f.jpeg#averageHue=%2309328c&amp;clientId=u36ddef60-4b23-4&amp;from=paste&amp;height=1408&amp;id=u502e6573&amp;originHeight=1536&amp;originWidth=2048&amp;originalType=binary&amp;ratio=1.0909090909090908&amp;rotation=0&amp;showTitle=false&amp;size=164854&amp;status=done&amp;style=none&amp;taskId=u070cc178-4cc3-46f3-8ac1-f3fd3f01e34&amp;title=&amp;width=1877.3333333333335" alt="QQ图片20210627115117.jpg"></p><h4 id="2-2-6-4-多重继承"><a href="#2-2-6-4-多重继承" class="headerlink" title="2.2.6.4 多重继承"></a>2.2.6.4 多重继承</h4><p>定义形式：<code>class B: public C , public D</code><br>了解父类表顺序对调用构造函数和析构函数的影响。对于上面的例子，先构造C再构造D，先析构D再析构C。</p><h3 id="2-2-7-虚函数与多态性、纯虚函数"><a href="#2-2-7-虚函数与多态性、纯虚函数" class="headerlink" title="2.2.7 虚函数与多态性、纯虚函数"></a>2.2.7 虚函数与多态性、纯虚函数</h3><h4 id="2-2-7-1虚函数与多态性"><a href="#2-2-7-1虚函数与多态性" class="headerlink" title="2.2.7.1虚函数与多态性"></a>2.2.7.1虚函数与多态性</h4><p><strong>程序 2.5 </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(P49)...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">void</span> <span class="title function_">breathe</span><span class="params">()</span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;animal breathe&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;   <span class="comment">/*注意此时不是虚函数*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fish</span> :</span> public animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  ...</span><br><span class="line">    <span class="type">void</span> <span class="title function_">breathe</span><span class="params">()</span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;fish bubble&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">breathetest</span><span class="params">(animal* pan)</span></span><br><span class="line">&#123;</span><br><span class="line">  pan-&gt;breathe();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  animal* pan;  <span class="comment">//指向animal类的指针pan</span></span><br><span class="line">  fish fi;</span><br><span class="line">  pan = &amp;fi;    <span class="comment">//将fish类的对象fi的地址直接赋给指向animal类的指针变量pan</span></span><br><span class="line">  breathetest(pan);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出animal breathe*/</span></span><br></pre></td></tr></table></figure><p>1、fish对象也是一个animal类，C++自动进行类型转换；反之，不能把animal对象看成fish对象。</p><p>2、当我们将fish转化为animal时，该对象就会被认为是原对象内存模型的上半部分。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708742439266-c5b377aa-1c43-45b6-849d-b4075033d0a6.jpeg#averageHue=%23fcfcfc&amp;clientId=u36ddef60-4b23-4&amp;from=paste&amp;height=1354&amp;id=u85029cfc&amp;originHeight=1477&amp;originWidth=3557&amp;originalType=binary&amp;ratio=1.0909090909090908&amp;rotation=0&amp;showTitle=false&amp;size=315758&amp;status=done&amp;style=none&amp;taskId=uf7498ddf-7578-450d-b406-d0c894c1451&amp;title=&amp;width=3260.5833333333335" alt="IMG_20210627_153537.jpg"></p><p>3、将父类函数修改为虚函数，输出结果为fish bubble。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(P49)...</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">breathe</span><span class="params">()</span>    <span class="comment">//虚函数</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/*输出fish bubble*/</span></span><br></pre></td></tr></table></figure><p>虚函数：用virtual关键字申明的函数—&gt;多态性；<br>迟邦定：编译时并不确定具体调用的函数，而是在运行时依据对象的类型来确认调用的是哪一个函数。</p><p>概括(用法)：在父类的函数前加上virtual关键字，在子类重写该函数，运行时将会根据对象的实际类型来调用相应的函数。</p><h4 id="2-2-7-2-纯虚函数"><a href="#2-2-7-2-纯虚函数" class="headerlink" title="2.2.7.2 纯虚函数"></a>2.2.7.2 纯虚函数</h4><ol><li>纯虚函数不被具体实现，是抽象类，不能实例化对象。</li><li>纯虚函数可以让类先具有一个操作名称，而没有操作内容，在子类继承时再去具体定义。</li></ol><p>写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="type">void</span> <span class="title function_">breathe</span><span class="params">()</span> = <span class="number">0</span> ;    <span class="comment">//1、等于0；2、无函数体</span></span><br></pre></td></tr></table></figure><p>注意：子类如果有对父类虚函数的覆盖定义，无论该覆盖定义是否有virtual，都是虚函数。</p><h3 id="2-2-8函数的覆盖和隐藏"><a href="#2-2-8函数的覆盖和隐藏" class="headerlink" title="2.2.8函数的覆盖和隐藏"></a>2.2.8函数的覆盖和隐藏</h3><h4 id="2-2-8-1-覆盖"><a href="#2-2-8-1-覆盖" class="headerlink" title="2.2.8.1 覆盖"></a>2.2.8.1 覆盖</h4><p>1、覆盖(P52)：发生在父类和子类之间    的   函数完全一样（函数名、参数列表），编译器根据实际类型确定要调用的函数。<br>2、对比重载：重载是发生在同一个类当中；覆盖是发生在父类和子类之间</p><p><strong>程序2.6 函数的覆盖</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">breathe</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;animal breathe&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fish</span> :</span> public animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  <span class="type">void</span> <span class="title function_">breathe</span><span class="params">()</span>     <span class="comment">//覆盖</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;fish bubble&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    fish fi;</span><br><span class="line">    fi.breathe();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出fish bubble*/</span></span><br></pre></td></tr></table></figure><h4 id="2-2-8-2-隐藏"><a href="#2-2-8-2-隐藏" class="headerlink" title="2.2.8.2 隐藏"></a>2.2.8.2 隐藏</h4><p>两种父类函数隐藏的情况：</p><ol><li>子类和父类函数完全相同（函数名、参数列表），但父类函数没有virtual，则父类函数被隐藏。</li><li>子类和父类函数同名，但参数列表不同，则父类函数被隐藏。</li></ol><p>区别隐藏与覆盖：覆盖是发生在父类与子类之间，两个函数必须完全相同且都是虚函数。否则就是隐藏。</p><h3 id="2-2-9-引用"><a href="#2-2-9-引用" class="headerlink" title="2.2.9 引用"></a>2.2.9 引用</h3><p>定义形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> &amp;b = a;  <span class="comment">//引用必须在申明时就初始化，与a绑定;后面不会再与其他变量绑定</span></span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>引用只是一个别名，不占用内存空间；此处要和指针区分开来。</li><li>引用多用于函数的形参定义。如程序2.4所示。</li></ol><p><strong>程序2.7  引用示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;                <span class="comment">//换成引用意思表达更清晰：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*以下为用指针交换数据*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span>;         <span class="comment">//void change(int&amp; a,int&amp; b);</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;y=&quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  change(&amp;x,&amp;y);                <span class="comment">//是对x和y的地址互换还是对x和y互换？     change(x,y);</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;y=&quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span>        <span class="comment">//void change(int a,int b)</span></span><br><span class="line">&#123;                                   <span class="comment">//&#123;</span></span><br><span class="line">  <span class="type">int</span> c;                            <span class="comment">// int c;</span></span><br><span class="line">  c = *a;                          <span class="comment">//  c = a;</span></span><br><span class="line">  *a = *b;                          <span class="comment">// a = b;</span></span><br><span class="line">  *b = c;                           <span class="comment">// b = c;</span></span><br><span class="line">&#125;                                   <span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-10-C-类设计习惯和头文件重复包含问题的解决"><a href="#2-2-10-C-类设计习惯和头文件重复包含问题的解决" class="headerlink" title="2.2.10 C++类设计习惯和头文件重复包含问题的解决"></a>2.2.10 C++类设计习惯和头文件重复包含问题的解决</h3><p>1、头文件存放类的定义及类成员函数的声明；<br>源文件存放类中成员函数的实现。</p><p>2、注意文件包含；<br><code>#include &quot;animal.h&quot;  //&quot;&quot;，从当前目录开始搜索，然后是系统目录和PATH环境变量所列出的目录</code><br><code>#include &lt;iostream&gt;   //&lt;&gt;，从系统目录开始搜索，然后是PATH环境变量所列出的目录。``不搜索当前目录</code><br>注意子类的头文件中也要包含父类的头文件，如fish.h中的#include “animal.h”。</p><p>3、::是作用域表示符，表明函数或数据成员属于哪个类；<br>前面如果不跟类名，表示全局函数（即非成员函数）或全局数据。</p><p>4、在头文件中声明函数时用了virtual，在源文件中就不用写virtual。</p><p>5、要解决类重复定义的问题，要使用条件预处理指令（如课后程序animal.h和fish.h所示）</p><p><strong>程序2.8 条件预处理指令解决类重复定义的问题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ANIMAL_H_H     <span class="comment">//如果没有定义ANIMAL_H_H，就定义ANIMAL_H_H，接着申明animal类</span></span></span><br><span class="line">                       <span class="comment">//如果定义过了ANIMAL_H_H，直接跳至endif</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANIMAL_H_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="2-2-11-VC-程序编译连接的原理与过程"><a href="#2-2-11-VC-程序编译连接的原理与过程" class="headerlink" title="2.2.11 VC++程序编译连接的原理与过程"></a>2.2.11 VC++程序编译连接的原理与过程</h3><p>1、编译：头文件不参与编译<br>源文件单独编译<br>XXX.obj目标文件<br>2、链接</p><p>编译链接过程如下。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708742459674-ddc535d0-7134-4034-bcdb-8b0f50519dab.jpeg#averageHue=%23f5f5f4&amp;clientId=u36ddef60-4b23-4&amp;from=paste&amp;height=2178&amp;id=ufc444e15&amp;originHeight=2376&amp;originWidth=3489&amp;originalType=binary&amp;ratio=1.0909090909090908&amp;rotation=0&amp;showTitle=false&amp;size=1163196&amp;status=done&amp;style=none&amp;taskId=ua1badef6-adaa-465f-bcc3-a18f715f92f&amp;title=&amp;width=3198.2500000000005" alt="IMG_20210627_171323.jpg"></p><h2 id="课后程序-1"><a href="#课后程序-1" class="headerlink" title="课后程序"></a>课后程序</h2><p><strong>animal.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*animal.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ANIMAL_H_H     <span class="comment">//如果没有定义ANIMAL_H_H，就定义ANIMAL_H_H，接着申明animal类</span></span></span><br><span class="line">                       <span class="comment">//如果定义过了ANIMAL_H_H，直接跳至endif</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANIMAL_H_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">  animal();</span><br><span class="line">  ~animal();</span><br><span class="line">  <span class="type">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">void</span> <span class="title function_">sleep</span><span class="params">()</span>;</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">breathe</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>animal.cpp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*animal.cpp*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;animal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">animal::animal()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">animal::~animal()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">animal::eat</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">animal::sleep</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">animal::breathe</span><span class="params">()</span>      <span class="comment">//在头文件中有virtual,则在源文件中不用加virtual</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;animal breathe&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fish.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*fish.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;animal.h&quot;</span>  <span class="comment">//fish类从animal类继承</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FISH_H_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FISH_H_H</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fish</span> :</span>public animal     <span class="comment">//结构体、类名后面没有括号()</span></span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  <span class="type">void</span> <span class="title function_">breathe</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>fish.cpp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*fish.cpp*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fish.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fish::breathe</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fish bubble&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.cpp*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;animal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fish.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">breathetest</span><span class="params">(animal* pan)</span></span><br><span class="line">&#123;</span><br><span class="line">  pan-&gt;breathe();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  animal* pan;</span><br><span class="line">  fish fi;</span><br><span class="line">  animal an;</span><br><span class="line">  pan = &amp;fi;</span><br><span class="line">  breathetest(pan);</span><br><span class="line">  pan = &amp;an;</span><br><span class="line">  breathetest(pan);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708742476799-76e92417-5326-4278-b8a6-e365d0bfc278.png#averageHue=%2312100e&amp;clientId=u36ddef60-4b23-4&amp;from=paste&amp;height=55&amp;id=u257db54c&amp;originHeight=60&amp;originWidth=166&amp;originalType=binary&amp;ratio=1.0909090909090908&amp;rotation=0&amp;showTitle=false&amp;size=2019&amp;status=done&amp;style=none&amp;taskId=u14eaddc1-0bb1-403a-b47f-18db63b8233&amp;title=&amp;width=152.16666666666669" alt="image(1).png"></p><h2 id="问题及反思"><a href="#问题及反思" class="headerlink" title="问题及反思"></a>问题及反思</h2><p>vs2019编程出现的问题：<br>1、建立C++空项目后，要在右侧工程的源文件的文件夹下创建XXX.cpp文件；</p><p>否则编译时无法启动程序XXX.exe，系统找不到指定文件。</p><p>2、头文件#include <iostream.h>后添加using namespace std；<br>否则报错：error C1083: 无法打开包括文件:“iostream.h”: No such file or directory<br>3、定义结构体或类时，别忘记最后的分号；结构体名或类名后面没有小括号；<br>4、引用成员函数别忘记括号：pt.output();<br>5、.sln为项目文件</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708745317287-3559a957-3a2e-46a4-9260-acce8d441597.png#averageHue=%23f0f3fa&amp;clientId=u36ddef60-4b23-4&amp;from=paste&amp;height=244&amp;id=u6da8e2a2&amp;originHeight=266&amp;originWidth=317&amp;originalType=binary&amp;ratio=1.0909090909090908&amp;rotation=0&amp;showTitle=false&amp;size=14898&amp;status=done&amp;style=none&amp;taskId=u02c08995-b3c7-471b-9695-f85765db29c&amp;title=&amp;width=290.58333333333337" alt="image(2).png"></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708745329159-794985ec-0dc0-45ee-9a70-3a28ad394216.png#averageHue=%23f3f2f2&amp;clientId=u36ddef60-4b23-4&amp;from=paste&amp;height=261&amp;id=u85290e4d&amp;originHeight=285&amp;originWidth=637&amp;originalType=binary&amp;ratio=1.0909090909090908&amp;rotation=0&amp;showTitle=false&amp;size=48246&amp;status=done&amp;style=none&amp;taskId=ud923bd32-08e5-4e4c-a797-3e09019c401&amp;title=&amp;width=583.9166666666667" alt="image(3).png"></p><h2 id="参考文献-1"><a href="#参考文献-1" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]&lt;<a href="https://blog.csdn.net/weixin_43751983/article/details/91147918">https://blog.csdn.net/weixin_43751983/article/details/91147918</a> &gt;this指针<br>[2]孙鑫.VC++深度详解修订版[M]. 北京:电子工业出版社, 2012. 27-62.</p><hr><h1 id="第三章-MFC框架程序剖析"><a href="#第三章-MFC框架程序剖析" class="headerlink" title="第三章 MFC框架程序剖析"></a>第三章 MFC框架程序剖析</h1><h2 id="3-1创建MFC-AppWizard"><a href="#3-1创建MFC-AppWizard" class="headerlink" title="3.1创建MFC AppWizard"></a>3.1创建MFC AppWizard</h2><p>如何利用vs2019创建MFC应用见参考文献[1]<br>需要注意的地方有<br>[1]创建MFC单文档应用程序</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708745341365-2e5d3bc4-d1c1-4bcb-9ced-e225a099ccb7.jpeg#averageHue=%23f6f5f1&amp;clientId=u36ddef60-4b23-4&amp;from=paste&amp;height=722&amp;id=u866d3efa&amp;originHeight=788&amp;originWidth=1050&amp;originalType=binary&amp;ratio=1.0909090909090908&amp;rotation=0&amp;showTitle=false&amp;size=97959&amp;status=done&amp;style=none&amp;taskId=u570fef31-d012-4839-9eaa-3695cbec5ff&amp;title=&amp;width=962.5000000000001" alt="屏幕截图 2021-06-28 101949.jpg"></p><p>[2]开启类视图窗口</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708745349967-79931c34-9233-41fc-ba5e-050932aa1319.png#averageHue=%23faf7f1&amp;clientId=u36ddef60-4b23-4&amp;from=paste&amp;height=477&amp;id=ua24ef771&amp;originHeight=520&amp;originWidth=322&amp;originalType=binary&amp;ratio=1.0909090909090908&amp;rotation=0&amp;showTitle=false&amp;size=19727&amp;status=done&amp;style=none&amp;taskId=u13b05d18-4f4d-44d0-8be9-87d6464991f&amp;title=&amp;width=295.1666666666667" alt="image(4).png"></p><h2 id="3-2基于MFC的程序框架剖析"><a href="#3-2基于MFC的程序框架剖析" class="headerlink" title="3.2基于MFC的程序框架剖析"></a>3.2基于MFC的程序框架剖析</h2><p>在MFC中，类的命名都以C开头；对于单文档应用程序，如图3.2所示，都有：</p><ul><li>CAboutDlg帮助类，同于说明这个工程的开发信息；</li><li>CMainFrame主框架类；</li><li>C工程名App应用程序入口；</li><li>C工程名Doc文档类，用来管理、存放数据；</li><li>C工程名View用来将文档中的数据可视化。</li></ul><p>CMainFrame类和CTestView类都有一个共同的基类：Cwnd类，其封装了与窗口相关的操作。</p><h3 id="3-2-1-MFC中的WinMain函数"><a href="#3-2-1-MFC中的WinMain函数" class="headerlink" title="3.2.1 MFC中的WinMain函数"></a>3.2.1 MFC中的WinMain函数</h3><p>文件路径（在安装路径下直接搜索MFC,找到mfc）：D:\Program Files (x86)\visualstudio\VC\Tools\MSVC\14.29.30037\atlmfc\src，打开appmodul.cpp 查找WinMain</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> WINAPI</span><br><span class="line">_tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,     <span class="comment">//右键_tWinMain,单击转到定义：#define _tWinMain   WinMain</span></span><br><span class="line">  _In_ LPTSTR lpCmdLine, <span class="type">int</span> nCmdShow)</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(suppress: 4985)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// call shared/exported WinMain</span></span><br><span class="line">  <span class="keyword">return</span> AfxWinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-1-1-theApp全局对象"><a href="#3-2-1-1-theApp全局对象" class="headerlink" title="3.2.1.1 theApp全局对象"></a>3.2.1.1 theApp全局对象</h4><p>以简单的C++源程序为例，在入口函数main()加载之前，就已经为全局变量（对象）分配了内存空间，并为其赋了初值。对于一个全局对象来说，此时就会调用该对象的构造函数构造该对象并进行初始化操作，然后才是进入main()函数。(P72例3-4已标出先后顺序)</p><p>对于MFC来说，通过产生一个应用程序类的对象来唯一标识应用程序的实例。每个MFC程序有且仅有一个从应用程序类（CWinApp）派生的类；每个MFC程序实例有且仅有一个该派生类的实例化对象，即theApp全局对象，theApp表示了该应用程序本身。theApp的定义如程序3.1所示，在test.cpp中查看。</p><p><strong>程序3.1 theApp全局对象</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*test.cpp*/</span></span><br><span class="line"><span class="comment">// 唯一的 CtestApp 对象</span></span><br><span class="line">CtestApp theApp;    <span class="comment">//theApp是CtestApp的一个对象，注意其是一个全局对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*test.h*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CtestApp</span> :</span> public CWinApp   <span class="comment">//CtestApp继承于CWinApp，后者表示应用程序类</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件路径（在安装路径下直接搜索MFC,找到mfc）：D:\Program Files (x86)\visualstudio\VC\Tools\MSVC\14.29.30037\atlmfc\src，打开appcore.cpp 查找CWinApp（184行）其中，<br><strong>程序3.2</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CWinApp::CWinApp(LPCTSTR lpszAppName)  <span class="comment">//注意此处有参数</span></span><br><span class="line">&#123; ...   </span><br><span class="line">pModuleState-&gt;m_pCurrentWinApp = this; <span class="comment">//此处this代表子类CTestApp的对象，即theApp</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序3.3</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CWinApp</span> :</span> public CWinThread</span><br><span class="line">&#123;...</span><br><span class="line">  explicit <span class="title function_">CWinApp</span><span class="params">(LPCTSTR lpszAppName = <span class="literal">NULL</span>)</span>;     <span class="comment">// app name defaults to EXE name;构造函数形参有默认值默认值</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>补充：如果某个函数的参数有默认值，那么在调用该函数时可以传参，也可以不传参直接使用默认值。</p><p>由程序3.3可见，来CWinApp类的定义时，CWinApp的构造函数的形参有默认值NULL。因此，在调用CWinApp类的构造函数时，不用显式地传参。</p><h4 id="3-2-1-2-AfxWinMain函数"><a href="#3-2-1-2-AfxWinMain函数" class="headerlink" title="3.2.1.2 AfxWinMain函数"></a>3.2.1.2 AfxWinMain函数</h4><p>WinMain函数实际上是通过调用AfxWinMain函数来完成它的功能的。<br>其中，Afx前缀的函数代表应用程序框架函数，辅助我们生成应用程序框架的应用模型。在MFC中，Afx为前缀的函数都是全局函数，可以在程序的任何位置调用。</p><p>在AfxWinMain函数的定义中，有<br><strong>程序3.4</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*pThread和pApp这两个指针是一致的，这两个指针都指向CTestApp类的对象，即theApp全局对象*/</span>  </span><br><span class="line">    CWinThread* pThread = AfxGetThread();</span><br><span class="line">  CWinApp* pApp = AfxGetApp();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*MFC内部管理所调用的函数*/</span></span><br><span class="line">  <span class="keyword">if</span> (pApp != <span class="literal">NULL</span> &amp;&amp; !pApp-&gt;InitApplication())</span><br><span class="line">    <span class="keyword">goto</span> InitFailure;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用的是子类InitInstance()：因为在父类CWinApp中的InitInstance()是虚函数*/</span></span><br><span class="line">  <span class="keyword">if</span> (!pThread-&gt;InitInstance())&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*消息循环*/</span></span><br><span class="line">  nReturnCode = pThread-&gt;Run();</span><br></pre></td></tr></table></figure><h4 id="3-2-1-3-InitInstance函数"><a href="#3-2-1-3-InitInstance函数" class="headerlink" title="3.2.1.3  InitInstance函数"></a>3.2.1.3  InitInstance函数</h4><p>见程序3.4的第九行。</p><h3 id="3-2-2-MFC框架窗口"><a href="#3-2-2-MFC框架窗口" class="headerlink" title="3.2.2 MFC框架窗口"></a>3.2.2 MFC框架窗口</h3><h4 id="3-2-2-1-设计和注册窗口"><a href="#3-2-2-1-设计和注册窗口" class="headerlink" title="3.2.2.1 设计和注册窗口"></a>3.2.2.1 设计和注册窗口</h4><p>窗口类的注册是由位于wincore.cpp的AfxEndDeferRegisterClass函数完成的。AfxEndDeferRegisterClass函数预定义了几种缺省的窗口类，首先判断窗口类的类型，再赋予其相应的类名。部分代码如书本p79所示。</p><p>接着调用AfxRegisterClass函数注册从窗口类,该函数首先获得窗口类信息，窗口已经注册，返回真。否则注册该窗口类。</p><p>注意：AfxRegisterClass实际上就是AfxEndDeferRegisterClass（宏定义）；</p><h4 id="3-2-2-2-创建窗口"><a href="#3-2-2-2-创建窗口" class="headerlink" title="3.2.2.2 创建窗口"></a>3.2.2.2 创建窗口</h4><p>窗口的创建是由CWnd类中的CreateEx函数完成的。定义：afxwin.h,实现：wincore.cpp。（以Ex结尾的函数表示扩展函数。）</p><p>CreateEx函数不是虚函数，CFrameWnd类的Create函数内调用的实际上就是CWnd类的CreatEx函数。CreateEx函数内部调用的PreCreateWindow函数是一个虚函数，在产生窗口之前有机会修改窗口外观。</p><h4 id="3-2-2-3-显示和更新窗口"><a href="#3-2-2-3-显示和更新窗口" class="headerlink" title="3.2.2.3 显示和更新窗口"></a>3.2.2.3 显示和更新窗口</h4><p>CTestApp中名为m_pMainWnd的成员变量保存了应用程序框架窗口（CMainFrame）对象的指针，在InitInstance函数（初始化工作：注册、显示、更新）内部：<br><strong>程序3.5</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唯一的一个窗口已初始化，因此显示它并对其进行更新</span></span><br><span class="line">  m_pMainWnd-&gt;ShowWindow(SW_SHOW);<span class="comment">//显示</span></span><br><span class="line">  m_pMainWnd-&gt;UpdateWindow();<span class="comment">//更新</span></span><br></pre></td></tr></table></figure><h3 id="3-2-3-消息循环"><a href="#3-2-3-消息循环" class="headerlink" title="3.2.3 消息循环"></a>3.2.3 消息循环</h3><p>见程序3.4的第12行。在thrdcore.cpp中<code>/*消息循环*/    nReturnCode = pThread-&gt;Run();</code></p><p>书本p85例3-16，该函数主要结构是一个for循环，在收到WM_QUIT时退出。在循环中的PumpMessage()与第一章的SDK编程的消息处理代码一致。</p><h3 id="3-2-4-MFC运行过程梳理"><a href="#3-2-4-MFC运行过程梳理" class="headerlink" title="3.2.4 MFC运行过程梳理"></a>3.2.4 MFC运行过程梳理</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708745365962-cb74b989-7e48-4bf6-a2d8-648637033aea.jpeg#averageHue=%2393928e&amp;clientId=u36ddef60-4b23-4&amp;from=paste&amp;height=1938&amp;id=u7043a8f4&amp;originHeight=2114&amp;originWidth=3521&amp;originalType=binary&amp;ratio=1.0909090909090908&amp;rotation=0&amp;showTitle=false&amp;size=1817235&amp;status=done&amp;style=none&amp;taskId=ue64837f9-9983-4081-a9f1-7fd32b838a4&amp;title=&amp;width=3227.5833333333335" alt="IMG_20210628_164535.jpg"></p><h2 id="3-3-窗口类、窗口对象与窗口"><a href="#3-3-窗口类、窗口对象与窗口" class="headerlink" title="3.3 窗口类、窗口对象与窗口"></a>3.3 窗口类、窗口对象与窗口</h2><h3 id="3-3-1-三者之间的关系"><a href="#3-3-1-三者之间的关系" class="headerlink" title="3.3.1 三者之间的关系"></a>3.3.1 三者之间的关系</h3><p>:: 前面没有东西，表示所使用的函数是一个全局函数。如果当前定义的成员函数与内部调用的API函数重名，后者必须加  :: ，否则报错。</p><p>C窗口类对象与窗口并不是一回事，他们之间唯一的关系是C窗口类对象内部定义了一个窗口句柄变量，保存了与这个C窗口类对象相关的那个窗口的句柄。窗口销毁时，与之对应的C窗口类对象销毁与否要看其生命周期是否结束。但C++窗口类对象销毁时，与之相关的窗口也将销毁。</p><p>上段话用自己的话说：在窗口销毁后，CWnd的成员变量m_hWnd设为NULL，并没有被销毁（也有可能被销毁：对象生命周期结束（函数运行到右大括号“}”））；而在C++窗口类对象析构时，窗口被销毁。</p><p>在系统文件afxwin.h中,CWnd已有一个用于保存句柄的成员变量m_hWnd,ShowWindow()和UpdateWindow()不需要再传递这个句柄，因为它已经是成员变量。<br><strong>程序3.6</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*afxwin.h*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CWnd</span> :</span> public CCmdTarget</span><br><span class="line">&#123;</span><br><span class="line">  DECLARE_DYNCREATE(CWnd)</span><br><span class="line">protected:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> MSG* PASCAL <span class="title function_">GetCurrentMessage</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attributes</span></span><br><span class="line">public:</span><br><span class="line">  HWND m_hWnd;            <span class="comment">// must be first data member</span></span><br><span class="line">    ......</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*lesson3:\\wainmain.cpp*/</span></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">WinMain</span><span class="params">(  HINSTANCE hInstance,      <span class="comment">// handle to current instance</span></span></span><br><span class="line"><span class="params">  HINSTANCE hPrevInstance,  <span class="comment">// handle to previous instance</span></span></span><br><span class="line"><span class="params">  LPSTR lpCmdLine,          <span class="comment">// command line</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> nCmdShow              <span class="comment">// show state</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设计窗口类</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//注册窗口类</span></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//创建窗口类</span></span><br><span class="line">    CWnd wnd;</span><br><span class="line">    wnd.CreateEx(...);</span><br><span class="line">    wnd.ShowWindow(SW_SHOWNORMAL);</span><br><span class="line">    wnd.UpdateWindow();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对比第一章：</span></span><br><span class="line"><span class="comment">    创建窗口</span></span><br><span class="line"><span class="comment">  HWND hwnd;</span></span><br><span class="line"><span class="comment">  hwnd = CreateWindowEx();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  显示及刷新窗口</span></span><br><span class="line"><span class="comment">  ::ShowWindow(hwnd, SW_SHOWNORMAL);</span></span><br><span class="line"><span class="comment">  ::UpdateWindow(hwnd);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    注意ShowWindow和UpdateWindow的参数，原因是：CWnd类定义过了一个HWND类型的成员变量m_hWnd用于保存这个窗口的句柄，</span></span><br><span class="line"><span class="comment">    在调用CWnd类中的ShowWindow显示窗口时，就不在需要传递这个句柄了，因为它已经是成员变量了，该函数可以直接使用它。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    在窗口销毁后，CWnd的成员变量m_hWnd设为NULL，并没有被销毁；而在C++窗口类对象析构时，窗口被销毁。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//消息循环</span></span><br><span class="line">     ...   </span><br><span class="line">         </span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-在窗口中显示按钮"><a href="#3-3-2-在窗口中显示按钮" class="headerlink" title="3.3.2 在窗口中显示按钮"></a>3.3.2 在窗口中显示按钮</h3><p>CButton的Create函数声明：<br><code>BOOL Create( LPCTSTR lpszCaption, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID );</code></p><ul><li>lpszCaption：按钮文本；</li><li>dwStyle：按钮风格+窗口风格；</li><li>rect：定义一个矩形区域；</li><li>pParentWnd：指定父窗口。MFC不再通过窗口句柄，而是通过一个与窗口相关的C++窗口类对象指针来传递窗口对象。</li><li>nID:按钮控件标识。可取整数随机值。在框架窗口产生之后，再创建该标识，否则没地方放置。</li></ul><p>窗口创建时都会产生WM_Create消息，OnCreate函数用于相应这条窗口创建消息。</p><p>如果将按钮创建在CMainFrame::OnCreate()函数内，按钮的父窗口是主框架窗口，此时按钮遮挡住了保存等按钮。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708745378767-bd154cd4-0ce9-412f-9727-f627a5a7ba16.png#averageHue=%23f8f8f8&amp;clientId=u36ddef60-4b23-4&amp;from=paste&amp;height=359&amp;id=u19b856da&amp;originHeight=392&amp;originWidth=473&amp;originalType=binary&amp;ratio=1.0909090909090908&amp;rotation=0&amp;showTitle=false&amp;size=11529&amp;status=done&amp;style=none&amp;taskId=u37cbe054-bf17-449b-b5c2-7e27b0cd463&amp;title=&amp;width=433.58333333333337" alt="image(5).png"></p><p>改为在CTestView.cpp中创建button，首先在testView.cpp中创建OnCreate函数，步骤如问题及反思[3]所示。运行结果如下。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708745389524-b5a69e4b-93ce-491f-930c-66b1dd73768e.jpeg#averageHue=%23f9f9f8&amp;clientId=u36ddef60-4b23-4&amp;from=paste&amp;height=342&amp;id=ua360e299&amp;originHeight=373&amp;originWidth=478&amp;originalType=binary&amp;ratio=1.0909090909090908&amp;rotation=0&amp;showTitle=false&amp;size=21537&amp;status=done&amp;style=none&amp;taskId=u37f2b81c-7387-496f-b8b5-b65cb635e91&amp;title=&amp;width=438.1666666666667" alt="屏幕截图 2021-06-29 103602.jpg"></p><p>而将m_btn.Create()中的this改为GetParent(),运行结果变为</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708745400906-50533c80-aedc-4146-aec2-bbfbb55d0523.png#averageHue=%23f8f8f8&amp;clientId=u36ddef60-4b23-4&amp;from=paste&amp;height=359&amp;id=ud85f9d87&amp;originHeight=392&amp;originWidth=473&amp;originalType=binary&amp;ratio=1.0909090909090908&amp;rotation=0&amp;showTitle=false&amp;size=11529&amp;status=done&amp;style=none&amp;taskId=u026d89e7-0cc3-4c9b-897d-8f389cd56f3&amp;title=&amp;width=433.58333333333337" alt="image(6).png"></p><p>可见，按钮的位置与其父窗口有关，与创建它的代码所在的类无关。</p><p>将按钮窗口销毁，m_btn并没有销毁，因为m_btn是CTestView类的一个成员变量，其生命周期与CTestView对象一致。</p><h2 id="课后程序-2"><a href="#课后程序-2" class="headerlink" title="课后程序"></a>课后程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*testview.h*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CtestView</span> :</span> public CView</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">private:</span><br><span class="line">  CButton m_btn;  <span class="comment">//在定义类的成员变量时都以&quot;m_&quot;为前缀，表明这个变量是类的成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*testview.cpp*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CtestView::OnCreate</span><span class="params">(LPCREATESTRUCT lpCreateStruct)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (CView::OnCreate(lpCreateStruct) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*CButton的Create函数声明：BOOL Create( LPCTSTR lpszCaption, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID );*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  m_btn.Create(_T(&quot;button&quot;), WS_CHILD | BS_DEFPUSHBUTTON, CRect(0, 0, 100, 100), this, 123);</span></span><br><span class="line"><span class="comment">//  m_btn.ShowWindow(SW_SHOWNORMAL);//窗口显示</span></span><br><span class="line"></span><br><span class="line">  m_btn.Create(_T(<span class="string">&quot;button&quot;</span>), WS_CHILD | BS_DEFPUSHBUTTON |WS_VISIBLE , CRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>), this, <span class="number">123</span>);</span><br><span class="line"><span class="comment">//  m_btn.Create(_T(&quot;button&quot;), WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON, CRect(0, 0, 100, 100), GetParent(), 123);</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">  &quot;按钮&quot;：名称； CRect(0,0,100,100)：矩形区域； 123：ID号。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  WS_CHILD（窗口风格）:The window is a child window. A window with this style cannot have a menu bar.</span></span><br><span class="line"><span class="comment">  BS_DEFPUSHBUTTON（按钮风格）:下按按钮风格</span></span><br><span class="line"><span class="comment">  WS_VISIBLE:The window is initially visible.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  this指针（代表对象本身）</span></span><br><span class="line"><span class="comment">  GetParent():Call this function to get a pointer to a child window&#x27;s parent window</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  C2664  “BOOL CButton::Create(LPCTSTR,DWORD,const RECT &amp;,CWnd *,UINT)”: 无法将参数 1 从“const char [7]”转换为“LPCTSTR”  test  E:\VCProject\Lesson3\test\test\MainFrm.cpp  68</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  解决方法：</span></span><br><span class="line"><span class="comment">  方法1、&quot;button&quot;改为_T(&quot;button&quot;)[2]</span></span><br><span class="line"><span class="comment">  方法2、调试&gt;&gt;XXX调试属性&gt;&gt;配置属性&gt;&gt;高级&gt;&gt;高级属性&gt;&gt;字符集，改为：使用多字节字符集[3]</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708745412623-e486145b-9b48-4a8b-ba6e-f207c4956bfd.jpeg#averageHue=%23f9f9f8&amp;clientId=u36ddef60-4b23-4&amp;from=paste&amp;height=342&amp;id=u66b53f0d&amp;originHeight=373&amp;originWidth=478&amp;originalType=binary&amp;ratio=1.0909090909090908&amp;rotation=0&amp;showTitle=false&amp;size=21537&amp;status=done&amp;style=none&amp;taskId=ue47d26be-ba4d-42d3-836f-addde49943d&amp;title=&amp;width=438.1666666666667" alt="屏幕截图 2021-06-29 103602(1).jpg"></p><h2 id="问题及反思-1"><a href="#问题及反思-1" class="headerlink" title="问题及反思"></a>问题及反思</h2><p>[1]如何利用vs2019创建MFC应用见参考文献[1]</p><p>[2]C2664    “BOOL CButton::Create(LPCTSTR,DWORD,const RECT &amp;,CWnd *,UINT)”: 无法将参数 1 从“const char [7]”转换为“LPCTSTR”<br>解决方法：<br>方法1、”button”改为_T(“button”)<br>方法2、调试&gt;&gt;XXX调试属性&gt;&gt;配置属性&gt;&gt;高级&gt;&gt;高级属性&gt;&gt;字符集，改为：使用多字节字符集</p><p>[3]vs2019为一个类添加某函数的方法如下所示。第四步单击最右侧向下小三角，选择Add  OnCreate。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/21452222/1708745424131-528c1482-9393-43d1-b507-4772e7c31b8c.jpeg#averageHue=%23e6ecec&amp;clientId=u36ddef60-4b23-4&amp;from=paste&amp;height=828&amp;id=uf058e09c&amp;originHeight=903&amp;originWidth=332&amp;originalType=binary&amp;ratio=1.0909090909090908&amp;rotation=0&amp;showTitle=false&amp;size=106972&amp;status=done&amp;style=none&amp;taskId=u4ea5f69f-e3b6-422b-9d3a-28dade09475&amp;title=&amp;width=304.33333333333337" alt="屏幕截图 2021-06-29 103208.jpg"></p><h2 id="参考文献-2"><a href="#参考文献-2" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] &lt;<a href="https://blog.csdn.net/m0_37062716/article/details/113827243?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control">https://blog.csdn.net/m0_37062716/article/details/113827243?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control</a> &gt;.安装MFC,创建MFC工程文件</p><p>[2]<a href="[https://blog.csdn.net/huijie4728/article/details/50487315](https://blog.csdn.net/huijie4728/article/details/50487315)">[https://blog.csdn.net/huijie4728/article/details/50487315](https://blog.csdn.net/huijie4728/article/details/50487315)</a> . 问题及反思[2]</p><p>[3]<a href="[https://blog.csdn.net/feilong911hao/article/details/39231533?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control](https://blog.csdn.net/feilong911hao/article/details/39231533?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control)">[https://blog.csdn.net/feilong911hao/article/details/39231533?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control](https://blog.csdn.net/feilong911hao/article/details/39231533?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control)</a> . 问题及反思[2]</p><p>[4]孙鑫.VC++深度详解修订版[M]. 北京:电子工业出版社, 2012. 63-99.</p><hr><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="4-1-MFC消息映射机制"><a href="#4-1-MFC消息映射机制" class="headerlink" title="4.1 MFC消息映射机制"></a>4.1 MFC消息映射机制</h2><h3 id="4-1-1-classwizard"><a href="#4-1-1-classwizard" class="headerlink" title="4.1.1 classwizard"></a>4.1.1 classwizard</h3><p>所有操作，包括鼠标点击鼠标移动等操作都只能由视类窗口捕获。因为视类窗口在框架窗口之上，如果在框架窗口操作。就会被视类窗口覆盖而看不见了。</p><p>删除通过向导添加的消息响应函数时，应在向导中删除。</p><h3 id="4-1-2-消息映射机制"><a href="#4-1-2-消息映射机制" class="headerlink" title="4.1.2 消息映射机制"></a>4.1.2 消息映射机制</h3><p>一个MFC消息响应函数在程序中有3处相关信息：</p><p>1、消息响应函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*drawView.h*/</span></span><br><span class="line"><span class="comment">// 生成的消息映射函数</span></span><br><span class="line">protected:</span><br><span class="line">  DECLARE_MESSAGE_MAP()</span><br><span class="line">public:</span><br><span class="line">  afx_msg <span class="type">void</span> <span class="title function_">OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span>;</span><br></pre></td></tr></table></figure><p>2、消息映射宏</p><p>消息映射宏ON_WM_LBUTTONDOWN()的作用：把消息(WM_LBUTTONDOWN)与消息响应函数(OnLButtonDown)关联起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN_MESSAGE_MAP(CdrawView, CView)</span><br><span class="line">  <span class="comment">// 标准打印命令</span></span><br><span class="line">  ON_COMMAND(ID_FILE_PRINT, &amp;CView::OnFilePrint)</span><br><span class="line">  ON_COMMAND(ID_FILE_PRINT_DIRECT, &amp;CView::OnFilePrint)</span><br><span class="line">  ON_COMMAND(ID_FILE_PRINT_PREVIEW, &amp;CView::OnFilePrintPreview)</span><br><span class="line">  ON_WM_LBUTTONDOWN()</span><br><span class="line">END_MESSAGE_MAP()</span><br></pre></td></tr></table></figure><p>3、消息响应函数的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*drawView.cpp*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">  MessageBox(<span class="string">&quot;click down&quot;</span>);</span><br><span class="line">  CView::OnLButtonDown(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MFC消息映射方式的具体实现：在每个能接受和处理消息的类中，定义一个消息和消息函数静态对照表，即消息映射表。<strong>在消息映射表中，消息和对应的消息处理函数指针成对出现。</strong>某个类能处理的所有信息及其对应的消息处理函数地址都列在这个类对应的静态表中。当有消息需要处理时，程序只能搜索该消息静态表，查看表中是否含有该消息，就知道该类能否处理此消息。如果能处理，则同样依照静态表能很容易找到并调用对应的消息处理函数。</p><h2 id="4-2-绘制线条"><a href="#4-2-绘制线条" class="headerlink" title="4.2 绘制线条"></a>4.2 绘制线条</h2><p>在基类中添加成员变量的原因：可以一直存在；而在子类中，程序运行到右}，变量的生命周期就结束了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CdrawView</span> :</span> public CView&#123;...</span><br><span class="line">private:</span><br><span class="line">  CPoint m_ptOrigin;</span><br><span class="line">  ...&#125;;</span><br></pre></td></tr></table></figure><p>在构造函数中将m_ptOrigin赋0以初始化后，在消息响应函数中将鼠标按下的信息保存到基类的成员变量m_ptOrigin中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;<span class="comment">//CPoint point接收按下鼠标左键的位置</span></span><br><span class="line">  m_ptOrigin = point;</span><br><span class="line">  <span class="comment">/*保存该位置到基类的成员变量；</span></span><br><span class="line"><span class="comment">  **当前的鼠标坐标也就是划线的起点坐标。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  CView::OnLButtonDown(nFlags, point);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后添加WM_LButtonUp.</p><h3 id="4-2-1-利用SDK全局函数实现划线功能"><a href="#4-2-1-利用SDK全局函数实现划线功能" class="headerlink" title="4.2.1 利用SDK全局函数实现划线功能"></a>4.2.1 利用SDK全局函数实现划线功能</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体实现如下：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 获取设备描述表</span></span><br><span class="line">  HDC hdc;</span><br><span class="line">  hdc = ::GetDC(m_hWnd);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//移动到线条的起点</span></span><br><span class="line">  MoveToEx(hdc , m_ptOrigin.x , m_ptOrigin.y , <span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//划线</span></span><br><span class="line">  LineTo(hdc , point.x , point.y );</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//释放设备描述表</span></span><br><span class="line">  ::ReleaseDC(m_hWnd , hdc);</span><br><span class="line"></span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699693442-7e86c413-92a8-470b-a890-5b28d08cdf89.png#averageHue=%23fcfbfb&amp;id=YgJFN&amp;originHeight=739&amp;originWidth=795&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=%E5%9B%BE4.1%20%E5%88%A9%E7%94%A8SDK%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%88%92%E7%BA%BF%E5%8A%9F%E8%83%BD" alt=""></p><p>1、获取设备描述表(平台SDK的GetDC)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字典</span></span><br><span class="line"><span class="comment">//平台SDK的GetDC</span></span><br><span class="line">HDC <span class="title function_">GetDC</span><span class="params">(</span></span><br><span class="line"><span class="params">  HWND hWnd</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//本例</span></span><br><span class="line">HDC hdc;<span class="comment">//HDC:A handle to a device context (DC).</span></span><br><span class="line"><span class="comment">/*device context (DC):There are four types of DCs: display, </span></span><br><span class="line"><span class="comment">printer, memory (or compatible), and information. </span></span><br><span class="line"><span class="comment">Each type serves a specific purpose*/</span></span><br><span class="line"></span><br><span class="line">hdc = ::GetDC(m_hWnd);</span><br><span class="line"><span class="comment">/*用自己的话说（暂时的理解是），HWND hWnd就是当前窗口，HDC hdc就是用来画画的，</span></span><br><span class="line"><span class="comment">GetDC()就是把当前窗口中用来画画的一部分（DC）取出来赋给hdc变量,</span></span><br><span class="line"><span class="comment">意思是接下来的画的东西都会保存在hdc上，也就是保存在了hWnd当前窗口的DC上</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//注意最后释放 </span></span><br><span class="line">::ReleaseDC(m_hWnd , hdc);<span class="comment">//将m_hWnd窗口的hdc释放</span></span><br></pre></td></tr></table></figure><p>2、鼠标移动到线条的起点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">MoveToEx</span><span class="params">(</span></span><br><span class="line"><span class="params">  HDC     hdc, <span class="comment">//设备描述表句柄</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span>     x,</span></span><br><span class="line"><span class="params">  <span class="type">int</span>     y, <span class="comment">//起点坐标</span></span></span><br><span class="line"><span class="params">  LPPOINT lppt <span class="comment">//指向point结构体的指针，保存移动操作前鼠标的位置坐标</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">MoveToEx(hdc , m_ptOrigin.x , m_ptOrigin.y , <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>3、划线</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">LineTo</span><span class="params">(</span></span><br><span class="line"><span class="params">  HDC hdc,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> x,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> y<span class="comment">//终点坐标</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">LineTo(hdc , point.x , point.y );</span><br></pre></td></tr></table></figure><h3 id="4-2-2-利用MFC的CDC类实现画图功能"><a href="#4-2-2-利用MFC的CDC类实现画图功能" class="headerlink" title="4.2.2 利用MFC的CDC类实现画图功能"></a>4.2.2 利用MFC的CDC类实现画图功能</h3><p>MFC为我们提供了一个设备描述表的封装类CDC，该类封装了所有绘图操作。该类中的数据成员m_hDC保存与CDC类相关的DC句柄，因此不需要DC句柄作为参数，其作用类似m_hWnd。而平台SDK提供的全局TextOut()则不然。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  CDC* pDC = GetDC(); <span class="comment">//此处的GetDC是CWnd()的而不是平台SDK的。</span></span><br><span class="line">  pDC-&gt;MoveTo(m_ptOrigin);<span class="comment">//从什么位置</span></span><br><span class="line">  <span class="comment">/*pDC是指向CDC类的指针，MoveTo()是CDC类的函数，所以用指向符-&gt;*/</span></span><br><span class="line">  <span class="comment">/*如果是CDC类的对象的话就用“.”号*/</span></span><br><span class="line">  pDC-&gt;LineTo(point);<span class="comment">//画线到什么位置</span></span><br><span class="line">  ReleaseDC(pDC);</span><br><span class="line"></span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的GetDC是CWnd()的而不是平台SDK的。对比4.2.1的GetDC</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字典</span></span><br><span class="line">CWnd::GetDC </span><br><span class="line">CDC* <span class="title function_">GetDC</span><span class="params">( )</span>;</span><br></pre></td></tr></table></figure><h3 id="4-2-3-利用MFC的CClientDC类实现画图功能"><a href="#4-2-3-利用MFC的CClientDC类实现画图功能" class="headerlink" title="4.2.3 利用MFC的CClientDC类实现画图功能"></a>4.2.3 利用MFC的CClientDC类实现画图功能</h3><p>CClientDC类派生于CDC类，并在构造函数时<strong>自动调用GetDC和ReleaseDC</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  CClientDC <span class="title function_">dc</span><span class="params">(this)</span>;</span><br><span class="line"><span class="comment">/*CClientDC dc(CWnd* pWnd);</span></span><br><span class="line"><span class="comment">**CWnd* pWnd是指向窗口的指针，此处需要指向视类窗口对象，即CdrawView。</span></span><br><span class="line"><span class="comment">**在CdrawView::OnLButtonUp(...)中使用this指向CdrawView自己。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*DetParent()返回父类窗口的指针*/</span></span><br><span class="line"></span><br><span class="line">  dc.MoveTo(m_ptOrigin);</span><br><span class="line">  dc.LineTo(point);</span><br><span class="line"><span class="comment">/*这里CClientDC类型的变量dc是一个对象，因此使用点操作符来调用该对象的函数；</span></span><br><span class="line"><span class="comment">**4.2.2中，pDC是指向CDC类的指针，MoveTo()是CDC类的函数，所以用指向符-&gt;  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  </span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4-利用MFC的CWindowDC类实现画图功能"><a href="#4-2-4-利用MFC的CWindowDC类实现画图功能" class="headerlink" title="4.2.4 利用MFC的CWindowDC类实现画图功能"></a>4.2.4 利用MFC的CWindowDC类实现画图功能</h3><p>CWindowDC类派生于CDC类，并在构造函数时<strong>自动调用GetDC和ReleaseDC</strong>，调用方式与CClientDC一样。</p><p>不同于CClientDC的是，CWindowDC可以访问整个窗口区域，包括框架窗口的客户区（菜单栏以下）和非客户区（标题栏和菜单栏）；而CClientDC最多只能到客户区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  CWindowDC <span class="title function_">dc</span><span class="params">(GetDesktopWindow())</span>;<span class="comment">//整个桌面窗口</span></span><br><span class="line">  <span class="comment">//CWindowDC dc(GetParent());//框架窗口，包括客户区和非客户区</span></span><br><span class="line">  <span class="comment">//CWindowDC dc(this);//视类窗口</span></span><br><span class="line">  dc.MoveTo(m_ptOrigin);</span><br><span class="line">  dc.LineTo(point);</span><br><span class="line">  </span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-5-在桌面窗口划线"><a href="#4-2-5-在桌面窗口划线" class="headerlink" title="4.2.5 在桌面窗口划线"></a>4.2.5 在桌面窗口划线</h3><p>见4.2.4。</p><h3 id="4-2-6-绘制线条色彩"><a href="#4-2-6-绘制线条色彩" class="headerlink" title="4.2.6 绘制线条色彩"></a>4.2.6 绘制线条色彩</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  CPen <span class="title function_">pen</span><span class="params">(PS_SOLID, <span class="number">1</span>, RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span>;</span><br><span class="line">  CClientDC <span class="title function_">dc</span><span class="params">(this)</span>;</span><br><span class="line">  <span class="comment">//只创建CPen不会生效，还要将其选入设备描述表</span></span><br><span class="line">  CPen* pOldPen = dc.SelectObject(&amp;pen);</span><br><span class="line">  dc.MoveTo(m_ptOrigin);</span><br><span class="line">  dc.LineTo(point);</span><br><span class="line">  <span class="comment">//还原设备描述表</span></span><br><span class="line">  dc.SelectObject(pOldPen);</span><br><span class="line"></span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699693561-d4db98aa-a5a0-4a80-a00b-5c6d2afdc349.png#averageHue=%23fbfafa&amp;id=wcueU&amp;originHeight=599&amp;originWidth=715&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;status=done&amp;style=none&amp;title=%E5%9B%BE4.2%20%E7%BB%98%E5%88%B6%E5%BD%A9%E8%89%B2%E7%BA%BF%E6%9D%A1" alt="图4.2 绘制彩色线条" title="图4.2 绘制彩色线条"></p><p>1、Cpen类创建画笔对象，该类封装了画笔的相关操作</p><p><code>CPen (int nPenStyle , int Width , COLORREF crColor);</code></p><p>三个参数分别代表线形、线宽和颜色。</p><p>颜色用RGB(r,g,b)表示，每个参数都是0~255之间。黑色全0，白色全255.</p><p>2、在程序中构造GDI对象后,该对象不会立即生效，必须<strong>(作用1)选入设备描述表</strong>后，才会生效。<code>SelectObject()</code>函数除了实现以上操作，还会<strong>(作用2)返回指向先前被选中对象的指针</strong>，以在完成绘画后，还原设备描述表。</p><p>小结：需要使用<code>SelectObject()</code>选入设备描述表：CPen类、Rectangle函数</p><h2 id="4-3-画刷"><a href="#4-3-画刷" class="headerlink" title="4.3 画刷"></a>4.3 画刷</h2><h3 id="4-3-1-简单画刷"><a href="#4-3-1-简单画刷" class="headerlink" title="4.3.1 简单画刷"></a>4.3.1 简单画刷</h3><p>利用CBrush类创建画刷对象，以填充一块区域。</p><p><code>CBrush(COLORREF crColor )</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  CBrush <span class="title function_">brush</span><span class="params">(RGB(<span class="number">255</span> , <span class="number">0</span>, <span class="number">0</span>))</span>;<span class="comment">//创建红色画刷</span></span><br><span class="line">  CClientDC <span class="title function_">dc</span><span class="params">(this)</span>;<span class="comment">//创建并获取设备描述表</span></span><br><span class="line">  <span class="comment">//利用红色画刷填充鼠标拖拽过程中产生的矩形区域</span></span><br><span class="line">  dc.FillRect(CRect(m_ptOrigin, point), &amp;brush);</span><br><span class="line">  </span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699693661-4f28b577-50a3-4725-89ab-c8820f6d5111.png#averageHue=%23fbc6c6&amp;id=iUBHB&amp;originHeight=560&amp;originWidth=635&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;status=done&amp;style=none&amp;title=%E5%9B%BE4.3%20%E7%BA%A2%E8%89%B2%E7%AE%80%E5%8D%95%E7%94%BB%E5%88%B7" alt="图4.3 红色简单画刷" title="图4.3 红色简单画刷"></p><p>1、FillRect函数：利用画刷填充鼠标拖拽过程中产生的矩形区域，包括左边和上部边界，不填充右边和底部边界。</p><p><code>void FillRect( LPCRECT lpRect, CBrush* pBrush );</code></p><p>1、<code>lpRect</code>：指向一个RECT结构体或CRect对象指针。本例使用CRect()函数,即   <code>CRect( POINT topLeft, POINT bottomRight );</code>第一个参数是左上角点，第二个参数是右下角点，以确定一个矩形。</p><p>2、<code>pBrush</code>：指向用于填充矩形的画刷对象的指针。</p><h3 id="4-3-2-位图画刷"><a href="#4-3-2-位图画刷" class="headerlink" title="4.3.2 位图画刷"></a>4.3.2 位图画刷</h3><p>CBrush类中有如下构造函数：<code>CBrush (CBitmap* pBitMap);</code>其中，CBitmap类是位图类。创建CBitmap对象时，仅调用其构造函数，并不能得到有用的位图对象，还需要调用初始化函数来初始化该位图对象。本例中用加载位图的初始化函数：<code>LoadBitmap(UINT nIDResource);</code>。其中，<code>nIDResource</code>是资源ID号，在资源视图中查看，如图4.6所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  CBitmap bitmap;<span class="comment">//创建位图对象</span></span><br><span class="line">  bitmap.LoadBitmap(IDB_BITMAP1);<span class="comment">//初始化位图对象</span></span><br><span class="line">  CBrush <span class="title function_">brush</span><span class="params">(&amp;bitmap)</span>;<span class="comment">//将位图对象装进画刷</span></span><br><span class="line">  CClientDC <span class="title function_">dc</span><span class="params">(this)</span>;<span class="comment">//创建并获取设备描述表</span></span><br><span class="line">  <span class="comment">//用位图填充矩形区域</span></span><br><span class="line">  dc.FillRect(CRect(m_ptOrigin , point) , &amp;brush);</span><br><span class="line"></span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699693762-0fb01846-4578-4426-b142-8da40dd2e4f8.png#averageHue=%23faf8f8&amp;id=rr2t3&amp;originHeight=536&amp;originWidth=540&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;status=done&amp;style=none&amp;title=%E5%9B%BE4.3%20%E4%BD%8D%E5%9B%BE%E7%94%BB%E5%88%B7%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C" alt="图4.3 位图画刷运行结果" title="图4.3 位图画刷运行结果"></p><p>1、位图的创建过程如下所示。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699693851-c49376bd-9887-41db-bba3-2b217dc2c643.png#averageHue=%2327323b&amp;id=INXoX&amp;originHeight=530&amp;originWidth=331&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p><img src="image/image (1" alt="">_4EcJoeM6pn.png&gt;)</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699693954-5da557da-f305-4d56-a5a7-991b455a66e0.png#averageHue=%23f2f1f0&amp;id=O9tW0&amp;originHeight=391&amp;originWidth=541&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;status=done&amp;style=none&amp;title=%E5%9B%BE4.5%20%E4%BD%8D%E5%9B%BE%E7%9A%84%E5%88%9B%E5%BB%BA" alt="图4.5 位图的创建" title="图4.5 位图的创建"></p><p>2、资源ID在资源视图中查看</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699694042-c77a2d2d-6dc5-466f-808f-d8b111e18588.png#averageHue=%23242c33&amp;id=BXuvi&amp;originHeight=525&amp;originWidth=330&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;status=done&amp;style=none&amp;title=%E5%9B%BE4.6%20%E6%9F%A5%E7%9C%8B%E8%B5%84%E6%BA%90ID" alt="图4.6 查看资源ID" title="图4.6 查看资源ID"></p><h3 id="4-3-3-透明画刷"><a href="#4-3-3-透明画刷" class="headerlink" title="4.3.3 透明画刷"></a>4.3.3 透明画刷</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  CClientDC <span class="title function_">dc</span><span class="params">(this)</span>;</span><br><span class="line">  <span class="comment">//创建空画刷</span></span><br><span class="line">  CBrush* pBrush = CBrush::FromHandle(</span><br><span class="line">          (HBRUSH) GetStockObject(NULL_BRUSH));</span><br><span class="line">  <span class="comment">//将画刷选入设备描述表</span></span><br><span class="line">  CBrush* pOldBrush = dc.SelectObject(pBrush);</span><br><span class="line">  dc.Rectangle(CRect(m_ptOrigin, point));</span><br><span class="line">  dc.SelectObject(pBrush);</span><br><span class="line"></span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699694153-87275896-fa7e-4ca9-b5ee-29627d1c10e5.png#averageHue=%23f9f8f8&amp;id=aUomT&amp;originHeight=576&amp;originWidth=582&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;status=done&amp;style=none&amp;title=%E5%9B%BE4.7%20%E9%80%8F%E6%98%8E%E7%94%BB%E5%88%B7" alt="图4.7 透明画刷" title="图4.7 透明画刷"></p><p>1、GetStockObject()函数,获取一个黑点或白色的画刷句柄</p><p>GetStockObject(NULL_BRUSH);获取一个空画刷</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HGDIOBJ <span class="title function_">GetStockObject</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">int</span> fnObject   <span class="comment">// stock object type</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>再利用强制类型转换，将HGDIOBJ类型转换为HBRUSH类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(HBRUSH) GetStockObject(NULL_BRUSH);</span><br></pre></td></tr></table></figure><p>2、FromHandle()函数将画刷句柄转化为画刷对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> CBrush* PASCAL <span class="title function_">FromHandle</span><span class="params">( HBRUSH hBrush )</span>;</span><br><span class="line"><span class="comment">/*Parameters(参数)</span></span><br><span class="line"><span class="comment">hBrush </span></span><br><span class="line"><span class="comment">Specifies the HANDLE to a Windows CE GDI brush. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Return Value</span></span><br><span class="line"><span class="comment">A pointer to a CBrush object if successful; otherwise, it is NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="static静态成员函数"><a href="#static静态成员函数" class="headerlink" title="static静态成员函数"></a><strong>static静态成员函数</strong></h4><p><strong>P126</strong></p><p>(1)<strong>静态成员</strong>函数和静态成员变量<strong>属于类本身</strong>，而不属于某一个变量，<strong>在类加载的时候，既为他们分配了空间</strong>，所以可以通过<strong>类名::函数名</strong>或<strong>类名:变量名</strong>来访问。而非静态成员函数和非静态成员变量属于对象的方法和数据，即应先产生类的对象，再通过类的对象去引用。</p><p>(2)<strong>在静态成员函数中是不能调用非静态成员的</strong>，包括非静态成员函数和非静态成员变量；静态成员函数<strong>只能访问静态成员变量</strong>。而<strong>非静态成员函数中是可以调用静态成员函数的</strong>。</p><p>(1)和(2)小结：也就是说，无论采用什么样的操作，代码都是在内存中运行的。<strong>程序只有在内存中占有一席之地，才能够访问它。</strong></p><p>(3)对于静态成员变量，必须对其<strong>初始化</strong>，并且应<strong>在类的定义之外</strong>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>;<span class="comment">//静态成员函数</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;x = &quot;</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> x;<span class="comment">//静态成员变量</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Point::x = <span class="number">0</span>;<span class="comment">//知识点(3)：1初始化2在类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Point::init();<span class="comment">//知识点(1)：用类名::函数名来直接调用</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果输出x = 0*/</span></span><br></pre></td></tr></table></figure><h2 id="4-4-绘制连续线条"><a href="#4-4-绘制连续线条" class="headerlink" title="4.4 绘制连续线条"></a>4.4 绘制连续线条</h2><p>为捕获鼠标移动过程的每一个点，可以通过捕获鼠标移动消息(WM_MouseMove)来实现。只要鼠标在程序窗口中移动，都会进入这个消息响应函数中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*drawView.h*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CdrawView</span> :</span> public CView</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">private:</span><br><span class="line">  BOOL m_bdraw;<span class="comment">//判断鼠标左键是否按下去，按下为真，否则为假</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*drawView.cpp*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  m_ptOrigin = point;</span><br><span class="line">  m_bdraw = <span class="number">1</span>;</span><br><span class="line">  CView::OnLButtonDown(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  m_bdraw = <span class="number">0</span>;</span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnMouseMove</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  CClientDC <span class="title function_">dc</span><span class="params">(this)</span>;</span><br><span class="line">  CPen <span class="title function_">pen</span><span class="params">(PS_SOLID , <span class="number">1</span> , RGB(<span class="number">255</span> , <span class="number">0</span> , <span class="number">0</span>))</span>;</span><br><span class="line">  CPen* pOldPen = dc.SelectObject(&amp;pen);</span><br><span class="line">  <span class="keyword">if</span> (m_bdraw == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    dc.MoveTo(m_ptOrigin);<span class="comment">//第一次左键按下</span></span><br><span class="line">    dc.LineTo(point);<span class="comment">//将起点与终点连线</span></span><br><span class="line">    m_ptOrigin = point;</span><br><span class="line">    <span class="comment">/*绘制完当前线段后，立即将上一段的终点位置赋给下一段的起点*/</span></span><br><span class="line">    dc.SelectObject(pOldPen);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CView::OnMouseMove(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699694251-1d815638-0a60-4b88-8631-f5a14aa2f72d.png#averageHue=%23faf9f9&amp;id=TvaSY&amp;originHeight=520&amp;originWidth=430&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;status=done&amp;style=none&amp;title=%E5%9B%BE4.8%20%E8%BF%9E%E7%BB%AD%E7%BB%98%E5%9B%BE%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C" alt="图4.8 连续绘图运行结果" title="图4.8 连续绘图运行结果"></p><h2 id="4-5-绘制扇形效果线条"><a href="#4-5-绘制扇形效果线条" class="headerlink" title="4.5 绘制扇形效果线条"></a>4.5 绘制扇形效果线条</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CdrawView::OnMouseMove</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">    dc.LineTo(m_ptOld);<span class="comment">//表示鼠标移动过程中的连线中，每个极小的线段</span></span><br><span class="line">    <span class="comment">//m_ptOrigin = point;//修改起点信息</span></span><br><span class="line">    m_ptOld = point;<span class="comment">//m_ptOld用于保存鼠标上一个移动点</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699694365-6851228c-add6-4f4f-af6c-410469b8a33f.png#averageHue=%23bfbfbe&amp;id=TH6yB&amp;originHeight=577&amp;originWidth=571&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;status=done&amp;style=none&amp;title=%E5%9B%BE4.9%20%E5%B8%A6%E8%BE%B9%E6%89%87%E5%BD%A2" alt="图4.9 带边扇形" title="图4.9 带边扇形"></p><h2 id="问题及反思-2"><a href="#问题及反思-2" class="headerlink" title="问题及反思"></a>问题及反思</h2><p>[1]位图创建过程见4.3.2</p><h2 id="参考文献-3"><a href="#参考文献-3" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]孙鑫.VC++深度详解修订版[M]. 北京:电子工业出版社, 2012. 100-134.</p><hr><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="5-1-插入符"><a href="#5-1-插入符" class="headerlink" title="5.1 插入符"></a>5.1 插入符</h2><h3 id="5-1-1-创建插入符"><a href="#5-1-1-创建插入符" class="headerlink" title="5.1.1 创建插入符"></a>5.1.1 创建插入符</h3><p>在窗口创建之后的WM_CREATE消息响应函数OnCreate中添加创建插入符代码：</p><p><code>void CreateSolidCaret(int nWidth , int nHeight);</code>若参数为0，则使用系统定义。</p><p>接着，使用<code>ShowCaret();</code>显示插入符。</p><p>对于CreateSolidCaret()的两个参数，可以根据<strong>字体度量信息</strong>自动调整插入符：</p><p><code>BOOL GetTextMetrics( LPTEXTMATRIC lpMetrics ) const;</code>其中，参数要求一个指向TEXTMETRIC结构体的指针，函数从DC中获取字体度量信息后填充进这个结构体。</p><p>经常用到的TEXTMETRIC结构体变量：</p><ul><li>int tmHeight;   //tmAscent+tmDescent</li><li>int tmAscent;   //升序高度</li><li>int tmDescent;   //降序高度</li><li>int tmAveCharWidth;   //平均宽度</li><li>int tmMaxCharWidth;   //最大字符宽度</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CtextView::OnCreate</span><span class="params">(LPCREATESTRUCT lpCreateStruct)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (CView::OnCreate(lpCreateStruct) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>  在此添加您专用的创建代码</span></span><br><span class="line">  CClientDC <span class="title function_">dc</span><span class="params">(this)</span>;</span><br><span class="line">  TEXTMETRIC tm;</span><br><span class="line">  dc.GetTextMetrics(&amp;tm);</span><br><span class="line">  CreateSolidCaret(tm.tmAveCharWidth / <span class="number">8</span> , tm.tmHeight); <span class="comment">//除以8是经验值</span></span><br><span class="line">  ShowCaret();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//创建插入符</span></span><br></pre></td></tr></table></figure><h3 id="5-1-2-创建图形插入符"><a href="#5-1-2-创建图形插入符" class="headerlink" title="5.1.2 创建图形插入符"></a>5.1.2 创建图形插入符</h3><p><code>void CreateCaret(CBitmap* pBitmap);</code>创建图形插入符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CtextView::OnCreate</span><span class="params">(LPCREATESTRUCT lpCreateStruct)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (CView::OnCreate(lpCreateStruct) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>  在此添加您专用的创建代码</span></span><br><span class="line"><span class="comment">//CBitmap对象在基类CView中创建</span></span><br><span class="line">  bitmap.LoadBitmap(IDB_BITMAP1);</span><br><span class="line">  CreateCaret(&amp;bitmap);</span><br><span class="line">  ShowCaret();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//位图插入符</span></span><br></pre></td></tr></table></figure><h2 id="5-2-窗口重绘"><a href="#5-2-窗口重绘" class="headerlink" title="5.2 窗口重绘"></a>5.2 窗口重绘</h2><h3 id="5-2-1-OnDraw函数"><a href="#5-2-1-OnDraw函数" class="headerlink" title="5.2.1 OnDraw函数"></a>5.2.1 OnDraw函数</h3><p>窗口重绘时，已输入的文字或图形就会被擦除。如想要保留，则需要WM_PAINT的消息响应函数OnCreate将内容再次输出（重绘）。</p><p>字符串类CString,其对象可以当作普通变量赋值、相加。</p><p>CDC类封装的TetOut(x,y,str);在指定位置显示字符串。</p><h3 id="5-2-2-添加字符串资源"><a href="#5-2-2-添加字符串资源" class="headerlink" title="5.2.2 添加字符串资源"></a>5.2.2 添加字符串资源</h3><p><code>BOOL LoadString(UINT nID);</code></p><p>其中，nID为字符串资源标识，如下图所示。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699694584-c0c2cce4-27da-4d50-bbb4-57010ae21186.png#averageHue=%23242b32&amp;id=KIzAw&amp;originHeight=515&amp;originWidth=314&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699694920-662b5ee5-3d6e-432d-b91e-06e95eacbc2e.png#averageHue=%23272d32&amp;id=qii1b&amp;originHeight=653&amp;originWidth=565&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CtextView::OnDraw</span><span class="params">(CDC* pDC)</span></span><br><span class="line">&#123;</span><br><span class="line">  CtextDoc* pDc = GetDocument();</span><br><span class="line">  ASSERT_VALID(pDoc);</span><br><span class="line">  <span class="keyword">if</span> (!pDoc)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此处为本机数据添加绘制代码</span></span><br><span class="line">  CString str;</span><br><span class="line">  str = <span class="string">&quot;VC++深入编程&quot;</span>;</span><br><span class="line">  pDC-&gt;TextOut(<span class="number">0</span>,<span class="number">0</span>,str);</span><br><span class="line"></span><br><span class="line">  str.LoadString(IDS_STRINGVC);</span><br><span class="line">  pDC-&gt;TextOut(<span class="number">0</span>,<span class="number">50</span>,str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699695015-c469fe2c-7750-4dd3-98ed-cdaeebd61f94.png#averageHue=%23f6f5f5&amp;id=tWjX9&amp;originHeight=384&amp;originWidth=381&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h2 id="5-3-路径层"><a href="#5-3-路径层" class="headerlink" title="5.3 路径层"></a>5.3 路径层</h2><p>1、步骤：</p><ol><li>打开路径层：BeginPath</li><li>利用GDI提供的绘图函数绘图</li><li>关闭路径层：EndPath</li></ol><p>2、<code>CSize GetTextExtent(str)</code>：获取某个特定<strong>字符串的宽度和高度</strong>,返回CSize对象。和GetTextMetrics（字体度量）区分。</p><p>3、裁剪区域：可以理解为一个绘图区域，大小可以由我们来控制，以后的绘图操作仅限于这个矩形区域内。</p><p>CDC类提供了<code>BOOL SelectClipPath(int nMod);</code>用于把当前设置的路径层和DC中已有的剪裁区域按照一定指定的模式进行一个互操作。</p><p>nMod是用于指定互操作的模式，如：</p><p>RGN_DIFF：新的剪裁区域包含当前剪裁区域，但排除当前路径层区域。</p><p>RGN_AND：剪裁区域和路径层的交集</p><p>小结：如果希望整幅图形中的某一部分与其他部分有所区别，就可以把这个部分的图形放置在一个路径层中，然后利用SelectClipPath函数设置一种模式，让路径层和剪裁区域进行互操作以达到一种特殊的效果。</p><h2 id="5-4-字符输入"><a href="#5-4-字符输入" class="headerlink" title="5.4 字符输入"></a>5.4 字符输入</h2><p>利用CString类对象可以直接字符输入。</p><p>输入字符，就会有WM_CHAR消息，在OnChar消息处理函数中写代码，说明要如何处理该消息。</p><p>设置插入符位置函数：CWnd类中的<code>SetCaretPos(POINT point);</code>函数。将插入符移动到鼠标左键单击处。</p><p>清除字符可以直接用CString类中的<code>Empty()</code> 来实现。</p><p>1、回车处理（ASCII为0x0d）</p><p>插入符横坐标不变，纵坐标发生变化：当前插入点的纵坐标加上字体高度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">0x0d</span> == nChar)</span><br><span class="line">&#123;</span><br><span class="line">  m_strLine.Empty();<span class="comment">//清空当前字符串</span></span><br><span class="line">  m_ptOrigin.y += tm.tmHeight;<span class="comment">//移动插入点</span></span><br><span class="line">  dc.TextOut(m_ptOrigin.x , m_ptOrigin.y , m_strLine);<span class="comment">//在新的插入点输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、退格键（ASCII为0x08）</p><p>步骤：</p><ol><li>设置文本颜色为背景色：<code>virtual COLORREF SetTextColor( COLORREF crColor );</code>返回原来的颜色。CDC::<code>GetBkColor()</code>获取背景色。</li><li>输出</li><li>在字符串变量中删除要删除的文字<code>CString Left( int nCount ) const;</code>其中，nCount指字符串左边指定数目的字符。<code>int GetLength( ) const;</code>获取长度。</li><li>还原文字颜色</li><li>输出</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">0x08</span> == nChar)</span><br><span class="line">&#123;</span><br><span class="line">  COLORREF clr = dc.SetTextColor(dc.GetBkColor());<span class="comment">//设置文本颜色为背景色</span></span><br><span class="line">  dc.TextOut(m_ptOrigin.x , m_ptOrigin.y , str);<span class="comment">//输出</span></span><br><span class="line">  m_strLine = m_strLine.Left(m_strLine.GetLength() - <span class="number">1</span>);<span class="comment">//在字符串变量中删除要删除的文字</span></span><br><span class="line">  dc.SetTextColor(clr);<span class="comment">//还原文字颜色</span></span><br><span class="line">  dc.TextOut(m_ptOrigin.x , m_ptOrigin.y , m_strLine);<span class="comment">//输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、设置字体</p><p>1、创建字体对象；</p><p>2、CFont类设置字体</p><p><code>BOOL CreatePointFont( int nPointSize, LPCTSTR lpszFaceName, CDC* pDC = NULL );</code></p><p>(字体高度，字体名称，NULL)</p><p>3、将字体选入DC，SelectObject(CFont *font);</p><p>4、字幕变色功能</p><p>CDC::DrawText函数 在指定矩形范围内输出文字。</p><p><code>int DrawText(const CString&amp; str, LPRECT lpRect, UINT nFormat );</code></p><p>（要输出的字符串，文字显示范围的矩形，文本的输出格式）</p><p>CWnd::SetTimer函数 定时器函数<br><code>UINT SetTimer( UINT nIDEvent, UINT nElapse, void (CALLBACK EXPORT* lpfnTimer)( HWND, UINT, UINT, DWORD) );</code></p><ul><li>UINT nIDEvent：非零定时器标识，函数调用成功，则返回标识；</li><li>UINT nElapse：以<strong>毫秒</strong>为单位的时间间隔，即每隔多长时间发送一次定时器消息<strong>WM_TIMER</strong>。程序在OnTimer函数中编写。</li><li>CALLBACK EXPORT* lpfnTimer：如果设置了该回调函数，则系统调用该回调函数处理消息。如果NULL，则窗口对象CWnd来处理</li></ul><p>参考文献：<br>[1]孙鑫.VC++深度详解修订版[M]. 北京:电子工业出版社, 2012. 135-161.</p><h1 id="第六章-菜单"><a href="#第六章-菜单" class="headerlink" title="第六章 菜单"></a>第六章 菜单</h1><h2 id="一、创建菜单项"><a href="#一、创建菜单项" class="headerlink" title="一、创建菜单项"></a>一、创建菜单项</h2><p>资源管理器→menu项→双击IDR_MAINFRAME打开菜单编辑器</p><p>pop-up类型的菜单是弹出式菜单，不能进行命令响应。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpg/21452222/1708699500215-bec03e70-374a-43bb-92c2-029a19c87c6f.jpg#averageHue=%23e3e6e4&amp;id=v01Cj&amp;originHeight=1730&amp;originWidth=4262&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>ID号的命名规则：</p><p>IDM菜单资源</p><p>IDC光标资源</p><p>IDI图标资源</p><h2 id="二、为菜单项添加响应函数"><a href="#二、为菜单项添加响应函数" class="headerlink" title="二、为菜单项添加响应函数"></a>二、为菜单项添加响应函数</h2><p>打开ClassWizard【类向导】，</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpg/21452222/1708699500872-5f67e29b-8676-434b-a466-4f60c3ca8330.jpg#averageHue=%23c8cbc9&amp;id=LhMv0&amp;originHeight=2161&amp;originWidth=3328&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><ol><li>区别Message中的COMMAND和UPDATE_COMMAND_UI<br>COMMAND处理该菜单对应的<strong>功能</strong>。<br>UPDATE_COMMAND_UI处理菜单应对的<strong>用户界面</strong>。 </li><li>菜单项响应顺序：view→doc→mainframe→App </li><li>Windows消息的分类<br>1、标准消息：除 WM<em>COMMAND 之外，**所有以 WM</em>开头的消息<strong>都是标准消息。<br>CWnd类，都可以接收到这类消息。<br>2、命令消息：来自菜单、加速键或工具栏按钮的消息。这类消息都</strong>以 WM_COMMAND 形式呈现<strong>。<br>在 MFC 中，通过菜单项的标识（ID）来区分不同的命令消息；在 SDK 中，通过消息的wParam 参数识别。从 CCmdTarget 派生的类，都可以接收到这类消息。<br>3、通告消息：由控件产生的消息，例如按钮的单击、列表框的选择等。目的是为了向其父窗口（通常是对话框）通知事件的发生。这类消息也是</strong>以 WM_COMMAND 形式呈现<strong>。从CCmdTarget 派生的类，都可以接收到这类消息。<br>实际上，CWnd 类派生于 CCmdlTarget类。也就是说</strong>凡是从 CWnd 派生的类，它们既可以接收标准消息，也可以接收命令消息和通告消息。而对于那些从 CCmdTarget 派生的类，则只能接收命令消息和通告消息，不能接收标准消息。** </li><li>菜单消息响应过程：mainframe类接收消息→view首先处理，若不行→doc→mainframe→App </li></ol><h2 id="三、基本菜单操作"><a href="#三、基本菜单操作" class="headerlink" title="三、基本菜单操作"></a>三、基本菜单操作</h2><h3 id="1、了解菜单结构"><a href="#1、了解菜单结构" class="headerlink" title="1、了解菜单结构"></a>1、了解菜单结构</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/jpg/21452222/1708699501330-d837189f-b543-4873-949f-be1b606995c2.jpg#averageHue=%23adaea9&amp;id=o2rhw&amp;originHeight=1670&amp;originWidth=2791&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>程序的主菜单属于框架窗口，因此要在框架类的OnCreate中编程。</p><h3 id="2、标记菜单"><a href="#2、标记菜单" class="headerlink" title="2、标记菜单"></a>2、标记菜单</h3><p>获取程序菜单栏：CWnd类 <code>CMenu* GetMenu( ) const;</code> </p><p>获取子菜单：CMenu类<code>CMenu* GetSubMenu( int nPos ) const;</code>参数是子菜单的索引号,注意分隔栏也占据索引号。</p><p>添加或移除标记：CMenu类<code>UINT CheckMenuItem( UINT nIDCheckItem, UINT nCheck );</code></p><p> Parameters<br><em>nIDCheckItem</em>：Specifies the menu item to be checked, as determined by <em>nCheck</em>.<br><em>nCheck_Specifies ：how to check the menu item and how to determine the position of the item in the menu. The _nCheck</em> parameter can be a combination of MF_CHECKED or MF_UNCHECKED with MF_BYPOSITION or MF_BYCOMMAND flags.</p><ul><li>MF_BYCOMMAND   指定第一个参数通过ID</li><li>MF_BYPOSITION   指定第一个参数通过索引号</li><li>MF_CHECKED   设置复选标记</li><li>MF_UNCHECKED  移走复选标记</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetMenu()-&gt;GetSubMenu(<span class="number">0</span>)-&gt;CheckMenuItem(<span class="number">0</span>,MF_BYPOSITION | MF_CHECKED);</span><br></pre></td></tr></table></figure><h3 id="3、默认菜单项（粗体）"><a href="#3、默认菜单项（粗体）" class="headerlink" title="3、默认菜单项（粗体）"></a>3、默认菜单项（粗体）</h3><p>注意子菜单只能有一个默认菜单项。</p><p>CMenu类<code>BOOL SetDefaultItem( UINT uItem, BOOL fByPos = FALSE );</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetMenu()-&gt;GetSubMenu(<span class="number">0</span>)-&gt;SetDefaultItem(<span class="number">2</span>,MF_BYPOSITION);</span><br></pre></td></tr></table></figure><h3 id="4、图形标记菜单"><a href="#4、图形标记菜单" class="headerlink" title="4、图形标记菜单"></a>4、图形标记菜单</h3><p>CMenu类：<code>BOOL SetMenuItemBitmaps( UINT nPosition, UINT nFlags, const CBitmap* pBmpUnchecked, const CBitmap* pBmpChecked );</code></p><p>pBmpUnchecked是取消选中时的位图；pBmpchecked是选中状态时的位图。</p><p>获取系统的信息度量：<code>int GetSystemMetrics( int nIndex);</code>其中，参数用于指定希望获取哪部分的系统信息。SM_CXMENUCHECK和SM_CYMENUCHECK用于获取菜单项标记图形的默认尺寸。</p><p>CString类的Format函数类似C中的printf。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CBitmap m_bitmap;<span class="comment">//头文件全局变量</span></span><br><span class="line"></span><br><span class="line">m_bitmap.LoadBitmap(IDB_BITMAP1);</span><br><span class="line">GetMenu()-&gt;GetSubMenu(<span class="number">0</span>)-&gt;SetMenuItemBitmaps(<span class="number">0</span>, MF_BYPOSITION, &amp;m_bitmap, &amp;m_bitmap);</span><br><span class="line"></span><br><span class="line">Ctring str;</span><br><span class="line">str.Format(<span class="string">&quot;x = %d , y = %d&quot;</span>, GetSystemMetrics(SM_CXMENUCHECK), GetSystemMetrics(SM_CYMENUCHECK));</span><br><span class="line">MessageBox(str);</span><br></pre></td></tr></table></figure><h3 id="5、禁用菜单项"><a href="#5、禁用菜单项" class="headerlink" title="5、禁用菜单项"></a>5、禁用菜单项</h3><p>CMenu类：<code>UINT EnableMenuItem( UINT nIDEnableItem, UINT nEnable );</code></p><p>nEnable：</p><p><strong>MF_BYCOMMAND</strong>   Specifies that the parameter gives the command ID of the existing menu item. This is the default.</p><p><strong>MF_BYPOSITION</strong>   Specifies that the parameter gives the position of the existing menu item. The first item is at position 0.</p><p><strong>MF_DISABLED</strong>   Disables the menu item so that it cannot be selected but does not dim it.</p><p><strong>MF_ENABLED</strong>   Enables the menu item so that it can be selected and restores it from its dimmed state.</p><p><strong>MF_GRAYED</strong>   Disables the menu item so that it cannot be selected and dims it.</p><p>常把<strong>MF_GRAYED</strong>和<strong>MF_DISABLED</strong>放在一起使用。</p><p>发现不能正常禁用？</p><p>// NOTE: m_bAutoMenuEnable is set to FALSE in the constructor of </p><p>// CMainFrame so no ON_UPDATE_COMMAND_UI or ON_COMMAND handlers are </p><p>// needed, and CMenu::EnableMenuItem() will work as expected.</p><p>即在CMainFrame构造函数中添加m_bAutoMenuEnable = FALSE;</p><h3 id="6、移除和装载菜单"><a href="#6、移除和装载菜单" class="headerlink" title="6、移除和装载菜单"></a>6、移除和装载菜单</h3><p>CWnd类：<code>BOOL SetMenu( CMenu* pMenu );</code>CMenu* pMenu 指向一个新的菜单对象，若值为NULL，则移除当前菜单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*移除菜单*/</span></span><br><span class="line">SetMenu(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*装载菜单资源*/</span></span><br><span class="line">Cmenu menu;<span class="comment">//1、框架类成员变量2、若是局部变量，结尾一定要加Detach函数</span></span><br><span class="line"></span><br><span class="line">menu.LoadMenu(IDR_MAINFRAME);</span><br><span class="line">SetMenu(&amp;menu);</span><br><span class="line">menu.Detach();<span class="comment">//menu是局部变量的情况，将菜单句柄与菜单对象分离</span></span><br></pre></td></tr></table></figure><h2 id="四、MFC菜单命令更新机制"><a href="#四、MFC菜单命令更新机制" class="headerlink" title="四、MFC菜单命令更新机制"></a>四、MFC菜单命令更新机制</h2><p>菜单项状态的维护依赖于CN_UPDATE_COMMAND_UI消息，该消息智能用于菜单项，不能用于永久显示的顶级菜单（即弹出式菜单）。</p><p>在BEGIN_MESSAGE_MAP和END_MESSAGE_MAP之间添加宏以捕获消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)<span class="comment">//自动添加的</span></span><br><span class="line">  ON_WM_CREATE()</span><br><span class="line">  ON_UPDATE_COMMAND_UI(ID_FILE_NEW, &amp;CMainFrame::OnUpdateFileNew)</span><br><span class="line">END_MESSAGE_MAP()</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CMainFrame::OnUpdateEditCut</span><span class="params">(CCmdUI* pCmdUI)</span><span class="comment">//消息响应函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令更新用户界面处理程序代码</span></span><br><span class="line">  pCmdUI-&gt;Enable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*CCmdUI类决定一个菜单项是否可以使用(Enable)，是否有标记(SetCheck)，改变菜单项文本(SetText)*/</span></span><br><span class="line"><span class="comment">/*CCmdUI类有成员变量m_nID保存对象ID和m_nIndex保存对象索引*/</span></span><br></pre></td></tr></table></figure><p>如果只是利用禁用菜单项，菜单项变灰禁用，但工具栏按钮依然能够使用。而如果使用命令更新机制，则都不能使用。</p><h2 id="五、快捷菜单"><a href="#五、快捷菜单" class="headerlink" title="五、快捷菜单"></a>五、快捷菜单</h2><p>（上下文菜单、右键菜单）</p><p>为CView类添加一个WM_CONTEXTMENU消息处理函数，当鼠标右键单击窗口时，就会调用该函数。</p><p>显示快捷菜单函数：                                                                                                                          <code>BOOL TrackPopupMenu( UINT nFlags, int x, int y, CWnd* pWnd, LPCRECT lpRect = NULL );</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CmenuView::OnContextMenu</span><span class="params">(CWnd* pWnd, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此处添加消息处理程序代码</span></span><br><span class="line">  CMenu popmenu;</span><br><span class="line">  popmenu.LoadMenu(IDR_POPMENU1); <span class="comment">//读取资源</span></span><br><span class="line">  popmenu.GetSubMenu(<span class="number">0</span>)-&gt;TrackPopupMenu(</span><br><span class="line">  TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON, point.x, point.y, this);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TPM_LEFTALIGN定位弹出菜单，使其左侧与 x 指定的坐标对齐。*/</span></span><br></pre></td></tr></table></figure><h2 id="六、动态菜单操作"><a href="#六、动态菜单操作" class="headerlink" title="六、动态菜单操作"></a>六、动态菜单操作</h2><h3 id="1、针对子菜单的动态操作"><a href="#1、针对子菜单的动态操作" class="headerlink" title="1、针对子菜单的动态操作"></a>1、针对子菜单的动态操作</h3><p>1、把一个新的子菜单<strong>添加到</strong>菜单栏<strong>末尾</strong>。CMenu类：<code>BOOL AppendMenu ( UINT nFlags, UINT nIDNewItem = 0, LPCTSTR lpszNewItem = NULL);</code></p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpg/21452222/1708699501561-3f340dfe-030a-4ce0-9471-7406f1b09a3d.jpg#id=IBEb6&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>CMenu类：CreateMenu()创建一个弹出菜单，并与CMenu对象关联</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CMenu m_menu;<span class="comment">//成员变量</span></span><br><span class="line"></span><br><span class="line">m_menu.CreateMenu();</span><br><span class="line">GetMenu()-&gt;AppendMenu(MF_POPUP, (UINT)m_menu.m_hMenu, <span class="string">&quot;TEST&quot;</span>);</span><br></pre></td></tr></table></figure><p>2、两个子菜单中间<strong>插入</strong>子菜单。CMenu类：                                                                                     <code>BOOL InsertMenu( UINT nPosition, UINT nFlags, UINT nIDNewItem = 0, LPCTSTR lpszNewItem = NULL );</code></p><p>用法类似AppendMenu</p><p>3、<strong>删除</strong>子菜单或菜单项。CMenu类：<code>BOOL DeleteMenu( UINT nPosition, UINT nFlags );</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除子菜单</span></span><br><span class="line">  GetMenu()-&gt;DeleteMenu(<span class="number">0</span>,MF_BYPOSITION );</span><br><span class="line"><span class="comment">//删除菜单项</span></span><br><span class="line">GetMenu()-&gt;GetSubMenu(<span class="number">1</span>)-&gt;DeleteMenu(<span class="number">0</span>,MF_BYPOSITION );</span><br></pre></td></tr></table></figure><h3 id="2、针对菜单项的动态操作"><a href="#2、针对菜单项的动态操作" class="headerlink" title="2、针对菜单项的动态操作"></a>2、针对菜单项的动态操作</h3><p>1、插入菜单项同样使用AppendMenu和InsertMenu</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m_menu.AppendMenuA(MF_STRING, <span class="number">111</span>, <span class="string">&quot;hello&quot;</span>);<span class="comment">//往弹出菜单TEST中添加菜单项</span></span><br><span class="line">GetMenu()-&gt;GetSubMenu(<span class="number">0</span>)-&gt;AppendMenu(MF_STRING, <span class="number">113</span>, <span class="string">&quot;hello1&quot;</span>);<span class="comment">//往文件子菜单末尾添加菜单项</span></span><br><span class="line">GetMenu()-&gt;GetSubMenu(<span class="number">0</span>)-&gt;InsertMenu(<span class="number">1</span>, MF_BYPOSITION | MF_STRING , <span class="number">112</span> , <span class="string">&quot;VC编程&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="3、为-动态添加的菜单项-添加响应函数"><a href="#3、为-动态添加的菜单项-添加响应函数" class="headerlink" title="3、为  动态添加的菜单项  添加响应函数"></a>3、为  动态添加的菜单项  添加响应函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在头文件resource.h中创建菜单资源ID</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IDM_HELLO   111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//源文件中</span></span><br><span class="line">m_menu.AppendMenuA(MF_STRING, IDM_HELLO, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遵循消息映射机制：增加3处代码实现消息响应</span></span><br><span class="line"><span class="comment">//1、在响应这个菜单命令的类中添加响应函数原型，位于声明消息映射宏之上，（第11行所示）</span></span><br><span class="line">protected:</span><br><span class="line">  afx_msg <span class="type">int</span> <span class="title function_">OnCreate</span><span class="params">(LPCREATESTRUCT lpCreateStruct)</span>;</span><br><span class="line">  afx_msg <span class="type">void</span> <span class="title function_">OnHello</span><span class="params">()</span>;</span><br><span class="line">  DECLARE_MESSAGE_MAP()</span><br><span class="line">  </span><br><span class="line"><span class="comment">//2、在源文件的消息映射表中添加消息映射，消息映射宏是ON_COMMAND宏，（第17行所示）</span></span><br><span class="line"><span class="comment">//注意：消息映射表中，代码结尾不加分号</span></span><br><span class="line">BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)</span><br><span class="line">  ON_WM_CREATE()</span><br><span class="line">  ON_COMMAND(IDM_HELLO,OnHello)</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、添加消息响应函数定义</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CMainFrame::OnHello</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  MessageBox(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第七章-对话框（一）"><a href="#第七章-对话框（一）" class="headerlink" title="第七章 对话框（一）"></a>第七章 对话框（一）</h1><h2 id="1、基本知识"><a href="#1、基本知识" class="headerlink" title="1、基本知识"></a>1、基本知识</h2><p>控件：通常作为对话框的子窗口创建</p><p>对话框的种类：</p><p>模态对话框：对话框显示时，程序暂停执行，直到关闭对话框。</p><p>非模态：显示对话框时，可以执行其他任务。</p><h2 id="2、创建和显示"><a href="#2、创建和显示" class="headerlink" title="2、创建和显示"></a>2、创建和显示</h2><p>CDialog对话框资源类</p><p>1.新建一个MFC类与该对话框关联：双击新建的对话框。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/21452222/1708699501922-1462270c-902c-4927-b2f5-081462113f6d.png#id=gUC7t&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>新建对话框资源后有两个按钮，功能一样（关闭对话框），返回值不同。</p><p>OK    IDOK    OnOK</p><p>Cancel     IDCANCEL     OnCancel</p><p>2.<code>**DoDataExchange()**</code>：完成对话框数据的交换和校验。</p><p>3.在视类中</p><p><strong><code>CDialog::DoModal</code></strong>创建并显示模态对话框</p><p><strong><code>CDialog::EndDialog</code></strong>关闭模态对话框</p><h2 id="3、创建动态按钮"><a href="#3、创建动态按钮" class="headerlink" title="3、创建动态按钮"></a>3、创建动态按钮</h2><p>1.视类→工具箱→对话框编辑器     创建一个按钮。</p><p>2.为该按钮添加功能</p><p>类向导→选择该对象对应的BN_CLICKED（按钮被单击的消息）消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">在CTestDlg类添加</span><br><span class="line">private:</span><br><span class="line">  CButton m_btn;<span class="comment">//动态按钮对象</span></span><br><span class="line">  BOOL isbtncreate;<span class="comment">//判断动态按钮是否被创建，在构造函数中初始化为0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CTestDlg::OnClickedBtnAdd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//动态创建按钮</span></span><br><span class="line">  <span class="comment">//static BOOL isbtncreate = 0;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isbtncreate == <span class="number">0</span>)<span class="comment">//判断动态按钮是否被创建,</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//CButton::Create创建按钮</span></span><br><span class="line">    m_btn.Create(_T(<span class="string">&quot;new&quot;</span>), WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON, CRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>), this, <span class="number">123</span>);</span><br><span class="line">    isbtncreate = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_btn.DestroyWindow();<span class="comment">//销毁窗口</span></span><br><span class="line">    isbtncreate = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化变量的两种方法</p><p>1.创建成员变量，并在构造函数中初始化；</p><p>2.创建静态局部变量同时初始化。</p><h2 id="4、对话框控件"><a href="#4、对话框控件" class="headerlink" title="4、对话框控件"></a>4、对话框控件</h2><h3 id="1-静态文本控件"><a href="#1-静态文本控件" class="headerlink" title="1.静态文本控件"></a>1.静态文本控件</h3><p>IDC_STATIC不能响应消息，可通过修改ID来响应消息</p><p><strong><code>CWnd::GetDlgItem</code></strong>获取对话框子控件的指针</p><p><strong><code>CWnd::GetWindowText</code></strong>获取窗口文本</p><p><strong><code>CWnd::SetWindowText</code></strong>设置窗口文本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CTestDlg::OnClickedNumber1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">  CString str;</span><br><span class="line">  <span class="keyword">if</span> (GetDlgItem(IDC_NUMBER1)-&gt;GetWindowText(str),str == <span class="string">&quot;数值1&quot;</span>)</span><br><span class="line">  <span class="comment">//逗号表达式，返回最后一个表达式的值</span></span><br><span class="line">  &#123;</span><br><span class="line">    GetDlgItem(IDC_NUMBER1)-&gt;SetWindowText(<span class="string">&quot;Number1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    GetDlgItem(IDC_NUMBER1)-&gt;SetWindowText(<span class="string">&quot;数值1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在属性中选中通知（Notify）选项，否则不能向其父窗口发送鼠标事件。</p><h3 id="2-编辑框控件"><a href="#2-编辑框控件" class="headerlink" title="2.编辑框控件"></a>2.编辑框控件</h3><p>🌟GetDlgItem()获取编辑框框窗口对象的指针</p><p>1.法一：<code>**GetDlgItem→Get(Set)WindowText**</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CTestDlg::OnClickedBtnAdd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//编辑框控件法一：  CWnd::GetDlgItem()-&gt;Get(Set)WindowText();获取(设置)指定窗口文本</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> num1, num2, num3;</span><br><span class="line">  <span class="type">char</span> ch1[<span class="number">10</span>], ch2[<span class="number">10</span>], ch3[<span class="number">10</span>];</span><br><span class="line">  </span><br><span class="line">  GetDlgItem(IDC_EDIT1)-&gt;GetWindowText(ch1, <span class="number">10</span>);<span class="comment">//(指向存放字符串内存的指针，最大字符数目)</span></span><br><span class="line">  GetDlgItem(IDC_EDIT2)-&gt;GetWindowText(ch2, <span class="number">10</span>);</span><br><span class="line">  num1 = atoi(ch1);<span class="comment">//atoi字符串-&gt;数值</span></span><br><span class="line">  num2 = atoi(ch2);</span><br><span class="line">  num3 = num1 + num2;</span><br><span class="line">  _itoa_s(num3, ch3, <span class="number">10</span>);<span class="comment">//itoa数值-&gt;字符串，这里的10代表10进制</span></span><br><span class="line">  GetDlgItem(IDC_EDIT3)-&gt;SetWindowText(ch3);<span class="comment">//将ch3中的字符串显示在编辑框中</span></span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>2.法二：<code>**Get(Set)DlgItemText**</code></p><p>=GetDlgItem+Get(Set)WindowText</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CTestDlg::OnClickedBtnAdd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//编辑框控件法二：CWnd::Get(Set)DlgItemText()获取指定控件上的文本</span></span><br><span class="line">  <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, num3 = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> ch1[<span class="number">10</span>], ch2[<span class="number">10</span>], ch3[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">  GetDlgItemText(IDC_EDIT1, ch1,<span class="number">10</span>);</span><br><span class="line">  GetDlgItemText(IDC_EDIT2, ch2,<span class="number">10</span>);<span class="comment">//=GetDlgItem + GetWindowText</span></span><br><span class="line">  </span><br><span class="line">  num1 = atoi(ch1);</span><br><span class="line">  num2 = atoi(ch2);</span><br><span class="line">  num3 = num1 + num2;</span><br><span class="line">  _itoa_s(num3, ch3, <span class="number">10</span>);</span><br><span class="line">  </span><br><span class="line">  SetDlgItemText(IDC_EDIT3, ch3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CTestDlg::OnClickedBtnAdd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//编辑框控件法二：CWnd::Get(Set)DlgItemText()获取指定控件上的文本</span></span><br><span class="line">  <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, num3 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//  char ch1[10], ch2[10], ch3[10];</span></span><br><span class="line">  CString str1, str2, str3;</span><br><span class="line">  GetDlgItemText(IDC_EDIT1, str1);</span><br><span class="line">  GetDlgItemText(IDC_EDIT2, str2);</span><br><span class="line">  num1 = atoi(str1);</span><br><span class="line">  num2 = atoi(str2);</span><br><span class="line">  num3 = num1 + num2;</span><br><span class="line"><span class="comment">//  str3 = (CString)num3;</span></span><br><span class="line"><span class="comment">//错误  C2440  “类型强制转换” : 无法从“int”转换为“CString”</span></span><br><span class="line"><span class="comment">//Format是CString类的一个成员函数，它通过格式操作使任意类型的数据转换成一个字符串。</span></span><br><span class="line">  str3.Format(<span class="string">&quot;%d&quot;</span>,num3);</span><br><span class="line">  SetDlgItemText(IDC_EDIT3, str3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.<strong><code>CWnd::Get(Set)DlgItemInt</code></strong>返回指定控件的文本并将其转换为一个整数值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CTestDlg::OnClickedBtnAdd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, num3 = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  num1 = GetDlgItemInt(IDC_EDIT1);</span><br><span class="line">  num2 = GetDlgItemInt(IDC_EDIT2);</span><br><span class="line">  num3 = num1 + num2;</span><br><span class="line">  </span><br><span class="line">  SetDlgItemInt(IDC_EDIT3, num3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.控件与整型变量相关联（注意DoDataExchange和UpdateData一起用）</p><p>步骤：项目→类向导→成员变量→IDC_EDIT1→添加变量→类别（值）→变量名称→变量类型→其他（最大值、最小值等）</p><p><img src="image/屏幕截图 2021-08-01 110502_J5FSHM4WxG.jpg" alt=""></p><p><img src="image/屏幕截图 2021-08-01 114550_mUnOKGHFru.jpg" alt=""></p><p>系统为我们创建的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*1、头文件定义*/</span></span><br><span class="line">  <span class="comment">// 编辑框与数值变量相关联</span></span><br><span class="line">  <span class="type">int</span> m_num1;</span><br><span class="line">  <span class="type">int</span> m_num2;</span><br><span class="line">  <span class="type">int</span> m_num3;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*2、构造函数初始化*/</span></span><br><span class="line">CTestDlg::CTestDlg(CWnd* pParent <span class="comment">/*=nullptr*/</span>)</span><br><span class="line">  : CDialog(IDD_DIALOG1, pParent)</span><br><span class="line">  <span class="comment">//数值变量初始化</span></span><br><span class="line">  , m_num1(<span class="number">0</span>)</span><br><span class="line">  , m_num2(<span class="number">0</span>)</span><br><span class="line">  , m_num3(<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*3、DoDataExchange将对话框控件与类成员变量相关联，要配合UpDateDate使用*/</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">CTestDlg::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span><br><span class="line">&#123;</span><br><span class="line">  CDialog::DoDataExchange(pDX);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//控件与数值变量关联</span></span><br><span class="line">  DDX_Text(pDX, IDC_EDIT1, m_num1);<span class="comment">//DDX_前缀用于数据交换</span></span><br><span class="line">  DDV_MinMaxInt(pDX, IDC_EDIT1, <span class="number">0</span>, <span class="number">100</span>);<span class="comment">//设定数值范围，DDV_数据校验</span></span><br><span class="line">  DDX_Text(pDX, IDC_EDIT2, m_num2);</span><br><span class="line">  DDX_Text(pDX, IDC_EDIT3, m_num3); </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>自己编写的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">void</span> <span class="title function_">CTestDlg::OnClickedBtnAdd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//法四：控件与数值变量相关联</span></span><br><span class="line"></span><br><span class="line">  UpdateData();<span class="comment">//和DoDataExchange配合使用，参数为TRUE(缺省)：函数获取对话框数据</span></span><br><span class="line">  m_num3 = m_num1 + m_num2;</span><br><span class="line">  UpdateData(FALSE);<span class="comment">//参数为FALSE：以变量的值来初始化对话框控件</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动消息提示框：</p><p><img src="image/屏幕截图 2021-08-01 114102_eotD0A4Rvf.jpg" alt=""></p><p>5.控件与控件变量相关联</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">系统自动添加</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*1、头文件定义*/</span></span><br><span class="line">  <span class="comment">//编辑框与控件变量相关联</span></span><br><span class="line">  CEdit m_edit1;</span><br><span class="line">  CEdit m_edit2;</span><br><span class="line">  CEdit m_edit3;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*2、DoDataExchange将对话框控件与类成员变量相关联，要配合UpDateDate使用*/</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">CTestDlg::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span><br><span class="line">&#123;</span><br><span class="line">  CDialog::DoDataExchange(pDX);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//控件与控件变量关联</span></span><br><span class="line">  DDX_Control(pDX, IDC_EDIT1, m_edit1);</span><br><span class="line">  DDX_Control(pDX, IDC_EDIT2, m_edit2);</span><br><span class="line">  DDX_Control(pDX, IDC_EDIT3, m_edit3);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">手动添加</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//法五：控件与控件变量相关联</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, num3 = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> ch1[<span class="number">10</span>], ch2[<span class="number">10</span>], ch3[<span class="number">10</span>];</span><br><span class="line">  </span><br><span class="line">  m_edit1.GetWindowText(ch1, <span class="number">10</span>);</span><br><span class="line">  m_edit2.GetWindowText(ch2, <span class="number">10</span>);</span><br><span class="line">  </span><br><span class="line">  num1 = atoi(ch1);</span><br><span class="line">  num2 = atoi(ch2);</span><br><span class="line">  num3 = num1 + num2;</span><br><span class="line">  _itoa_s(num3, ch3, <span class="number">10</span>);</span><br><span class="line">  </span><br><span class="line">  m_edit3.SetWindowText(ch3);</span><br></pre></td></tr></table></figure><p>6.<strong><code>SendMessage()</code></strong>发送消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, num3 = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> ch1[<span class="number">10</span>], ch2[<span class="number">10</span>], ch3[<span class="number">10</span>];</span><br><span class="line">  ::SendMessage(GetDlgItem(IDC_EDIT1)-&gt;m_hWnd, WM_GETTEXT, <span class="number">10</span>, (LPARAM)ch1);<span class="comment">//获取编辑框窗口对象的指针</span></span><br><span class="line">  ::SendMessage(m_edit2.m_hWnd, WM_GETTEXT, <span class="number">10</span>, (LPARAM)ch2);<span class="comment">//第一个参数直接利用控件变量获取句柄</span></span><br><span class="line"><span class="comment">//Windows系统中，获取文本的消息是WM_GETTEXT，将系统指定窗口的文本复制到调用者提供的一个缓存中</span></span><br><span class="line"><span class="comment">//wParam指定复制的字符数，lParam保存窗口文本的缓存地址</span></span><br><span class="line"></span><br><span class="line">  num1 = atoi(ch1);</span><br><span class="line">  num2 = atoi(ch2);</span><br><span class="line">  num3 = num1 + num2;</span><br><span class="line">  _itoa_s(num3, ch3, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  m_edit3.SendMessage(WM_SETTEXT, <span class="number">0</span>, (LPARAM)ch3);</span><br><span class="line"><span class="comment">//WM_SETTEXT设置窗口文本的消息，lParam指定设置窗口文本的字符串地址</span></span><br></pre></td></tr></table></figure><p>7.<strong><code>SendDlgItemMessage()</code></strong>直接给对话框的子控件发送消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法七：</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, num3 = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ch1[<span class="number">10</span>], ch2[<span class="number">10</span>], ch3[<span class="number">10</span>];</span><br><span class="line">SendDlgItemMessage(IDC_EDIT1, WM_GETTEXT, <span class="number">10</span>, (LPARAM)ch1);</span><br><span class="line">SendDlgItemMessage(IDC_EDIT2, WM_GETTEXT, <span class="number">10</span>, (LPARAM)ch2);</span><br><span class="line"></span><br><span class="line">num1 = atoi(ch1);</span><br><span class="line">num2 = atoi(ch2);</span><br><span class="line">num3 = num1 + num2;</span><br><span class="line">_itoa_s(num3, ch3, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">SendDlgItemMessage(IDC_EDIT3, WM_SETTEXT, <span class="number">0</span>, (LPARAM)ch3);</span><br></pre></td></tr></table></figure><p>补充：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//设置复选内容</span></span><br><span class="line"> SendDlgItemMessage(IDC_EDIT3, EM_SETSEL, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// EM_GETSEL获得编辑框中的复选内容</span></span><br><span class="line"><span class="comment">//EM_SETSEL设置……，EM表示Edit Control Message</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//wParam接收复选内容开始位置，lParam ……结束位置.</span></span><br><span class="line"><span class="comment">//wParam=0，lParam=-1,表示所有文本</span></span><br><span class="line"> m_edit3.SetFocus();<span class="comment">//设置光标</span></span><br></pre></td></tr></table></figure><h2 id="5、对话框的伸缩"><a href="#5、对话框的伸缩" class="headerlink" title="5、对话框的伸缩"></a>5、对话框的伸缩</h2><h1 id="CWnd-SetWindowPos"><a href="#CWnd-SetWindowPos" class="headerlink" title="CWnd::SetWindowPos"></a>CWnd::SetWindowPos</h1><p><strong>BOOL SetWindowPos (const CWnd*</strong> <em>pWndInsertAfter</em>,  <strong>int</strong> <em>x</em>,  <strong>int</strong> <em>y</em>,  <strong>int</strong> <em>cx</em>,  <strong>int</strong> <em>cy</em>,  <strong>UINT</strong> <em>nFlags)//</em> 设置窗口位置、大小、z次序等</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpg/21452222/1708699502034-14cd3b22-f8c9-45db-9bd8-8452e3a71eed.jpg#id=a13XF&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h1 id="CWnd-GetDlgItem"><a href="#CWnd-GetDlgItem" class="headerlink" title="CWnd::GetDlgItem"></a>CWnd::GetDlgItem</h1><p>This method retrieves a pointer to the specified control or child window in a dialog box or other window. The pointer returned is usually cast to the type of control identified by <em>nID</em>.<br><em>CWnd</em>   GetDlgItem (int<em> <em>nID</em> <em>*)const;</em></em></p><h1 id="CWnd-SetDlgItemText"><a href="#CWnd-SetDlgItemText" class="headerlink" title="CWnd::SetDlgItemText"></a>CWnd::SetDlgItemText</h1><p><strong>void SetDlgItemText(int</strong> <em>nID</em><strong>,  LPCTSTR</strong> <em>lpszString);//</em> 将nID中的文本设置为<em>lpszString</em> </p><h1 id="CWnd-GetWindowRect"><a href="#CWnd-GetWindowRect" class="headerlink" title="CWnd::GetWindowRect"></a>CWnd::GetWindowRect</h1><p><strong>void GetWindowRect(LPRECT</strong> <em>lpRect)const;//</em> 获得窗口尺寸</p><p>CRect::IsRectNull</p><p>CRect::IsRectEmpty</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CTestDlg::OnBnClickedButton1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">  CString str;</span><br><span class="line">  <span class="keyword">if</span> (GetDlgItemText(IDC_BUTTON1,str),str == <span class="string">&quot;收缩&lt;&lt;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    SetDlgItemText(IDC_BUTTON1, <span class="string">&quot;括展&gt;&gt;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    SetDlgItemText(IDC_BUTTON1, <span class="string">&quot;收缩&lt;&lt;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> CRect rectlarge;<span class="comment">//原对话框尺寸</span></span><br><span class="line">  <span class="type">static</span> CRect rectsmall;<span class="comment">//切割后的尺寸</span></span><br><span class="line">  <span class="keyword">if</span> (rectlarge.IsRectNull())<span class="comment">//判断矩形区域是否为空</span></span><br><span class="line">  &#123;</span><br><span class="line">    CRect rectseparator;<span class="comment">//分割线的尺寸</span></span><br><span class="line">    GetDlgItem(IDC_SEPARATOR)-&gt;GetWindowRect(rectseparator);<span class="comment">//获得分割线的尺寸</span></span><br><span class="line">    GetWindowRect(rectlarge);<span class="comment">//获得原对话框的尺寸</span></span><br><span class="line">    rectsmall.top = rectlarge.top;</span><br><span class="line">    rectsmall.left = rectlarge.left;</span><br><span class="line">    rectsmall.right = rectlarge.right;</span><br><span class="line">    rectsmall.bottom = rectseparator.bottom;<span class="comment">//将对话框底部的尺寸更改</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (str == <span class="string">&quot;收缩&lt;&lt;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    SetWindowPos(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, rectsmall.Width(), rectsmall.Height(), SWP_NOMOVE | SWP_NOZORDER);<span class="comment">//设置窗口的位置和大小</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    SetWindowPos(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, rectlarge.Width(), rectlarge.Height(), SWP_NOMOVE | SWP_NOZORDER);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、输入焦点的传递"><a href="#6、输入焦点的传递" class="headerlink" title="6、输入焦点的传递"></a>6、输入焦点的传递</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CTestDlg::OnBnClickedOk</span><span class="params">()</span><span class="comment">//注释掉默认的OnOK</span></span><br><span class="line">&#123;</span><br><span class="line">  GetNextDlgTabItem(GetFocus())-&gt;SetFocus();<span class="comment">//按照TAB顺序循环查找【格式】-&gt;【TAB顺序】</span></span><br><span class="line"><span class="comment">//  CDialog::OnOK();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WNDPROC prevproc;<span class="comment">//窗口过程类型，接收先前的窗口过程。窗口过程函数是全局函数，里面的函数不能再用CWnd的成员函数，只能用API函数</span></span><br><span class="line">LRESULT CALLBACK WinEnterProc<span class="comment">//windowproc函数</span></span><br><span class="line">(</span><br><span class="line">  HWND hwnd,      <span class="comment">// handle to window</span></span><br><span class="line">  UINT uMsg,      <span class="comment">// message identifier</span></span><br><span class="line">  WPARAM wParam,  <span class="comment">// first message parameter</span></span><br><span class="line">  LPARAM lParam   <span class="comment">// second message parameter</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (uMsg == WM_CHAR &amp;&amp; wParam == <span class="number">0x0d</span>)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="comment">//    ::SetFocus(::GetNextWindow(hwnd, GW_HWNDNEXT));</span></span><br><span class="line"><span class="comment">//    ::SetFocus(::GetWindow(hwnd, GW_HWNDNEXT));</span></span><br><span class="line">    ::SetFocus(::GetNextDlgTabItem(::GetParent(hwnd), hwnd, <span class="number">0</span>));<span class="comment">//SetFocus设置焦点，GetFocus得到焦点</span></span><br><span class="line">                                  <span class="comment">//GetNextWindow、GetWindow获得下一个窗口的句柄</span></span><br><span class="line">                                  <span class="comment">//GetNextDlgTabItem按照TAB顺序转移焦点</span></span><br><span class="line"><span class="comment">//    return 1;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//按下的按键不是回车，让先前的窗口过程来处理</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> prevproc(hwnd,uMsg,wParam,lParam);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">CTestDlg::OnInitDialog</span><span class="params">()</span><span class="comment">//对话框及其子控件创建完成将要显示之前调用。虚函数。</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">CDialog::OnInitDialog</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line">  <span class="comment">//SetWindowLong修改指定窗口的属性，本例修改已指定的过程函数</span></span><br><span class="line">  prevproc = (WNDPROC)SetWindowLong(GetDlgItem(IDC_EDIT1)-&gt;m_hWnd, GWL_WNDPROC<span class="comment">/*设置新的窗口过程地址*/</span>, (LONG)WinEnterProc<span class="comment">/*新的窗口过程地址*/</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> TRUE;  <span class="comment">// return TRUE unless you set the focus to a control</span></span><br><span class="line">          <span class="comment">// 异常: OCX 属性页应返回 FALSE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、默认按钮的说明"><a href="#7、默认按钮的说明" class="headerlink" title="7、默认按钮的说明"></a>7、默认按钮的说明</h2><p>收缩按钮设置为默认按钮，即在其属性对话框中选择default button选项，就不会再由CTestDlg类的OnOK函数来响应。<br>当用户按下回车键时，windows将查看对话框中是否存在默认按钮, 如果没有默认按钮，就会调用虚拟的OnOK函数, 即没有默认ok按钮。这个默认OnOK函数的ID是IDOK。而不是IDC_OK.</p><h1 id="第八章-对话框2"><a href="#第八章-对话框2" class="headerlink" title="第八章 对话框2"></a>第八章 对话框2</h1><h2 id="1、逃跑按钮"><a href="#1、逃跑按钮" class="headerlink" title="1、逃跑按钮"></a>1、逃跑按钮</h2><p>/<em>逃跑按钮创建过程<br>1、创建新类（专注于逃跑功能）</em>存储地址的变量<br><em>OnMouseMove()<br>2、CTestDlg.h控件与控件变量关联，即创建了新类的对象<br>3、CTestDlg.cpp的OnInitDialog()中两个对象存储对方首地址<br>4、鼠标移动OnMouseMove()接收WM_MOUSEMOVE消息，执行程序</em>/</p><h2 id="2、属性表单的创建"><a href="#2、属性表单的创建" class="headerlink" title="2、属性表单的创建"></a>2、属性表单的创建</h2><p>一个属性表单是由一个或多个属性页组成，属性页对应MFC中的CPropertyPage类，一个属性页的标题就是选项卡的名称。</p><p>步骤：</p><p>1、创建属性页</p><p><img src="image/屏幕截图 2021-08-06 102753_TUrnaTOgaJ.jpg" alt=""></p><p>2、添加控件</p><p>组框Group Box</p><p>单选按钮Radio Button</p><p>复选框Check Box</p><p>列表框控件List Box</p><p>静态文本控件Static Box</p><p>组合框Combo Box</p><p>simple，能输入，总是显示列表框</p><p>dropdown，能输入只有单击下拉列表后，列表框才弹出</p><p>droplist,只读，只能从下来列表选择内容</p><p>3、为对话框资源创建新类</p><p>1.创建新类步骤：<a href="https://blog.csdn.net/KJ_Study/article/details/109057281">参考1</a>，在“添加MFC类”中添加类名与ID号一致，基类中选择相应的类型</p><p>属性页CPropertyPage</p><p>属性表单CPropertySheet</p><p>2.在属性表单（CPropSheet）中，创建三个属性页对象，并在构造函数中初始化。用AddPage将属性页添加进属性表单，构造函数指明了2中实例化对象的方法（ID/字符串）</p><p>CPropSheet::AddPage将属性页添加到属性表单中</p><p>OnPropertysheet::DoModal()创建模态属性表单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*定义*/</span></span><br><span class="line">  <span class="comment">//自定义成员变量</span></span><br><span class="line">  PROP1 m_prop1;</span><br><span class="line">  PROP2 m_prop2;</span><br><span class="line">  PROP3 m_prop3;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*初始化*/</span></span><br><span class="line"> CPropSheet::CPropSheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)</span><br><span class="line">  :CPropertySheet(nIDCaption, pParentWnd, iSelectPage)<span class="comment">//用ID号来构造属性表单</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化属性页</span></span><br><span class="line">  AddPage(&amp;m_prop1);<span class="comment">//CPropSheet::AddPage将属性页添加到属性表单中</span></span><br><span class="line">  AddPage(&amp;m_prop2);</span><br><span class="line">  AddPage(&amp;m_prop3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CPropSheet::CPropSheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)</span><br><span class="line">  :CPropertySheet(pszCaption, pParentWnd, iSelectPage)<span class="comment">//用字符串来构造属性表单</span></span><br><span class="line">&#123;</span><br><span class="line">  AddPage(&amp;m_prop1);</span><br><span class="line">  AddPage(&amp;m_prop2);</span><br><span class="line">  AddPage(&amp;m_prop3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在视类中创建菜单命令响应函数，用字符串实例化属性表单对象，并用DoModal创建模态属性表单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CpropView::OnPropertysheet</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">  CPropSheet <span class="title function_">propsheet</span><span class="params">(<span class="string">&quot;属性表单&quot;</span>)</span>;<span class="comment">//使用字符串构造属性表单对象</span></span><br><span class="line"><span class="comment">//  propsheet.SetWizardMode();//创建向导样式时添加</span></span><br><span class="line">  propsheet.DoModal();<span class="comment">//创建模态属性表单</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、向导的创建"><a href="#3、向导的创建" class="headerlink" title="3、向导的创建"></a>3、向导的创建</h2><p>1、更改向导底部按钮CPropertySheet::SetWizardButtons</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">PROP1::OnSetActive</span><span class="params">()</span><span class="comment">//右键PROP1类-&gt;类向导-&gt;虚函数-&gt;OnSetActive-&gt;编辑代码</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line">  CPropertySheet* psheet = (CPropertySheet*)GetParent();<span class="comment">//属性页的父窗口属性表单，并将CWnd*转换为CPropertySheet*</span></span><br><span class="line">  psheet-&gt;SetWizardButtons(PSWIZB_NEXT);<span class="comment">//CPropertySheet::SetWizardButtons设置对话框上的按钮</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> CPropertyPage::OnSetActive();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROP2,PROP3过程类似，SetWizardButtons参数不同。</span><br></pre></td></tr></table></figure><p>1、设置第一个属性页</p><p>将第一个单选按钮设置为Group属性以添加成员变量。第一个单选按钮设置为Group后，之后的按钮和这个按钮属于同一组，直到遇到下一个Group。同一组内的控件关联的成员变量的值依次为1、2、3…</p><p>单击【下一步】，调用OnWizardNext()虚函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*PROP1.h*/</span></span><br><span class="line">  <span class="type">int</span> m_occupation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*PROP1.cpp*/</span> </span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">PROP1::PROP1()</span><br><span class="line">  : CPropertyPage(IDD_PROP1)</span><br><span class="line">  , m_occupation(<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据交换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PROP1::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span><br><span class="line">&#123;</span><br><span class="line">  CPropertyPage::DoDataExchange(pDX);</span><br><span class="line">  DDX_Radio(pDX, IDC_RADIO1, m_occupation);<span class="comment">//单选按钮和成员变量之间的数据交换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断</span></span><br><span class="line">LRESULT <span class="title function_">PROP1::OnWizardNext</span><span class="params">()</span><span class="comment">//单击【下一步】，调用OnWizardNext()虚函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line">  UpdateData();<span class="comment">//系统通过调用UpdateData()来调用DoDataExchange以完成控件与变量的数据交换</span></span><br><span class="line">               <span class="comment">//TRUE从控件得到成员变量的值。 FAUSE用成员变量的值初始化控件</span></span><br><span class="line">  <span class="keyword">if</span> (m_occupation == <span class="number">-1</span>)<span class="comment">//用户没有选择职业</span></span><br><span class="line">  &#123;</span><br><span class="line">    MessageBox(<span class="string">&quot;请选择职业！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//OnWizardNext()返回0，进入下一个属性</span></span><br><span class="line">              <span class="comment">//返回-1，禁止属性页变更</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (m_workaddress == <span class="string">&quot;&quot;</span> )<span class="comment">//工作地点为空</span></span><br><span class="line">  &#123;</span><br><span class="line">    MessageBox(<span class="string">&quot;请选择工作地点！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> CPropertyPage::OnWizardNext();<span class="comment">//进入下一个页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">PROP1::OnInitDialog</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  CPropertyPage::OnInitDialog();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line">  CListBox* listbox = (CListBox*)GetDlgItem(IDC_LIST1);</span><br><span class="line">  listbox-&gt;AddString(<span class="string">&quot;北京&quot;</span>);<span class="comment">//CListBox::AddString添加字符串到列表框</span></span><br><span class="line">  listbox-&gt;AddString(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line">  listbox-&gt;AddString(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> TRUE;  <span class="comment">// return TRUE unless you set the focus to a control</span></span><br><span class="line">          <span class="comment">// 异常: OCX 属性页应返回 FALSE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、设置第二个属性页</p><p>操作类似第一个属性页</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LRESULT <span class="title function_">PROP2::OnWizardNext</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line">  UpdateData();</span><br><span class="line">  <span class="keyword">if</span> (m_football || m_basketball || m_volleyball || m_swim)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> CPropertyPage::OnWizardNext();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    MessageBox(<span class="string">&quot;请选择那你的兴趣爱好！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//返回-1，禁止属性页变更</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、设置第三个属性页</p><p>CComboBox::AddString向组合框的列表框中添加字符串选项</p><p>CComboBox::SetCurSel选择列表框中的一个字符串，并将其显示在该组合框的编辑框中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">PROP3::OnInitDialog</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  CPropertyPage::OnInitDialog();</span><br><span class="line">  <span class="comment">//组合框控件由一个编辑框和一个列表框组成</span></span><br><span class="line">  <span class="comment">//CComboBox::AddString向组合框的列表框中添加字符串选项</span></span><br><span class="line">  <span class="comment">//CComboBox::SetCurSel(set current selection)选择列表框中的一个字符串，并将其显示在该组合框的编辑框中</span></span><br><span class="line">  CComboBox* combobox = (CComboBox*)GetDlgItem(IDC_COMBO1);</span><br><span class="line">  combobox-&gt;AddString(<span class="string">&quot;1000元以下&quot;</span>);</span><br><span class="line">  combobox-&gt;AddString(<span class="string">&quot;1000元-2000元&quot;</span>);</span><br><span class="line">  combobox-&gt;AddString(<span class="string">&quot;2000元-3000元&quot;</span>);</span><br><span class="line">  combobox-&gt;AddString(<span class="string">&quot;3000元以上&quot;</span>);<span class="comment">//取消属性框中的排序功能以关闭自动排序</span></span><br><span class="line">  combobox-&gt;SetCurSel(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> TRUE;  <span class="comment">// return TRUE unless you set the focus to a control</span></span><br><span class="line">          <span class="comment">// 异常: OCX 属性页应返回 FALSE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CComboBox::GetCurSel得到当前选项的索引值</p><p>CComboBox::GetLBText得到对应索引值的文本并存储在字符串中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*提取用户的薪资选项，并存储在m_strsalary中*/</span></span><br><span class="line">BOOL <span class="title function_">PROP3::OnWizardFinish</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line">  <span class="type">int</span> index;</span><br><span class="line">  CComboBox* combobox = (CComboBox*)GetDlgItem(IDC_COMBO1);</span><br><span class="line">  index = combobox -&gt;GetCurSel();<span class="comment">//得到当前选项的索引值</span></span><br><span class="line">  combobox-&gt;GetLBText(index, m_strsalary);<span class="comment">//得到对应索引值的文本并存储在字符串m_strsalary中</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> CPropertyPage::OnWizardFinish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、将结果在视类显示</p><p>memset初始化数组</p><p>Invalidate();//让视类窗口无效，从而引起重绘，然后在OnDraw中完成信息的输</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*propView.h*/</span></span><br><span class="line">  <span class="comment">//自定义成员变量</span></span><br><span class="line">  <span class="type">int</span> m_ioccupation;  <span class="comment">//职业</span></span><br><span class="line">  CString m_strworkaddress;<span class="comment">//工作地点</span></span><br><span class="line">  BOOL m_blike[<span class="number">4</span>];<span class="comment">//爱好</span></span><br><span class="line">  CString m_strsalary;<span class="comment">//薪资水平</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*propView.cpp*/</span></span><br><span class="line">  <span class="comment">//构造函数中初始化</span></span><br><span class="line">CpropView::CpropView() noexcept</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此处添加构造代码</span></span><br><span class="line">  m_ioccupation = <span class="number">-1</span>;  <span class="comment">//职业,对于一个组，未选为-1</span></span><br><span class="line">  m_strworkaddress = <span class="string">&quot;&quot;</span>;<span class="comment">//工作地点</span></span><br><span class="line">  <span class="built_in">memset</span>(m_blike , <span class="number">0</span> , <span class="keyword">sizeof</span>(m_blike));<span class="comment">//爱好,将m_blike内存的sizeof(m_blike)个字节设为0</span></span><br><span class="line">  m_strsalary = <span class="string">&quot;&quot;</span>;<span class="comment">//薪资水平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*一般情况下，CPropertySheet 类的 DoModal 函数的返回值是 IDOK 或 IDCANCEL。</span></span><br><span class="line"><span class="comment">但是如果属性表单已经被创建为向导了,那么该函数的返回值将是 ID_WIZFINISH 或 IDCANCEL.</span></span><br><span class="line"><span class="comment">因此,在程序中应该对属性表单对象的 DoModal 函数的返回值进行判断，</span></span><br><span class="line"><span class="comment">如果返回的是【完成】按钮的 ID:ID_WIZFINISH，那么才进行输出处理。*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CpropView::OnPropertysheet</span><span class="params">()</span><span class="comment">//菜单项响应函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">  CPropSheet <span class="title function_">propsheet</span><span class="params">(<span class="string">&quot;属性表单&quot;</span>)</span>;<span class="comment">//使用字符串构造属性表单对象</span></span><br><span class="line">  propsheet.SetWizardMode();<span class="comment">//设置向导样式</span></span><br><span class="line"><span class="comment">//  propsheet.DoModal();//创建模态属性表单</span></span><br><span class="line">  <span class="keyword">if</span> (ID_WIZFINISH == propsheet.DoModal())<span class="comment">//属性表单被创建向导，DoModal()返回ID_WIZFINISH</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_ioccupation = propsheet.m_prop1.m_occupation;<span class="comment">//向导.属性页.属性页成员</span></span><br><span class="line">    m_strworkaddress = propsheet.m_prop1.m_workaddress;</span><br><span class="line">    m_blike[<span class="number">0</span>] = propsheet.m_prop2.m_football;</span><br><span class="line">    m_blike[<span class="number">1</span>] = propsheet.m_prop2.m_basketball;</span><br><span class="line">    m_blike[<span class="number">2</span>] = propsheet.m_prop2.m_volleyball;</span><br><span class="line">    m_blike[<span class="number">3</span>] = propsheet.m_prop2.m_swim;</span><br><span class="line">    m_strsalary = propsheet.m_prop3.m_strsalary;</span><br><span class="line">    Invalidate();<span class="comment">//让视类窗口无效，从而引起重绘，然后在OnDraw中完成信息的输出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口重绘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CpropView::OnDraw</span><span class="params">(CDC* pDC)</span></span><br><span class="line">&#123;</span><br><span class="line">  CpropDoc* pDoc = GetDocument();</span><br><span class="line">  ASSERT_VALID(pDoc);</span><br><span class="line">  <span class="keyword">if</span> (!pDoc)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此处为本机数据添加绘制代码</span></span><br><span class="line">  CFont font;</span><br><span class="line">  font.CreatePointFont(<span class="number">100</span>, <span class="string">&quot;宋体&quot;</span>,pDC);<span class="comment">//创建字体</span></span><br><span class="line">  CFont* pfont;</span><br><span class="line">  pfont = pDC-&gt;SelectObject(&amp;font);<span class="comment">//将字体选入设备描述表，并保存旧字体</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//职位</span></span><br><span class="line">  CString position;</span><br><span class="line">  position = <span class="string">&quot;你的职业:&quot;</span>;</span><br><span class="line">  <span class="keyword">switch</span> (m_ioccupation)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    position += <span class="string">&quot;程序员&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    position += <span class="string">&quot;系统工程师&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    position += <span class="string">&quot;项目经理&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pDC-&gt;TextOut(<span class="number">0</span>, <span class="number">0</span>, position);<span class="comment">//将文本展示在视类窗口</span></span><br><span class="line"></span><br><span class="line">  TEXTMETRIC tm;</span><br><span class="line">  pDC-&gt;GetTextMetrics(&amp;tm);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//工作地点</span></span><br><span class="line">  CString workplace;</span><br><span class="line">  workplace = <span class="string">&quot;你的工作地点:&quot;</span>;</span><br><span class="line">  workplace += m_strworkaddress;</span><br><span class="line">  pDC-&gt;TextOut(<span class="number">0</span>, tm.tmHeight, workplace);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//兴趣爱好</span></span><br><span class="line">  CString hobby;</span><br><span class="line">  hobby = <span class="string">&quot;你的爱好:&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (m_blike[<span class="number">0</span>])</span><br><span class="line">    hobby += <span class="string">&quot;足球 &quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (m_blike[<span class="number">1</span>])</span><br><span class="line">    hobby += <span class="string">&quot;篮球 &quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (m_blike[<span class="number">2</span>])</span><br><span class="line">    hobby += <span class="string">&quot;排球 &quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (m_blike[<span class="number">3</span>])</span><br><span class="line">    hobby += <span class="string">&quot;游泳 &quot;</span>;</span><br><span class="line">  pDC-&gt;TextOut(<span class="number">0</span>, tm.tmHeight*<span class="number">2</span>, hobby);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//薪资</span></span><br><span class="line">  CString salary;</span><br><span class="line">  salary = <span class="string">&quot;你的薪资水平:&quot;</span>;</span><br><span class="line">  salary += m_strsalary;</span><br><span class="line">  pDC-&gt;TextOut(<span class="number">0</span>, tm.tmHeight*<span class="number">3</span>, salary);</span><br><span class="line"></span><br><span class="line">  pDC-&gt;SelectObject(pfont);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第九章-定制应用程序外观"><a href="#第九章-定制应用程序外观" class="headerlink" title="第九章 定制应用程序外观"></a>第九章 定制应用程序外观</h1><h2 id="4、工具栏编程ToolBar"><a href="#4、工具栏编程ToolBar" class="headerlink" title="4、工具栏编程ToolBar"></a>4、工具栏编程ToolBar</h2><p>1.在工具栏上添加、删除按钮</p><p>创建按钮：按钮和菜单项用一样的ID</p><p>按钮之间的分隔符：用鼠标把按钮向右拖动一段距离</p><p>删除按钮：将按钮脱出工具栏</p><p>2.创建工具栏</p><p>分析系统创建的工具栏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cmainframe头文件中</span><br><span class="line">CToolBar          m_wndToolBar;</span><br><span class="line"></span><br><span class="line">cmainframe.cpp中</span><br><span class="line"><span class="type">int</span> <span class="title function_">CMainFrame::OnCreate</span><span class="params">(LPCREATESTRUCT lpCreateStruct)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||</span><br><span class="line">    !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))</span><br><span class="line">  &#123;</span><br><span class="line">    TRACE0(<span class="string">&quot;未能创建工具栏\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// 未能创建</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> ....</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 如果不需要可停靠工具栏，则删除这三行</span></span><br><span class="line">  m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);<span class="comment">//工具栏对象的成员函数EnableDocking，表示工具栏对象可以停靠</span></span><br><span class="line">  <span class="comment">//CBRS_ALIGN_ANY允许停靠在任意位置</span></span><br><span class="line">  EnableDocking(CBRS_ALIGN_ANY);<span class="comment">//CFrameWnd对象的EnableDocking成员函数，表示主框架窗口可以被停靠</span></span><br><span class="line">  DockControlBar(&amp;m_wndToolBar);<span class="comment">//工具栏停靠在主框架窗口上</span></span><br></pre></td></tr></table></figure><p>创建自定义工具栏(参照系统工具栏)</p><p>1.新建ToolBar资源</p><p>2.构造ToolBar对象</p><p>3.调用Create函数创建工具栏，并将其与ToolBar对象关联</p><p>4.LoadToolBar加载工具栏</p><p>5.设置停靠位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">头文件  </span><br><span class="line">CToolBar    m_newtoolbar;<span class="comment">//2.构造ToolBar对象</span></span><br><span class="line">  </span><br><span class="line">源文件</span><br><span class="line">  <span class="keyword">if</span> (!m_newtoolbar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_RIGHT | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||</span><br><span class="line">    !m_newtoolbar.LoadToolBar(IDR_TOOLBAR1))</span><br><span class="line"><span class="comment">//3.调用Create函数创建工具栏，并将其与ToolBar对象关联</span></span><br><span class="line"><span class="comment">//4.LoadToolBar加载工具栏</span></span><br><span class="line">  &#123;</span><br><span class="line">    TRACE0(<span class="string">&quot;未能创建工具栏\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// 未能创建</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//5.设置停靠位置</span></span><br><span class="line">  m_newtoolbar.EnableDocking(CBRS_ALIGN_ANY);</span><br><span class="line">  DockControlBar(&amp;m_newtoolbar);</span><br></pre></td></tr></table></figure><p>改进方法<strong><code>CFrameWnd::ShowControlBar</code></strong>隐藏或显示指定的控制条</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CMainFrame::OnViewNewtoolbar</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">/*   </span></span><br><span class="line"><span class="comment">if (!m_newtoolbar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_RIGHT | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||</span></span><br><span class="line"><span class="comment">    !m_newtoolbar.LoadToolBar(IDR_TOOLBAR1))</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    TRACE0(&quot;未能创建工具栏\n&quot;);</span></span><br><span class="line"><span class="comment">    return -1;      // 未能创建</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  m_newtoolbar.EnableDocking(CBRS_ALIGN_ANY);</span></span><br><span class="line"><span class="comment">  DockControlBar(&amp;m_newtoolbar);   </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">          </span><br><span class="line">  ShowControlBar(&amp;m_newtoolbar, !m_newtoolbar.IsWindowVisible(), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CMainFrame::OnUpdateViewNewtoolbar</span><span class="params">(CCmdUI* pCmdUI)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 在菜单项前添加标记,见第六章</span></span><br><span class="line">  pCmdUI-&gt;SetCheck(m_newtoolbar.IsWindowVisible());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、状态栏StatusBar"><a href="#5、状态栏StatusBar" class="headerlink" title="5、状态栏StatusBar"></a>5、状态栏StatusBar</h2><p>步骤：</p><p>1.在资源视图String Table中添加响应的ID</p><p>2.在源文件中将响应的ID添加进indicator（状态行指示器）中</p><p>系统创建的状态栏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  CStatusBar        m_wndStatusBar;<span class="comment">//定义默认状态栏对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> UINT indicators[] =</span><br><span class="line">&#123;</span><br><span class="line">  ID_SEPARATOR,           <span class="comment">// 状态行指示器</span></span><br><span class="line">  ID_INDICATOR_CAPS,</span><br><span class="line">  ID_INDICATOR_NUM,</span><br><span class="line">  ID_INDICATOR_SCRL,</span><br><span class="line"><span class="comment">//  IDS_TIMER,</span></span><br><span class="line"><span class="comment">//  IDS_PROGRESS,</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//OnCreate()中</span></span><br><span class="line"> <span class="keyword">if</span> (!m_wndStatusBar.Create(this))<span class="comment">//创建状态栏对象</span></span><br><span class="line">  &#123;</span><br><span class="line">    TRACE0(<span class="string">&quot;未能创建状态栏\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// 未能创建</span></span><br><span class="line">  &#125;</span><br><span class="line">  m_wndStatusBar.SetIndicators(indicators, <span class="keyword">sizeof</span>(indicators)/<span class="keyword">sizeof</span>(UINT));<span class="comment">//设置状态指示器(数组设置状态栏内容，数组元素个数)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在OnTimer()中添加</span><br><span class="line"><span class="comment">//在状态栏显示动态变化的系统时间</span></span><br><span class="line">  CTime time;<span class="comment">//接收系统时间</span></span><br><span class="line">  CString str;<span class="comment">//系统时间文本</span></span><br><span class="line">  CClientDC <span class="title function_">dc</span><span class="params">(this)</span>;<span class="comment">//调用GetTextExtent()</span></span><br><span class="line">  CSize sz;<span class="comment">//接收时间字符串大小</span></span><br><span class="line">  <span class="type">int</span> indicatorindex =  <span class="number">0</span>;<span class="comment">//indicator索引</span></span><br><span class="line"></span><br><span class="line">  time = CTime::GetCurrentTime();<span class="comment">//获取系统时间保存进time中</span></span><br><span class="line">  str = time.Format(<span class="string">&quot;%H:%M:%S&quot;</span>);<span class="comment">//将time中的时间格式化</span></span><br><span class="line">  indicatorindex = m_wndStatusBar.CommandToIndex(IDS_TIMER);<span class="comment">//获取ID在indicator中的索引</span></span><br><span class="line">  sz = dc.GetTextExtent(str);<span class="comment">//获取文本显示宽度 </span></span><br><span class="line">  </span><br><span class="line">  m_wndStatusBar.SetPaneInfo(indicatorindex, IDS_TIMER, SBPS_NORMAL, sz.cx);<span class="comment">//设置状态栏右侧小窗口属性</span></span><br><span class="line">  m_wndStatusBar.SetPaneText(indicatorindex, str);<span class="comment">//将str显示到indicator数组对应的小窗口</span></span><br></pre></td></tr></table></figure><h2 id="6、进度栏"><a href="#6、进度栏" class="headerlink" title="6、进度栏"></a>6、进度栏</h2><h1 id="CProgressCtrl-Create-进度栏类CProgressCtrl"><a href="#CProgressCtrl-Create-进度栏类CProgressCtrl" class="headerlink" title="CProgressCtrl::Create//进度栏类CProgressCtrl"></a>CProgressCtrl::Create//进度栏类CProgressCtrl</h1><p><strong>BOOL</strong> <strong>Create(</strong> <strong>DWORD</strong> <em>dwStyle</em><strong>,</strong> <strong>const</strong> <strong>RECT&amp;</strong> <em>rect</em><strong>,</strong> <strong>CWnd*</strong> <em>pParentWnd</em><strong>,</strong> <strong>UINT</strong> <em>nID);//</em> 创建进度栏</p><h1 id="CProgressCtrl-SetPos"><a href="#CProgressCtrl-SetPos" class="headerlink" title="CProgressCtrl::SetPos"></a>CProgressCtrl::SetPos</h1><p><strong>int</strong> <strong>SetPos(</strong> <strong>int</strong> <em>nPos);//</em> 设置进度栏当前进度</p><h1 id="CStatusBar-GetItemRect"><a href="#CStatusBar-GetItemRect" class="headerlink" title="CStatusBar::GetItemRect"></a>CStatusBar::GetItemRect</h1><p><strong>void GetItemRect(int</strong> <em>nIndex</em><strong>,LPRECT</strong> <em>lpRect)const;//</em> 得到状态栏小窗格大小</p><p>🌟补充消息响应过程</p><p>1.头文件声明（定义）函数afx_msg LRESULT  OnProgress(WPARAM, LPARAM);</p><p>2.消息与函数关联ON_MESSAGE(UM_PROGRESS, &amp;OnProgress)</p><p>3.实现函数LRESULT CMainFrame::OnProgress(WPARAM wParam, LPARAM lParam) </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CMainFrame::OnPaint</span><span class="params">()</span><span class="comment">//窗口大小发生变化-&gt;窗口重绘-&gt;重新获得rect</span></span><br><span class="line">&#123;</span><br><span class="line">  CPaintDC <span class="title function_">dc</span><span class="params">(this)</span>; <span class="comment">// device context for painting</span></span><br><span class="line">                     <span class="comment">// <span class="doctag">TODO:</span> 在此处添加消息处理程序代码</span></span><br><span class="line">                     <span class="comment">// 不为绘图消息调用 CFrameWnd::OnPaint()</span></span><br><span class="line">             </span><br><span class="line">  CRect rect;</span><br><span class="line">  m_wndStatusBar.GetItemRect(<span class="number">5</span>, &amp;rect);<span class="comment">//获得窗格大小并储存在rect中</span></span><br><span class="line">  <span class="keyword">if</span> (!m_progress.m_hWnd)<span class="comment">//如果句柄没有值，说明对象没有创建</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_progress.Create(WS_VISIBLE | WS_CHILD | PBS_SMOOTH, rect, &amp;m_wndStatusBar, <span class="number">123</span>);<span class="comment">//创建进度栏，WS_CHILD:The window is a child window. </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_progress.MoveWindow(rect);<span class="comment">//移动窗格，The CRect object or RECT structure that specifies the new size and position. </span></span><br><span class="line">  &#125;</span><br><span class="line">  m_progress.SetPos(<span class="number">50</span>);<span class="comment">//设置进度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、在状态栏上显示鼠标当前位置"><a href="#7、在状态栏上显示鼠标当前位置" class="headerlink" title="7、在状态栏上显示鼠标当前位置"></a>7、在状态栏上显示鼠标当前位置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CstyleView::OnMouseMove</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line"><span class="comment">//视类中捕获鼠标移动的消息WM_MOUSEMOVE</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">  CString str;</span><br><span class="line">  str.Format(<span class="string">&quot;x = %d  y = %d&quot;</span>,point.x, point.y);<span class="comment">//格式化鼠标位置</span></span><br><span class="line">  ((CMainFrame*)GetParent())-&gt;m_wndStatusBar.SetWindowText(str);</span><br><span class="line">  <span class="comment">/*上述代码中，首先格式化鼠标当前位置的信息。然后为了把该信息显示在</span></span><br><span class="line"><span class="comment">状态栏的第一个窗格上，需要获取状态栏对象。而状态栏对象是在框架类窗口中定义的，同时，</span></span><br><span class="line"><span class="comment">框架类窗口是视类窗口的父窗口，因此在视类对象中通过调用 GetParent 函数就可以得到</span></span><br><span class="line"><span class="comment">视类的父窗口，即框架窗口。因为该函数返回的是一个CWnd 类型的指针，而这里需要的</span></span><br><span class="line"><span class="comment">是 CMainFrame 类型的指针，所以需要进行一个转换。然后利用框架窗口对象去调用该对</span></span><br><span class="line"><span class="comment">象内部的状态栏成员变量：m_wndStatusBar，以得到状态栏对象，*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*因为上述代码用到了框架类的类型，所以要在头文件中包含框架类头文件*/</span></span><br><span class="line">  </span><br><span class="line">  CView::OnMouseMove(nFlags, point);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="十、绘图控制"><a href="#十、绘图控制" class="headerlink" title="十、绘图控制"></a>十、绘图控制</h1><h3 id="1、简单绘图"><a href="#1、简单绘图" class="headerlink" title="1、简单绘图"></a>1、简单绘图</h3><p>CPen pen</p><p>SelectObject</p><p>GetStockObject</p><p>FromHandle</p><p>SetPixel</p><p>Rectangle</p><p>Ellipse</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*头文件*/</span></span><br><span class="line"><span class="comment">//自定义成员变量</span></span><br><span class="line">private:</span><br><span class="line">  UINT m_nDrawType;<span class="comment">//标记用户选择那种图形</span></span><br><span class="line">  CPoint m_ptOrigin;<span class="comment">//保存鼠标左键按下的点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*构造函数*/</span></span><br><span class="line">CGraphicView::CGraphicView() noexcept</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此处添加构造代码</span></span><br><span class="line">  m_nDrawType = <span class="number">0</span>;<span class="comment">//初始化绘图图形类型</span></span><br><span class="line">  m_ptOrigin = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*视类消息处理程序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CGraphicView::OnDot</span><span class="params">()</span><span class="comment">//点</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">  m_nDrawType = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CGraphicView::OnLine</span><span class="params">()</span><span class="comment">//直线</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">  m_nDrawType = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CGraphicView::OnRectangle</span><span class="params">()</span><span class="comment">//矩形</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">  m_nDrawType = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CGraphicView::OnEllipse</span><span class="params">()</span><span class="comment">//椭圆</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">  m_nDrawType = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CGraphicView::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">  m_ptOrigin = point;<span class="comment">//保存鼠标左键按下的位置</span></span><br><span class="line">  </span><br><span class="line">  CView::OnLButtonDown(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CGraphicView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span><span class="comment">//鼠标左键抬起，实现绘图功能</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">  CClientDC <span class="title function_">dc</span><span class="params">(this)</span>;<span class="comment">//绘图操作首先要有DC对象</span></span><br><span class="line">  CPen <span class="title function_">pen</span><span class="params">(PS_SOLID, <span class="number">10</span>, RGB(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>))</span>;<span class="comment">//线条的颜色由DC中的画笔颜色确定，构造CPen对象并指定其颜色</span></span><br><span class="line">  dc.SelectObject(&amp;pen);<span class="comment">//将画笔选入设备描述表</span></span><br><span class="line">                        <span class="comment">//加载资源用LoadBitmap等，CDC对象用SelectObject(&amp;xxx)  </span></span><br><span class="line">  CBrush* pBrush = CBrush::FromHandle((HBRUSH)GetStockObject(NULL_BRUSH));<span class="comment">//GetStockObject调用NULL_BRUSH创建透明画刷</span></span><br><span class="line">                                                                          <span class="comment">//CBrush的静态成员变量FromHandle将画刷句柄转化为指向画刷对象的指针</span></span><br><span class="line">                                                                          <span class="comment">//FromHandle的参数是HBRUSH类型，强制类型转化</span></span><br><span class="line">  dc.SelectObject(pBrush);<span class="comment">//将画刷选入设备描述表</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (m_nDrawType)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    dc.SetPixel(point, RGB(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>));<span class="comment">//在指定的点设置一个像素</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    dc.MoveTo(m_ptOrigin);</span><br><span class="line">    dc.LineTo(point);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    dc.Rectangle(CRect(m_ptOrigin,point));<span class="comment">//利用CRect对象绘制矩形</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    dc.Ellipse(CRect(m_ptOrigin, point));<span class="comment">//绘制椭圆</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  CView::OnLButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意将CDC对象加入设备miaoshub；</p><p>注意静态成员函数的调用方式：要声明是哪个类的。</p><h2 id="2、线宽线型（设置对话框）"><a href="#2、线宽线型（设置对话框）" class="headerlink" title="2、线宽线型（设置对话框）"></a>2、线宽线型（设置对话框）</h2><p>1、将设置对话框创建一个新的对话框类</p><p>2、在主菜单添加设置菜单项并设置消息响应函数</p><p>3、控件关联无符号整型变量，View类创建同类型变量以保存其值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CGraphicView::OnSetting</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">  CSettingDlg dlg;<span class="comment">//实例化设置对话框对象</span></span><br><span class="line">  dlg.m_nLineWidth = m_nLineWidth;<span class="comment">//保持之前设置过的线宽</span></span><br><span class="line">  dlg.m_nLineStyle = m_nLineStyle;<span class="comment">//保持之前设置过的线型</span></span><br><span class="line">  <span class="keyword">if</span> (IDOK == dlg.DoModal())</span><br><span class="line">  &#123;</span><br><span class="line">    m_nLineWidth = dlg.m_nLineWidth;<span class="comment">//保存新设置的值</span></span><br><span class="line">    m_nLineStyle = dlg.m_nLineStyle;<span class="comment">//保存设置的线型，WINGDI.h定义了一些符号常量，包括线型</span></span><br><span class="line">                                    <span class="comment">//本例设置的对话框的线型排序正好按照WINGDI.h的顺序定义</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、颜色对话框"><a href="#3、颜色对话框" class="headerlink" title="3、颜色对话框"></a>3、颜色对话框</h2><p>CColorDialog默认颜色对话框类了解（m_cc、CHOOSECOLOR、rgbResult、Flags (CC_RGBINIT)）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CGraphicView::OnColor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">  CColorDialog colordlg;<span class="comment">//CColorDialog颜色对话框类</span></span><br><span class="line">  colordlg.m_cc.Flags |= CC_RGBINIT;<span class="comment">//设置颜色对话框初始选择的颜色，需要设置该对话框的CC_RGBINIT标记</span></span><br><span class="line">  <span class="comment">/*实际上，当在创建 CColorDialog 对象 dlg 时，它的数据成员 m_cc 中的 Flags 成员已经具有了一些初始的默认标记。</span></span><br><span class="line"><span class="comment">  当我们将 CC_RGBINTT 标记直接赋给 Flags 成员时，就相当于将 Flags 成员初始默认的标记都去掉了。</span></span><br><span class="line"><span class="comment">  这里不能给 Flags 标记直接赋值，应利用或操作（|）将CC_RGBINIT 标记与 Flags 先前的标记组合起来。*/</span></span><br><span class="line">  colordlg.m_cc.rgbResult = m_ctr;<span class="comment">//保持之前设置过的颜色</span></span><br><span class="line">  <span class="keyword">if</span> (IDOK == colordlg.DoModal())<span class="comment">//创建颜色对话框</span></span><br><span class="line">  &#123;</span><br><span class="line">    m_ctr = colordlg.m_cc.rgbResult;<span class="comment">//CColorDialog类有一个结构体类型的变量m_cc</span></span><br><span class="line">                                    <span class="comment">//CHOOSECOLOR结构体的rgbResult变量保存了用户选择的颜色</span></span><br><span class="line">                                    <span class="comment">//将用户选择的颜色保存在m_ctr中</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、字体对话框"><a href="#4、字体对话框" class="headerlink" title="4、字体对话框"></a>4、字体对话框</h2><p>DeleteObject释放这个字体资源</p><p>CFont::CreateFontIndirect利用lpLogFont指向的LOGFONT结构体中的一些特征初始化CFont对象</p><p>Invalidate()引起窗口重绘</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">头文件</span><br><span class="line">CFont m_font;<span class="comment">//字体对象</span></span><br><span class="line">CString m_strFontName;<span class="comment">//保存所选字体的名称</span></span><br><span class="line"></span><br><span class="line">源文件</span><br><span class="line"><span class="type">void</span> <span class="title function_">CGraphicView::OnFont</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">  CFontDialog fontdlg;<span class="comment">//字体对话框对象</span></span><br><span class="line">  <span class="keyword">if</span> (IDOK == fontdlg.DoModal())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_font.m_hObject)</span><br><span class="line">    <span class="comment">/*利用CGdiobject 对象的数据成员 m_hObject 来判断 m_font 对象是否已经与某个字体资源相关联了，</span></span><br><span class="line"><span class="comment">    该变量保存了与CGdiObject对象相关联的Windows GDI 的资源句柄。</span></span><br><span class="line"><span class="comment">    如果已经有关联了，则调用 DeleteObject 释放这个字体资源*/</span></span><br><span class="line">    &#123;</span><br><span class="line">      m_font.DeleteObject();</span><br><span class="line">    &#125;</span><br><span class="line">    m_font.CreateFontIndirect(fontdlg.m_cf.lpLogFont);<span class="comment">//CFont::CreateFontIndirect利用lpLogFont指向的LOGFONT结构体中的一些特征初始化CFont对象</span></span><br><span class="line">    m_strFontName = fontdlg.m_cf.lpLogFont-&gt;lfFaceName;<span class="comment">//lfFaceName保存了字体名字</span></span><br><span class="line">    Invalidate();</span><br><span class="line">    <span class="comment">/*窗口的客户区无效意味着需要重绘，例如，如果一个被其它窗口遮住的窗口变成了前台窗口，</span></span><br><span class="line"><span class="comment">    那么原来被遮住的部分就是无效的，需要重绘。这时Windows会在应用程序的消息队列中放置WM_PAINT消息。</span></span><br><span class="line"><span class="comment">    MFC为窗口类提供了WM_PAINT的消息处理函数OnPaint，OnPaint负责重绘窗口。</span></span><br><span class="line"><span class="comment">    视图类有一些例外，在视图类的OnPaint函数中调用了OnDraw函数，实际的重绘工作由OnDraw来完成。*/</span></span><br><span class="line">    <span class="comment">/*系统会在多个不同的时机发送WM_PAINT消息：</span></span><br><span class="line"><span class="comment">    当第一次创建一个窗口时，当改变窗口的大小时，当把窗口从另一个窗口背后移出时，当最大化或最小化窗口时，等等，</span></span><br><span class="line"><span class="comment">    这些动作都是由系统管理的，应用只是被动地接收该消息，在消息处理函数中进行绘制操作；</span></span><br><span class="line"><span class="comment">    大多数的时候应用也需要能够主动引发窗口中的绘制操作，比如当窗口显示的数据改变的时候，</span></span><br><span class="line"><span class="comment">    这一般是通过InvalidateRect和 InvalidateRgn函数来完成的。*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/jpg/21452222/1708699502177-0fc3285d-547f-4612-98a7-b50c3b52a61e.jpg#id=BNRC1&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h2 id="5、示例对话框"><a href="#5、示例对话框" class="headerlink" title="5、示例对话框"></a>5、示例对话框</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CSettingDlg::OnChangeLineWidth</span><span class="params">()</span></span><br><span class="line"><span class="comment">//对编辑框控件中的文本改变时，会向父窗口发送EN_CHANGE消息</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  Invalidate();<span class="comment">//让窗口重绘以在OnPaint中完成示例线条的绘制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CSettingDlg::OnClickedRadio1</span><span class="params">()</span></span><br><span class="line"><span class="comment">//单击Radio Button时，按钮会向对话框发送BN_CLICKED消息</span></span><br><span class="line">&#123;</span><br><span class="line">  Invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CSettingDlg::OnClickedRadio2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">  Invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CSettingDlg::OnClickedRadio3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">  Invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CSettingDlg::OnPaint</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  CPaintDC <span class="title function_">dc</span><span class="params">(this)</span>; <span class="comment">// device context for painting</span></span><br><span class="line">             <span class="comment">// <span class="doctag">TODO:</span> 在此处添加消息处理程序代码</span></span><br><span class="line">             <span class="comment">// 不为绘图消息调用 CDialog::OnPaint()</span></span><br><span class="line">  UpdateData();<span class="comment">//当控件与一个成员变量相关联时，如果想让控件上的值反应到成员变量上，必须调用UpdateData()</span></span><br><span class="line">  CPen <span class="title function_">pen</span><span class="params">(m_nLineStyle, m_nLineWidth, m_clr)</span>;</span><br><span class="line">  dc.SelectObject(&amp;pen);</span><br><span class="line"></span><br><span class="line">  CRect rect;</span><br><span class="line">  GetDlgItem(IDC_SAMPLE)-&gt;GetWindowRect(&amp;rect);</span><br><span class="line">  <span class="comment">/*要想在组框中绘图，那么首先要得到组框的矩形区域范围。</span></span><br><span class="line"><span class="comment">  这可以通过调用GetDlgltem 函数来得到指向组框窗口对象的指针，</span></span><br><span class="line"><span class="comment">  然后利用 GetWindowRect 函数获得组框窗口矩形区域的大小,参数是指向CRect或RECT结构体的变量，接收屏幕坐标</span></span><br><span class="line"><span class="comment">  需要提醒读者注意的是，这里不能直接调用 GetWindowRect 函数，否则得到的将是对话框的矩形区域大小。*/</span></span><br><span class="line">  ScreenToClient(&amp;rect);<span class="comment">//得到矩形区域的大小后，将其原点从屏幕坐标转化为客户坐标（即将应用程序坐标转化为设置对话框坐标）</span></span><br><span class="line"></span><br><span class="line">  dc.MoveTo(rect.left+<span class="number">20</span>,rect.top+rect.Height()/<span class="number">2</span>);<span class="comment">//组框左上角的y值+矩形区域高度的一半，即将线条移动到示例窗口中间</span></span><br><span class="line">  dc.LineTo(rect.right - <span class="number">20</span>, rect.top + rect.Height() / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、改变对话框及其控件的背景和文本WM-CTLCOLOR"><a href="#6、改变对话框及其控件的背景和文本WM-CTLCOLOR" class="headerlink" title="6、改变对话框及其控件的背景和文本WM_CTLCOLOR"></a>6、改变对话框及其控件的背景和文本WM_CTLCOLOR</h2><p>1、改变对话框及其控件的背景</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件声明</span></span><br><span class="line">  CBrush m_brush;<span class="comment">//画刷</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数初始化</span></span><br><span class="line">  m_clr = RGB(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  m_brush.CreateSolidBrush(RGB(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>));<span class="comment">//利用CreateSolidBrush函数将m_brush初始化画刷颜色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//消息响应函数</span></span><br><span class="line">HBRUSH <span class="title function_">CSettingDlg::OnCtlColor</span><span class="params">(CDC* pDC, CWnd* pWnd, UINT nCtlColor)</span><span class="comment">//每一个控件（对话框和子控件）在绘制时都发送WM_CTLCOLOR消息</span></span><br><span class="line">&#123;</span><br><span class="line">  HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>  在此更改 DC 的任何特性</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>  如果默认的不是所需画笔，则返回另一个画笔</span></span><br><span class="line">  <span class="keyword">if</span> (IDC_LINE_STYLE == pWnd-&gt;GetDlgCtrlID())<span class="comment">//判断是否为线型组框</span></span><br><span class="line">  &#123;</span><br><span class="line">    pDC-&gt;SetTextColor(RGB(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>));<span class="comment">//设置文本颜色为红色</span></span><br><span class="line">    pDC-&gt;SetBkMode(TRANSPARENT);<span class="comment">//将控件上的文字背景设置为透明</span></span><br><span class="line">    <span class="keyword">return</span> m_brush;<span class="comment">//如果想要改变背景颜色，只需要自定义一个画刷，然后让OnColor函数返回这个画刷句柄即可</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (IDC_LINE_WIDTH == pWnd-&gt;GetDlgCtrlID())</span><br><span class="line">  &#123;</span><br><span class="line">    pDC-&gt;SetTextColor(RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//    pDC-&gt;SetBkMode(TRANSPARENT);</span></span><br><span class="line">    pDC-&gt;SetBkColor(RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));<span class="comment">//设置窗口背景色</span></span><br><span class="line">    <span class="keyword">return</span> m_brush;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hbr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、改变控件的文本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件声明</span></span><br><span class="line">private:</span><br><span class="line">  CFont m_font;<span class="comment">//改变控件上的文本字体</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//构造函数初始化</span></span><br><span class="line">  m_font.CreatePointFont(<span class="number">200</span>,<span class="string">&quot;华文行楷&quot;</span>);<span class="comment">//初始化字体</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//消息响应函数</span></span><br><span class="line">  HBRUSH <span class="title function_">CSettingDlg::OnCtlColor</span><span class="params">(CDC* pDC, CWnd* pWnd, UINT nCtlColor)</span><span class="comment">//每一个控件（对话框和子控件）在绘制时都发送WM_CTLCOLOR消息</span></span><br><span class="line">&#123;</span><br><span class="line">  HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>  在此更改 DC 的任何特性</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>  如果默认的不是所需画笔，则返回另一个画笔</span></span><br><span class="line">  <span class="keyword">if</span> (IDC_TEXT == pWnd-&gt;GetDlgCtrlID())</span><br><span class="line">  &#123;</span><br><span class="line">    pDC-&gt;SelectObject(&amp;m_font);<span class="comment">//将字体选入设备描述表-&gt;改变字体</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hbr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、改变按钮的背景色及文本</p><h2 id="7、位图的显示"><a href="#7、位图的显示" class="headerlink" title="7、位图的显示"></a>7、位图的显示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CGraphicView::OnEraseBkgnd</span><span class="params">(CDC* pDC)</span><span class="comment">//擦除背景时，系统发送WM_ERASEBKGND消息</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">  CBitmap bitmap;</span><br><span class="line">  bitmap.LoadBitmap(IDB_BITMAP1);</span><br><span class="line">  BITMAP bmp;<span class="comment">//定义BITMAP结构体变量</span></span><br><span class="line">  bitmap.GetBitmap(&amp;bmp);<span class="comment">//CBitmap::GetBitmap用位图信息填充BITMAP结构体</span></span><br><span class="line"></span><br><span class="line">  CDC dcCompatible;<span class="comment">//创建兼容DC</span></span><br><span class="line">  dcCompatible.CreateCompatibleDC(pDC);<span class="comment">//兼容DC(源DC)和当前DC兼容</span></span><br><span class="line"></span><br><span class="line">  dcCompatible.SelectObject(&amp;bitmap);<span class="comment">//将位图选入兼容DC，从而确定兼容DC显示表面的大小</span></span><br><span class="line"></span><br><span class="line">  CRect rect;</span><br><span class="line">  GetClientRect(&amp;rect);<span class="comment">//获得目的DC客户区大小</span></span><br><span class="line"><span class="comment">//  pDC-&gt;BitBlt(0, 0, rect.Width(), rect.Height(), &amp;dcCompatible, 0, 0, SRCCOPY);//BitBlt()将源DC的位图1:1复制到目的DC</span></span><br><span class="line">  pDC-&gt;StretchBlt(<span class="number">0</span>, <span class="number">0</span>, rect.Width(), rect.Height(), &amp;dcCompatible, <span class="number">0</span>, <span class="number">0</span>,bmp.bmWidth,bmp.bmHeight, SRCCOPY);</span><br><span class="line">  <span class="comment">//StretchBlt复制位图并实现拉伸或压缩；bmp.bmWidth,bmp.bmHeight存储源矩形的宽度和高度</span></span><br><span class="line">  <span class="keyword">return</span> TRUE;<span class="comment">//已经擦除过窗口背景了，返回非零值</span></span><br><span class="line"><span class="comment">//  return CView::OnEraseBkgnd(pDC);//将窗口背景擦除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//构造函数初始化</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 孙鑫VC++深入详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> mfc </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
